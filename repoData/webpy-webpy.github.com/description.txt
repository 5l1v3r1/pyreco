---
layout: default
title: web.py 0.3 API
---

# web.py 0.3 API

## Hello world

`print` will be replaced with `return`.

    import web

    urls = (
        '/(.*)', 'hello'
    )
    app = web.application(urls, globals())

    class hello:        
        def GET(self, name):
            if not name: name = 'world'
            return 'Hello,', name+'!'

    if __name__ == "__main__": 
        app.run()

## database

db configuration will not be global any more. Multiple databases can be used at the same time and no `web.load()` magic required to make database work.

    import web

    db = web.database(dbn='postgres', db='todo', user='you', pw='')

    db.select('todo')
    db.select('todo', where='id=$id', vars={'id': 2})
    db.query('SELECT * FROM todo')

## application
Application is a new way of mapping urls to classes, coming in 0.3.
There will be many different kinds of supported applications.

### web.application
Application to delegate requests based on path.

    urls = (
        "/hello", "hello", 
        "/magic/.*", "magic")

    app = web.application(urls, globals())

### web.auto_application
Application similar to web.application but urls are constructed automatiacally using metaclasses.

    app = web.auto_application()

    class hello(app.page):
        def GET(self):
            return "hello, world!"

### web.subdir_application
Application to delegate requests based on subdir.
This allows reuse of code easily by taking some exiting app and mounting it at a directory.

    import wiki
    import blog
    import auth

    mapping = (
        "/wiki", wiki.app, 
        "/blog", blog.app,
        "/auth", auth.app)
    
    app = web.subdir_application(mapping)

### web.subdomain_application
Application to delegate requests based on host.
This makes virtual hosting very easy.

    import mainsite
    import usersite

    mapping = (
        "(www\.)?example.com", mainsite.app,
        ".*\.example.com", usersite.app
    )

    app = web.subdomain_application(mapping)

## testing

Testing becomes very easy with applications. Both doctest and unittest can be used to test web applications.

doctest:

    urls = ("/hello", "hello")
    app = web.application(urls, globals())
    
    class hello:
        """Hello world example.

            >>> response = app.request("/hello")
            >>> response.data
            'hello, world!'
            >>> response.status
            '200 OK'
            >>> response.headers['Content-Type']
            'text/plain'
        """
        def GET(self):
            web.header('Content-Type', 'text/plain')
            return "hello, world!"

unittest:

    import unittest
    from helloworld import app

    class HelloWorldTest(unittest.TestCase):
        def testHelloWorld(self):
            response = app.request('/hello')
            self.assertEquals(response.data, 'hello, world!')
            self.assertEquals(response.headers['Content-Type'], 'text/plain')
            self.assertEquals(response.status, '200 OK')

    if __name__ == "__main__":
        unittest.main()

## templates

* no whitespace magic
* better error reporting
* should allow template reuse
* Probably use Adam Atlas's implementation

## Contrib

* New module, `web.contrib` with contributed utilities, which are not part of the web.py core. For example, good auth module (port from django?) and OpenID support.


---
layout: default
title: Change log
---

# Change log

**2012-06-26: web.py 0.37**

* Fixed datestr issue on Windows -- #155
* Fixed Python 2.4 compatability issues (tx fredludlow)
* Fixed error in utils.safewrite (tx shuge) -- #95
* Allow use of web.data() with app.request() -- #105
* Fixed an issue with session initializaton (tx beardedprojamz) -- #109
* Allow custom message on 400 Bad Request (tx patryk) -- #121
* Made djangoerror work on GAE. -- #80
* Handle malformatted data in the urls. -- #117
* Made it easier to stop the dev server -- #100, #122
* Added support fot customizing cookie_path in session (tx larsga) -- #89
* Added exception for "415 Unsupported Media" (tx JirkaChadima) -- #145
* Added GroupedDropdown to support `<optgroup>` tag (tx jzellman) -- #152
* Fixed failure in embedded interpreter - #87
* Optimized web.cookies (tx benhoyt) - #148


** 2011-07-04: web.py 0.36**

* Upgraded to CherryPy WSGIServer 3.2.0. -- #66
* Various Jython compatibility fixes (tx Ben Noordhuis)
* allow strips to accept lists -- #69
* Improvements to setcookie (tx lovelylain) -- #65
* Added __contains__ method to Session. (tx lovelylain) #65
* Added secure option to session. -- #38
* Fixed db.delete error with `using` clause (tx berndtj) -- #28
* Fixed the case of no where-clauses in db.where
* Fixed threadlocal error in python2.3 -- #77
* Fixed TemplateResult inconsistant behavior -- #78
* Fixed query execution issues with MSSQL -- #71

** 2011-05-15: web.py 0.35**

* Better ThreaedDict implementation using threadlocal (tx Ben Hoyt)
* Make Form a new-style class -- #53
* Optimized SQLQuery.join and generation of multiple_insert query -- #58
* New: support for Amazon\'s Simple Email Service
* Added httponly keyword to setcookie (tx Justin Davis)
* Added httponly only option to sessions and enabled it by default (tx Justin Davis)
* made htmlquote and htmlunquote work with unicode
* Added doseq support for web.url
* New flag web.config.debug_sql to control printing of db queries (tx Nimrod S. Kerrett)
* Fixed inserting default values into MySQL -- #49
* Fixed rendering of Dropdown with mutliple values (tx krowbar) -- #43
* Fixed mutliple set-cookie header issue with session -- #45
* Fixed error in safeunicode when used with appengine datastore objects
* Fixed unicode error in generating debugerror -- #26
* Fixed GAE compilation issue -- #24
* Fixed unicode encoding issue in templates -- #17
* Fixed a bug in form.RadioButton when called with tuple options (tx fhsm) -- #13
* Fixed error in creating PostgresDB with pgdb driver (tx cninucci) -- #23
* Support auto convertion of timestamp/date datatypes in sqlite to datetime.data objects -- #22
* Fixed escaping issue on GAE -- #10
* fixed form.validates for checkbox (tx Justin Davis).
* fixed duplicate content-type in web.sendmail -- #20
* Fix: create session dirs if required (tx Martin Marcher)
* Fixed safestr to make use of encoding argument (tx s7v7nislands)
* Don\'t allow /static/../foo urls in dev webserver (tx Arnar Lundesgaard)
* Disabled debug mode in flup server (tx irrelative) -- #35
* And a lot of unicode fixes


** 2010-03-20: web.py 0.34**

* fix: boolen test works even for sqlite results (tx Emyr Thomas for the idea)
* fix issue with loop.xx variables in templetor (Bug#476708)
* hide unwanted tracebacks in debugerror
* display correct template line numbers in debugerror
* new utilities: counter, safeiter, safewrite, requeue, restack (by Aaron Swartz)
* various form.py fixes and improvements
* automatically escape % characters in the db query (Bug#516516)
* fix non-deterministic template order (Bug#490209)
* attachment support for web.sendmail (tx gregglind)
* template.py optimizations and extension support

**2009-10-28: web.py 0.33**

* form.Button takes optional argument `html`
* remove obsolete write function in http.py (tx Justin) (Bug#315337)
* refactor httpserver.runsimple code
* improve form.py for customizability
* new: add background updating to memoize
* fix: use sendmail from web.config.sendmail_path (tx Daniel Schwartz)
* fix: make web.profiler work on Windows (tx asmo) (Bug#325139)
* fix changequery to make it work correctly even when the input has multi-valued fields (Bug#118229)
* fix: make sure sequence exists before queying for currval(seqname) when executing postgres insert query (Bug#268705)
* fix: raise web.notfound() instead of return in autodelegate (tx SeC) 
* fix: raise NotSupportedError when len or bool is used on sqlite result (Bug#179644)
* fix: make db paramater optional for creating postgres DB to allow taking it from environ. (Bug#153491)
* fix unicode errors in db module
* fix: convert unicode strings to UTF8 before printing SQL queries
* fix unicode error in debugerror
* fix: don't convert file upload data to unicode even when file={} is not passed to web.input
* fix checkbox value/checked confusion (Bug#128233)
* fix: consider empty lines as part of the indented block in templetor
* fix: fix a bug in web.group

**2009-06-04: web.py 0.32**

* optional from_address to web.emailerrors
* upgrade wsgiserver to CherryPy/3.1.2
* support for extensions in Jinja2 templates (tx Zhang Huangbin)
* support web.datestr for datetime.date objects also
* support for lists in db queries
* new: uniq and iterview
* fix: set debug=False when application is run with mod_wsgi (tx
Patrick Swieskowski)
[Bug#370904](https://bugs.launchpad.net/webpy/+bug/370904)
* fix: make web.commify work  with decimals
[Bug#317204](https://bugs.launchpad.net/webpy/+bug/317204)
* fix: unicode issues with sqlite database
[Bug#373219](https://bugs.launchpad.net/webpy/+bug/373219)
* fix: urlquote url when the server is lighttpd
[Bug#339858](https://bugs.launchpad.net/webpy/+bug/339858)
* fix: issue with using date.format in templates
* fix: use TOP instead of LIMIT in mssql database
[Bug#324049](https://bugs.launchpad.net/webpy/+bug/324049)
* fix: make sessions work well with expirations
* fix: accept both list and tuple as arg values in form.Dropdown
[Bug#314970](https://bugs.launchpad.net/webpy/+bug/314970)
* fix: match parenthesis when parsing `for` statement in templates
* fix: fix python 2.3 compatibility
* fix: ignore dot folders when compiling templates (tx Stuart Langridge)
* fix: don't consume KeyboardInterrupt and SystemExit errors
* fix: make application work well with iterators

** 2008-12-10: 0.31**

* new: browser module
* new: test utilities
* new: ShelfStore
* fix: web.cookies error when default is None
* fix: paramstyle for OracleDB (tx kromakey)
* fix: performance issue in SQLQuery.join
* fix: use wsgi.url_scheme to find ctx.protocol

**2008-12-06: 0.3**

* new: replace print with return (<i>backward-incompatible</i>)
* new: application framework (<i>backward-incompatible</i>)
* new: modular database system (<i>backward-incompatible</i>)
* new: templetor reimplementation
* new: better unicode support
* new: debug mode (web.config.debug)
* new: better db pooling
* new: sessions
* new: support for GAE
* new: etag support
* new: web.openid module
* new: web.nthstr
* fix: various form.py fixes
* fix: python 2.6 compatibility
* fix: file uploads are not loaded into memory
* fix: SQLLiteral issue (Bug#180027)
* change: web.background is moved to experimental (<i>backward-incompatible</i>) 
* improved API doc generation (tx Colin Rothwell)

**2008-01-19: 0.23**

* fix: for web.background gotcha ([133079](http://bugs.launchpad.net/webpy/+bug/133079))
* fix: for postgres unicode bug ([177265](http://bugs.launchpad.net/webpy/+bug/177265))
* fix: web.profile behavior in python 2.5 ([133080](http://bugs.launchpad.net/webpy/+bug/133080))
* fix: only uppercase HTTP methods are allowed. ([176415](http://bugs.launchpad.net/webpy/+bug/176415))
* fix: transaction error in with statement ([125118](http://bugs.launchpad.net/webpy/+bug/125118))
* fix: fix in web.reparam ([162085](http://bugs.launchpad.net/webpy/+bug/162085))
* fix: various unicode issues ([137042](http://bugs.launchpad.net/webpy/+bug/137042), [180510](http://bugs.launchpad.net/webpy/+bug/180510), [180549](http://bugs.launchpad.net/webpy/+bug/180549), [180653](http://bugs.launchpad.net/webpy/+bug/180653))
* new: support for https
* new: support for secure cookies
* new: sendmail
* new: htmlunquote


**2007-08-23: 0.22**

* compatibility with new DBUtils API ([122112](https://bugs.launchpad.net/webpy/+bug/122112))
* fix reloading ([118683](https://bugs.launchpad.net/webpy/+bug/118683))
* fix compatibility between `changequery` and `redirect` ([118234](https://bugs.launchpad.net/webpy/+bug/118234))
* fix relative URI in `web.redirect` ([118236](https://bugs.launchpad.net/webpy/+bug/118236))
* fix `ctx._write` support in built-in HTTP server ([121908](https://bugs.launchpad.net/webpy/+bug/121908))
* fix `numify` strips things after '.'s ([118644](https://bugs.launchpad.net/webpy/+bug/118644))
* fix various unicode isssues ([114703](https://bugs.launchpad.net/webpy/+bug/114703), [120644](https://bugs.launchpad.net/webpy/+bug/120644), [124280](https://bugs.launchpad.net/webpy/+bug/124280))

**2007-05-28: 0.21**

* <strong>security fix:</strong> prevent bad characters in headers
* support for cheetah template reloading                    
* support for form validation                               
* new `form.File`                                           
* new `web.url`                                             
* fix rendering issues with hidden and button inputs        
* fix 2.3 incompatability with `numify`                     
* fix multiple headers with same name                       
* fix web.redirect issues when homepath is not /            
* new CherryPy wsgi server                                  
* new nested transactions                                   
* new sqlliteral                                            

**2006-05-09: 0.138**

* New function: `intget`
* New function: `datestr`
* New function: `validaddr`
* New function: `sqlwhere`
* New function: `background`, `backgrounder`
* New function: `changequery`
* New function: `flush`
* New function: `load`, `unload`
* New variable: `loadhooks`, `unloadhooks`
* Better docs; generating [docs](documentation) from web.py now
* global variable `REAL_SCRIPT_NAME` can now be used to work around lighttpd madness
* fastcgi/scgi servers now can listen on sockets
* `output` now encodes Unicode
* `input` now takes optional `_method` argument
* <strong>Potentially-incompatible change:</strong> `input` now returns `badrequest` automatically when `requireds` aren't found
* `storify` now takes lists and dictionaries as requests (see docs)
* `redirect` now blanks any existing output
* Quote SQL better when `db_printing` is on
* Fix delay in `nomethod`
* Fix `urlquote` to encode better.
* Fix 2.3 incompatibility with `iters` (tx ??)
* Fix duplicate headers
* Improve `storify` docs
* Fix `IterBetter` to raise IndexError, not KeyError

**2006-03-27: 0.137**

* Add function `dictfindall` (tx Steve Huffman)
* Add support to `autodelegate` for arguments
* Add functions `httpdate` and `parsehttpdate`
* Add function `modified`
* Add support for FastCGI server mode
* Clarify `dictadd` documentation (tx Steve Huffman)
* Changed license to public domain
* Clean up to use `ctx` and `env` instead of `context` and `environ`
* Improved support for PUT, DELETE, etc. (tx list)
* Fix `ctx.fullpath` (tx Jesir Vargas)
* Fix sqlite support (tx Dubhead)
* Fix documentation bug in `lstrips` (tx Gregory Petrosyan)
* Fix support for IPs and ports (1/2 tx Jesir Vargas)
* Fix `ctx.fullpath` (tx Jesir Vargas)
* Fix sqlite support (tx Dubhead)
* Fix documentation bug in `lstrips` (tx Gregory Petrosyan)
* Fix `iters` bug with sets
* Fix some breakage introduced by Vargas's patch
* Fix `sqlors` bug
* Fix various small style things (tx Jesir Vargas)
* Fix bug with `input` ignoring GET input

**2006-02-22: 0.136 (svn)**

* Major code cleanup (tx to Jesir Vargas for the patch).
* 2006-02-15: 0.135
* Really fix that mysql regression (tx Sean Leach).
* 2006-02-15: 0.134
* The `StopIteration` exception is now caught. This can be used by functions that do things like check to see if a user is logged in. If the user isn't, they can output a message with a login box and raise StopIteration, preventing the caller from executing.
* Fix some documentation bugs.
* Fix mysql regression (tx mrstone).

**2006-02-12: 0.133**

* Docstrings! (tx numerous, esp. Jonathan Mark (for the patch) and Guido van Rossum (for the prod))
* Add `set` to web.iters.
* Make the `len` returned by `query` an int (tx ??).
* <strong>Backwards-incompatible change:</strong> `base` now called `prefixurl`.
* <strong>Backwards-incompatible change:</strong> `autoassign` now takes `self` and `locals()` as arguments.

**2006-02-07: 0.132**

* New variable `iters` is now a listing of possible list-like types (currently list, tuple, and, if it exists, Set).
* New function `dictreverse` turns `{1:2}` into `{2:1}`.
* `Storage` now a dictionary subclass.
* `tryall` now takes an optional prefix of functions to run.
* `sqlors` has various improvements.
* Fix a bunch of DB API bugs.
* Fix bug with `storify` when it received multiple inputs (tx Ben Woosley).
* Fix bug with returning a generator (tx Zbynek Winkler).
* Fix bug where len returned a long on query results (tx F.S).


**2006-01-31: 0.131 (not officially released)**

* New function `_interpolate` used internally for interpolating strings.
* Redone database API. `select`, `insert`, `update`, and `delete` all made consistent. Database queries can now do more complicated expressions like `$foo.bar` and `${a+b}`. You now have to explicitly pass the dictionary to look up variables in. Pass `vars=locals()` to get the old functionality of looking up variables .
* New functions `sqllist` and `sqlors` generate certain kinds of SQL.

**2006-01-30: 0.13**

* New functions `found`, `seeother`, and `tempredirect` now let you do other kinds of redirects. `redirect` now also takes an optional status parameter. (tx many)
* New functions `expires` and `lastmodified` make it easy to send those headers.
* New function `gone` returns a 410 Gone (tx David Terrell).
* New function `urlquote` applies url encoding to a string.
* New function `iterbetter` wraps an iterator and allows you to do __getitem__s on it.
* Have `query` return an `iterbetter` instead of an iterator.
* Have `debugerror` show tracebacks with the innermost frame first.
* Add `__hash__` function to `threadeddict` (and thus, `ctx`).
* Add `context.host` value for the requested host name.
* Add option `db_printing` that prints database queries and the time they take.
* Add support for database pooling (tx Steve Huffman).
* Add support for passing values to functions called by `handle`. If you do `('foo', 'value')` it will add `'value'` as an argument when it calls `foo`.
* Add support for scgi (tx David Terrell for the patch).
* Add support for web.py functions that are iterators (tx Brendan O'Connor for the patch).
* Use new database cursors on each call instead of reusing one.
* `setcookie` now takes an optional `domain` argument.
* Fix bug in autoassign.
* Fix bug where `debugerror` would break on objects it couldn't display.
* Fix bug where you couldn't do `#include`s inline.
* Fix bug with `reloader` and database calls.
* Fix bug with `reloader` and base templates.
* Fix bug with CGI mode on certain operating systems.
* Fix bug where `debug` would crash if called outside a request.
* Fix bug with `context.ip` giving weird values with proxies.

**2006-01-29: 0.129**

* Add Python 2.2 support.

**2006-01-28: 0.128**

* Fix typo in `web.profile`.

**2006-01-28: 0.127**

* Fix bug in error message if invalid dbn is sent (tx Panos Laganakos).

**2006-01-27: 0.126**

* Fix typos in Content-Type headers (tx Beat Bolli for the prod).

**2006-01-22: 0.125**

* Support Cheetah 2.0.

**2006-01-22: 0.124**

* Fix spacing bug (tx Tommi Raivio for the prod).

**2006-01-16: 0.123**

* Fix bug with CGI usage (tx Eddie Sowden for the prod).


**2006-01-14: 0.122**

* Allow DELETEs from `web.query` (tx Joost Molenaar for the prod).

**2006-01-08: 0.121**

* Allow import of submodules like `pkg.mod.cn` (tx Sridhar Ratna).
* Fix a bug in `update` (tx Sergey Khenkin).

**2006-01-05: 0.12**

* <strong>Backwards-incompatible change:</strong> `db_parameters` is now a dictionary.
* <strong>Backwards-incompatible change:</strong> `sumdicts` is now `dictadd`.
* Add support for PyGreSQL, MySQL (tx Hallgrimur H. Gunnarsson).
* Use HTML for non-Cheetah error message.
* New function `htmlquote()`.
* New function `tryall()`.
* `ctx.output` can now be set to a generator. (tx Brendan O'Connor)

**2006-01-04: 0.117**

* Add support for psycopg 1.x. (tx Gregory Price)

**2006-01-04: 0.116**

* Add support for Python 2.3. (tx Evan Jones)

**2006-01-04: 0.115**

* Fix some bugs where database queries weren't reparameterized. Oops!
* Fix a bug where `run()` wasn't getting the right functions.
* Remove a debug statement accidentally left in.
* Allow `storify` to be used on dictionaries. (tx Joseph Trent)

**2006-01-04: 0.114**

* Make `reloader` work on Windows. (tx manatlan)
* Fix some small typos that affected colorization. (tx Gregory Price)

**2006-01-03: 0.113**

* Reorganize `run()` internals so mod_python can be used. (tx Nicholas Matsakis)

**2006-01-03: 0.112**

* Make `reloader` work when `code.py` is called with a full path. (tx David Terrell)

**2006-01-03: 0.111**

* Fixed bug in `strips()`. (tx Michael Josephson)

**2006-01-03: 0.11**

* First public version.

---
layout: default
title: asd
---

# asd

asdasd
---
layout: default
title: Alternating Style
---

# Alternating Style

Problem: You want to alternate the background color of a list's elements as you dynamically generate it from a passed sequence.

Solution: Give templetor access to the `int` built-in and use modulo to test.

## code.py ##

    web.template.Template.globals['int'] = int


## template.html ##

    <ul>
    $var i: 0
    $for track in tracks:
        $var i: ${int(self.i) + 1}
        <li class="
        $if int(self.i) % 2:
            odd
        $else:
            even
        ">$track.title</li>
    </ul>


## New Templetor ##

In the new implementation of templetor (which will be the default when version .3 is released), within any template loop you have access to a $loop variable.  This works like so:


    <ul>
    $for foo in foos:
        <li class="$loop.parity">
        $foo
        </li>
    </ul>


---
layout: default
title: 交替风格
---

# 交替风格

### 问题: 

你想通过数据集合动态的生成交替背景色的列表.

### 方法: 

Give templetor access to the `int` built-in and use modulo to test.

## code.py ##

    web.template.Template.globals['int'] = int


## template.html ##

    <ul>
    $var i: 0
    $for track in tracks:
        $var i: ${int(self.i) + 1}
        <li class="
        $if int(self.i) % 2:
            odd
        $else:
            even
        ">$track.title</li>
    </ul>


## New Templetor ##

In the new implementation of templetor (which will be the default when version .3 is released), within any template loop you have access to a $loop variable.  This works like so:


    <ul>
    $for foo in foos:
        <li class="$loop.parity">
        $foo
        </li>
    </ul>
---
layout: default
title: Application processors, hooks
---

# Application processors, hooks

Autre langages [english](/../application_processors) | ...

##  Probleme

Comment utiliser les application processors, charger les hooks et les décharger ? [Note traducteur: est-il possible de traduire "hook" par personnalisation du fonctionnement?]

## Solution

L'application web.py permet d'ajouter des processors qui peuvent effectuer quelques traitements avant et après l'execution des requêtes.

    def my_processor(handler): 
        print 'avant le traitement de la requête'
        result = handler() 
        print 'après le traitement de la requête'
        return result

    app.add_processor(my_processor)

Le chargement et déchargement des hooks peuvent être utilisés pour faire des actions au début et à la fin des requêtes.

    def my_loadhook():
        print "mon chargement de hook"

    def my_unloadhook():
        print "mon déchargement de hook"

    app.add_processor(web.loadhook(my_loadhook))
    app.add_processor(web.unloadhook(my_unloadhook))

Vous pouvez écrire ou utiliser les variables globales dans les fonctions hook, par exemple : web.header()

    def my_loadhook():
        web.header('Content-type', "text/html; charset=utf-8")

    app.add_processor(web.loadhook(my_loadhook))


###Tip: et vous pouvez également utiliser web.ctx ou web.input() dans un hook.

    def my_loadhook():
        input = web.input()
        print input
---
layout: default
title: Application processors, hooks
---

# Application processors, hooks

Other languages : [français](/../cookbook/application_processors/fr) | ...

##  Problem

How to use application processors, loadhooks and unload hooks?

## Solution

web.py application allows adding processors which can do some processing before and after executing the requests

    def my_processor(handler): 
        print 'before handling'
        result = handler() 
        print 'after handling'
        return result

    app.add_processor(my_processor)

Load hooks and unload hooks can be used to do actions at begining and end of requests.

    def my_loadhook():
        print "my load hook"

    def my_unloadhook():
        print "my unload hook"

    app.add_processor(web.loadhook(my_loadhook))
    app.add_processor(web.unloadhook(my_unloadhook))

you can write or use global variables in hook function, for example: web.header()

    def my_loadhook():
        web.header('Content-type', "text/html; charset=utf-8")

    app.add_processor(web.loadhook(my_loadhook))

###Tip: and also can use web.ctx or web.input() in hook.

    def my_loadhook():
        input = web.input()
        print input
---
layout: default
title: Application processors
---

# Application processors

## 问题

如何使用应用处理器，加载钩子(loadhooks)和卸载钩子(unloadhook)？

## 解法

web.py可以在处理请求之前或之后，通过添加处理器(processor)来完成某些操作。

    def my_processor(handler): 
        print 'before handling'
        result = handler() 
        print 'after handling'
        return result

    app.add_processor(my_processor)

可以用加载钩子(loadhook)和卸载钩子(unloadhook)的方式来完成同样的操作，它们分别在请求开始之前和结束之后工作。

    def my_loadhook():
        print "my load hook"

    def my_unloadhook():
        print "my unload hook"

    app.add_processor(web.loadhook(my_loadhook))
    app.add_processor(web.unloadhook(my_unloadhook))

你可以在钩子中使用和修改全局变量，比如：web.header()

    def my_loadhook():
        web.header('Content-type', "text/html; charset=utf-8")

    app.add_processor(web.loadhook(my_loadhook))

###提示: 你也可以在钩子中使用 web.ctx 和 web.input() 。

    def my_loadhook():
        input = web.input()
        print input

---
layout: default
title: How to use web.background
---

# How to use web.background

*WARNING* web.backgrounder was moved to experimental with web.py 3.x and it no longer part of the default distribution. You can get it from [here](http://github.com/webpy/webpy/blob/686aafab4c1c5d0e438b4b36fab3d14d121ef99f/experimental/background.py) and put it in the same directory as application.py i.e. the web directory for this to work.

Intro
-----

web.background (and web.backgrounder) are python function decorators which allow you to execute a function in a separate background thread to that thread which served the current HTTP request and later report back on the status of the background thread (the stdout of the background function is in effect returned to the "backgrounder" that initiated the thread.

This allows you to respond quickly to the client and move to to serving other http requests, while the background thread performs some long running function.

Example
-------

    #!/usr/bin/env python
    # -*- coding: utf-8 -*-
    from web import run, background, backgrounder
    from datetime import datetime; now = datetime.now
    from time import sleep

    urls = (
        '/', 'index',
        )

    class index:
        @backgrounder
        def GET(self):
            print "Started at %s" % now()
            print "hit f5 to refresh!"
            longrunning()
            

    @background
    def longrunning():
        for i in range(10):
            sleep(1)
            print "%s: %s" % (i, now())

    if __name__ == '__main__':
        run(urls, globals())

On requesting http://localhost:8080/ you will be redirected automatically to a URL like http://localhost:8080/?_t=3080772748 ( depending on the background thread id) and (after you hit refresh a few times) you'll see something like;

    Started at 2008-06-14 15:50:26.764474
    hit f5 to refresh!
    0: 2008-06-14 15:50:27.763813
    1: 2008-06-14 15:50:28.763861
    2: 2008-06-14 15:50:29.763844
    3: 2008-06-14 15:50:30.763853
    4: 2008-06-14 15:50:31.764778
    5: 2008-06-14 15:50:32.763852
    6: 2008-06-14 15:50:33.764338
    7: 2008-06-14 15:50:34.763925
    8: 2008-06-14 15:50:35.763854
    9: 2008-06-14 15:50:36.763789

Notes
------------

web.py keeps track of threads in the background.threaddb dictionary. It's easy to examine the state of it like;

    class threaddbviewer:
        def GET(self):
            for k, v in background.threaddb.items():
                print "%s - %s" % ( k, v )

web.py doesn't attempt to clean up threaddb dictionary, which allows the output (like http://localhost:8080/?_t=3080772748 ) to continue to be served but is going to fill up memory over time.

Probably the backgrounder needs to clean up, as it's able to determine the thread id (from web.input() - '_t') although it's actually the background function which knows when it's finished, but doesn't know it's thread ID.

Note also [How not to do thread local storage with Python](http://blogs.gnome.org/jamesh/2008/06/11/tls-python/) - thread id's are going to get re-used at some point (there's probably bugs to report here).

In other words, _handle with care_.
---
layout: default
title: 如何使用web.background
---

# 如何使用web.background

*注意！！*  web.backgrounder已转移到web.py 3.X实验版本中，不再是发行版中的一部分。你可以在[这里](http://github.com/webpy/webpy/blob/686aafab4c1c5d0e438b4b36fab3d14d121ef99f/experimental/background.py)下载，要把它与application.py放置在同一目录下才能正运行。

介绍
-----

web.background和web.backgrounder都是python装饰器，它可以让某个函式在一个单独的background线程中运行，而主线程继续处理当前的HTTP请求，并在稍后报告background线程的状态(事实上，后台函式的标准输出(stdout)被返回给启动该线程的"backrounder")。
译注：我本来想将background thread翻译为后台线程，后来认为作者本意是想表达“被background修饰的函式所在的线程”，最后翻译采用“background线程”

这样，服务器就可以在处理其他http请求的同时，快速及时地响应当前客户端请求。同时，background线程继续执行需要长时间运行的函式。

例子
-------

    #!/usr/bin/env python
    # -*- coding: utf-8 -*-
    from web import run, background, backgrounder
    from datetime import datetime; now = datetime.now
    from time import sleep

    urls = (
        '/', 'index',
        )

    class index:
        @backgrounder
        def GET(self):
            print "Started at %s" % now()
            print "hit f5 to refresh!"
            longrunning()
            

    @background
    def longrunning():
        for i in range(10):
            sleep(1)
            print "%s: %s" % (i, now())

    if __name__ == '__main__':
        run(urls, globals())

在请求http://localhost:8080/时，将自动重定向到类似http://localhost:8080/?_t=3080772748的网址(t后面的数字就是background线程id)，接下来(在点击几次刷新之后)就会看到如下信息：

    Started at 2008-06-14 15:50:26.764474
    hit f5 to refresh!
    0: 2008-06-14 15:50:27.763813
    1: 2008-06-14 15:50:28.763861
    2: 2008-06-14 15:50:29.763844
    3: 2008-06-14 15:50:30.763853
    4: 2008-06-14 15:50:31.764778
    5: 2008-06-14 15:50:32.763852
    6: 2008-06-14 15:50:33.764338
    7: 2008-06-14 15:50:34.763925
    8: 2008-06-14 15:50:35.763854
    9: 2008-06-14 15:50:36.763789

提示
------------

web.py在background.threaddb字典中保存线程信息。这就很容易检查线程的状态；

    class threaddbviewer:
        def GET(self):
            for k, v in background.threaddb.items():
                print "%s - %s" % ( k, v )

web.py并不会主动去清空threaddb词典，这使得输出(如http://localhost:8080/?_t=3080772748)会一直执行，直到内存被用满。

通常是在backgrounder函式中做线程清理工作，是因为backgrounder可以获得线程id(通过web.input()得到"_t"的值，就是线程id)，从而根据线程id来回收资源。这是因为虽然background能知道自己何时结束，但它无法获得自己的线程id，所以background无法自己完成线程清理。

还要注意 [How not to do thread local storage with Python 在python中如何避免多线程本地存储](http://blogs.gnome.org/jamesh/2008/06/11/tls-python/) - 线程ID有时会被重用(可能会引发错误)

在使用web.background时，还是那句话－－“小心为上”
---
layout: default
title: Browser Testing
---

# Browser Testing

### Problem

You want to test webpy applications.

### Solution

Use the 'browser' module. 
    
    urls = (
        '/', 'Index',
        '/login', 'Login',
    )

    class Index:
    
        def GET(self):
            return """
            <html><body>
            <a href="/login">Login</a>
            </body></html>"""

    class Login:
        
        def GET(self):
            return """
            <html><body>
            <form name="login" action="">
            Name: <input type="text" name="username"><br>
            PW: <input type="password" name="password"><br>
            </form>
            </body><html>
            """
    
        def POST(self):
            i = web.input()
            return "Welcome " + i.name
             
    
    app = web.application(urls, globals())
    
    b = app.browser()
    b.open('/')
    b.follow_link(text='Login')

    b.select_form(name='login')
    b['username'] = 'joe'
    b['password'] = 'secret'
    b.submit()

    assert b.path == '/login'
    assert 'Welcome joe' in b.get_text()

It is also possible to use the browser module for crawling or testing
existing websites.

    b = web.Browser()
    b.open('http://webpy.org')
    b.follow_link(url_regex='login')

    b.select_form(name='login')
    b['username'] = 'joe'
    b['password'] = 'secret'
    b.submit()

    assert b.path == '/'
    assert 'Log Out' in b.get_text() 
---
layout: default
title: Apach + CGIの配置
---

# Apach + CGIの配置

ここでは、web.pyアプリケーションを作成、実行するために必要となる簡単な手順を説明します。

* web.pyとflupsをインストールします。

* 下記のドキュメント通りにアプリケーションを作成します。

        if __name__ == "__main__":
            web.run(urls, globals())

この例では、`app.py`という名前で、`/www/app`の中に配置し、`http://serever/app/app.py`でアクセスできる必要があります。

* Apacheを設定します。(ここでは、バージョン2.2を例にします)

        ScriptAlias /app "/www/app/"
        <Directory "/www/app/">
                Options +ExecCGI +FollowSymLinks
                Order allow,deny
                Allow from all
        </Directory>

これで完了です。あなたのアプリケーションは`http://server/app/app.py`からアクセスができます。このアプリケーションで扱えるその他のURLは、例えば、
`http://server/app/app.py/myurl`のように、このURLの末尾に付け加えます。

---
layout: default
title: CGI deployment on Apache
---

# CGI deployment on Apache

Here are the simple steps needed to create and run an web.py application.

* Install web.py and flups

* Create the application as documented

        if __name__ == "__main__":
            web.application(urls, globals()).run()

For our example, let it be named `app.py`, located in `/www/app` and we need it accessible as `http://server/app/app.py`.

* Configure Apache (version 2.2 in this example)

        ScriptAlias /app "/www/app/"
        <Directory "/www/app/">
                Options +ExecCGI +FollowSymLinks
                Order allow,deny
                Allow from all
        </Directory>

That's it. Your application is accessible via `http://server/app/app.py/`. Additional URLs handled by the application are added to the end of the URL, for examples `http://server/app/app.py/myurl`.

* .htaccess configuration 

              Options +ExecCGI
              AddHandler cgi-script .py
              DirectoryIndex index.py
              <IfModule mod_rewrite.c>
                  RewriteEngine on
                  RewriteBase /
                  RewriteCond %{REQUEST_FILENAME} !-f
                  RewriteCond %{REQUEST_FILENAME} !-d
                  RewriteCond %{REQUEST_URI} !^/favicon.ico$
                  RewriteCond %{REQUEST_URI} !^(/.*)+index.py/
                  RewriteRule ^(.*)$ index.py/$1 [PT]
              </IfModule>

Here it is assumed that your application is called index.py. The above htaccess checks if some static file/directory exists failing which it routes the data to your index.py. Change the Rewrite Base to a sub-directory if needed.

#Hiding the script name using mod_rewrite (tested with webpy 0.33)

(warning: this section written by someone new to webpy; it works, but may not follow prescribed practices)

If you want your app accessible as `http://server/app/` and not `http://server/app/app.py/` (i.e. `http://server/app/articles/` and not `http://server/app/app.py/articles`) then you need to tweak mod_rewrite a bit. Here's an example of the relevant bit in a .htaccess file (placed in `/www/app` or wherever `app.py` is):

    RewriteEngine on
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteRule ^(.*)$ app.py/$1 [L]

It's cruder than the rewrite rules presented above. The first rule states that if a file exists it should be served by the webserver (ideally you'd want something more secure than that, like only certain file types, or only static/). The second line says in any request of form `.../app.py/blah` we should run `app.py` and give it `blah`.

So now if you go to `http://server/app/` you'll hit `app.py`'s handler for `'/'`. If you go to `http://server/app/articles`, the handler for `'/articles'`, etc.

Are we done? Well, that's what I thought. There's still one problem: webpy doesn't know how things were rewritten on the way *in*, so it doesn't know how to rewrite them on the way *out*.

For instance, one can normally use `web.url()` to compose urls such that the right content is found. Want `static/style.css`? Call `web.url('/static/style.css') and you'll get ... `/app/app.py/static/style.css` ... not what we wanted. That doesn't exist. Problem.

If you don't use `web.url()`, it can still bite you because *webpy* does. Say `raise web.seeother('/')` and you'll end up at `http://server/app/app.py/`, which defeats the purpose of hiding it using mod_rewrite.

How to fix that prefix on the way out then? That's stored in `web.ctx.homepath`. Unfortunately, efforts to modify that didn't work for me. Some old forum post said it comes from the environment variable `SCRIPT_NAME` but that didn't work either. It turns out `REAL_SCRIPT_NAME` works though, so we can add the following to our `app.py`, before initialising webpy:

    import os

    home = '/app'
    os.environ["SCRIPT_NAME"] = home
    os.environ["REAL_SCRIPT_NAME"] = home

    #and calling web.application or whatever goes here or after

This seems to work. Running `raise web.seeother('/')` gets us to `http://server/app/` like we wanted.
---
layout: default
title: CGI deployment on Apache
---

# CGI deployment on Apache

Here are the simple steps needed to create and run an web.py application.

* Install web.py and flups

* Create the application as documented

        if __name__ == "__main__":
            web.run(urls, globals())

For our example, let it be named `app.py`, located in `/www/app` and we need it accessible as `http://server/app/app.py`.

* Configure Apache (version 2.2 in this example)

        ScriptAlias /app "/www/app/"
        <Directory "/www/app/">
                Options +ExecCGI +FollowSymLinks
                Order allow,deny
                Allow from all
        </Directory>

That's it. Your application is accessible via `http://server/app/app.py/`. Additional URLs handled by the application are added to the end of the URL, for examples `http://server/app/app.py/myurl`.

* .htaccess configuration 

              Options +ExecCGI
              AddHandler cgi-script .py
              DirectoryIndex index.py
              <IfModule mod_rewrite.c>
                  RewriteEngine on
                  RewriteBase /
                  RewriteCond %{REQUEST_FILENAME} !-f
                  RewriteCond %{REQUEST_FILENAME} !-d
                  RewriteCond %{REQUEST_URI} !^/favicon.ico$
                  RewriteCond %{REQUEST_URI} !^(/.*)+index.py/
                  RewriteRule ^(.*)$ index.py/$1 [PT]
              </IfModule>

Here it is assumed that your application is called index.py. The above htaccess checks if some static file/directory exists failing which it routes the data to your index.py. Change the Rewrite Base to a sub-directory if needed.
---
layout: default
title: How to concatenate two rendered templates?
---

# How to concatenate two rendered templates?

### Problem:

How to concatenate two rendered templates?

### Solution:

    render = web.template.render('templates')

    def GET(): 
        article = render.article() 
        comments = render.comments() 
        return render.index(unicode(article), unicode(comments))
---
layout: default
title: 提供XML访问
---

# 提供XML访问

### 问题

如何在web.py中提供XML访问？

如果需要为第三方应用收发数据，那么提供xml访问是很有必要的。

### 解法

根据要访问的xml文件(如response.xml)创建一个XML模板。如果XML中有变量，就使用相应的模板标签进行替换。下面是一个例子：

    $def with (code)
    <?xml version="1.0"?>
    <RequestNotification-Response>
    <Status>$code</Status>
    </RequestNotification-Response>

为了提供这个XML，需要创建一个单独的web.py程序(如response.py)，它要包含下面的代码。注意：要用"web.header('Content-Type', 'text/xml')"来告知客户端－－正在发送的是一个XML文件。


    import web

    render = web.template.render('templates/', cache=False)

    urls = (
        '/(.*)', 'index'
    )

    app = web.application(urls, globals())

    class index:
        def GET(self, code):
            web.header('Content-Type', 'text/xml')
            return render.index(code)

    web.webapi.internalerror = web.debugerror
    if __name__ == '__main__': app.run()
---
layout: default
title: 
---


---
layout: default
title: 在webpy中使用Mako模板引擎
---

# 在webpy中使用Mako模板引擎

### 问题
如何在webpy中使用Mako模板引擎?
### 解决方案
首先需要安装Mako和web.py(0.3):http://www.makotemplates.org/ 然后尝试下面的代码:
<pre>
# encoding: utf-8
# File: code.py
import web
from web.contrib.template import render_mako
urls = (
        '/(.*)', 'hello'
        )
app = web.application(urls, globals(), autoreload=True)
# input_encoding and output_encoding is important for unicode
# template file. Reference:
# http://www.makotemplates.org/docs/documentation.html#unicode
render = render_mako(
        directories=['templates'],
        input_encoding='utf-8',
        output_encoding='utf-8',
        )

class hello:
    def GET(self, name):
        return render.hello(name=name)
        # Another way:
        #return render.hello(**locals())

if __name__ == "__main__":
    app.run()
</pre>

### 模板文件

<pre>
## File: templates/hello.html

Hello, ${name}.
</pre>

### 注意:
如果你使用Apache+mod_wsgi来部署webpy程序, 你也许会在Apache错误日志中得到下面的错误信息:
[Sat Jun 21 21:56:22 2008] [error] [client 192.168.122.1] TopLevelLookupException: Cant locate template for uri 'index.html'

你必须使用绝对路径指出模板的位置.
你也可以使用相对路径来让它更简单一些:
<pre>
import os

render = render_mako(
        directories=[os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),],
        input_encoding='utf-8',
        output_encoding='utf-8',
        )
</pre>
### 参考:
http://code.google.com/p/modwsgi/wiki/ApplicationIssues
---
layout: default
title: Application processors
---

# Application processors

## 问题

如何使用应用处理器，加载钩子(loadhooks)和卸载钩子(unloadhook)？

## 解法

web.py可以在处理请求之前或之后，通过添加处理器(processor)来完成某些操作。

    def my_processor(handler): 
        print 'before handling'
        result = handler() 
        print 'after handling'
        return result

    app.add_processor(my_processor)

可以用加载钩子(loadhook)和卸载钩子(unloadhook)的方式来完成同样的操作，它们分别在请求开始之前和结束之后工作。

    def my_loadhook():
        print "my load hook"

    def my_unloadhook():
        print "my unload hook"

    app.add_processor(web.loadhook(my_loadhook))
    app.add_processor(web.unloadhook(my_unloadhook))
---
layout: default
title: 如何使用web.background
---

# 如何使用web.background

*注意！！*  web.backgrounder已转移到web.py 3.X实验版本中，不再是发行版中的一部分。你可以在[这里](http://github.com/webpy/webpy/blob/686aafab4c1c5d0e438b4b36fab3d14d121ef99f/experimental/background.py)下载，要把它与application.py放置在同一目录下才能正运行。

介绍
-----

web.background和web.backgrounder都是python装饰器，它可以让某个函式在一个单独的background线程中运行，而主线程继续处理当前的HTTP请求，并在稍后报告background线程的状态(事实上，后台函式的标准输出(stdout)被返回给启动该线程的"backrounder")。
译注：我本来想将background thread翻译为后台线程，后来认为作者本意是想表达“被background修饰的函式所在的线程”，最后翻译采用“background线程”

这样，服务器就可以在处理其他http请求的同时，快速及时地响应当前客户端请求。同时，background线程继续执行需要长时间运行的函式。

例子
-------

    #!/usr/bin/env python
    # -*- coding: utf-8 -*-
    from web import run, background, backgrounder
    from datetime import datetime; now = datetime.now
    from time import sleep

    urls = (
        '/', 'index',
        )

    class index:
        @backgrounder
        def GET(self):
            print "Started at %s" % now()
            print "hit f5 to refresh!"
            longrunning()
            

    @background
    def longrunning():
        for i in range(10):
            sleep(1)
            print "%s: %s" % (i, now())

    if __name__ == '__main__':
        run(urls, globals())

在请求http://localhost:8080/时，将自动重定向到类似http://localhost:8080/?_t=3080772748的网址(t后面的数字就是background线程id)，接下来(在点击几次刷新之后)就会看到如下信息：

    Started at 2008-06-14 15:50:26.764474
    hit f5 to refresh!
    0: 2008-06-14 15:50:27.763813
    1: 2008-06-14 15:50:28.763861
    2: 2008-06-14 15:50:29.763844
    3: 2008-06-14 15:50:30.763853
    4: 2008-06-14 15:50:31.764778
    5: 2008-06-14 15:50:32.763852
    6: 2008-06-14 15:50:33.764338
    7: 2008-06-14 15:50:34.763925
    8: 2008-06-14 15:50:35.763854
    9: 2008-06-14 15:50:36.763789

提示
------------

web.py在background.threaddb字典中保存线程信息。这就很容易检查线程的状态；

    class threaddbviewer:
        def GET(self):
            for k, v in background.threaddb.items():
                print "%s - %s" % ( k, v )

web.py并不会主动去清空threaddb词典，这使得输出(如http://localhost:8080/?_t=3080772748)会一直执行，直到内存被用满。

通常是在backgrounder函式中做线程清理工作，是因为backgrounder可以获得线程id(通过web.input()得到"_t"的值，就是线程id)，从而根据线程id来回收资源。这是因为虽然background能知道自己何时结束，但它无法获得自己的线程id，所以background无法自己完成线程清理。

还要注意 [How not to do thread local storage with Python 在python中如何避免多线程本地存储](http://blogs.gnome.org/jamesh/2008/06/11/tls-python/) - 线程ID有时会被重用(可能会引发错误)

在使用web.background时，还是那句话－－“小心为上”
---
layout: default
title: 如何操作Cookie
---

# 如何操作Cookie

##问题

如何设置和获取用户的Cookie?

##解法

对web.py而言，设置/获取Cookie非常方便。

###设置Cookies
####概述
    setcookie(name, value, expires="", domain=None, secure=False): 
       
* *name* `(string)` - Cookie的名称，由浏览器保存并发送至服务器。
* *value* `(string)` -Cookie的值，与Cookie的名称相对应。
* *expires* `(int)` - Cookie的过期时间，这是个可选参数，它决定cookie有效时间是多久。以秒为单位。它必须是一个整数，而绝不能是字符串。
* *domain* `(string)` - Cookie的有效域－在该域内cookie才是有效的。一般情况下，要在某站点内可用，该参数值该写做站点的域（比如.webpy.org），而不是站主的主机名（比如wiki.webpy.org）
* *secure* `(bool)`- 如果为True，要求该Cookie只能通过HTTPS传输。.

####示例
用`web.setcookie()` 设置cookie,如下:

    class CookieSet:
        def GET(self):
            i = web.input(age='25')
            web.setcookie('age', i.age, 3600)
            return "Age set in your cookie"


用 GET方式调用上面的类将设置一个名为age,默认值是25的cookie(实际上，默认值25是在web.input中赋予i.age的，从而间接赋予 cookie，而不是在setcookie函式中直接赋予cookie的)。这个cookie将在一小时后(即3600秒)过期。

`web.setcookie()`的第三个参数－"expires"是一个可选参数，它用来设定cookie过期的时间。如果是负数，cookie将立刻过期。如果是正数，就表示cookie的有效时间是多久，以秒为单位。如果该参数为空，cookie就永不过期。

###获得Cookies
####概述
获取Cookie的值有很多方法，它们的区别就在于找不到cookie时如何处理。
#####方法1（如果找不到cookie，就返回None）：
    web.cookies().get(cookieName)  
        #cookieName is the name of the cookie submitted by the browser
#####方法2（如果找不到cookie，就抛出AttributeError异常）：
    foo = web.cookies()
    foo.cookieName
#####方法3（如果找不到cookie，可以设置默认值来避免抛出异常）：
    foo = web.cookies(cookieName=defaultValue)
    foo.cookieName   # return the value (which could be default)
        #cookieName is the name of the cookie submitted by the browser

####示例：
用`web.cookies()` 访问cookie.  如果已经用`web.setcookie()`设置了Cookie, 就可以象下面这样获得Cookie:

    class CookieGet:
        def GET(self):
            c = web.cookies(age="25")
            return "Your age is: " + c.age

这个例子为cookie设置了默认值。这么做的原因是在访问时，若cookie不存在，web.cookies()就会抛出异常，如果事先设置了默认值就不会出现这种情况。

如果要确认cookie值是否存在，可以这样做：

    class CookieGet:
        def GET(self):
            try: 
                 return "Your age is: " + web.cookies().age
            except:
                 # Do whatever handling you need to, etc. here.
                 return "Cookie does not exist."

或

    class CookieGet:
        def GET(self):
            age=web.cookies().get(age)
            if age:
                return "Your age is: %s" % age
            else:
                return "Cookie does not exist."
---
layout: default
title: web.ctx
---

# web.ctx

问题
-------

如何在代码中得到客户端信息？比如：来源页面(referring page)或是客户端浏览器类型

解法
--------

使用web.ctx即可。首先讲一点架构的东西：web.ctx基于threadeddict类，又被叫做ThreadDict。这个类创建了一个类似字典(dictionary-like)的对象，对象中的值都是与线程id相对应的。这样做很妙,因为很多用户同时访问系统时，这个字典对象能做到仅为某一特定的HTTP请求提供数据(因为没有数据共享，所以对象是线程安全的)

web.ctx保存每个HTTP请求的特定信息，比如客户端环境变量。假设，我们想知道正在访问某页面的用户是从哪个网页跳转而来的：

例子
-------

    class example:
        def GET(self):
            referer = web.ctx.env.get('HTTP_REFERER', 'http://google.com')
            raise web.seeother(referer)

上述代码用web.ctx.env获取HTTP_REFERER的值。如果HTTP＿REFERER不存在，就会将google.com做为默认值。接下来，用户就会被重定向回到之前的来源页面。

web.ctx另一个特性，是它可以被loadhook赋值。例如：当一个请求被处理时，会话(Session)就会被设置并保存在web.ctx中。由于web.ctx是线程安全的，所以我们可以象使用普通的python对象一样，来操作会话(Session)。

'ctx'中的数据成员
-------------------

### Request ###
*   `environ` 又被写做. `env` &ndash; 包含标准WSGI环境变量的字典。
*   `home` &ndash; 应用的http根路径(译注：可以理解为应用的起始网址，协议＋站点域名＋应用所在路径)例：*http://example.org/admin*
*   `homedomain` &ndash; 应用所在站点(可以理解为协议＋域名) *http://example.org*
*   `homepath` &ndash; 当前应用所在的路径，例如： */admin*
*   `host` &ndash; 主机名（域名）＋用户请求的端口（如果没有的话，就是默认的80端口），例如： *example.org*, *example.org:8080*
*   `ip` &ndash; 用户的IP地址，例如： *xxx.xxx.xxx.xxx*
*   `method` &ndash; 所用的HTTP方法，例如： *GET*
*   `path` &ndash; 用户请求路径，它是基于当前应用的相对路径。在子应用中，匹配外部应用的那部分网址将被去掉。例如：主应用在`code.py`中，而子应用在`admin.py`中。在`code.py`中, 我们将`/admin`关联到`admin.app`。 在`admin.py`中, 将`/stories`关联到`stories`类。在 `stories`中, `web.ctx.path`就是`/stories`, 而非`/admin/stories`。形如： */articles/845*
*   `protocol` &ndash; 所用协议，例如： *https*
*   `query` &ndash; 跟在'？'字符后面的查询字符串。如果不存在查询参数，它就是一个空字符串。例如： *?fourlegs=good&twolegs=bad*
*   `fullpath` 可以视为 `path + query` &ndash; 包含查询参数的请求路径，但不包括'homepath'。例如：*/articles/845?fourlegs=good&twolegs=bad*

### Response ###
*   `status` &ndash; HTTP状态码（默认是'200 OK') *401 Unauthorized 未经授权*
*   `headers` &ndash; 包含HTTP头信息(headers)的二元组列表。
*   `output` &ndash; 包含响应实体的字符串。
---
layout: default
title: 自定义NotFound消息
---

# 自定义NotFound消息

## 问题

如何定义NotFound消息和其他消息？

## 解法

    import web

    urls = (...)
    app =  web.application(urls, globals())

    def notfound():
        return web.notfound("Sorry, the page you were looking for was not found.")

        # You can use template result like below, either is ok:
        #return web.notfound(render.notfound())
        #return web.notfound(str(render.notfound()))

    app.notfound = notfound


要返回自定义的NotFound消息，这么做即可：

    class example:
        def GET(self):
            raise web.notfound()

也可以用同样的方法自定义500错误消息：

    def internalerror():
        return web.internalerror("Bad, bad server. No donut for you.")

    app.internalerror = internalerror
---
layout: default
title: Hello World!
---

# Hello World!

## 问题

如何用web.py实现Hello World!？

## 解法

    import web

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()

###提示：要保证网址有无'/'结尾，都能指向同一个类。就要多写几行代码，如下：

在URL开头添加代码：

    '/(.*)/', 'redirect', 

然后用redirect类处理以'/'结尾的网址：

    class redirect:
        def GET(self, path):
            web.seeother('/' + path)
---
layout: default
title: 管理自带webserver日志
---

# 管理自带webserver日志

## 问题

如何操作web.py自带的webserver的日志？

## 解法

我们可以用[wsgilog](http://pypi.python.org/pypi/wsgilog/)来操作内置的webserver的日志，并做其为中间件加到应用中。

如下，写一个Log类继承wsgilog.WsgiLog，在_init_中把参数传给基类，如[这个例子](http://github.com/harryf/urldammit/blob/234bcaae6deb65240e64ee3199213712ed62883a/dammit/log.py)：

    import sys, logging
    from wsgilog import WsgiLog, LogIO
    import config

    class Log(WsgiLog):
        def __init__(self, application):
            WsgiLog.__init__(
                self,
                application,
                logformat = '%(message)s',
                tofile = True,
                file = config.log_file,
                interval = config.log_interval,
                backups = config.log_backups
                )
            sys.stdout = LogIO(self.logger, logging.INFO)
            sys.stderr = LogIO(self.logger, logging.ERROR)

接下来，当应用运行时，传递一个引用给上例中的Log类即可(假设上面代码是'mylog'模块的一部分，代码如下)：

    from mylog import Log
    application = web.application(urls, globals())
    application.run(Log)
---
layout: default
title: 跳转(seeother)与重定向(redirect)
---

# 跳转(seeother)与重定向(redirect)

## web.seeother 和 web.redirect

### 问题
在处理完用户输入后（比方说处理完一个表单），如何跳转到其他页面？

### 解法

    class SomePage:
        def POST(self):
            # Do some application logic here, and then:
            raise web.seeother('/someotherpage')

POST方法接收到一个post并完成处理之后，它将给浏览器发送一个303消息和新网址。接下来，浏览器就会对这个新网址发出GET请求，从而完成跳转。

注意：web.seeother和web.redirect不支持0.3以下版本。

### 区别
用web.redirect方法似乎也能做同样的事情，但通常来说，这并太友好。因为web.redirect发送的是301消息－这是永久重定向。因为大多数Web浏览器会缓存新的重定向，所以当我们再次执行该操作时，会自动直接访问重定向的新网址。很多时候，这不是我们所想要的结果。所以在提交表单时，尽量使用seeother。但是在下面要提到的这种场合，用redirect却是最恰当的：我们已经更改了网站的网址结构，但是仍想让用户书签/收藏夹中的旧网址不失效。

(注：要了解seeother和redirect的区别，最好是看一下http协议中不同消息码的含义。)
---
layout: default
title: 发送邮件
---

# 发送邮件

### 问题

在web.py中，如何发送邮件？

### 解法

在web.py中使用`web.sendmail()`发送邮件. 

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message')

如果在`web.config`中指定了邮件服务器，就会使用该服务器发送邮件，否则，就根据`/usr/lib/sendmail`中的设置发送邮件。

    web.config.smtp_server = 'mail.mydomain.com'

如果要发送邮件给多个收件人，就给to_address赋值一个邮箱列表。

    web.sendmail('cookbook@webpy.org', ['user1@example.com', 'user2@example.com'], 'subject', 'message')

`cc`和`bcc`关键字参数是可选的，分别表示抄送和暗送接收人。这两个参数也可以是列表，表示抄送/暗送多人。

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message', cc='user1@example.com', bcc='user2@example.com')

`headers`参数是一个元组，表示附加标头信息(Addition headers)

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message',
            cc='user1@example.com', bcc='user2@example.com',
            headers=({'User-Agent': 'webpy.sendmail', 'X-Mailer': 'webpy.sendmail',})
            )
---
layout: default
title: 如何用Gmail发送邮件
---

# 如何用Gmail发送邮件

### 问题 

如何用Gmail发送邮件？

### 解法

安装和维护邮件服务器通常是沉闷乏味的。所以如果你有Gmail帐号，就可以使用Gmail做为SMTP服务器来发送邮件，我们唯一要做的就只是在`web.config`中指定Gmail的用户名和密码。

    web.config.smtp_server = 'smtp.gmail.com'
    web.config.smtp_port = 587
    web.config.smtp_username = 'cookbook@gmail.com'
    web.config.smtp_password = 'secret'
    web.config.smtp_starttls = True

设置好之后，web.sendmail就能使用Gmail帐号来发送邮件了，用起来和其他邮件服务器没有区别。

    web.sendmail('cookbook@gmail.com', 'user@example.com', 'subject', 'message')

可以在这里了解有关Gmail设置的更多信息 [GMail: Configuring other mail clients][1] 

[1]: http://mail.google.com/support/bin/answer.py?hl=en&answer=13287
---
layout: default
title: Sessions
---

# Sessions

### 问题

如何在web.py中使用session

### 解法

*注意！！！：session并不能在调试模式(Debug mode)下正常工作，这是因为session与调试模试下的重调用相冲突(有点类似firefox下著名的Firebug插件，使用Firebug插件分析网页时，会在火狐浏览器之外单独对该网页发起请求，所以相当于同时访问该网页两次)，下一节中我们会给出在调试模式下使用session的解决办法。*

`web.session`模块提供session支持。下面是一个简单的例子－－统计有多少人正在使用session(session计数器)：

    import web
    web.config.debug = False
    urls = (
        "/count", "count",
        "/reset", "reset"
    )
    app = web.application(urls, locals())
    session = web.session.Session(app, web.session.DiskStore('sessions'), initializer={'count': 0})

    class count:
        def GET(self):
            session.count += 1
            return str(session.count)
            
    class reset:
        def GET(self):
            session.kill()
            return ""

    if __name__ == "__main__":
        app.run()

web.py在处理请求之前，就加载session对象及其数据；在请求处理完之后，会检查session数据是否被改动。如果被改动，就交由session对象保存。

上例中的`initializer`参数决定了session初始化的值，它是个可选参数。

如果用数据库代替磁盘文件来存储session信息，只要用`DBStore`代替`DiskStore`即可。使用DBStore需要建立一个表，结构如下：

     create table sessions (
        session_id char(128) UNIQUE NOT NULL,
        atime timestamp NOT NULL default current_timestamp,
        data text
    );

`DBStore`被创建要传入两个参数：`db`对象和session的表名。

    db = web.database(dbn='postgres', db='mydatabase', user='myname', pw='')
    store = web.session.DBStore(db, 'sessions')
    session = web.session.Session(app, store, initializer={'count': 0})


｀web.config｀中的`sessions_parameters`保存着session的相关设置，`sessions_parameters`本身是一个字典，可以对其修改。默认设置如下：

    web.config.session_parameters['cookie_name'] = 'webpy_session_id'
    web.config.session_parameters['cookie_domain'] = None
    web.config.session_parameters['timeout'] = 86400, #24 * 60 * 60, # 24 hours   in seconds
    web.config.session_parameters['ignore_expiry'] = True
    web.config.session_parameters['ignore_change_ip'] = True
    web.config.session_parameters['secret_key'] = 'fLjUfxqXtfNoIldA0A0J'
    web.config.session_parameters['expired_message'] = 'Session expired'

 * cookie_name - 保存session id的Cookie的名称
 * cookie_domain - 保存session id的Cookie的domain信息
 * timeout - session的有效时间 ，以秒为单位
 * ignore_expiry - 如果为True，session就永不过期
 * ignore_change_ip - 如果为true，就表明只有在访问该session的IP与创建该session的IP完全一致时，session才被允许访问。
 * secret_key       - 密码种子，为session加密提供一个字符串种子
 * expired_message  - session过期时显示的提示信息。
---
layout: default
title: 在子应用下使用session
---

# 在子应用下使用session

#提示
这个解决方案是来自web.py邮件列表。[this](http://www.mail-archive.com/webpy@googlegroups.com/msg02557.html)

##问题
如何在子应用中使用session？

##解法

web.py默认session信息只能在主应用中共享，即便在其他模块中import Session都不行。在app.py（或main.py）可以这样初始化session：

    session = web.session.Session(app, web.session.DiskStore('sessions'),
    initializer = {'test': 'woot', 'foo':''})

.. 接下来创建一个被web.loadhook加载的处理器(processor)

    def session_hook():
        web.ctx.session = session

    app.add_processor(web.loadhook(session_hook))

.. 在子应用(假设是sub-app.py)中，可以这样操作session:

    print web.ctx.session.test
    web.ctx.session.foo = 'bar'
---
layout: default
title: 在调试模式下使用session
---

# 在调试模式下使用session

# 问题

如何在调试模式下使用session?

# 解法

使用web.py自带的webserver提供web服务时，web.py就运行在调试模式下。当然最简单的办法就是禁用调试，只要令`web.config.debug = False`即可。

    import web
    web.config.debug = False

    # rest of your code


如果非要用调试模式下使用session，可以用非主流的一些办法。哈哈

因为调试模式支持模块重载入(重载入，绝非重载。是reload,而非override)，所以reloader会载入主模块两次，因此，就会创建两个session对象。但我们只要把session存储在全局的数据容器中，就能避免二次创建session。

下面这个例子就是把session保存在 `web.config`中：

    import web
    urls = ("/", "hello")

    app = web.application(urls, globals())

    if web.config.get('_session') is None:
        session = web.session.Session(app, web.session.DiskStore('sessions'), {'count': 0})
        web.config._session = session
    else:
        session = web.config._session

    class hello:
       def GET(self):
           print 'session', session
           session.count += 1
           return 'Hello, %s!' % session.count

    if __name__ == "__main__":
       app.run()
---
layout: default
title: 用cherrypy提供SSL支持
---

# 用cherrypy提供SSL支持

## 问题

如何用内置的cheerypy提供SSL支持？

## 解法

    import web
    
    from web.wsgiserver import CherryPyWSGIServer

    CherryPyWSGIServer.ssl_certificate = "path/to/ssl_certificate"
    CherryPyWSGIServer.ssl_private_key = "path/to/ssl_private_key"

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()
---
layout: default
title: 提供静态文件 (诸如js脚本, css样式表和图象文件)
---

# 提供静态文件 (诸如js脚本, css样式表和图象文件)

### 问题
如何在web.py自带的web server中提供静态文件访问？

### 解法

在当前应用的目录下，创建一个名为static的目录，把要提供访问的静态文件放在里面即可。

例如, 网址 <code>http://localhost/static/logo.png</code> 将发送 <code>./static/logo.png</code> 给客户端。
---
layout: default
title: 如何流传输大文件
---

# 如何流传输大文件

### 问题

如何流传输大文件？

### 解法

要流传输大文件，需要添加传输译码(Transfer-Encoding)区块头，这样才能一边下载一边显示。否则，浏览器将缓冲所有数据直到下载完毕才显示。

如果这样写：直接修改基础字符串(例中就是j)，然后用Yield返回－－是没有效果的。如果要使用Yield,就要向对所有内容使用yield。因为这个函式此时是一个产生器。(注：请处请详看Yield文档，在此不做过多论述。)


例子

    # Simple streaming server demonstration
    # Uses time.sleep to emulate a large file read
    import web
    import time
     
    urls = (
        "/",    "count_holder",
        "/(.*)",  "count_down",
        )
    app = web.application(urls, globals())
     

    class count_down:
        def GET(self,count):
            # These headers make it work in browsers
            web.header('Content-type','text/html')
            web.header('Transfer-Encoding','chunked')        
            yield '<h2>Prepare for Launch!</h2>'
            j = '<li>Liftoff in %s...</li>'
            yield '<ul>'
            count = int(count)
            for i in range(count,0,-1):
                out = j % i
                time.sleep(1)
                yield out
            yield '</ul>'
            time.sleep(1)
            yield '<h1>Lift off</h1>'
            
    class count_holder:
        def GET(self):
            web.header('Content-type','text/html')
            web.header('Transfer-Encoding','chunked')        
            boxes = 4
            delay = 3
            countdown = 10
            for i in range(boxes):
                output = '<iframe src="/%d" width="200" height="500"></iframe>' % (countdown - i)
                yield output
                time.sleep(delay)
            
    if __name__ == "__main__":
        app.run()
---
layout: default
title: 使用子应用
---

# 使用子应用

## 问题

如何在当前应用中包含定义在其他文件中的某个应用？

## 解法

在`blog.py`中:

    import web
    urls = (
      "", "reblog",
      "/(.*)", "blog"
    )

    class reblog:
        def GET(self): raise web.seeother('/')

    class blog:
        def GET(self, path):
            return "blog " + path

    app_blog = web.application(urls, locals())

当前的主应用`code.py`:

    import web
    import blog
    urls = (
      "/blog", blog.app_blog,
      "/(.*)", "index"
    )
    
    class index:
        def GET(self, path):
            return "hello " + path
    
    app = web.application(urls, locals())

    if __name__ == "__main__":
        app.run()
---
layout: default
title: 在webpy中使用Mako模板引擎
---

# 在webpy中使用Mako模板引擎

### 问题
如何在webpy中使用Mako模板引擎?
### 解决方案
首先需要安装Mako和web.py(0.3):http://www.makotemplates.org/ 然后尝试下面的代码:
<pre>
# encoding: utf-8
# File: code.py
import web
from web.contrib.template import render_mako
urls = (
        '/(.*)', 'hello'
        )
app = web.application(urls, globals(), autoreload=True)
# input_encoding and output_encoding is important for unicode
# template file. Reference:
# http://www.makotemplates.org/docs/documentation.html#unicode
render = render_mako(
        directories=['templates'],
        input_encoding='utf-8',
        output_encoding='utf-8',
        )

class hello:
    def GET(self, name):
        return render.hello(name=name)
        # Another way:
        #return render.hello(**locals())

if __name__ == "__main__":
    app.run()
</pre>

### 模板文件

<pre>
## File: templates/hello.html

Hello, ${name}.
</pre>

### 注意:
如果你使用Apache+mod_wsgi来部署webpy程序, 你也许会在Apache错误日志中得到下面的错误信息:
[Sat Jun 21 21:56:22 2008] [error] [client 192.168.122.1] TopLevelLookupException: Cant locate template for uri 'index.html'

你必须使用绝对路径指出模板的位置.
你也可以使用相对路径来让它更简单一些:
<pre>
import os

render = render_mako(
        directories=[os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),],
        input_encoding='utf-8',
        output_encoding='utf-8',
        )
</pre>
### 参考:
http://code.google.com/p/modwsgi/wiki/ApplicationIssues
---
layout: default
title: 用户认证
---

# 用户认证

#原作者没有写完，但是可以参照下一节，写得很详细

##问题
如何完成一个用户认证系统？

##解法
用户认证系统由这几个部分组成：用户添加，用户登录，用户注销以及验证用户是否已登录。用户认证系统一般都需要一个数据库。在这个例子中，我们要用到MD5和SQLite。

##
    import hashlib
    import web    

    def POST(self):
        i = web.input()

        authdb = sqlite3.connect('users.db')
        pwdhash = hashlib.md5(i.password).hexdigest()
        check = authdb.execute('select * from users where username=? and password=?', (i.username, pwdhash))
        if check: 
            session.loggedin = True
            session.username = i.username
            raise web.seeother('/results')   
        else: return render.base("Those login details don't work.")   

##注意
这仅仅是个例子，可不要在真实的生产环境中应用哦。
---
layout: default
title: 在PostgreSQL下实现用户认证
---

# 在PostgreSQL下实现用户认证

##问题
- 如何利用PostgreSQL数据库实现一个用户认证系统？

##解法
- 用户认证系统有很多功能。在这个例子中，将展示如何在PostgreSQL数据库环境下一步一步完成一个用户认证系统

##必需
- 因为要用到make模板和postgreSQL数据库，所以要:
	import web
	from web.contrib.template import render_mako
	import pg

## 第一步：创建数据库
首先，为创建一个用户表。虽然这个表结构非常简单，但对于大部分项目来说都足够用了。

##
	CREATE TABLE example_users
	(
	  id serial NOT NULL,
	  user character varying(80) NOT NULL,
	  pass character varying(80) NOT NULL,
	  email character varying(100) NOT NULL,
	  privilege integer NOT NULL DEFAULT 0,
	  CONSTRAINT utilisateur_pkey PRIMARY KEY (id)
	)

## 第二步：确定网址
登录和注销对应两个网址：

- "Login" 对应登录页

- "Reset" 对应注销页

##
	urls = (
	 	'/login', 'login',
		'/reset', 'reset',
		 )



## 第三步：判断用户是否登录
要判断用户是否已登录，是非常简单的，只要有个变量记录用户登录的状态即可。在login/reset类中使用这段代码:

##
	def logged():
		if session.login==1:
			return True
		else:
			return False

## 第四步：简单的权限管理
我把我的用户划为四类：管理员，用户，读者（已登录），访客（未登录）。根据example_users表中定义的不同权限，选择不同的模板路径。

##
	def create_render(privilege):
		if logged():
			if privilege==0:
				render = render_mako(
					directories=['templates/reader'],
					input_encoding='utf-8',
					output_encoding='utf-8',
					)
			elif privilege==1:
				render = render_mako(
					directories=['templates/user'],
					input_encoding='utf-8',
					output_encoding='utf-8',
					)
			elif privilege==2:
				render = render_mako(
					directories=['templates/admin'],
					input_encoding='utf-8',
					output_encoding='utf-8',
					)
		else:
			render = render_mako(
				directories=['templates/communs'],
				input_encoding='utf-8',
				output_encoding='utf-8',
				)
		return render
	
## 第五：登录(Login)和注销(Reset)的python类
现在，让我们用个轻松的方法来解决：
- 如果你已登录，就直接重定向到login_double.html模板文件
- 否则，还是到login.html。

##
	class login:
		def GET(self):
			if logged():
				render = create_render(session.privilege)
				return "%s" % (
					render.login_double()				)
			else:
				render = create_render(session.privilege)
				return "%s" % (
					render.login()
					)

- 好了。现在写POST()方法。从.html文件中，我们得到表单提交的变量值(见login.html)，并根据变量值得到example_users表中对应的user数据
- 如果登录通过了，就重定向到login_ok.html。
- 如果没通过，就重定向到login_error.html。

##	
		def POST(self):
			user, passwd = web.input().user, web.input().passwd
			ident = db.query("select * from example_users where user = '%s'" % (user)).getresult()
			try:
				if passwd==ident[0][2]:
					session.login=1
					session.privilege=ident[0][4]
					render = create_render(session.privilege)
					return "%s" % (
							render.login_ok()
							)
				else:
					session.login=0
					session.privilege=0
					render = create_render(session.privilege)
					return "%s" % (
						render.login_error()
						)
			except:
				session.login=0
				session.privilege=0
				render = create_render(session.privilege)
				return "%s" % (
					render.login_error()
					)

对于reset方法，只要清除用户session，再重定向到logout.html模板页即可。
##
	class reset:
		def GET(self):
			session.login=0
			session.kill()
			render = create_render(session.privilege)
			return "%s" % (
				render.logout()
			 	)

## 6th: 第六步：HTML模板帮助
嗯，我认为没有人想看这个，但我喜欢把所有的信息都提供出来。最重要的就是login.html。

##
	<FORM action=/login method=POST>
		<table id="login">
			<tr>
				<td>User: </td>
				<td><input type=text name='user'></td>
			</tr>
			<tr>
				<td>Password: </td>
				<td><input type="password" name=passwd></td>
			</tr>
			<tr>
				<td></td>
				<td><input type=submit value=LOGIN></td>
			</tr>
		</table>
	</form>

## 第七：问题或疑问？
- 邮件：您可以联想我，我的邮箱是guillaume(at)process-evolution(dot)fr
- IRC：#webpy on irc.freenode.net (pseudo: Ephedrax) 
- 翻译：我是法国人，我的英文不好...你可以修改我的文档(译注：哈哈，谦虚啥，你那是没见过wrongway的山东英文...)
---
layout: default
title: 用soaplib实现webservice
---

# 用soaplib实现webservice

### 问题

如何用soaplib实现webservice?

### 解法
Optio的[soaplib](http://trac.optio.webfactional.com/)通过用装饰器指定类型，从而直接编写SOAP web service。而且它也是到目前为止，唯一为web service提供WSDL文档的Python类库。



    import web 
    from soaplib.wsgi_soap import SimpleWSGISoapApp
    from soaplib.service import soapmethod
    from soaplib.serializers import primitive as soap_types

    urls = ("/hello", "HelloService",
            "/hello.wsdl", "HelloService",
            )
    render = web.template.Template("$def with (var)\n$:var")


    
    class SoapService(SimpleWSGISoapApp):
        """Class for webservice """

        #__tns__ = 'http://test.com'
    
        @soapmethod(soap_types.String,_returns=soap_types.String)
        def hello(self,message):
            """ Method for webservice"""
            return "Hello world "+message
     


    class HelloService(SoapService):
        """Class for web.py """
        def start_response(self,status, headers):
            web.ctx.status = status
            for header, value in headers:
                web.header(header, value)
    
    
        def GET(self):
            response = super(SimpleWSGISoapApp, self).__call__(web.ctx.environ, self.start_response)
            return render("\n".join(response))
    
    
        def POST(self):
            response = super(SimpleWSGISoapApp, self).__call__(web.ctx.environ, self.start_response)
            return render("\n".join(response))
     
    app=web.application(urls, globals())
    
    if __name__ == "__main__":
        app.run()




可以用soaplib客户端测试一下：

    >>> from soaplib.client import make_service_client
    >>> from test import HelloService
    >>> client = make_service_client('http://localhost:8080/hello', HelloService())
    >>> client.hello('John')
    'Hello world John'

可以在[http://localhost:8080/hello.wsdl](http://localhost:8080/hello.wsdl)查看WSDL。

欲了解更多，请查看 [soaplib](http://trac.optio.webfactional.com/),
---
layout: default
title: Travailler avec les cookies
---

# Travailler avec les cookies

Autre langages: [english](/../cookies) | ...

##Problème:

Comment déposer et récupérer les cookies d'un utilisateur qui navigue sur le site?

##Solution:

Web.py permet d'une façon très simple d'utiliser les méthodes de dépot/récupération de cookies (setting/getting).

###Déposer des cookies
####Vue d'ensemble
    setcookie(name, value, expires="", domain=None, secure=False): 
       
* *name* `(string)` - Le véritable nom du cookie, tel qu'il est stocké par le navigateur, et retourné vers le serveur.
* *value* `(string)` - La valeur que vous voulez stocker sous ce nom.
* *expires* `(int)` - Optionnel. C'est le temps en secondes jusqu'à ce que le navigateur voit le cookie expirer. *Note: ce doit être un entier, pas une chaîne*
* *domain* `(string)` - Le nom de domaine pour lequel le cookie est valide. Par défaut, réglé sur le site d'accueil, cela vous permet de définir le domaine, plutôt que simplement un hôte(tel que `.webpy.org`).
* *secure* `(bool)`- Si vrai, exige que le cookie soit envoyé via HTTPS.

####Exemple

`web.setcookie()` peut être utilisé pour déposer un cookie à un utilisateur, comme ceci:

    class CookieSet:
        def GET(self):
            i = web.input(age='25')
            web.setcookie('age', i.age, 3600)
            return "Age set in your cookie"


L'appel de la classe ci-dessus avec GET déposera un cookie nommé "age" ayant pour valeur par défaut "25" (cette valeur par défaut provient en fait de web.input et non de la fonction setcookie), et qui expirera dans une heure (3600 secondes).


Le troisième (et optionnel) argument de `web.setcookie()`, "expires", vous permet de définir quand vous voulez que votre cookie expire. Tout nombre négatif expirera le cookie immédiatement. Un nombre positif est le nombre de secondes durant lequel le cookie va durer (3600 se traduirait en une heure de durée du cookie). Laisser cet argument vide a pour conséquence, d'expirer le cookie session quand le navigateur s'arrête. Pour créer un cookie permanent, mettez à jour le temps d'expiration du cookie à intervalles réguliers (exemple : quand un utilisateur s'est connecté)


###Récuperer des cookies
####Vue d'ensemble

Il existe de nombreuses méthodes pour retrouver des cookies, en fonction de la réaction souhaitée à un cookie manquant.

#####Méthode 1 (Renvoi None si le cookie n'est pas trouvé):
    web.cookies().get(cookieName)  
        #cookieName est le nom du cookie présenté par le navigateur
#####Méthode  2 (Lève une exception AttributeError si le cookie n'est pas trouvé):
    foo = web.cookies()
    foo.cookieName
#####Méthode  3 (Evite la levée d'exception en attribuant une valeur par défaut au cookie qui n'a pas été trouvé):
    foo = web.cookies(cookieName=defaultValue)
    foo.cookieName   # renvoi la valeur (qui pourrait être par défaut)
        #cookieName est le nom du cookie présenté par le navigateur

####Exemple


`web.cookies()` peut être utilisé pour accéder à un cookie déjà défini. Si un cookie est créé en utilisant le code `web.setcookie()` plus haut, il peut être retrouvé de cette façon:

    class CookieGet:
        def GET(self):
            c = web.cookies(age="25")
            return "Your age is: " + c.age

L'exemple définit une valeur par défaut pour le cookie si il n'existe pas. La raison de fixer une valeur par défaut est que si il y a une tentative de consultation du cookie, mais qu'il n'existe pas, `web.cookies()` lève une exception.

Parfois, vous voudrez savoir concrètement si quelque chose n'existe pas, auquel cas, vous pourrez utiliser quelque chose comme ce qui suit:

    class CookieGet:
        def GET(self):
            try: 
                 return "Votre age : " + web.cookies().age
            except:
                 # Faites ce que vous avez besoin ici
                 return "Le cookie n'existe pas."

Ce code tente d'utiliser le cookie présenté par le navigateur, mais ne lui donne pas une valeur par défaut. Si le cookie n'existe pas, une exception est levée, et la clause `except` est executée, donnant au serveur la possibilité de gérer l'absence de cookie.

ou

    class CookieGet:
        def GET(self):
            age=web.cookies().get(age)
            if age:
                return "Votre age est: %s" % age
            else:
                return "Le cookie n'existe pas."
---
layout: default
title: cookies
---

# cookies

Other languages: [français](/../cookbook/cookies/fr) | ...

##Problem
You want to set and retrieve cookies for a user browsing the site.

##Solution
Web.py *comes* with an easy to use method for setting/getting cookies.

###Setting Cookies
####Overview
    setcookie(name, value, expires="", domain=None, secure=False): 
       
* *name* `(string)` - The actual name of the cookie, as stored by the browser, and returned to the server.
* *value* `(string)` - The value you want stored under that name.
* *expires* `(int)` - Optionally, is the time in seconds until the browser should expire the cookie.  Note: this must be an integer, not a string.
* *domain* `(string)` - The domain the cookie is valid for. By default, set to the host accessed, this allows you to set the domain, rather than just a host (such as `.webpy.org`).
* *secure* `(bool)`- If True, require that the cookie only be sent over HTTP/S.

####Example
`web.setcookie()` can be used to set the cookie for a user, like this:

    class CookieSet:
        def GET(self):
            i = web.input(age='25')
            web.setcookie('age', i.age, 3600)
            return "Age set in your cookie"


Calling the above class with GET will set a cookie named "age" with a default value equal to "25" (this default value actually comes from the web.input processing, NOT the setcookie function), which expires in 1 hour (3600 seconds).

The third (and optional) argument to `web.setcookie()`, "expires", allows you to set when you want your cookie to expire.  Any negative number will expire the cookie immediately.  Any positive number is the number of seconds that the cookie will last (3600 would result in an hour long cookie).  Leaving this argument empty results in a session cookie, which expires when your browser shuts down.  To make the cookie "permanent", simply update cookie expiration time at regular interval (e.g. when user logged in).

###Retrieving Cookies
####Overview
There are many methods to retrieve cookies, depending on the desired reaction to a missing cookie.
#####Way 1 (return None if cookie is not found):
    web.cookies().get(cookieName)  
        #cookieName is the name of the cookie submitted by the browser
#####Way 2 (raises exception AttributeError if cookie is not found):
    foo = web.cookies()
    foo.cookieName
#####Way 3 (avoids exception by setting default value for cookie if not found):
    foo = web.cookies(cookieName=defaultValue)
    foo.cookieName   # return the value (which could be default)
        #cookieName is the name of the cookie submitted by the browser

####Example
`web.cookies()` can be used to access an already set cookie.  If a cookie is set using the `web.setcookie()` code from above, it can be retrieved like this:

    class CookieGet:
        def GET(self):
            c = web.cookies(age="25")
            return "Your age is: " + c.age

The example sets a default value for the cookie if it does not exist.  The reason for setting a default value is that if the cookie is attempted to be accessed, but does not exist, `web.cookies()` raises an exception.  

Sometimes, you want to know specifically if something doesn't exist, in which case you can use something like the following:

    class CookieGet:
        def GET(self):
            try: 
                 return "Your age is: " + web.cookies().age
            except:
                 # Do whatever handling you need to, etc. here.
                 return "Cookie does not exist."

This code attempts to use the cookie submitted by the browser, but does not give it a default value.  If the cookie doesn't exist, an exception is raised, and the `except` clause is executed, giving the server an opportunity to handle the lack of cookie.

or

    class CookieGet:
        def GET(self):
            age=web.cookies().get('age')
            if age:
                return "Your age is: %s" % age
            else:
                return "Cookie does not exist."
---
layout: default
title: 如何操作Cookie
---

# 如何操作Cookie

##问题

如何设置和获取用户的Cookie?

##解法

对web.py而言，设置/获取Cookie非常方便。

###设置Cookies
####概述
    setcookie(name, value, expires="", domain=None, secure=False): 
       
* *name* `(string)` - Cookie的名称，由浏览器保存并发送至服务器。
* *value* `(string)` -Cookie的值，与Cookie的名称相对应。
* *expires* `(int)` - Cookie的过期时间，这是个可选参数，它决定cookie有效时间是多久。以秒为单位。它必须是一个整数，而绝不能是字符串。
* *domain* `(string)` - Cookie的有效域－在该域内cookie才是有效的。一般情况下，要在某站点内可用，该参数值该写做站点的域（比如.webpy.org），而不是站主的主机名（比如wiki.webpy.org）
* *secure* `(bool)`- 如果为True，要求该Cookie只能通过HTTPS传输。.

####示例
用`web.setcookie()` 设置cookie,如下:

    class CookieSet:
        def GET(self):
            i = web.input(age='25')
            web.setcookie('age', i.age, 3600)
            return "Age set in your cookie"


用 GET方式调用上面的类将设置一个名为age,默认值是25的cookie(实际上，默认值25是在web.input中赋予i.age的，从而间接赋予 cookie，而不是在setcookie函式中直接赋予cookie的)。这个cookie将在一小时后(即3600秒)过期。

`web.setcookie()`的第三个参数－"expires"是一个可选参数，它用来设定cookie过期的时间。如果是负数，cookie将立刻过期。如果是正数，就表示cookie的有效时间是多久，以秒为单位。如果该参数为空，cookie就永不过期。

###获得Cookies
####概述
获取Cookie的值有很多方法，它们的区别就在于找不到cookie时如何处理。
#####方法1（如果找不到cookie，就返回None）：
    web.cookies().get(cookieName)  
        #cookieName is the name of the cookie submitted by the browser
#####方法2（如果找不到cookie，就抛出AttributeError异常）：
    foo = web.cookies()
    foo.cookieName
#####方法3（如果找不到cookie，可以设置默认值来避免抛出异常）：
    foo = web.cookies(cookieName=defaultValue)
    foo.cookieName   # return the value (which could be default)
        #cookieName is the name of the cookie submitted by the browser

####示例：
用`web.cookies()` 访问cookie.  如果已经用`web.setcookie()`设置了Cookie, 就可以象下面这样获得Cookie:

    class CookieGet:
        def GET(self):
            c = web.cookies(age="25")
            return "Your age is: " + c.age

这个例子为cookie设置了默认值。这么做的原因是在访问时，若cookie不存在，web.cookies()就会抛出异常，如果事先设置了默认值就不会出现这种情况。

如果要确认cookie值是否存在，可以这样做：

    class CookieGet:
        def GET(self):
            try: 
                 return "Your age is: " + web.cookies().age
            except:
                 # Do whatever handling you need to, etc. here.
                 return "Cookie does not exist."

或

    class CookieGet:
        def GET(self):
            age=web.cookies().get('age')
            if age:
                return "Your age is: %s" % age
            else:
                return "Cookie does not exist."

---
layout: default
title: How to protect forms from CSRF attacks
---

# How to protect forms from CSRF attacks

## Problem

How to make sure a POST form submission genuinely originates from a form created by the application,
and is not a [Cross-Site Request Forgery](https://secure.wikimedia.org/wikipedia/en/wiki/Csrf).

## Solution

We keep a unique csrf_token that is rendered as a hidden field inside post forms and can not be guessed by CSRF attackers.
This token gets checked during POST methods.

We need 4 things:

1. A `csrf_token()` function - to use inside form templates. It either returns the existing `session.csrf_token` or generates a new one.

1. A `@csrf_protected` decorator for `POST()` methods. It pops `session.csrf_token` and compares it with the `csrf_token`
   input we expect to get from a genuine form (see `<input type="hidden" ...>` below.
   Whether the test succeeds or fails, this will make sure that next time `csrf_token()` is called (most probably - from
   inside a form's template), a new token will be generated.

1. Make `csrf_token()` available to templates by adding it to the globals of our `render` object.

1. Add `<input type="hidden" name="csrf_token" value="$csrf_token()"/>` to the forms in the templates.


We define `csrf_token()` like this:

    def csrf_token():
        if not session.has_key('csrf_token'):
            from uuid import uuid4
            session.csrf_token=uuid4().hex
        return session.csrf_token
    
The `@csrf_protected` decorator is defined like this:

    def csrf_protected(f):
        def decorated(*args,**kwargs):
            inp = web.input()
            if not (inp.has_key('csrf_token') and inp.csrf_token==session.pop('csrf_token',None)):
                raise web.HTTPError(
                    "400 Bad request",
                    {'content-type':'text/html'},
                    """Cross-site request forgery (CSRF) attempt (or stale browser form).
    <a href="">Back to the form</a>."""') # Provide a link back to the form
            return f(*args,**kwargs)
        return decorated

In order to make csrf_token() available to templates, we need to add it to the globals of the `render` object like this:

    render = web.template.render('templates',globals={'csrf_token':csrf_token})

A template that renders a POST form (called - say - `myform.html`) would look like:

    <form method=post action="">
      <input type="hidden" name="csrf_token" value="$csrf_token()"/>
      # ... form fields ...
    </form>

If we're using a `Form` object from `web.form` called _form_, our `myform.html` template would look like:

    <form method=post action="">
      <input type="hidden" name="csrf_token" value="$csrf_token()"/>
      $:form.render()
    </form>

The form page's object would then look like:

    class myformpage:
        def GET(self):
            return render.myform(...)
        @csrf_protected # Verify this is not CSRF, or fail
        def POST(self):
            # If we're here - this is not a CSRF attack

A simple working demo is availale [here](https://gist.github.com/857297).

---
layout: default
title: web.ctx
---

# web.ctx

Autre langages: [english](/../ctx) | ...

Probleme
-------

Vous souhaitez utiliser des variables contextuelles dans votre code comme la page référante ou le navigateur du client.


Solution
--------

C'est possible en utilisant 'web.ctx'. D'abord un peu d'architecture: 'web.ctx' est basée sur la classe 'threadeddict', alias 'ThreadedDict'. Cette classe crée un objet de type dictionnaire qui possède des attributs spécifiques au processus id de thread. C'est élégant dans la mesure ou cela nous permet d'utiliser un objet de type dictionnaire, tandis que beaucoup d'utilisateurs accèdent au système simultanément, et l'objet ne contiendra que les données de la requête HTTP donnée. (aucune données n'est partagée donc l'objet est ["thread-safe"](http://fr.wikipedia.org/wiki/Threadsafe) -- _On dit qu’un programme ou qu'une portion de code est thread-safe s’il fonctionne correctement durant une exécution simultanée par plusieurs threads (processus légers)_.)


'web.ctx' contient des variables pour chaque requête qui comprennent des informations spécifiques pour chaque demande, comme les variables environnement du client. En supposant que vous vouliez déterminer quelle était la page référante d'un utilisateur accédant à une page: 

Exemple
-------

    class example:
        def GET(self):
            referer = web.ctx.env.get('HTTP_REFERER', 'http://google.com')
            raise web.seeother(referer)


Ce code utilise 'web.ctx.env' pour accéder à l'environnement variables 'HTTP_REFERER'. Si il n'y en a pas, ce sera par défaut google.com. Enfin, il redirige l'utilisateur vers la page d'où il vient.


'web.ctx' est aussi très pratique car il peut-être rêglé par un ['loadhook'] (../application_processors/fr). Les données session, par exemple, sont fixées chaque fois qu'une demande est traitée et les données sont stockées dans 'web.ctx'. Depuis que 'web.ctx' est ["thread-safe"](http://fr.wikipedia.org/wiki/Threadsafe), vous pouvez utiliser les données session comme si elles étaient un objet régulier python.


Données que l'on trouve dans 'ctx'
-------------------

### Request ###
*   `environ` alias 'env' &ndash; un dictionnaire contenant les variables environnement standard de [WSGI](http://www.python.org/dev/peps/pep-0333/#environ-variables)
*   `home` &ndash; le chemin de base pour l'application, y compris tout élément «consommée» par les applications extérieures *http://example.org/admin*
*   `homedomain` &ndash; ? (semble être le protocole + l'hôte) *http://example.org*
*   `homepath` &ndash; La partie du chemin requise par l'utilisateur, déduite de l'application courante. C'est à dire homepath + path = le chemin actuellement requis en HTTP par l'utilisateur. Exemple: */admin*

*   `host` &ndash; le nom d'hôte (domaine) et (si ce n'est pas celui par défaut) le port requis par l'utilisateur. Exemple: *example.org*, *example.org:8080*
*   `ip` &ndash; L'adresse ip de l'utilisateur. exemple: *xxx.xxx.xxx.xxx*
*   `method` &ndash; la méthode HTTP utilisée. exemple: *GET*
*   `path` &ndash; Le chemin demandé par l'utilisateur, relatif à l'aaplication en cours. Si vous utilisez des sous-applications, chaque partie de l'url filtrée par l'application externe sera déduite. Par exemple: vous avez une application principale dans code.py, et une sous application appelée 'admin.py'. Dans 'code.py', vous pointez '/admin' vers 'admin.app'. Dans 'admin.py', vous pointez '/stories' sur une classe nommée 'stories'. Au sein de 'stories', 'web.ctx.path' sera '/stories' et pas '/admin/stories'. Exemple: */articles/845*
*   `protocol` &ndash; Le protocole utilisé. Exemple:  *https*
*   `query` &ndash; Une chaîne vide s'il n'y a pas d'argument de requête autre que '?' suivit par la chaine de requête. Exemple *?fourlegs=good&twolegs=bad*
*   `fullpath` alias 'path + query' &ndash; Le chemin demandé inclut les arguments de requête mais n'inclut *pas* 'homepath'. Exemple : */articles/845?fourlegs=good&twolegs=bad*

### Response ###
*   `status` &ndash; Le code statut HTTP (par defaut '200 OK') *401 Unauthorized*
*   `headers` &ndash; Une liste de deux tuples contenant les en-têtes HTTP (headers)
*   `output` &ndash; Une chaîne contenant l'entité de réponse
---
layout: default
title: ctx
---

# ctx

Other languages: [français](/../cookbook/ctx/fr) | ...

Problem
-------

You want to use contextual variables in your code such as the referring page or the client's browser.

Solution
--------

Using `web.ctx` makes this possible. First a little architecture: `web.ctx` is based on the class `threadeddict` a.k.a. `ThreadedDict`. This class creates a dictionary-like object that has attributes specific to the thread process id. This is nice because it lets us use a dictionary-like object when many users are accessing the system simultaneously, and the object will only have the data for the given HTTP request (no data is shared so the object is thread-safe).

`web.ctx` holds variables for each request that contain specific information to each request such as the client environment variable. Assuming you want to determine what the referring page was for a user accessing a page:

Example
-------

    class example:
        def GET(self):
            referer = web.ctx.env.get('HTTP_REFERER', 'http://google.com')
            raise web.seeother(referer)

This code uses `web.ctx.env` to access the `HTTP_REFERER` environment variable. If there isn't one, it defaults to google.com. Finally, it redirects the user to the page they came from.

`web.ctx` is also useful because it can be set by a `loadhook`. Session data, for example, is set each time a request is handled and the data is stored in `web.ctx`. Since `web.ctx` is thread-safe, you can use the session data as if it were a regular python object.

Data Found in `ctx`
-------------------

### Request ###
*   `environ` a.k.a. `env` &ndash; a dictionary containing the standard [WSGI environment variables](http://www.python.org/dev/peps/pep-0333/#environ-variables)
*   `home` &ndash; the base path for the application, including any parts "consumed" by outer applications *http://example.org/admin*
*   `homedomain` &ndash; ? (appears to be protocol + host) *http://example.org*
*   `homepath` &ndash; The part of the path requested by the user which was trimmed off the current app. That is homepath + path = the path actually requested in HTTP by the user. E.g. */admin* This seems to be derived during startup from the environment variable REAL_SCRIPT_NAME. It affects what web.url() will prepend to supplied urls. This in turn affects where web.seeother() will go, which might interact badly with your url rewriting scheme (e.g. mod_rewrite)
*   `host` &ndash; the hostname (domain) and (if not default) the port requested by the user. E.g. *example.org*, *example.org:8080*
*   `ip` &ndash; the IP address of the user. E.g. *xxx.xxx.xxx.xxx*
*   `method` &ndash; the HTTP method used. E.g. *GET*
*   `path` &ndash; the path requested by the user, relative to the current application. If you are using subapplications, any part of the url matched by the outer application will be trimmed off. E.g. you have a main app in `code.py`, and a subapplication called `admin.py`. In `code.py`, you point `/admin` to `admin.app`.  In `admin.py`, you point `/stories` to a class called `stories`. Within `stories`, `web.ctx.path` will be `/stories`, not `/admin/stories`. E.g. */articles/845*
*   `protocol` &ndash; the protocol used. E.g. *https*
*   `query` &ndash; an empty string if there are no query arguments otherwise a `?` followed by the query string. E.g. *?fourlegs=good&twolegs=bad*
*   `fullpath` a.k.a. `path + query` &ndash; the path requested *including* query arguments but *not* including `homepath`. E.g. */articles/845?fourlegs=good&twolegs=bad*

### Response ###
*   `status` &ndash; the HTTP status code (default '200 OK') *401 Unauthorized*
*   `headers` &ndash; a list of 2-tuples containing HTTP headers
*   `output` &ndash; a string containing the response entity
---
layout: default
title: web.ctx
---

# web.ctx

问题
-------

如何在代码中得到客户端信息？比如：来源页面(referring page)或是客户端浏览器类型

解法
--------

使用web.ctx即可。首先讲一点架构的东西：web.ctx基于threadeddict类，又被叫做ThreadDict。这个类创建了一个类似字典(dictionary-like)的对象，对象中的值都是与线程id相对应的。这样做很妙,因为很多用户同时访问系统时，这个字典对象能做到仅为某一特定的HTTP请求提供数据(因为没有数据共享，所以对象是线程安全的)

web.ctx保存每个HTTP请求的特定信息，比如客户端环境变量。假设，我们想知道正在访问某页面的用户是从哪个网页跳转而来的：

例子
-------

    class example:
        def GET(self):
            referer = web.ctx.env.get('HTTP_REFERER', 'http://google.com')
            raise web.seeother(referer)

上述代码用web.ctx.env获取HTTP_REFERER的值。如果HTTP＿REFERER不存在，就会将google.com做为默认值。接下来，用户就会被重定向回到之前的来源页面。

web.ctx另一个特性，是它可以被loadhook赋值。例如：当一个请求被处理时，会话(Session)就会被设置并保存在web.ctx中。由于web.ctx是线程安全的，所以我们可以象使用普通的python对象一样，来操作会话(Session)。

'ctx'中的数据成员
-------------------

### Request ###
*   `environ` 又被写做. `env` &ndash; 包含标准WSGI环境变量的字典。
*   `home` &ndash; 应用的http根路径(译注：可以理解为应用的起始网址，协议＋站点域名＋应用所在路径)例：*http://example.org/admin*
*   `homedomain` &ndash; 应用所在站点(可以理解为协议＋域名) *http://example.org*
*   `homepath` &ndash; 当前应用所在的路径，例如： */admin*
*   `host` &ndash; 主机名（域名）＋用户请求的端口（如果没有的话，就是默认的80端口），例如： *example.org*, *example.org:8080*
*   `ip` &ndash; 用户的IP地址，例如： *xxx.xxx.xxx.xxx*
*   `method` &ndash; 所用的HTTP方法，例如： *GET*
*   `path` &ndash; 用户请求路径，它是基于当前应用的相对路径。在子应用中，匹配外部应用的那部分网址将被去掉。例如：主应用在`code.py`中，而子应用在`admin.py`中。在`code.py`中, 我们将`/admin`关联到`admin.app`。 在`admin.py`中, 将`/stories`关联到`stories`类。在 `stories`中, `web.ctx.path`就是`/stories`, 而非`/admin/stories`。形如： */articles/845*
*   `protocol` &ndash; 所用协议，例如： *https*
*   `query` &ndash; 跟在'？'字符后面的查询字符串。如果不存在查询参数，它就是一个空字符串。例如： *?fourlegs=good&twolegs=bad*
*   `fullpath` 可以视为 `path + query` &ndash; 包含查询参数的请求路径，但不包括'homepath'。例如：*/articles/845?fourlegs=good&twolegs=bad*

### Response ###
*   `status` &ndash; HTTP状态码（默认是'200 OK') *401 Unauthorized 未经授权*
*   `headers` &ndash; 包含HTTP头信息(headers)的二元组列表。
*   `output` &ndash; 包含响应实体的字符串。
---
layout: default
title: Personnaliser le message NotFound
---

# Personnaliser le message NotFound

Autre langages: [english](/../custom_notfound) | ...

## Probleme

Comment personnaliser les messages notfound et autres?

## Solution

    import web

    urls = (...)
    app =  web.application(urls, globals())

    def notfound():
        return web.notfound("Désolé, la page que vous recherchez n'a pas été trouvée.")

	# Vous pouvez utiliser des résultats avec gabarits comme ci-dessous, l'un ou l'autre fonctionne: 
        #return web.notfound(render.notfound())
        #return web.notfound(str(render.notfound()))

    app.notfound = notfound


Puis, pour renvoyer la 404 personnalisée depuis votre code, faites juste:

    class example:
        def GET(self):
            raise web.notfound()

De la même manière, le message InternalError peut aussi être personnalisé:

    def internalerror():
        return web.internalerror("Vilain, vilain serveur. Pas de friandises.")

    app.internalerror = internalerror
---
layout: default
title: Custom NotFound message
---

# Custom NotFound message

Other languages:  [français](/../cookbook/custom_notfound/fr) | ...

## Problem

How to customize notfound and other messages?

## Solution

    import web

    urls = (...)
    app =  web.application(urls, globals())

    def notfound():
        return web.notfound("Sorry, the page you were looking for was not found.")

        # You can use template result like below, either is ok:
        #return web.notfound(render.notfound())
        #return web.notfound(str(render.notfound()))

    app.notfound = notfound


And to return the custom 404 from your code, just do:

    class example:
        def GET(self):
            raise web.notfound()

In the same way InternalError message can also be customized.

    def internalerror():
        return web.internalerror("Bad, bad server. No donut for you.")

    app.internalerror = internalerror
---
layout: default
title: 自定义NotFound消息
---

# 自定义NotFound消息

## 问题

如何定义NotFound消息和其他消息？

## 解法

    import web

    urls = (...)
    app =  web.application(urls, globals())

    def notfound():
        return web.notfound("Sorry, the page you were looking for was not found.")

        # You can use template result like below, either is ok:
        #return web.notfound(render.notfound())
        #return web.notfound(str(render.notfound()))

    app.notfound = notfound


要返回自定义的NotFound消息，这么做即可：

    class example:
        def GET(self):
            raise web.notfound()

也可以用同样的方法自定义500错误消息：

    def internalerror():
        return web.internalerror("Bad, bad server. No donut for you.")

    app.internalerror = internalerror
---
layout: default
title: db.delete
---

# db.delete

### Problem

You want to delete data that's been entered into a database.

### Solution

    import web
    
    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')
    db.delete('mytable', where="id=10")

It is also accepts "using" and "vars" parameters.

The delete method returns the number of rows deleted.
---
layout: default
title: db.delete 数据删除
---

# db.delete 数据删除

### 问题

在数据库中删除数据。

### 解决办法

    import web
    
    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')
    db.delete('mytable', where="id=10")

上面接受 "using" 和 "vars" 参数。

删除方法返回被删除的影响行数。
---
layout: default
title: Web.py using FastCGI and Apache 2
---

# Web.py using FastCGI and Apache 2

#Requirements
* Apache 2.x
* [mod_fcgid](http://httpd.apache.org/mod_fcgid/)
* [mod_rewrite](http://httpd.apache.org/docs/2.0/rewrite/)
* [Flup](http://trac.saddi.com/flup)

Note, on CentOS compiling mod_fcgid requires apache-devel be installed (available via yum).
#Apache Configuration
Replace '/var/www/myapp/' with the path to your apps directory

    LoadModule rewrite_module modules/mod_rewrite.so
    LoadModule fcgid_module modules/mod_fcgid.so

    SocketPath /tmp/fcgidsock
    SharememPath /tmp/fcgid_shm

    Alias /static "/var/www/myapp/static"
    Alias / "/var/www/myapp/"
    <Directory "/var/www/myapp/">
        allow from all
        SetHandler fcgid-script    
        Options +ExecCGI
        AllowOverride None
        <IfModule mod_rewrite.c>      
           RewriteEngine on
           RewriteBase /
           RewriteCond %{REQUEST_URI} !^/icons
           RewriteCond %{REQUEST_URI} !^/favicon.ico$
           RewriteCond %{REQUEST_URI} !^(/.*)+code.py/
           RewriteRule ^(.*)$ code.py/$1 [PT]
        </IfModule>
    </Directory>

    <Directory "/var/www/myapp/static">
          allow from all
          AllowOverride None
          Options -ExecCGI
          SetHandler None
      </Directory>




#Hello World
Note the following line is required:
web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)

    #!/usr/bin/python

    import web

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello: 
        def GET(self):
            return 'Hello, world!'

    web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
    if __name__ == "__main__":
        app.run()


#Run
1. Start your server. 
1. Open your application with your browser
1. To confirm your application is running try:

<code>
 ps aux | grep code.py
</code>

#Troubleshooting

<br>
###Check your apache error log for information!

<br>
##Common problems
<br>

###File permissions. 
You might see error code 255 in your logs.
Ensure the directory is readable and that code. py is executable:

<code>
chmod +x code.py
</code>

###404 Not Found. 
Is your Alias path correct in your apache configuration?

###Other problems
Web.py spawns http://0.0.0.0:8080, dies unexpectedly, or returns nothing. 
Did you add this line?
<pre>
 web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
</pre>
#Misc
* After updating your application you may need to restart your web server to see the changes.
* If you do not have root access to your Apache server, you may not have access to all of the above commands in the .htaccess file in your project directory. [See this githup repository](http://github.com/stevekochscience/webpy-bluehost-helloworld) for a first-draft workaround, using hosted server on bluehost.com.  (This is a hack written by someone who doesn't understand Apache and web.py thoroughly.)


---
layout: default
title: Web.py using FastCGI and Apache 2
---

# Web.py using FastCGI and Apache 2

#Requirements
* Apache 2.x
* [mod_fcgid](http://fastcgi.coremail.cn/)
* [mod_rewrite](http://httpd.apache.org/docs/2.0/rewrite/)
* [Flup](http://trac.saddi.com/flup)

Note, on CentOS compiling mod_fcgid requires apache-devel be installed (available via yum).
#Apache Configuration
Replace '/var/www/myapp/' with the path to your apps directory

    LoadModule rewrite_module modules/mod_rewrite.so
    LoadModule fcgid_module modules/mod_fcgid.so

    SocketPath /tmp/fcgidsock
    SharememPath /tmp/fcgid_shm

    Alias /static "/var/www/myapp/static"
    Alias / "/var/www/myapp/"
    <Directory "/var/www/myapp/">
        allow from all
        SetHandler fcgid-script    
        Options +ExecCGI
        AllowOverride None
        <IfModule mod_rewrite.c>      
           RewriteEngine on
           RewriteBase /
           RewriteCond %{REQUEST_URI} !^/icons
           RewriteCond %{REQUEST_URI} !^/favicon.ico$
           RewriteCond %{REQUEST_URI} !^(/.*)+code.py/
           RewriteRule ^(.*)$ code.py/$1 [PT]
        </IfModule>
    </Directory>

    <Directory "/var/www/myapp/static">
          allow from all
          AllowOverride None
          Options -ExecCGI
          SetHandler None
      </Directory>




#Hello World
Note the following line is required:
web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)

    #!/usr/bin/python

    import web

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello: 
        def GET(self):
        return 'Hello, world!'

    web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
    if __name__ == "__main__":
        app.run()


#Run
1. Start your server. 
1. Open your application with your browser
1. To confirm your application is running try:

<code>
 ps aux | grep code.py
</code>

#Troubleshooting

<br>
###Check your apache error log for information!

<br>
##Common problems
<br>

###File permissions. 
You might see error code 255 in your logs.
Ensure the directory is readable and that code. py is executable:

<code>
chmod +x code.py
</code>

###404 Not Found. 
Is your Alias path correct in your apache configuration?

###Other problems
Web.py spawns http://0.0.0.0:8080, dies unexpectedly, or returns nothing. 
Did you add this line?
<pre>
 web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
</pre>
#Misc
After updating your application you may need to restart your web server to see the changes.
---
layout: default
title: Webpy + LightTTPD avec FastCGi
---

# Webpy + LightTTPD avec FastCGi

Autre langages: [english](/../fastcgi-lighttpd) | ...

##Problème:

Comment configurer [lighttpd](http://www.lighttpd.net/) sous Debian GNU/Linux ?

##Solution:

*Si vous avez des problèmes avec cette astuce, veuillez lire ce [fil](http://www.mail-archive.com/webpy@googlegroups.com/msg02800.html).
Ce qui suit s'applique à la version 1.4.18 de lighttpd.*

###Note:  
* Vous devez remplacer <code>code.py</code> par le nom de votre propre fichier.
* <code>/path-to/webpy-app</code> que vous trouverez ci-dessous, concerne le chemin vers le répertoire contenant votre <code>code.py</code>
* <code>/path-to/webpy-app/code.py</code> est le chemin complet de votre **fichier python**


Si vous n'êtes pas certain de savoir quelle version de [lighttpd](http://www.lighttpd.net/) s'execute, tapez : <code>lighttpd -v</code> dans la console.

*Note: La version précédente de lighttpd organise les fichiers .conf différemment. Cependant, les mêmes principes s'appliquent aussi bien sur eux.*


##Configuration de lighttpd sous Debian GNU/Linux

<pre>
Fichiers er répertoires de /etc/lighttpd:
---------------------------------------

lighttpd.conf:
         fichier de configuration principal

conf-available/
        
	Ce répertoire contient une série de fichiers .conf. Ces fichiers contiennent
	les directives de configuration nécesssaire pour charger et executer les modules
	du serveur web. Si vous voulez créer vos propres fichiers, leurs noms doivent être
	construits ainsi : nn-name.conf. "nn" est un nombre à deux chiffres (ce nombre est 
	utilisé pour déterminer l'ordre de chargement des fichiers)	

conf-enabled/
        
	Afin d'activer effectivement un module pour lighttpd, il est nécessaire
	de créer dans ce répertoire un lien symbolique vers le fichier .conf concerné 
	du répertoire conf-available/.

l'Activation et désactivation des modules peut se faire en lançant:
	/usr/sbin/lighty-enable-mod 
 	/usr/sbin/lighty-disable-mod scripts.
</pre>

<strong>

Pour web.py vous devrez activer mod_fastcgi et mod_rewrite en executant:
<code>/usr/sbin/lighty-enable-mod</code> et en fournissant <code>fastcgi</code>
(mod_rewrite sera activé dans le fichier <code>10-fastcgi.conf</code>, comme vous pourrez le voir dans un instant.)


##Voici les instructions pour les fichiers suivants:

* <code>/etc/lighttpd/lighttpd.conf</code>
* <code>/etc/lighttpd/conf-available/10-fastcgi.conf</code>
* <code>code.py</code>

### <code>/etc/lighttpd/lighttpd.conf</code>

<pre>
server.modules              = (
            "mod_access",
            "mod_alias",
            "mod_accesslog",
            "mod_compress",
)
server.document-root       = "/path-to/webpy-app"
</pre>


*Dans mon cas, j'ai utilisé [postgreSQL](http://doc.ubuntu-fr.org/postgresql). Pour executer lighttpd avec postgres et afin d'accorder des autorisations à la base de donnée, j'ai ajouté la ligne:*

<pre>
server.username = "postgres"
</pre>

###<code>/etc/lighttpd/conf-available/10-fastcgi.conf</code>

<pre>
server.modules   += ( "mod_fastcgi" )
server.modules   += ( "mod_rewrite" )

 fastcgi.server = ( "/code.py" =>
 (( "socket" => "/tmp/fastcgi.socket",
    "bin-path" => "/path-to/webpy-app/code.py",
    "max-procs" => 1,
   "bin-environment" => (
     "REAL_SCRIPT_NAME" => ""
   ),
   "check-local" => "disable"
 ))
 )

 url.rewrite-once = (
   "^/favicon.ico$" => "/static/favicon.ico",
   "^/static/(.*)$" => "/static/$1",
   "^/(.*)$" => "/code.py/$1",
 )
</pre>

###<code>code.py</code>  
En haut du fichier, ajoutez:

<pre>
#!/usr/bin/env python
</pre>

.. et n'oubliez pas de le rendre executable (Autrement, vous aurez une erreur "permission denied"):

<pre>
$ chmod 755 /path-to/webpy-app/code.py
</pre>
---
layout: default
title: Webpy + LightTTPD with FastCGi
---

# Webpy + LightTTPD with FastCGi

Other languages: [français](/../cookbook/fastcgi-lighttpd/fr) | ...

*If you have problems with this recipe read this [thread](http://www.mail-archive.com/webpy@googlegroups.com/msg02800.html)*

*The following applies on lighttpd version 1.4.18*

##Note:  
* You may replace <code>code.py</code> with your own file name.
* <code>/path-to/webpy-app</code> found below refers to the path to the directory contains your <code>code.py</code>
* <code>/path-to/webpy-app/code.py</code> is the full path to your **python file**

If you are not certain what version you are running simply type: <code>lighttpd -v</code> at your console.

Note: Earlier version of lighttpd may organize the .conf files differently. Yet, the same principles applied on them as well.

###ligghttpd Configuration under Debian GNU/Linux

<pre>
Files and Directories in /etc/lighttpd:
---------------------------------------

lighttpd.conf:
         main configuration file

conf-available/
        This directory contains a series of .conf files. These files contain
        configuration directives necessary to load and run webserver modules.
        If you want to create your own files they names should be
        build as nn-name.conf where "nn" is two digit number (number
        is used to find order for loading files)

conf-enabled/
        To actually enable a module for lighttpd, it is necessary to create a
        symlink in this directory to the .conf file in conf-available/.

Enabling and disabling modules could be done by provided
/usr/sbin/lighty-enable-mod and /usr/sbin/lighty-disable-mod scripts.
</pre>

<strong>
For web py you should enable mod_fastcgi and mod_rewrite, thus run: <code>/usr/sbin/lighty-enable-mod</code> and supply <code>fastcgi</code>  
(mod_rewrite will be enabled within <code>10-fastcgi.conf</code> file as you will see in a moment).

##Below are instructions for the following files:
* <code>/etc/lighttpd/lighttpd.conf</code>
* <code>/etc/lighttpd/conf-available/10-fastcgi.conf</code>
* <code>code.py</code>

###<code>/etc/lighttpd/lighttpd.conf</code>

<pre>
server.modules              = (
            "mod_access",
            "mod_alias",
            "mod_accesslog",
            "mod_compress",
)
server.document-root       = "/path-to/webpy-app"
</pre>

In my case I used postgresql and therefore runs lighttpd as postgres in order to grant permissions to the database, therefore I added the line:

<pre>
server.username = "postgres"
</pre>

###<code>/etc/lighttpd/conf-available/10-fastcgi.conf</code>

<pre>
server.modules   += ( "mod_fastcgi" )
server.modules   += ( "mod_rewrite" )

 fastcgi.server = ( "/code.py" =>
 (( "socket" => "/tmp/fastcgi.socket",
    "bin-path" => "/path-to/webpy-app/code.py",
    "max-procs" => 1,
   "bin-environment" => (
     "REAL_SCRIPT_NAME" => ""
   ),
   "check-local" => "disable"
 ))
 )

 url.rewrite-once = (
   "^/favicon.ico$" => "/static/favicon.ico",
   "^/static/(.*)$" => "/static/$1",
   "^/(.*)$" => "/code.py/$1",
 )
</pre>

###<code>/code.py</code>  
At the top of the file add:

<pre>
#!/usr/bin/env python
</pre>

and don't forget to make it executable (otherwise you will get a "permission denied" error):

<pre>
$ chmod 755 /path-to/webpy-app/code.py
</pre>
---
layout: default
title: 通过Fastcgi和lighttpd部署
---

# 通过Fastcgi和lighttpd部署

如果你对这个主题有任何问题，可以点击下面的链接访问相应的话题:

http://www.mail-archive.com/webpy@googlegroups.com/msg02800.html

下面的代码基于lighttpd 1.4.18，更高版本也可以工作

##Note:  
* 你可以重命名 <code>code.py</code>为任何你自己愿意的名字，该例子还是以code.py为例。
* <code>/path-to/webpy-app</code> 为包含你的 <code>code.py</code>代码的路径。
* <code>/path-to/webpy-app/code.py</code> 应该是你的**python file**的完整路径。

如果你还不确定你的lighttpd版本的话，你可以在命令行中使用<code>lighttpd -v</vode>查看相应的版本信息。

Note: 较早版本的lighttpd可能会按照不同的方式组织.conf文件，但是它们应该遵循的是相同的原则。

###ligghttpd 在 Debian GNU/Linux 下的配置文件

<pre>
Files and Directories in /etc/lighttpd:
---------------------------------------

lighttpd.conf:
         main configuration file

conf-available/
        This directory contains a series of .conf files. These files contain
        configuration directives necessary to load and run webserver modules.
        If you want to create your own files they names should be
        build as nn-name.conf where "nn" is two digit number (number
        is used to find order for loading files)

conf-enabled/
        To actually enable a module for lighttpd, it is necessary to create a
        symlink in this directory to the .conf file in conf-available/.

Enabling and disabling modules could be done by provided
/usr/sbin/lighty-enable-mod and /usr/sbin/lighty-disable-mod scripts.
</pre>

<strong>
对于web py， 你需要允许 mod_fastcgi 模块和 mod_rewrite模块, 运行: <code>/usr/sbin/lighty-enable-mod</code> 启用 <code>fastcgi</code> （Mac OS X可能不需要）  
(mod_rewrite 模块可能需要启用 <code>10-fastcgi.conf</code>文件).

##下面是文件的基本结构（Mac OS X不同）:
* <code>/etc/lighttpd/lighttpd.conf</code>
* <code>/etc/lighttpd/conf-available/10-fastcgi.conf</code>
* <code>code.py</code>

对于Mac OS X或任何以Mac Ports邓方式安装的lighttpd，可以直接在路径下编写.conf文件并用lighttpd -f xxx.conf启动lighttpd，而无需去修改或考虑任何文件结构。

<code>/etc/lighttpd/lighttpd.conf</code>

<pre>
server.modules              = (
            "mod_access",
            "mod_alias",
            "mod_accesslog",
            "mod_compress",
)
server.document-root       = "/path-to/webpy-app"
</pre>

对我来说，我使用 postgresql，因此需要授予对的数据库权限，可以添加行如下（如果不使用则不需要）。

<pre>
server.username = "postgres"
</pre>

<code>/etc/lighttpd/conf-available/10-fastcgi.conf</code>

<pre>
server.modules   += ( "mod_fastcgi" )
server.modules   += ( "mod_rewrite" )

 fastcgi.server = ( "/code.py" =>
 (( "socket" => "/tmp/fastcgi.socket",
    "bin-path" => "/path-to/webpy-app/code.py",
    "max-procs" => 1,
   "bin-environment" => (
     "REAL_SCRIPT_NAME" => ""
   ),
   "check-local" => "disable"
 ))
 )

如果本地的lighttpd跑不起来的话，需要设置check-local属性为disable。

 url.rewrite-once = (
   "^/favicon.ico$" => "/static/favicon.ico",
   "^/static/(.*)$" => "/static/$1",
   "^/(.*)$" => "/code.py/$1",
 )
</pre>

<code>/code.py</code>  
在代码头部添加以下代码，让系统环境使用系统环境中当前的python

<pre>
#!/usr/bin/env python
</pre>

最后不要忘记了要对需要执行的py代码设置执行权限，否则你可能会遇到“permission denied”错误。

<pre>
$ chmod 755 /path-to/webpy-app/code.py
</pre>
---
layout: default
title: Webpy + Nginx with FastCGI
---

# Webpy + Nginx with FastCGI

This cookbook entry explains how to run web.py on Nginx with Fastcgi.

### Requirements

* Nginx 0.8.\* or 0.7.\* (with fastcgi and rewrite module).
* Webpy 0.32
* Spawn-fcgi 1.6.2
* Flup

Older versions may work, but aren't tested.

### Resources

* [Nginx wiki](http://wiki.nginx.org/NginxInstall)
* [Spawn-fcgi](http://redmine.lighttpd.net/projects/spawn-fcgi/news)
* [Flup](http://trac.saddi.com/flup)

### Notes

* You may replace `index.py` with your own file name.
* `/path/to/www` Is the path to the directory where your webpy application is located.
* `/path/to/www/index.py` is the full path to your python file.
* Do not run anything until you are at *Run*.

## Nginx configuration

	location / {
            fastcgi_param REQUEST_METHOD $request_method;
            fastcgi_param QUERY_STRING $query_string;
            fastcgi_param CONTENT_TYPE $content_type;
            fastcgi_param CONTENT_LENGTH $content_length;
            fastcgi_param GATEWAY_INTERFACE CGI/1.1;
            fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;
            fastcgi_param REMOTE_ADDR $remote_addr;
            fastcgi_param REMOTE_PORT $remote_port;
            fastcgi_param SERVER_ADDR $server_addr;
            fastcgi_param SERVER_PORT $server_port;
            fastcgi_param SERVER_NAME $server_name;
            fastcgi_param SERVER_PROTOCOL $server_protocol;
            fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;
            fastcgi_param PATH_INFO $fastcgi_script_name;
            fastcgi_pass 127.0.0.1:9002;
	}

To serve static files add this:

        location /static/ {
            root /path/to/www;
            if (-f $request_filename) {
               rewrite ^/static/(.*)$  /static/$1 break;
            }
        }

__Note:__ the address and port may be different.

## Spawn-fcgi

You can start a process with:

	spawn-fcgi -d /path/to/www -f /path/to/www/index.py -a 127.0.0.1 -p 9002

### Start and shutdown script

Start:

	#!/bin/sh
	spawn-fcgi -d /path/to/www -f /path/to/www/index.py -a 127.0.0.1 -p 9002

Shutdown:

	#!/bin/sh
	kill `pgrep -f "python /path/to/www/index.py"`

__Note:__ You're free to choose which address, port, directory and filename to use, but be sure to adjust the Nginx configuration.

## Hello world!

Save the following code in your www directory and call the file index.py (or whatever you like).
The following line is required: `web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)`.

	#!/usr/bin/env python
	# -*- coding: utf-8 -*-

	import web

	urls = ("/.*", "hello")
	app = web.application(urls, globals())

	class hello:
		def GET(self):
			return 'Hello, world!'

	if __name__ == "__main__":
		web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
		app.run()

Note: make your file executable by doing `chmod +x index.py`. You'll get errors if it isn't executable.

## Run

1. Start a process with `spawn-fcgi`.
2. Start Nginx.

To check if it runs do `ps aux | grep index.py` or simply visit the page in your browser.

To reload your configuration:

	/path/to/nginx/sbin/nginx -s reload

And to stop:

	/path/to/nginx/sbin/nginx -s stop


## NOTES

### problem child exited with 2

solution:  insert `#!/usr/bin/env python` into header of main.py 
    
### problem spawn-fcgi child exited with 126

solution: `chmod +x main.py`



---
layout: default
title: Webpy + Nginx with FastCGI搭建Web.py
---

# Webpy + Nginx with FastCGI搭建Web.py

这一节讲解的是如何使用Nginx和FastCGI搭建Web.py应用

### 环境依赖的软件包

* Nginx 0.8.\* or 0.7.\* (需要包含fastcgi和rewrite模块)。
* Webpy 0.32
* Spawn-fcgi 1.6.2
* Flup

注意：Flup是最常见的忘记装的软件，需要安装

更老的版本应该也可以工作，但是没有测试过，最新的是可以工作的

### 一些资源

* [Nginx wiki](http://wiki.nginx.org/NginxInstall)
* [Spawn-fcgi](http://redmine.lighttpd.net/projects/spawn-fcgi/news)
* [Flup](http://trac.saddi.com/flup)

### Notes

* 你可以重命名`index.py`为任何你想要的文件名。
* `/path/to/www` 为代码路径。
* `/path/to/www/index.py`为python代码的完整路径。

## Nginx 配置文件

	location / {
	    include fastcgi_params;
	    fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;  # [1]
	    fastcgi_param PATH_INFO $fastcgi_script_name;        # [2]
	    fastcgi_pass 127.0.0.1:9002;
	}

对于静态文件可以添加如下配置:

	location /static/ {
	    if (-f $request_filename) {
		rewrite ^/static/(.*)$  /static/$1 break;
	    }
	}

__注意:__ 地址和端口号可能会是不同的。

## Spawn-fcgi

可以通过一下命令启动一个Spawn-fcgi进程:

	spawn-fcgi -d /path/to/www -f /path/to/www/index.py -a 127.0.0.1 -p 9002

### 启动和关闭的命令

启动:

	#!/bin/sh
	spawn-fcgi -d /path/to/www -f /path/to/www/index.py -a 127.0.0.1 -p 9002

关闭:

	#!/bin/sh
	kill `pgrep -f "python /path/to/www/index.py"`

__Note:__ 你可以随意填写地址和端口信息，但是一定需要和Nginx配置文件相匹配。

## Hello world!

讲下面的代码保存为index.py（或者任何你喜欢的），注意，使用Nginx配置的话，`web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)`这一行代码是必须的。

	#!/usr/bin/env python
	# -*- coding: utf-8 -*-

	import web

	urls = ("/.*", "hello")
	app = web.application(urls, globals())

	class hello:
		def GET(self):
			return 'Hello, world!'

	if __name__ == "__main__":
		web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
		app.run()

注意: 同样需要给代码设置权限，代码如下chmod +x index.py。

## 运行

1. 打开一个 `spawn-fcgi` 进程.
2. 打开 Nginx.

如果需要检查应用程序是否运行，使用`ps aux|grep index.py`可以很容易的查看。

重启nginx配置:

	/path/to/nginx/sbin/nginx -s reload

停止nginx:

	/path/to/nginx/sbin/nginx -s stop

注意：运行后可访问http://localhost访问网站，更多信息可以去参考nginx官方文档。
---
layout: default
title: Uploader un fichier
---

# Uploader un fichier

Autre langages: [english](/../fileupload) | ...

## Problème:

L'upload de fichiers peut être un peu difficile si vous n'êtes pas familier avec les formulaires
uploads, ou le CGI en général.

## Solution:

    import web
    
    urls = ('/upload', 'Upload')
    
    class Upload:
        def GET(self):
            return """<html><head></head><body>
    <form method="POST" enctype="multipart/form-data" action="">
    <input type="file" name="myfile" />
    <br/>
    <input type="submit" />
    </form>
    </body></html>"""
    
        def POST(self):
            x = web.input(myfile={})
            web.debug(x['myfile'].filename) # Ceci est le nom du fichier
            web.debug(x['myfile'].value) # Ceci est le contenu du fichier
            web.debug(x['myfile'].file.read()) # Ou utilisez un objet de type fichier
            raise web.seeother('/upload')


    if __name__ == "__main__":
       app = web.application(urls, globals()) 
       app.run()

## A savoir

Deux petites choses à surveiller:

* Le formulaire a besoin d'un attribut enctype="multipart/form-data", ou cela ne fonctionnera pas correctement.
* Dans le code de webpy, une valeur par défaut est néssessaire (*the myfile={}*) si vous voulez qu'il soit importé comme un objet FieldStorage CGI. Si vous ne spécifiez pas une valeur par défaut, le fichier sera transmis sous forme de chaîne -- cela fonctionne, mais vous perdez l'attribut nom de fichier.
---
layout: default
title: File Upload Recipe
---

# File Upload Recipe

Other languages: [français](/../cookbook/fileupload/fr) | ...

## Problem

File uploads can be a little tricky if you're not familiar with form uploads, or CGI in general.

## Solution

    import web
    
    urls = ('/upload', 'Upload')
    
    class Upload:
        def GET(self):
            return """<html><head></head><body>
    <form method="POST" enctype="multipart/form-data" action="">
    <input type="file" name="myfile" />
    <br/>
    <input type="submit" />
    </form>
    </body></html>"""
    
        def POST(self):
            x = web.input(myfile={})
            web.debug(x['myfile'].filename) # This is the filename
            web.debug(x['myfile'].value) # This is the file contents
            web.debug(x['myfile'].file.read()) # Or use a file(-like) object
            raise web.seeother('/upload')


    if __name__ == "__main__":
       app = web.application(urls, globals()) 
       app.run()

## Hang ups

A couple of things to watch out for:

* The form needs an attribute enctype="multipart/form-data", or this won't work correctly.
* In the webpy code, a default value is needed (the myfile={} part) if you want it to be imported as a CGI FieldStorage object.  If you don't specify the default value, the file will be passed as a string -- this works, but you lose the filename attribute.
---
layout: default
title: File Upload Recipe
---

# File Upload Recipe

## 问题

如果你不是很了解表单上传或者CGI的话, 你会觉得文件上传有点奇特.

## 解决方法

    import web
    
    urls = ('/upload', 'Upload')
    
    class Upload:
        def GET(self):
            return """<html><head></head><body>
    <form method="POST" enctype="multipart/form-data" action="">
    <input type="file" name="myfile" />
    <br/>
    <input type="submit" />
    </form>
    </body></html>"""
    
        def POST(self):
            x = web.input(myfile={})
            web.debug(x['myfile'].filename) # 这里是文件名
            web.debug(x['myfile'].value) # 这里是文件内容
            web.debug(x['myfile'].file.read()) # 或者使用一个文件对象
            raise web.seeother('/upload')


    if __name__ == "__main__":
       app = web.application(urls, globals()) 
       app.run()

## 注意

需要注意以下内容:

* 表单需要一个enctype="multipart/form-data"的属性, 否则不会正常工作.
* 在webpy的代码里, 如果你需要默认值的话, myfile就需要默认值了(myfile={}), 文件会以字符串的形式传输 -- 这确实可以工作, 但是你会丢失文件的名称
---
layout: default
title: Comment utiliser les formulaires
---

# Comment utiliser les formulaires

Autre langages: [english](/../forms) | ...

## Problème:

Comment utiliser les formulaires ?

## Solution: 

Le module `web.form`  fournit un support pour créer, valider et interpréter les formulaires.
Ce module contient une classe `Form` et des classes pour diverses entrées de type `Textbox`, `Password`, etc...


Chaque entrée peut prendre une liste de validateurs comme arguments qui sont validées par rapport à l'entrée lorsque `form.validates ()` est appelée.

La classe `Form` peut aussi prendre le mot-clé supplémentaire `validators` en arguments pour valider le formulaire en utilisant la saisie complète.

Voici un exemple de formulaire d'enregistrement d'un nouvel utilisateur.

    import web
    from web import form

    render = web.template.render('templates') # your templates

    vpass = form.regexp(r".{3,20}$", 'must be between 3 and 20 characters')
    vemail = form.regexp(r".*@.*", "must be a valid email address")

    register_form = form.Form(
        form.Textbox("username", description="Username"),
        form.Textbox("email", vemail, description="E-Mail"),
        form.Password("password", vpass, description="Password"),
        form.Password("password2", description="Repeat password"),
        form.Button("submit", type="submit", description="Register"),
        validators = [
            form.Validator("Passwords did't match", lambda i: i.password == i.password2)]

    )

    class register:
        def GET(self):
            # do $:f.render() in the template
            f = register_form()
            return render.register(f)

        def POST(self):
            f = register_form()
            if not f.validates():
                return render.register(f)
            else:
                # do whatever is required for registration

Et le gabarit doit ressembler à ca:

    $def with(form)

    <h1>Register</h1>
    <form method="POST">
        $:form.render()
    </form>
---
layout: default
title: How to use forms
---

# How to use forms

Other languages: [français](/../cookbook/forms/fr) | ...

## Problem

How to use forms.

## Solution

The `web.form` module provides support for creating, validating, and rendering forms.
This module contains a `Form` class and classes for various inputs like `Textbox`, `Password` etc.

Each input can take a list of validators as arguments which are validated against the input when `form.validates()` is called.

The `Form` class can take additional keyword argument `validators` to validate the form using complete input.

Here is an example of a new user registration form:

    import web
    from web import form

    render = web.template.render('templates') # your templates

    vpass = form.regexp(r".{3,20}$", 'must be between 3 and 20 characters')
    vemail = form.regexp(r".*@.*", "must be a valid email address")

    register_form = form.Form(
        form.Textbox("username", description="Username"),
        form.Textbox("email", vemail, description="E-Mail"),
        form.Password("password", vpass, description="Password"),
        form.Password("password2", description="Repeat password"),
        form.Button("submit", type="submit", description="Register"),
        validators = [
            form.Validator("Passwords did't match", lambda i: i.password == i.password2)]

    )

    class register:
        def GET(self):
            # do $:f.render() in the template
            f = register_form()
            return render.register(f)

        def POST(self):
            f = register_form()
            if not f.validates():
                return render.register(f)
            else:
                # do whatever is required for registration
 
And the register template should be something like this:

    $def with(form)

    <h1>Register</h1>
    <form method="POST">
        $:form.render()
    </form>
---
layout: default
title: 怎样使用表单 forms
---

# 怎样使用表单 forms

## 问题：

怎样使用表单 forms

## 解决：

'web.form'模块提供支持创建，校验和显示表单。该模块包含一个'Form'类和各种输入框类如'Textbox'，'Password'等等。

当'form.validates()'调用时，可以针对每个输入检测的哪个是有效的，并取得校验理由列表。

'Form'类同样可以使用完整输入附加的关键字参数'validators'来校验表单。

这里是一个新用户注册的表单的示例：

    import web
    from web import form

    render = web.template.render('templates') # your templates

    vpass = form.regexp(r".{3,20}$", 'must be between 3 and 20 characters')
    vemail = form.regexp(r".*@.*", "must be a valid email address")

    register_form = form.Form(
        form.Textbox("username", description="Username"),
        form.Textbox("email", vemail, description="E-Mail"),
        form.Password("password", vpass, description="Password"),
        form.Password("password2", description="Repeat password"),
        form.Button("submit", type="submit", description="Register"),
        validators = [
            form.Validator("Passwords did't match", lambda i: i.password == i.password2)]

    )

    class register:
        def GET(self):
            # do $:f.render() in the template
            f = register_form()
            return render.register(f)

        def POST(self):
            f = register_form()
            if not f.validates():
                return render.register(f)
            else:
                # do whatever is required for registration


然后注册的模板应该像是这样： 

    $def with(form)

    <h1>Register</h1>
    <form method="POST">
        $:form.render()
    </form>
---
layout: default
title: Render individual form fields
---

# Render individual form fields

### Problem

You want to render individual form fields in templates

### Solution

You can use the `render()` method for individual fields to render the fields in your template.

Let's assume you want to create a name/surname form. Very simple, with only two fields, and no validation, just for testing purposes.

    from web import form
    simple_form = form.Form(
        form.Textbox('name', description='Name'),
        form.Textbox('surname', description='Surname'),
    )

Usually you would either use `simple_form.render()` or `simple_form.render_css()`. But what if you want to render individual form fields one by one, so you can have more control over how it appears in your template? For that, you can use the `render()` method on individual fields.

We have defined two fields with names `name` and `surname`. Those names automatically become attributes of `simple_form` object.

    >>> simple_form.name.render()
    '<input type="text" name="name" id="name" />'
    >>> simple_form.surname.render()
    '<input type="text" name="surname" id="surname" />' 

You can also render individual descriptions in a similar way:

    >>> simple_form.surname.description
    'Surname'

What if you have a small template snippet (partial template) that you'd like to use universally for all form fields you have defined? You can iterate fields by using the `inputs` attribute of your form object. Here's an example:

    >>> for input in simple_form.inputs:
    ...     print input.description
    ...     print input.render()
    ... 
    Name
    <input type="text" name="name" id="name" />
    Surname
    <input type="text" name="surname" id="surname" />
---
layout: default
title: 个别显示表单字段
---

# 个别显示表单字段

### 问题：

怎样在模板中个别显示表单字段？

### 解决：

你可以使用'render()'方法在你的模板中显示部分的表单字段。

假设你想创建一个名字/姓氏表单。很简单，只有两个字段，不需要验证，只是为了测试目的。

    from web import form
    simple_form = form.Form(
        form.Textbox('name', description='Name'),
        form.Textbox('surname', description='Surname'),
    )

通常你可以使用`simple_form.render（）`或`simple_form.render_css（）`。
但如你果你想一个一个的显示表单的字段，或者你怎样才能对模板中的表单显示拥有更多的控制权限？如果是这样，你可以对你的个别字段使用`render()`方法。

我们定义了两个字段名称为`name`和`surname`。这些名称将自动成为`simple_form`对象的属性。

    >>> simple_form.name.render()
    '<input type="text" name="name" id="name" />'
    >>> simple_form.surname.render()
    '<input type="text" name="surname" id="surname" />' 

你同样可以通过类似的方法显示个别的描述：

    >>> simple_form.surname.description
    'Surname'

如果你有一个小模板片段（局部模板），你想统一的使用你所定义的所有表单字段？你可以使用表单对象的`inputs`属性迭代每个字段。下面是一个示例：

    >>> for input in simple_form.inputs:
    ...     print input.description
    ...     print input.render()
    ... 
    Name
    <input type="text" name="name" id="name" />
    Surname
    <input type="text" name="surname" id="surname" />
---
layout: default
title: Webpy + Google App Engine
---

# Webpy + Google App Engine

This cookbook entry explains how to run web.py as a google app engine application

### Requirements

* Google App Engine Python API
* web.py .38 or later

### Resources

* [Google App Engine](https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python)

###  Notes
* The mechanisms for running GAE in python2.7 and 2.5 are different, change the app.yaml accordingly
* code.py is the main file of your application (2.5)
* code.app is the object that cointains the return value of gaerun() (2.7)
* appname is the name that you specified while creating your GAE application
* runtime for 2.5 is python, 2.7 is python27
* threadsafe is only required in 2.7, read about it on the google app engine site

## app.yaml for python 2.5

	application: appname
	version: 1
	runtime: python
	api_version: 1

	handlers:
	- url: /.*
	  script: code.py

## app.yaml for python 2.7

	application: appname
	version: 1
	runtime: python27
	api_version: 1
	threadsafe: true

	handlers:
	- url: /.*
	  script: code.app

To serve static files, you must add this under handlers (where static is the name of your static dir):
    - url: /static
      static_dir: static

## Hello World!

This is a sample application that can be run by using dev_appserver.py (it is bundled with the SDK download):

	import web

	urls = (
		"/.*", "hello",
	)

	app = web.application(urls, globals())

	class hello:
		def GET(self):
			return 'Hello, world!'

	app = app.gaerun()

Save this as code.py (or whatever you specified in app.yaml) and type:
dev_appserver.py .

Now visit localhost:8080 in your browser and you should see hello world!

## NOTES

### There is a blank page or an internal server error

solution: Make sure that you are running the version of python specified in the app.yaml file

### dev_appserver.py is not found

solution: Make sure that it is in your path

---
layout: default
title: Hello World!
---

# Hello World!

Autre langages : [english](/../helloworld) | ...

## Probleme

Comment écrire un "Hello World" avec web.py


## Solution

    import web

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()

###Tip: Ecrire une url avec ou sans "/", pointe sur la même classe.

Ajoutez ce qui suit au début des urls.

    '/(.*)/', 'redirect', 


et vous utiliserez la classe suivante pour traiter ces urls.

    class redirect:
        def GET(self, path):
            web.seeother('/' + path)
---
layout: default
title: Hello World!
---

# Hello World!

## 問題点

web.py を使用して'Hello, world!'を表示させたいのですが？

## 解決手段

    import web

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()
---
layout: default
title: Hello World!
---

# Hello World!

Other languages : [français](/helloworld/fr) | ...

## Problem

How to write hello world with web.py

## Solution

    import web

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()

###Tip: Make url ending with or without '/' going to the same class.

add the following to the beginning of urls.

    '/(.*)/', 'redirect', 

and have the following class to handle those urls.

    class redirect:
        def GET(self, path):
            web.seeother('/' + path)
---
layout: default
title: Привет мир!!!
---

# Привет мир!!!

## Проблема

Как создать первое приложение("Hello world") с помощью web.py

## Решение

    import web

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()

###Tip: Make url ending with or without '/' going to the same class.

добавьте следующую строчкув начало списка urls.

    '/(.*)/', 'redirect', 

также добавьте следующий класс для обработки этого URL.

    class redirect:
        def GET(self, path):
            web.seeother('/' + path)
---
layout: default
title: Hello World!
---

# Hello World!

## 问题

如何用web.py实现Hello World!？

## 解法

    import web

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()

###提示：要保证网址有无'/'结尾，都能指向同一个类。就要多写几行代码，如下：

在URL开头添加代码：

    '/(.*)/', 'redirect', 

然后用redirect类处理以'/'结尾的网址：

    class redirect:
        def GET(self, path):
            web.seeother('/' + path)
---
layout: default
title: i18n support in template file
---

# i18n support in template file

i18n support in template file

Problem:

How to get i18n support in webpy template file? 
Solution:

Project directory structure: 

<pre>
proj/
   |- code.py
   |- i18n/
       |- messages.po
       |- en_US/
            |- LC_MESSAGES/
                   |- messages.po
                   |- messages.mo
   |- templates/
       |- hello.html

</pre>

File: proj/code.py 

<pre>
#!/usr/bin/env python
# encoding: utf-8

import web
import gettext

urls = (
    '/.*', 'hello',
    )

# File location directory.
curdir = os.path.abspath(os.path.dirname(__file__))

# i18n directory.
localedir = curdir + '/i18n'

gettext.install('messages', localedir, unicode=True)   
gettext.translation('messages', localedir, languages=['en_US']).install(True)  
render = web.template.render(curdir + '/templates/', globals={'_': _})

class hello:
    def GET(self):
        return render.hello()

# Run with buildin http server.
app = web.application(urls, globals())
if __name__ == "__main__":
    app.run()
</pre>

Template file: proj/templates/hello.html. 
<pre>$_("Message")</pre>

Create locale dir and use pygettext.py which shipped within Python-2.6 (in directory: Tools/i18n/) to extract messages from python scripts and templates files: 
<pre>
shell> cd /path/to/proj/
shell> mkdir -p i18n/en_US/LC_MESSAGES/
shell> python /path/to/pygettext.py -a -v -d messages -o i18n/messages.po \*.py templates/\*.html
Working on code.py
Working on templates/hello.html
</pre>

You will get pot file: i18n/messages.po. Its contents looks like below ('msgstr' contains translated message): 
<pre>
#: code.py:40
msgid "Message"
msgstr "This is translated message in file: code.py."
</pre>

Copy file 'i18n/messages.po' to directory 'i18n/en_US/LC_MESSAGES/', and then translate it. Use 'msgfmt' tool from 'gettext' package (not python moudule) or use file 'msgfmt.py' shipped within Python-2.6 (in directory: Tools/i18n/) to compile pot file to mo file: 
<pre>
shell> msgfmt -o i18n/en_US/LC_MESSAGES/messages.mo i18n/en_US/LC_MESSAGES/messages.po
</pre>
Start webpy http server: 
<pre>
shell> cd /path/to/proj/
shell> python code.py
http://0.0.0.0:8000/
</pre>
Start your web browser, e.g. firefox, and visit url: http://192.168.0.3:8000/, you will see translated message.
---
layout: default
title: i18n support in template file
---

# i18n support in template file

## 模板文件中的i18n支持  

### 问题:  

在web.py的模板文件中, 如何得到i18n的支持?  

### Solution:  

项目目录结构:

<pre>
proj/
   |- code.py
   |- i18n/
       |- messages.po
       |- en_US/
            |- LC_MESSAGES/
                   |- messages.po
                   |- messages.mo
   |- templates/
       |- hello.html

</pre>

文件: proj/code.py 

<pre>
#!/usr/bin/env python
# encoding: utf-8

import web
import gettext

urls = (
    '/.*', 'hello',
    )

# File location directory.
curdir = os.path.abspath(os.path.dirname(__file__))

# i18n directory.
localedir = curdir + '/i18n'

gettext.install('messages', localedir, unicode=True)   
gettext.translation('messages', localedir, languages=['en_US']).install(True)  
render = web.template.render(curdir + '/templates/', globals={'_': _})

class hello:
    def GET(self):
        return render.hello()

# 使用内建的HTTP服务器来运行.
app = web.application(urls, globals())
if __name__ == "__main__":
    app.run()
</pre>

模板文件: proj/templates/hello.html. 
<pre>$_("Message")</pre>

创建一个locale目录并使用python2.6内建的pygettext.py从python脚本和模板文件中导出翻译:
<pre>
shell> cd /path/to/proj/
shell> mkdir -p i18n/en_US/LC_MESSAGES/
shell> python /path/to/pygettext.py -a -v -d messages -o i18n/messages.po *.py templates/*.html
Working on code.py
Working on templates/hello.html
</pre>

你将会得到pot file: i18n/messages.po. 它的内容和下面的差不多
('msgstr'包含了翻译后的信息):  
<pre>
 # 文件 code.py:40
msgid "Message"
msgstr "This is translated message in file: code.py."
</pre>

拷贝文件'i18n/messages.po'到目录'i18n/en_US/LC_MESSAGES/'下, 然后翻译它. 使用gettext包的msgfmt工具或者使用python2.6内建的'msgfmt.py'文件将一个pot文件编译称mo文件:  
<pre>
shell> msgfmt -o i18n/en_US/LC_MESSAGES/messages.mo i18n/en_US/LC_MESSAGES/messages.po
</pre>

运行web.py的服务器: 

<pre>
shell> cd /path/to/proj/
shell> python code.py
http://0.0.0.0:8000/
</pre>
打开你的浏览器, 比如说firefox, 然后访问地址: http://192.168.0.3:8000/, 你将会看过翻译过的信息.
---
layout: default
title: Deploying web.py on IIS7 via PyISAPIe
---

# Deploying web.py on IIS7 via PyISAPIe

This guide is an account of the various steps, including snippets of relevant code that tweaked and added, in order to get a `web.py` script to work on IIS7 using `PyISAPIe`.  Please note that you must have Python as well as the [PyWin32 extensions][0] installed on Windows. _This guide was tested on two different 64-bit versions of Windows server with 32-bit versions of Python 2.6.6 installed and on IIS7 and IIS6_. 

First and foremost, I had to install the `web.py` module on the system. Having had trouble before with IIS with `web.py` installed through `easy_install`, I decided to be safe and installed it from source. Getting `web.py` to work with PyISAPIe required a small hack. In the file `Lib\site-packages\web\wsgi.py` lies the following function: 

    def _is_dev_mode():
        # quick hack to check if the program is running in dev mode.
        if os.environ.has_key('SERVER_SOFTWARE') \
            or os.environ.has_key('PHP_FCGI_CHILDREN') \
            or 'fcgi' in sys.argv or 'fastcgi' in sys.argv \
            or 'mod_wsgi' in sys.argv:
                return False
        return True

In its pristine state, when `web.py` is imported from a source file through PyISAPIe, an exception is thrown. The exception, while I don't have the exact message, is about it complaining about `sys.argv` not having an attribute `argv`, which reads fishy. Since the function `_is_dev_mode()` only checks whether `web.py` is being run in development mode, I thought I didn't care about it since I wanted everything to run in production mode. I edited the function such that its body would be bypassed, while it returned a `False` boolean value. It looked like this:

    def _is_dev_mode():
        return False
        # quick hack to check if the program is running in dev mode.
        if os.environ.has_key('SERVER_SOFTWARE') \
            or os.environ.has_key('PHP_FCGI_CHILDREN') \
            or 'fcgi' in sys.argv or 'fastcgi' in sys.argv \
            or 'mod_wsgi' in sys.argv:
                return False
        return True

This innocuous little addition did away with the exception.

Next up, I used default Hello World-esque example of `web.py`. I called it `code.py` (I placed it inside the folder `C:\websites\myproject`). It looked like this:

      import web
      urls = (
          '/.*', 'hello',
          )
      class hello:
          def GET(self):
              return "Hello, world."
      application = web.application(urls, globals()).wsgifunc()

It was pretty simple. You have to pay particular attention on the call to `web.application`. I called the `wsgifunc()` to return a WSGI-compatible function to boot the application.  

I set up a website under IIS using the IIS Management Console. Since I was working on a 64-bit server edition of Windows and had chosen to use 32-bit version of Python and all modules, I made sure to enable **32-bit support** for the application pool being used for the website. This was important. 

I decided to keep the PyISAPIe folder inside the folder where `code.py` rested. This PyISAPIe folder contained the `PyISAPIe.dll` file, and the `Http` folder. Inside the `Http` folder, I placed the most important file of all: the `Isapi.py`. That file could be thought of as the starting point for each request that is made, what glues the Request to the proper Handler and code. I worked with the `Examples\WSGI\Isapi.py` available as part of PyISAPIe. I tweaked the file to look like this:


    from Http.WSGI import RunWSGI
    from Http import Env
    #from md5 import md5
    from hashlib import md5
    import imp
    import os
    import sys
    sys.path.append(r"C:\websites\myproject")
    from code import application
    ScriptHandlers = {
        "/api/": application,
    }
    def RunScript(Path):
      global ScriptHandlers
      try:
        # attempt to call an already-loaded request function.
        return ScriptHandlers[Path]()
      except KeyError:
        # uses the script path's md5 hash to ensure a unique
        # name - not the best way to do it, but it keeps
        # undesired characters out of the name that will
        # mess up the loading.
        Name = '__'+md5(Path).hexdigest().upper()
        ScriptHandlers[Path] = \
          imp.load_source(Name, Env.SCRIPT_TRANSLATED).Request
        return ScriptHandlers[Path]()
    # URL prefixes to map to the roots of each application.
    Apps = {
      "/api/" : lambda P: RunWSGI(application),
    }
    # The main request handler.
    def Request():
      # Might be better to do some caching here?
      Name = Env.SCRIPT_NAME
      # Apps might be better off as a tuple-of-tuples,
      # but for the sake of representation I leave it
      # as a dict.
      for App, Handler in Apps.items():
        if Name.startswith(App):
          return Handler(Name)
      # Cause 500 error: there should be a 404 handler, eh?
      raise Exception, "Handler not found."

The important bits to note in the above code are the following:

* I import `application` from my `code` module. I set the PATH to include the directory in which the file `code.py` is so that the `import` statement does not complain. (I've to admit that the idea of import `application` and feeding it into `RunWSGI` came to while I was in the loo.)
* I defined a script handler which matches the URL prefix I want to associate with my `web.py` script. (_In hindsight, this isn't necessary, as the `RunScript()` is not being used in this example_).
* In the `Apps` dictionary, I again route the URL prefix to the `lambda` function which actually calls the `RunWSGI` function and feeds it `application`. 
* I also imported the `md5` function from the `hashlib` module instead of the `md5` module as originally defined in the file. This was because Python complained about `md5` module being deprecated and suggested instead of use `hashlib`.

I then defined a wild-card (Script map) extension in IIS for the website, mapping all requests to the `PyISAPIe.dll` file in _my project folder_. Which `PyISAPIe.dll` file is used is important. By default, it will look for the `Http` folder in the same directory where the DLL is. I restarted IIS (and possibly even Windows, just to be sure).

And that's pretty much it.

There's a caveat though. If you have specific URLs in your `web.py` script, you will have to modify each of those URLs to add the `/api/` prefix to them (or whatever URL prefix you set in the `Isapi.py`). Without that, `web.py` will not match any URLs in the file.

Good luck!

_PS: If you want to avoid using PyISAPIe, there is a simpler way of deploying web.py on IIS. It is documented crudely over [here][1]._

[0]: http://sourceforge.net/projects/pywin32/
[1]: http://forums.iis.net/t/1122937.aspx

---
layout: default
title: Web.py Cookbook
---

# Web.py Cookbook

Autres langages : [japan 日本語](/ja) | [chinese 简体中文](/zh-cn) | [english](/../cookbook) | ...

Documentation de type Cookbook pour web.py 0.3. Veuillez noter que certaines de ces fonctions ne sont pas disponibles dans les versions précedentes. 
La version actuelle 0.3 est la branche développement.

#Mise en forme

1. En termes de mise en forme, essayez d'utiliser un format de type cookbook... Comme ceci:
    
    ###Probleme: Vous voulez accéder aux données de la base ...
     
    ###Solution: Utilisez ce code ...

1. Notez que les urls n'ont pas besoin de "web" dans leur structures -- juste "/cookbook/select" , et pas "/cookbook/web.select".  

1. Cette documentation est finalement pour la version 0.3, donc veuillez ajouter du code qui ne fonctionne qu'avec cette version.

-------------------------------------------------

##Basique:
* [Hello World](/helloworld/fr). 
* [Servir des fichiers statiques](/staticfiles/fr).  
* [Comprendre la gestion des URLs](/url_handling/fr).  
* [Seeother et Redirect](/redirect+seeother/fr).  
* [Utiliser les sous-applications](/subapp/fr).  
* [Servir du XML](/xmlfiles/fr).   
* [Lire les données brutes d'un post](/postbasic/fr). 


##Avancé
* [web.ctx](/ctx/fr). 
* [Application processors, charger et décharger des hooks](/application_processors/fr). 
* [Comment utiliser web.background](/background). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Personnaliser le message NotFound](/custom_notfound/fr). 
* [Comment streamer de gros fichiers](/streaming_large_files/fr). 
* [Contrôler les evènements sur le serveur intégré par défaut](/logging/fr). 
* [Configurer le support SSL dans le serveur intégré](/ssl/fr).
* [Run-time language switch](/runtime-language-switch). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)

##Sessions et état des utilisateurs:
* [Travailler avec les sessions](/sessions/fr). 
* [Utiliser session avec reloader](/session_with_reloader/fr). 
* [Utiliser session dans les gabarits](/session_in_template/fr). 
* [Travailler avec les cookies](/cookies/fr). 
* [Authentification des utilisateurs](/userauth/fr). 
* [Authentification des utilisateurs avec base de données Postgresql](/userauthpgsql). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Utiliser les sessions avec les sous-applications](/sessions_with_subapp/fr). 


##Utils:
* [Envoi de Mail](/sendmail). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Envoi de Mail en utilisant Gmail](/sendmail_using_gmail/fr). 
* [Webservice en utilisant soaplib + WSDL](/webservice). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)

##Modèles de mise en forme, gabarits de mise en page:
* [Templetor: le système de gabarits de web.py](/docs/0.3/templetor.fr )
* [Mise en page selon un gabarit](/layout_template/fr). 
* [Alterner un style](/alternating_style). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Importer des fonctions dans les gabarits](/template_import). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [i18n support dans les fichiers gabarits](/i18n_support_in_template_file ). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Utiliser le moteur de gabarit Mako dans webpy](/template_mako). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Utiliser le moteur de gabarit Cheetah dans webpy](/template_cheetah). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Utiliser le moteur de gabarit  Jinja2 dans webpy](/template_jinja). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Comment utiliser les gabarits sur Google App Engine](/templates_on_gae). - traduction demandée, voir [Todo](/docs/0.3.fr/todo))

##Essais:
* [Tester avec Paste et Nose](/testing_with_paste_and_nose). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [RESTful doctesting using an application's request method](/restful_doctesting_using_request). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)

##Entrées utilisateurs:
* [Uploader un fichier](/fileupload/fr). 
* [Stocker un fichier uploadé](/storeupload/fr). 
* [Comment limiter la taille des fichiers uploadés](/limiting_upload_size/fr). 
* [Accéder aux entrées utilisateurs par le biais de web.input](/input/fr). 
* [Comment utiliser les formulaires](/forms/fr). 
* [Rendu individuel des champs de formulaires](/form_fields). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)

##Base de données:
* [Multiples bases de données](/multidbs). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Select: Récupérer les entrées d'une base de données](/select). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Update: Mettre à jour les entrées d'une base de données](/update). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Delete: Supprimer les entrées d'une base de données](/delete). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Insert: Ajouter des entrées à une base de donnée](/insert).  - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Query: Base de données - Requêtes avancées](/query). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Query: How to use database transactions](/transactions). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Comment utiliser sqlalchemy](/sqlalchemy). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Intégrer SQLite UDF (user-defined-functions) à la couche de base de données webpy](/sqlite-udf). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Utiliser un dictionnaire comme clause where](/where_dict). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)


##Déploiement:
* [Déploiement Fastcgi au travers lighttpd](/fastcgi-lighttpd/fr). 
* [Déploiement Fastcgi au travers Apache](/fastcgi-apache).  - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Déploiement CGI au travers Apache](/cgi-apache). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* Déploiement mod_python au travers Apache (requis)
* [Déploiement mod_wsgi au travers Apache](/mod_wsgi-apache ). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Déploiement mod_wsgi au travers Nginx](/mod_wsgi-nginx ). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Déploiement Fastcgi au travers Nginx](/fastcgi-nginx). - traduction demandée, voir [Todo](/docs/0.3.fr/todo)

##Sous-domaines:
* Sous-domaines et comment accéder au nom utilisateur (requis)
---
layout: default
title: クックブック
---

# クックブック

web.py 0.3 ベースのCookbookスタイルのドキュメントです。
古いバージョンでは利用可能ではない説明があります。
現在、バージョン 0.3 は開発版です。

#形式

1. 形式に関しては、Cookbookのような形式を使用するようにしてください。以下のような形式です。
    
    ###問題点: データベースにアクセスしたいのですが。
     
    ###解決手段: このコードを使ってください。

1. URLには"web"をつけないようにしてください。もし"/cookbook/select"ならば、"/cookbook/web.select"のようにしないでください。

1. 最後に、このドキュメンテーションはバージョン 0.3向けですので、あなたの知っている新バージョン用のコードを加えてください。

-------------------------------------------------

##Basics:
* [Hello World](/helloworld/ja)
* [staticファイル(js、css、画像など)について](/staticfiles/ja)
* [Seeother(HTTP/1.1 コード : 303)とRedirect](/redirect+seeother)
* [サブアプリケーションの使い方について(別ファイルのインクルード)](/subapp/ja)
* [Serving XML](/xmlfiles)

##Advanced
* [web.ctx](/ctx)
* [Application processors, loadhooks and unloadhooks](/application_processors)
* [How to use web.background](/background)
* [Custom NotFound message](/custom_notfound)

##Sessions and user state:
* [Session機能](/sessions)
* [Using session with reloader](/session_with_reloader)
* [Cookies機能](/cookies)
* ユーザ認証 (requested)

##Utils:
* [メール送信](/sendmail)
* [GMailへのメール送信](/sendmail_using_gmail)

##Templates:
* [Using Site Layout Templates](/layout_template)
* [Alternating Style](/alternating_style)
* [makoテンプレートエンジンの使用について](/template_mako/ja)
* [Cheetahテンプレートエンジンの使用について](/template_cheetah/ja)

##User Input:
* [ファイルアップロード](/fileupload)
* [リクエストデータ(web.inputを利用)へのアクセス](/input)
* Using basic forms (requested)

##Database:
* [複数データベース](/multidbs)
* [Select: データ検索(SELECT文)](/select)
* [Update: データ更新(UPDATE文)](/update)
* [Delete: データ削除(DELETE文)](/delete)
* [Insert: データ追加(INSERT文)](/Insert) 
* [問い合わせ(SQL文の発行)](/query)
* [トランザクションの使用](transactions)

##Deployment:
* [Lighttpd + Fastcgiの配置](/fastcgi-lighttpd)
* [Apache + Fastcgiの配置](/fastcgi-apache) 
* [Apache + CGIの配置](/cgi-apache/ja)
* mod_python deployment through Apache (requested)
* [mod_wsgi deployment through Apache](/mod_wsgi-apache )
* [mod_wsgi deployment through Nginx](/mod_wsgi-nginx )
* nginx deployment (requested)




##Subdomains:
* サブドメインおよびユーザー名を使用してにアクセスする方法 (requested)
---
layout: default
title: Web.py Cookbook
---

# Web.py Cookbook

_Other languages:_ [简体中文](/cookbook/index.zh-cn) | [日本語](/cookbook/index.ja) |  [Français](/cookbook/index.fr)

## Basics
* [Hello World](/cookbook/helloworld)
* [Serving Static Files](/cookbook/staticfiles)
* [Understanding URL handling](/cookbook/url_handling)
* [Seeother and Redirect](/cookbook/redirect%2Bseeother)
* [using subapplications](/cookbook/subapp)
* [Serving XML](/cookbook/xmlfiles)
* [Reading raw data from post](/cookbook/postbasic)

## Advanced
* [Contextual and Environment variables - web.ctx](/cookbook/ctx)
* [Application processors, loadhooks and unloadhooks](/cookbook/application_processors)
* [How to use web.background](/cookbook/background)
* [Custom NotFound message](/cookbook/custom_notfound)
* [How to Stream Large Files](/cookbook/streaming_large_files)
* [Control over logging for default HTTPServer](/cookbook/logging)
* [SSL support in built-in cherrypy server](/cookbook/ssl)
* [Run-time language switch](/cookbook/runtime-language-switch)

## Sessions and user state
* [Working with Session](/cookbook/sessions)
* [Using session with reloader](/cookbook/session_with_reloader)
* [Using session in template](/cookbook/session_in_template)
* [Working with Cookies](/cookbook/cookies)
* [User authentication](/cookbook/userauth)
* [User authentication with http basic auth (RFC2617)](/cookbook/userauthbasic)
* [User authentication with Postgresql database](/cookbook/userauthpgsql)
* [Sessions with sub-apps](/cookbook/sessions_with_subapp)
* [Unpack session stored in postgresql](/cookbook/unpack_postgres_session)

## Utils
* [Sending Mail](/cookbook/sendmail)
* [Sending Mail Using Gmail](/cookbook/sendmail_using_gmail)
* [Webservice using soaplib + WSDL](/cookbook/webservice)

## Templates
* [Templetor: The web.py templating system](/docs/0.3/templetor )
* [Using Site Layout Templates](/cookbook/layout_template)
* [Alternating Style](/cookbook/alternating_style)
* [Import functions into templates](/cookbook/template_import)
* [i18n support in template file](/cookbook/i18n_support_in_template_file )
* [Use Mako template engine in webpy](/cookbook/template_mako)
* [Use Cheetah template engine in webpy](/cookbook/template_cheetah)
* [Use Jinja2 template engine in webpy](/cookbook/template_jinja)
* [How to use templates on Google App Engine](/cookbook/templates_on_gae)
* [Concatenate two rendered templates](/cookbook/concatenate_two_rendered_templates)

## Testing
* [Testing with Paste and Nose](/cookbook/testing_with_paste_and_nose)
* [RESTful doctesting using an application's request method](/cookbook/restful_doctesting_using_request)

## User input
* [File Upload](/cookbook/fileupload)
* [Store an uploaded file](/cookbook/storeupload)
* [How to put a limit of size of uploaded files](/cookbook/limiting_upload_size)
* [Accessing user input through web.input](/cookbook/input)
* [How to use forms](/cookbook/forms) 
* [Render individual form fields](/cookbook/form_fields)
* [How to protect forms from CSRF attacks](/cookbook/csrf) 

## Databases
* [Multiple databases](/cookbook/multidbs)
* [Select: Retrieving entries from a database](/cookbook/select)
* [Update: Updating entries in a database](/cookbook/update)
* [Delete: Remove entries in a database](/cookbook/delete)
* [Insert: Adding entries to a database](/cookbook/insert) 
* [Query: Advanced database queries](/cookbook/query)
* [How to use database transactions](/cookbook/transactions)
* [Using sqlalchemy](/cookbook/sqlalchemy) 
* [Integrating SQLite UDF (user-defined-functions) with webpy database layer](/cookbook/sqlite-udf)
* [Using a dictionary as where clause](/cookbook/where_dict)


## Deployment
* [Fastcgi deployment through lighttpd](/cookbook/fastcgi-lighttpd)
* [Fastcgi deployment through Apache](/cookbook/fastcgi-apache) 
* [CGI deployment through Apache](/cookbook/cgi-apache)
* mod_python deployment through Apache (requested)
* [mod_wsgi deployment through Apache on Red Hat](/cookbook/mod_wsgi-apache)
* [mod_wsgi deployment through Apache on Ubuntu](/cookbook/mod_wsgi-apache-ubuntu)
* [mod_wsgi deployment through Nginx](/cookbook/mod_wsgi-nginx )
* [Fastcgi deployment through Nginx](/cookbook/fastcgi-nginx)
* [PyISAPIe deployment through IIS7/IIS6](/cookbook/iis7_iis6_windows_pyisapie)
* [Deploying as a google app engine application](/cookbook/google_app_engine)

## Subdomains
* Subdomains and how to access the username (requested)

---
layout: default
title: Web.py Cookbook 简体中文版
---

# Web.py Cookbook 简体中文版

欢迎来到web.py 0.3的Cookbook。提醒您注意：某些特性在之前的版本中并不可用。当前开发版本是0.3。

#格式

1. 在编排内容时，请尽量使用cookbook格式...如：
    
    ###问题：如何访问数据库中的数据？
     
    ###解法：使用如下代码...

1. 请注意，网址中不必含有"web"。如"/cookbook/select"，而非"/cookbook/web.select"。

1. 该手册适用于0.3版本，所以您在添加代码时，请确认代码能在新版本中工作。

-------------------------------------------------

##基本应用:
* [Hello World](helloworld.zh-cn)
* [提供静态文件访问](staticfiles.zh-cn)
* [理解URL控制](url_handling.zh-cn)
* [跳转与重定向](redirect%20seeother.zh-cn)
* [使用子应用](subapp.zh-cn)
* [提供XML访问](xmlfiles.zh-cn)
* [从post读取原始数据](postbasic.zh-cn)

##高级应用
* [用web.ctx获得客户端信息](ctx.zh-cn)
* [应用处理器，添加钩子和卸载钩子](application_processors.zh-cn)
* [如何使用web.background](background.zh-cn)
* [自定义NotFound信息](custom_notfound.zh-cn)
* [如何流传输大文件](streaming_large_files.zh-cn)
* [对自带的webserver日志进行操作](logging.zh-cn)
* [用cherrypy提供SSL支持](ssl.zh-cn)
* [实时语言切换](runtime-language-switch.zh-cn)

##Sessions and user state 会话和用户状态:
* [如何使用Session](sessions.zh-cn)
* [如何在调试模式下使用Session](session_with_reloader.zh-cn)
* [在template中使用session](session_in_template.zh-cn)
* [如何操作Cookie](cookies.zh-cn)
* [用户认证](userauth.zh-cn)
* [一个在postgreSQL数据库环境下的用户认证的例子](userauthpgsql.zh-cn)
* [如何在子应用中操作Session](sessions_with_subapp.zh-cn)


##Utils 实用工具:
* [如何发送邮件](sendmail.zh-cn)
* [如何利用Gmail发送邮件](sendmail_using_gmail.zh-cn)
* [使用soaplib实现webservice](webservice.zh-cn)

##Templates 模板
* [Templetor: web.py 模板系统](/docs/0.3/templetor.zh-cn)
* [使用站点布局模板](layout_template.zh-cn)
* [交替式风格 (未译)](alternating_style.zh-cn)
* [导入函数到模板中 (未译)](template_import.zh-cn)
* [模板文件中的i18n支持](i18n_support_in_template_file.zh-cn)
* [在web.py中使用Mako模板引擎 ](template_mako.zh-cn)
* [在web.py中使用Cheetah模板引擎](template_cheetah.zh-cn)
* [在web.py中使用Jinja2模板引擎](template_jinja.zh-cn)
* [如何在谷歌应用程序引擎使用模板](templates_on_gae.zh-cn)

##Testing 测试:
* [Testing with Paste and Nose (未译)](testing_with_paste_and_nose.zh-cn)
* [RESTful doctesting using an application's request method (未译)](restful_doctesting_using_request.zh-cn)

##User input 用户输入:
* [文件上传](fileupload.zh-cn)
* [保存上传的文件](storeupload.zh-cn)
* [上传文件大小限定](limiting_upload_size.zh-cn)
* [通过 web.input 接受用户输入](input.zh-cn)
* [怎样使用表单](forms.zh-cn)
* [显示个别表单字段](form_fields.zh-cn)

##Database 数据库
* [使用多数据库](multidbs.zh-cn)
* [Select: 查询数据](select.zh-cn)
* [Update: 更新数据 ](update.zh-cn)
* [Delete: 删除数据](delete.zh-cn)
* [Insert: 新增数据](Insert.zh-cn)
* [Query: 高级数据库查询](query.zh-cn)
* [怎样使用数据库事务](transactions.zh-cn)
* [使用 sqlalchemy](sqlalchemy.zh-cn)
* [整合 SQLite UDF (用户定义函数) 到 webpy 数据库层](sqlite-udf.zh-cn)
* [使用字典动态构造where子句](where_dict.zh-cn)

##Deployment 部署:
* [通过Fastcgi和lighttpd部署](fastcgi-lighttpd.zh-cn)
* [通过Webpy和Nginx with FastCGI搭建Web.py](fastcgi-nginx.zh-cn) 
* [CGI deployment through Apache (未译)](cgi-apache.zh-cn)
* mod_python deployment through Apache (requested)
* [通过Apache和mod_wsgi部署](mod_wsgi-apache.zh-cn)
* [mod_wsgi deployment through Nginx (未译)](mod_wsgi-nginx.zh-cn)
* [Fastcgi deployment through Nginx (未译)](fastcgi-nginx.zh-cn)

##Subdomains 子域名:
* Subdomains and how to access the username (requested)
---
layout: default
title: Accéder aux entrées utilisateurs par le biais de web.input
---

# Accéder aux entrées utilisateurs par le biais de web.input

Autre langages: [english](/../input) | ...


### Problème:

Comment obtenir les données utilisateur depuis un  formulaire, ou un paramètre encodé dans l'URL.

### Solution:

La méthode web.input() renvoi un objet web.storage (de type dictionnaire) qui contient les variables de l'url (dans GET) ou de l'en-tête HTTP (dans POST).
Par exemple, si vous allez sur la page http://example.com/test?id=10, vous voudrez extraire le id=10 en arrière plan. En utilisant web.input(), cela devient facile:

    class SomePage:
        def GET(self):
            user_data = web.input()
            return "<h1>" + user_data.id + "</h1>"

Parfois, vous aurez besoin de spécifier une variable par défaut, dans le cas ou aucune n'est donnée. Voici le même code avec une valeur par defaut:

    class SomePage:
        def GET(self):
            user_data = web.input(id="no data")
            return "<h1>" + user_data.id + "</h1>"


*Notez que les valeurs de web.input() sont des chaînes, même si ce sont des numéros qui lui sont passées*

Que faire si vous passez plusieurs noms de variable équivalents, comme ceci:

<select multiple size="3"><option>foo</option><option>bar</option><option>baz</option></select>


Vous aurez besoin de faire savoir à web.input qu'il doit s'attendre à des entrées multiples, sinon il les référencera tous, sauf un. Passez la valeur par défaut d'une liste à web.input et il fonctionnera correctement. Par exemple,  http://example.com?id=10&id=20:

    class SomePage:
        def GET(self):
            user_data = web.input(id=[])
            return "<h1>" + ",".join(user_data.id) + "</h1>"
---
layout: default
title: web.input
---

# web.input

Other languages: [français](/../cookbook/input/fr) | ...

##web.input

### Problem
You want user data from a form, or a url encoded parameter.

### Solution
The web.input() method returns a web.storage object (a dictionary-like object) that contains the variables from the url (in a GET) or in the http header (in a POST).  For example, if you go to the page http://example.com/test?id=10, on the Python backend you'll want to extract that the id=10.  Using web.input(), this becomes trivial:

    class SomePage:
        def GET(self):
            user_data = web.input()
            return "<h1>" + user_data.id + "</h1>"

Sometimes you may want to specify a default variable, in case none is given.  The same code with a default value for x:

    class SomePage:
        def GET(self):
            user_data = web.input(id="no data")
            return "<h1>" + user_data.id + "</h1>"

Note that the web.input() values will be strings even if there are numbers passed to it.  


What if you pass several of the same variable names, like this:

<select multiple size="3"><option>foo</option><option>bar</option><option>baz</option></select>

You need to let web.input know to expect multiple inputs, or it will clobber all but one.  Pass the default value of a list to web.input and it will work correctly.  For example, going to http://example.com?id=10&id=20:

    class SomePage:
        def GET(self):
            user_data = web.input(id=[])
            return "<h1>" + ",".join(user_data.id) + "</h1>"
---
layout: default
title: web.input
---

# web.input

##web.input

### 问题
如何从form或是url参数接受用户数据.

### 解决方法
web.input()方法返回一个包含从url(GET方法)或http header(POST方法,即表单POST)获取的变量的web.storage对象(类似字典).举个例子,如果你访问页面http://example.com/test?id=10,在Python后台你想取得 id=10 ,那么通过web.input()那就是小菜一碟:

    class SomePage:
        def GET(self):
            user_data = web.input()
            return "<h1>" + user_data.id + "</h1>"

有时你想指定一个默认变量,而不想使用None.参考下面的代码:

    class SomePage:
        def GET(self):
            user_data = web.input(id="no data")
            return "<h1>" + user_data.id + "</h1>"

注意,web.input()取得的值都会被当作string类型,即使你传递的是一些数字.


如果你想传递一个多值变量,比如像这样:

<select multiple size="3"><option>foo</option><option>bar</option><option>baz</option></select>

你需要让web.input知道这是一个多值变量,否则会变成一串而不是一个变量 .传递一个list给 web.input 作为默认值,就会正常工作.举个例子, 访问 http://example.com?id=10&id=20:

    class SomePage:
        def GET(self):
            user_data = web.input(id=[])
            return "<h1>" + ",".join(user_data.id) + "</h1>"

译者补充:
多值变量这儿,在WEB上除了上面所说的multiple select 和query strings外,用得最多的就是复选框(checkbox)了,另外还有多文件上传时的&lt;input type="file" ...&gt;.
---
layout: default
title: db.insert
---

# db.insert

###Problem: You want to add data to a database

###Solution: 

With version 0.3, databases are defined like this:

    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')

Once the database is defined as such, performing insert can be performed like this:
    
    # Insert an entry into table 'mytable'
    sequence_id = db.insert('mytable', firstname="Bob",lastname="Smith",joindate=web.SQLLiteral("NOW()"))

The insert statement takes the following keyword arguments:
 
tablename
seqname   
_test  
\**values
 


##tablename
The name of the table in your database to which you would like to add data to.

##seqname
An optional argument, the default value is None. Set `seqname` to the ID if it's not the default, or to `False`.

##_test
The _test variable lets you see the SQL produced by the statement:

    results = db.select('mytable', offset=10, _test=True) 
    ><sql: 'SELECT * FROM mytable OFFSET 10'>

##\**values
A set of named arguments that represent the fields in your table. If values are not given, the database may create default values or issue a warning.
---
layout: default
title: db.insert 向数据库中新增数据
---

# db.insert 向数据库中新增数据

###问题
如何向数据加新增数据？

###解决办法

在 0.3 中，数据库连接如下：

    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')

数据库连接写好以后，“insert” 操作如下：
    
    # 向 'mytable' 表中插入一条数据
    sequence_id = db.insert('mytable', firstname="Bob",lastname="Smith",joindate=web.SQLLiteral("NOW()"))

上面的操作带入了几个参数，我们来说明一下：

* tablename
* seqname   
* _test  
* \**values 


##tablename
表名，即你希望向哪个表新增数据。

##seqname
可选参数，默认 None。Set `seqname` to the ID if it's not the default, or to `False`.

##_test
`_test` 参数可以让你看到 SQL 的执行过程：

    results = db.select('mytable', offset=10, _test=True) 
    ><sql: 'SELECT * FROM mytable OFFSET 10'>

##\**values
字段参数。如果没有赋值，数据库可能创建默认值或者发出警告。
---
layout: default
title: Mise en page selon un gabarit
---

# Mise en page selon un gabarit

Autres langages : [english](/../layout_template) | ...



### Problème


Comment puis-je utiliser un modèle/gabarit de site qui s'affiche dans chaque page? (Dans d'autres frameworks, cela s'appelle l'héritage des templates - template inheritance)

### Solution


Cela peut être fait en utilisant l'attribut de base:

    render = web.template.render('templates/', base='layout')
    

Maintenant si vous faites quelque chose comme `render.foo ()` il cherchera le gabarit `templates/foo.html`, puis l'enveloppera dans le gabarit `templates/layout.html`



Le format de "layout.html" doit être un simple gabarit qui contient une variable. Par exemple:

    $def with (content)
    <html>
    <head>
        <title>Foo</title>
    </head>
    <body>
    $:content
    </body>
    </html>


Si vous ne souhaitez pas utiliser le modèle de base, il suffit de créer un deuxième objet, sans l'attribut "base", ainsi:

    render_plain = web.template.render('templates/')
    
###Astuce: Le titre de page est défini dans d'autres fichiers gabarits qui sont ensuite utilisés par la mise en page (layout.html). Par exemple:

#####templates/index.html
    $var title: This is title.

    <h3>Hello, world</h3>

#####templates/layout.html
    $def with (content)
    <html>
    <head>
        <title>$content.title</title>
    </head>
    <body>
    $:content
    </body>
    </html>


###Astuce: Ajouter des fichiers css dans d'autres fichiers gabarits. Exemple:

####templates/login.html

    $var cssfiles: static/login.css static/login2.css

    hello, world.

####templates/layout.html

    $def with (content)
    <html>
    <head>
        <title>$content.title</title>

        $if content.cssfiles:
            $for f in content.cssfiles.split():
                <link rel="stylesheet" href="$f" type="text/css" media="screen" charset="utf-8"/>

    </head>
    <body>
    $:content
    </body>
    </html>

Le code HTML de sortie ressemble à celui ci-dessous:

    <link rel="stylesheet" href="static/login.css" type="text/css" media="screen" charset="utf-8"/>
    <link rel="stylesheet" href="static/login2.css" type="text/css" media="screen" charset="utf-8"/>
---
layout: default
title: Site Layout Template
---

# Site Layout Template

Other languages : [français](/layout_template/fr) | ...

### Problem

How do I use a site-wide base template that displays across every page? (In other frameworks, this is called template inheritance.)

### Solution

This can be done using the base attribute:
    
    render = web.template.render('templates/', base='layout')
    
Now if you do something like `render.foo()` it will render the `templates/foo.html` template and then wrap it in the `templates/layout.html` template.

The format for "layout.html" should be a simple template that takes one variable.  For example:

    $def with (content)
    <html>
    <head>
        <title>Foo</title>
    </head>
    <body>
    $:content
    </body>
    </html>

If you don't want to use the base template for something, just create a second render object without the base attribute, like:

    render_plain = web.template.render('templates/')
    
###Tip: Page title is set in other template files which are then used by the layout (layout.html). Example:

#####templates/index.html
    $var title: This is title.

    <h3>Hello, world</h3>

#####templates/layout.html
    $def with (content)
    <html>
    <head>
        <title>$content.title</title>
    </head>
    <body>
    $:content
    </body>
    </html>

###Tip: Add css files in other template files. Example:
####templates/login.html

    $var cssfiles: static/login.css static/login2.css

    hello, world.

####templates/layout.html

    $def with (content)
    <html>
    <head>
        <title>$content.title</title>

        $if content.cssfiles:
            $for f in content.cssfiles.split():
                <link rel="stylesheet" href="$f" type="text/css" media="screen" charset="utf-8"/>

    </head>
    <body>
    $:content
    </body>
    </html>

The HTML output code looks like below:

    <link rel="stylesheet" href="static/login.css" type="text/css" media="screen" charset="utf-8"/>
    <link rel="stylesheet" href="static/login2.css" type="text/css" media="screen" charset="utf-8"/>
---
layout: default
title: 站点布局模板
---

# 站点布局模板

### 问题

如何让站点每个页面共享一个整站范围的模板？（在某些框架中，称为模板继承，比如ASP.NET中的母版页）

### 方法

我们可以用 base 属性来实现:
    
    render = web.template.render('templates/', base='layout')
    
现在如果你调用`render.foo()`方法，将会加载`templates/foo.html` 模板，并且它将会被 `templates/layout.html`模板包裹。

 "layout.html" 是一个简单模板格式文件，它包含了一个模板变量，如下:

    $def with (content)
    <html>
    <head>
        <title>Foo</title>
    </head>
    <body>
    $:content
    </body>
    </html>

在某些情况，如果不想使用基本模板，只需要创建一个没有base属性的reander对象，如下：

    render_plain = web.template.render('templates/')
    
###Tip: 在布局文件（layout.html）中定义的页面标题变量，如何在其他模板文件中赋值，如下:

#####templates/index.html
    $var title: This is title.

    <h3>Hello, world</h3>

#####templates/layout.html
    $def with (content)
    <html>
    <head>
        <title>$content.title</title>
    </head>
    <body>
    $:content
    </body>
    </html>

###Tip: 在其他模板中引用css文件，如下:
####templates/login.html

    $var cssfiles: static/login.css static/login2.css

    hello, world.

####templates/layout.html

    $def with (content)
    <html>
    <head>
        <title>$content.title</title>

        $if content.cssfiles:
            $for f in content.cssfiles.split():
                <link rel="stylesheet" href="$f" type="text/css" media="screen" charset="utf-8"/>

    </head>
    <body>
    $:content
    </body>
    </html>

输入的HTML代码如下:

    <link rel="stylesheet" href="static/login.css" type="text/css" media="screen" charset="utf-8"/>
    <link rel="stylesheet" href="static/login2.css" type="text/css" media="screen" charset="utf-8"/>
---
layout: default
title: Comment limiter la taille des fichiers uploadés
---

# Comment limiter la taille des fichiers uploadés

Autre langages: [english](/../limiting_upload_size) | ...

## Problème:

Comment limiter la taille des fichiers uploadés ?

## Solution:

web.py utilise le module `cgi` pour parser les entrées de l'utilisateur et le module `cgi` a une disposition visant à limiter la taille maximale des entrées.

Le code suivant limite la taille des données entrantes à 10 Mo.

    import cgi

    # Données entrantes maximum que nous acceptons lorsque REQUEST_METHOD est POST
    # 0 ==> Données entrantes illimitées
    cgi.maxlen = 10 * 1024 * 1024 # 10Mo


Noter que cela limite la taille des données POST, pas des fichiers uploadés. Cependant, ce sera presque pareil s'il n'y a pas d'autre entrée.

Le module `cgi` lève l'exception `ValueError` quand la taille des données entrées est supérieure à `cgi.maxlen`. Elle peut être interceptée pour afficher le message d'erreur requis.

    class upload:
        def POST(self):
            try:
                i = web.input(file={})
            except ValueError:
                return "File too large"
---
layout: default
title: How to put a limit on upload size
---

# How to put a limit on upload size

Other languages: [français](/../cookbook/limiting_upload_size/fr) | ...

## Problem

How to put a limit on upload size

## Solution

web.py uses `cgi` module to parse user inputs and the `cgi` module has a provision to limit max size of input.

The following code limits the size of input data to 10MB.

    import cgi

    # Maximum input we will accept when REQUEST_METHOD is POST
    # 0 ==> unlimited input
    cgi.maxlen = 10 * 1024 * 1024 # 10MB

Please note that this limits the size of POST data, not file uploaded. However they will be almost same if there is no other input.

The `cgi` module raises `ValueError` when the input size is more than `cgi.maxlen`. It can be caught to display required error message.

    class upload:
        def POST(self):
            try:
                i = web.input(file={})
            except ValueError:
                return "File too large"
---
layout: default
title: 上传文件大小限定
---

# 上传文件大小限定

## 问题

如何限定上传文件的大小？

## Solution

web.py 使用`cgi` 模块来解析用户的输入， 而 `cgi` 模块对最大输入大小有限制。

下面的代码限制了最大数据输入为 10MB.

    import cgi

    # Maximum input we will accept when REQUEST_METHOD is POST
    # 0 ==> unlimited input
    cgi.maxlen = 10 * 1024 * 1024 # 10MB

请注意这是对POST方法提交数据大小的限制，而不是上传文件大小。当然如果表单中没有其他输入数据，上传文件完全可以达到限制的大小。

`cgi` 模块将会抛出 `ValueError`异常，如果数据输入的大小超过了 `cgi.maxlen`。我们可以捕捉该异常而避免显示不友好的错误信息。

    class upload:
        def POST(self):
            try:
                i = web.input(file={})
            except ValueError:
                return "File too large"
---
layout: default
title: Contrôler les évènements sur le serveur intégré par défaut
---

# Contrôler les évènements sur le serveur intégré par défaut

Autre langages: [english](/../logging) | ...

## Problème:

Vous souhaitez contrôler le [logging](http://www.jmdoudoux.fr/java/dej/chap026.htm#logging-1), les évenements,  avec le serveur intégré.

## Solution:

Avec le serveur intégré, vous pouvez contrôler les évènements en utilisant [wsgilog](http://pypi.python.org/pypi/wsgilog/) et en le passant à votre application comme un logiciel médiateur ([middleware](http://fr.wikipedia.org/wiki/Middleware))

Vous devez sous-classer wsgilog.WsgiLog pour passer des arguments mot-clé à la base par [exemple](http://github.com/harryf/urldammit/blob/234bcaae6deb65240e64ee3199213712ed62883a/dammit/log.py)

    import sys, logging
    from wsgilog import WsgiLog, LogIO
    import config

    class Log(WsgiLog):
        def __init__(self, application):
            WsgiLog.__init__(
                self,
                application,
                logformat = '%(message)s',
                tofile = True,
                file = config.log_file,
                interval = config.log_interval,
                backups = config.log_backups
                )
            sys.stdout = LogIO(self.logger, logging.INFO)
            sys.stderr = LogIO(self.logger, logging.ERROR)

Ensuite, lorsque vous exécutez votre application, vous passez une référence à la classe. Par exemple (si ce qui précède est une partie du module 'mylog')

    from mylog import Log
    application = web.application(urls, globals())
    application.run(Log)
---
layout: default
title: Logging
---

# Logging

Other languages: [français](/../cookbook/logging/fr) | ...

## Problem:

You want to control logging for default HTTPServer.

## Solution:

With the built-in webserver you can control logging by using [wsgilog](http://pypi.python.org/pypi/wsgilog/) and passing it to your app as [middleware](http://en.wikipedia.org/wiki/Middleware).

This code works for wsgilog version 0.2

    import sys, logging
    from wsgilog import WsgiLog
    import config

    class Log(WsgiLog):
        def __init__(self, application):
            WsgiLog.__init__(
                self,
                application,
                logformat = '%(message)s',
                tofile = True,
                toprint = True,
                file = config.log_file,
                interval = config.log_interval,
                backups = config.log_backups
                )


Then when you run your app, you pass a reference to to the class e.g. (if the above was part of the module 'mylog')

    from mylog import Log
    application = web.application(urls, globals())
    application.run(Log)
---
layout: default
title: 管理自带webserver日志
---

# 管理自带webserver日志

## 问题

如何操作web.py自带的webserver的日志？

## 解法

我们可以用[wsgilog](http://pypi.python.org/pypi/wsgilog/)来操作内置的webserver的日志，并做其为中间件加到应用中。

如下，写一个Log类继承wsgilog.WsgiLog，在_init_中把参数传给基类，如[这个例子](http://github.com/harryf/urldammit/blob/234bcaae6deb65240e64ee3199213712ed62883a/dammit/log.py)：

    import sys, logging
    from wsgilog import WsgiLog, LogIO
    import config

    class Log(WsgiLog):
        def __init__(self, application):
            WsgiLog.__init__(
                self,
                application,
                logformat = '%(message)s',
                tofile = True,
                file = config.log_file,
                interval = config.log_interval,
                backups = config.log_backups
                )
            sys.stdout = LogIO(self.logger, logging.INFO)
            sys.stderr = LogIO(self.logger, logging.ERROR)

接下来，当应用运行时，传递一个引用给上例中的Log类即可(假设上面代码是'mylog'模块的一部分，代码如下)：

    from mylog import Log
    application = web.application(urls, globals())
    application.run(Log)
---
layout: default
title: Webpy + Apache with mod_wsgi on Ubuntu
---

# Webpy + Apache with mod_wsgi on Ubuntu

The following steps were tested on:

1. Ubuntu 10.04, with Apache 2.2.16 and mod_wsgi 3.2-2, and
2. Ubuntu 12.04, with Apache 2.2.22 and mod_wsgi 3.3-4.

The same steps should work in other versions of Ubuntu as well.

Note:

* You may replace `appname` with your own project name.
* You may replace `code.py` with your own file name.
* `/var/www/webpy-app` found below refers to the path to the directory contains your code.py.
* `/var/www/webpy-app/code.py` is the full path to your python file.

### Steps:

1. Install mod_wsgi:
        
        sudo apt-get install libapache2-mod-wsgi

 This will install a `.so` module in Apache's **module directory**:

        /usr/lib/apache2/modules/mod_wsgi.so

 It will also automatically configure Apache to load the `mod_wsgi` module upon restart. You can confirm the presence of the module in Apache's **available modules directory**…

        /etc/apache2/mods-available/wsgi.conf
        /etc/apache2/mods-available/wsgi.load
 …as well as in Apache's **enabled modules directory**:

        /etc/apache2/mods-enabled/wsgi.conf
        /etc/apache2/mods-enabled/wsgi.load
        
2. Configure a website on Apache to load the `mod_wsgi` module. This can either be your default website, or another Virtual Host, which you can create by copying `/etc/apache2/sites-available/default` to something like `/etc/apache2/sites-available/my-website`. Add the following lines, under the `DocumentRoot` directive:

        WSGIScriptAlias /appname /var/www/webpy-app/code.py/
        AddType text/html .py

 Typically, the above two lines are the only ones necessary to serve a website built with web.py. Most probably, you will additionally need to define a subdirectory in your application, from which static files will be served. In this case, add:

        Alias /appname/static /var/www/webpy-app/static/

 After you have finished editing your website definition, you need to enable it (in case it is not already enabled). Do:
 
        sudo a2ensite my-website
        
3. Finally, create a sample file `/var/www/webpy-app/code.py`:

        import web

        urls = (
            '/.*', 'hello',
            )

        class hello:
            def GET(self):
                return "Hello, world."

        application = web.application(urls, globals()).wsgifunc()

4. Point your browser to 'http://your_server_name/appname' to verify whether it works for you.

### Note: mod_wsgi + sessions

If you use sessions with `mod_wsgi`, you should change your code like below:

    app = web.application(urls, globals())

    curdir = os.path.dirname(__file__)
    session = web.session.Session(app, web.session.DiskStore(os.path.join(curdir,'sessions')),)

    application = app.wsgifunc()

### mod_wsgi performance:
For mod_wsgi performance, please refer to mod_wsgi wiki page:

<http://code.google.com/p/modwsgi/wiki/PerformanceEstimates>

---
layout: default
title: Webpy + Apache with mod_wsgi
---

# Webpy + Apache with mod_wsgi

The following steps were tested on Apache-2.2.3 (Red Hat Enterprise Linux 5.2, x86_64), mod_wsgi-2.0.

Note:

* You may replace 'appname' with your own project name.
* You may replace code.py with your own file name.
* /var/www/webpy-app found below refers to the path to the directory contains your code.py
* /var/www/webpy-app/code.py is the full path to your python file

Steps:

* Download and install mod_wsgi from its website: [http://code.google.com/p/modwsgi/](http://code.google.com/p/modwsgi/). It will install a '.so' module in Apache module directory. e.g.

        /usr/lib64/httpd/modules/

* Configure Apache to load mod_wsgi module and your project in httpd.conf:

        LoadModule wsgi_module modules/mod_wsgi.so

        WSGIScriptAlias /appname /var/www/webpy-app/code.py/

        Alias /appname/static /var/www/webpy-app/static/
        AddType text/html .py

        <Directory /var/www/webpy-app/>
            Order deny,allow
            Allow from all
        </Directory>

* Sample file 'code.py':

        import web

        urls = (
            '/.*', 'hello',
            )

        class hello:
            def GET(self):
                return "Hello, world."

        application = web.application(urls, globals()).wsgifunc()

* Point your browser to 'http://your_server_name/appname' to verify whether it works for you.

#Note: mod_wsgi + sessions

If you use sessions with mod_wsgi, you should change you code like below:

    app = web.application(urls, globals())

    curdir = os.path.dirname(__file__)
    session = web.session.Session(app, web.session.DiskStore(os.path.join(curdir,'sessions')),)

    application = app.wsgifunc()

#mod_wsgi performance:
For mod_wsgi performance, please refer to mod_wsgi wiki page:

<http://code.google.com/p/modwsgi/wiki/PerformanceEstimates>
---
layout: default
title: 使用Apache + mod_wsgi部署webpy应用
---

# 使用Apache + mod_wsgi部署webpy应用

下面的步骤在Apache-2.2.3 (Red Hat Enterprise Linux 5.2, x86_64),mod_wsgi-2.0中测试通过。（译者注：本人在Windows2003 + Apache-2.2.15 + mod_wsgi-3.0也测试通过）

注意：

* 您可以使用您自己的项目名称替换'appname'。
* 您可以使用您自己的文件名称替换'code.py'。
* /var/www/webpy-app 为包含您的code.py的文件夹目录路径。
* /var/www/webpy-app/code.py 是您的python文件的完整路径。

步骤：

* 下载和安装mod_wsgi从它的网站：

[http://code.google.com/p/modwsgi/](http://code.google.com/p/modwsgi/). 它将安装一个'.so'的模块到您的apache 模块文件夹，例如：

        /usr/lib64/httpd/modules/

* 在httpd.conf中配置Apache 加载 mod_wsgi模块和您的项目：

        LoadModule wsgi_module modules/mod_wsgi.so

        WSGIScriptAlias /appname /var/www/webpy-app/code.py/

        Alias /appname/static /var/www/webpy-app/static/
        AddType text/html .py

        <Directory /var/www/webpy-app/>
            Order deny,allow
            Allow from all
        </Directory>

* 演示文件 'code.py':

        import web

        urls = (
            '/.*', 'hello',
            )

        class hello:
            def GET(self):
                return "Hello, world."

        application = web.application(urls, globals()).wsgifunc()

* 在您的浏览器地址栏中输入' http://your_server_name/appname' 来验证它是否可用。

#注意: mod_wsgi + sessions

如果您需要在mod_wsgi中使用sessions，您可以改变您的代码如下：

    app = web.application(urls, globals())

    curdir = os.path.dirname(__file__)
    session = web.session.Session(app, web.session.DiskStore(curdir + '/' + 'sessions'),)

    application = app.wsgifunc()

#mod_wsgi 性能:
有关mod_wsgi的性能，请参考mod_wsgi的维基页：    [http://code.google.com/p/modwsgi/wiki/PerformanceEstimates](http://code.google.com/p/modwsgi/wiki/PerformanceEstimates)
---
layout: default
title: deploying web.py with nginx and mod_wsgi
---

# deploying web.py with nginx and mod_wsgi

It is possible to deploy web.py with nginx using a mod_wsgi similar to the module for Apache.

After compiling and installing nginx with mod_wsgi, you can easily get a web.py app up and running with the following config* (edit the paths and settings with your own):


    wsgi_python_executable  /usr/bin/python;

    server {
        listen 80;
        server_name www.domain_name.com domain_name.com;
        root /path/to/your/webpy;

        include /etc/nginx/wsgi_vars;
        location / {
            wsgi_pass /path/to/your/webpy/app.py;     
         }
    }

*Note: This is a snippet of the relevant information to setup mod_wsgi for your web app and NOT a full config for running nginx.

Helpful links:<br />
[ nginx website](http://nginx.net/ )<br />
[ wiki page on mod_wsgi](http://wiki.codemongers.com/NginxNgxWSGIModule )

---
layout: default
title: deploying web.py with nginx and mod_wsgi
---

# deploying web.py with nginx and mod_wsgi

It is possible to deploy web.py with nginx using a mod_wsgi similar to the module for Apache.

After compiling and installing nginx with mod_wsgi, you can easily get a web.py app up and running with the following config* (edit the paths and settings with your own):


    wsgi_python_executable  /usr/bin/python;

    server {
        listen 80;
        server_name www.domain_name.com domain_name.com;
        root /path/to/your/webpy;

        include /etc/nginx/wsgi_vars;
        location / {
            wsgi_pass /path/to/your/webpy/app.py;     
         }
    }

*Note: This is a snippet of the relevant information to setup mod_wsgi for your web app and NOT a full config for running nginx.

Helpful links:<br />
[ nginx website](http://nginx.net/ )<br />
[ wiki page on mod_wsgi](http://wiki.codemongers.com/NginxNgxWSGIModule )
---
layout: default
title: Multiple Databases
---

# Multiple Databases

webpy 0.3 supports multiple databases by removing the database from a part of the "web" module, and making it a more typical object.  For example:

    import web
    
    mydb1 = web.database(dbn='mysql', db='dbname1', user='foo')
    mydb2 = web.database(dbn='mysql', db='dbname2', user='foo')
    
All of the former database methods work on these objects, such as:

* select('table_name', where="foo = bar")
* insert('table_name', foo="bar", baz="asdf")
* update('table_name', where="id = 10", foo="bar")
* query('table_name', "SELECT * FROM users JOIN friends WHERE users.id = friends.id")

See the database module for more information.
---
layout: default
title: Multiple Databases
---

# Multiple Databases

## Problem
You want to access multiple databases in a single project.

## Solution

webpy 0.3 supports multiple databases by removing the database from a part of the "web" module, and making it a more typical object.  For example:

    import web
    
    db1 = web.database(dbn='mysql', db='dbname1', user='foo')
    db2 = web.database(dbn='mysql', db='dbname2', user='foo')
    
    print db1.select('foo', where='id=1')
    print db2.select('bar', where='id=5')
    
insert, update, delete and query methods can also be used in the similar way. 

Of course, you can use 'host' and 'port' to specify server address and listen port.
---
layout: default
title: 多数据库使用
---

# 多数据库使用

## 问题
如何在单独项目中应用多数据库?

## 解决办法

webpy 0.3 支持多数据库操作,并从web模块中移走数据库部分, 使其成为一个更典型的对象.  例子如下:

    import web
    
    db1 = web.database(dbn='mysql', db='dbname1', user='foo')
    db2 = web.database(dbn='mysql', db='dbname2', user='foo')
    
    print db1.select('foo', where='id=1')
    print db2.select('bar', where='id=5')
    
增加, 更新, 删除和查询的方法跟原有单数据库操作类似.

当然, 你可以使用host和port参数来指定服务器地址和监听端口.
---
layout: default
title: Lire les données brutes d un post
---

# Lire les données brutes d un post

Autres langages [english](/../postbasic) | ...

## Probleme:

Parfois, le client envoie de nombreuses données par la péthode post. Dans webpy, vous pouvez les traiter de cette façon:

## Solution:

    class RequestHandler():
        def POST():
            data = web.data() # Vous pouvez obtenir les données en utilisant cette méthode
---
layout: default
title: Reading raw data from post
---

# Reading raw data from post

Other languages: [français](/../cookbook/postbasic/fr) | ...

## Introduction

Sometimes, the client sends a lot of data by the POST method. In webpy, you can handle it like this.


## Code

    class RequestHandler():
        def POST():
            data = web.data() # you can get data use this method
---
layout: default
title: 从post读取原始数据
---

# 从post读取原始数据

## 介绍

有时候，浏览器会通过post发送很多数据。在webpy，你可以这样操作。


## 代码

    class RequestHandler():
        def POST():
            data = web.data() # 通过这个方法可以取到数据
---
layout: default
title: db.query
---

# db.query

### Problem

You want to perform advanced SQL statements like joins or counts.

### Solution

webpy doesn't try to build layers between you and your database.  Rather, it tries to make it easy to perform common tasks, and get out of your way when you need to do more advanced things.  Performing advanced database queries is no different.  For example:

    import web

    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')
    
    results = db.query("SELECT COUNT(*) AS total_users FROM users")
    print results[0].total_users # -> prints number of entries in 'users' table


or, for a JOIN example:

    import web
    
    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')
    
    results = db.query("SELECT * FROM entries JOIN users WHERE entries.author_id = users.id")


To prevent SQL injection attacks, db.query also accepts the "vars" syntax as described in [db.select](/cookbook/select):

    results = db.query("SELECT * FROM users WHERE id=$id", vars={'id':10})

This will escape user input, if you're trusting them for the "id" variable.
---
layout: default
title: 使用db.query进行高级数据库查询
---

# 使用db.query进行高级数据库查询

### 问题：

您要执行的SQL语句如：高级的联接或计数。

### 解决：

webpy不会尝试为您和您的数据库建立层。相反，它试图以方便的通用任务，走出自己的方式，当您需要做的更高级的主题。执行高级的数据库查询是没有什么不同。例如：

    import web

    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')
    
    results = db.query("SELECT COUNT(*) AS total_users FROM users")
    print results[0].total_users # -> prints number of entries in 'users' table


或者是，使用一个JOIN示例:

    import web
    
    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')
    
    results = db.query("SELECT * FROM entries JOIN users WHERE entries.author_id = users.id")


为了防止SQL注入攻击，db.query还接受了“vars”语法如下描述[db.select](select.zh-cn):

    results = db.query("SELECT * FROM users WHERE id=$id", vars={'id':10})

这将避免用户输入，如果你信任这个“id”变量。
---
layout: default
title: web.redirect et web.seeother
---

# web.redirect et web.seeother

Autres langages [english](/../redirect+seeother/) | ...


### Probleme

Après le traitement des entrées utilisateurs (depuis un formulaire, par exemple), vous souhaitez les rediriger vers une autre page.

### Solution

    class SomePage:
        def POST(self):
            # Executez une application logique ici, puis:
            raise web.seeother('/someotherpage')


Quand un post est envoyé à cette fonction, à la fin il enverra au navigateur un code HTTP 303, et le nouvel emplacement. Le navigateur va alors effectuer un GET sur l'emplacement défini dans l'argument seeother.

Note: web.seeother et web.redirect génèrent des exceptions dans la version 0.3.

### A savoir

Il est peu probable que vous utilisiez la fonction web.redirect très souvent -- elle semble faire la même chose, mais elle envoie le code HTTP 301, qui est une redirection permanente. La plupart des navigateurs mettront en cache la nouvelle redirection, et vous enverront automatiquement à cet emplacement lorsque vous essaierez d'exécuter l'action à nouveau. Un bon cas d'utilisation des redirections est lorsque vous modifiez la structure d'URL de votre site, mais que vous désirez conserver les anciens liens à cause des marques-pages, signets, ou favoris.
---
layout: default
title: web.redirect and web.seeother
---

# web.redirect and web.seeother

Other languages:  [français](/../cookbook/redirect+seeother/fr) | ...

## web.redirect and web.seeother

### Problem
After processing user input (from a form, let's say), you want to redirect them to another page.

### Solution

    class SomePage:
        def POST(self):
            # Do some application logic here, and then:
            raise web.seeother('/someotherpage')

When a post is sent to this function, on completion it will send the browser an http code 303, and the new location. The browser will then perform a GET on the location defined in the seeother argument.

Note: web.seeother and web.redirect are made exceptions in 0.3.

### Hangups
It's unlikely that you want to use the web.redirect function very often -- it appears to do the same thing, but it sends the http code 301, which is a permanent redirect.  Most web browsers will cache the new redirection, and will send you to that location automatically when you try to perform the action again.  A good use case for redirect is when you're changing the URL structure of your site, but want the old links to work due to bookmarking.
---
layout: default
title: 跳转(seeother)与重定向(redirect)
---

# 跳转(seeother)与重定向(redirect)

## web.seeother 和 web.redirect

### 问题
在处理完用户输入后（比方说处理完一个表单），如何跳转到其他页面？

### 解法

    class SomePage:
        def POST(self):
            # Do some application logic here, and then:
            raise web.seeother('/someotherpage')

POST方法接收到一个post并完成处理之后，它将给浏览器发送一个303消息和新网址。接下来，浏览器就会对这个新网址发出GET请求，从而完成跳转。

注意：web.seeother和web.redirect不支持0.3以下版本。

### 区别
用web.redirect方法似乎也能做同样的事情，但通常来说，这并太友好。因为web.redirect发送的是301消息－这是永久重定向。因为大多数Web浏览器会缓存新的重定向，所以当我们再次执行该操作时，会自动直接访问重定向的新网址。很多时候，这不是我们所想要的结果。所以在提交表单时，尽量使用seeother。但是在下面要提到的这种场合，用redirect却是最恰当的：我们已经更改了网站的网址结构，但是仍想让用户书签/收藏夹中的旧网址不失效。

(注：要了解seeother和redirect的区别，最好是看一下http协议中不同消息码的含义。)
---
layout: default
title: RESTful doctesting using app.request
---

# RESTful doctesting using app.request

RESTful doctesting using app.request

    #!/usr/bin/env python
    
    """
    RESTful web.py testing
    
    usage: python webapp.py 8080 [--test]
    
    >>> req = app.request('/mathematicians', method='POST')
    >>> req.status
    '400 Bad Request'
    
    >>> name = {'first': 'Beno\xc3\xaet', 'last': 'Mandelbrot'}
    >>> data = urllib.urlencode(name)
    >>> req = app.request('/mathematicians', method='POST', data=data)
    >>> req.status
    '201 Created'
    >>> created_path = req.headers['Location']
    >>> created_path
    '/mathematicians/b-mandelbrot'
    >>> fn = '<h1 class=fn>{0} {1}</h1>'.format(name['first'], name['last'])
    >>> assert fn in app.request(created_path).data
    
    """
    
    import doctest
    import urllib
    import sys
    
    import web
    
    
    paths = (
      '/mathematicians(/)?', 'Mathematicians',
      '/mathematicians/([a-z])-([a-z]{2,})', 'Mathematician'
    )
    app = web.application(paths, globals())
    
    dbname = 'test' if sys.argv[-1] == '--test' else 'production'
    db = {} # db = web.database(..., db='math_{0}'.format(dbname))
    
    
    class Mathematicians:
    
      def GET(self, slash=False):
        """list all mathematicians and form to create new one"""
        if slash:
            raise web.seeother('/mathematicians')
        mathematicians = db.items() # db.select(...)
        return web.template.Template("""$def with (mathematicians)
          <!doctype html>
          <html>
          <head>
            <meta charset=utf-8>
            <title>Mathematicians</title>
          </head>
          <body>
            <h1>Mathematicians</h1>
            $if mathematicians:
              <ul class=blogroll>
                $for path, name in mathematicians:
                  <li class=vcard><a class="fn url"
                  href=/mathematicians/$path>$name.first $name.last</a></li>
              </ul>
            <form action=/mathematicians method=post>
              <label>First <input name=first type=text></label>
              <label>Last <input name=last type=text></label>
              <input type=submit value=Add>
            </form>
          </body>
          </html>""")(mathematicians)
    
      def POST(self, _):
        """create new mathematician"""
        name = web.input('first', 'last')
        key = '{0}-{1}'.format(name.first[0].lower(), name.last.lower())
        name.first, name.last = name.first.capitalize(), name.last.capitalize()
        db[key] = name # db.insert(...)
        path = '/mathematicians/{0}'.format(key)
        web.ctx.status = '201 Created'
        web.header('Location', path)
        return web.template.Template("""$def with (path, name)
          <!doctype html>
          <html>
          <head>
            <meta charset=utf-8>
            <title>Profile Created</title>
          </head>
          <body>
            <p>Profile created for <a href=$path>$name.first $name.last</a>.</p>
          </body>
          </html>""")(path, name)
    
    
    class Mathematician:
    
      def GET(self, first_initial, last_name):
        """display mathematician"""
        key = '{0}-{1}'.format(first_initial, last_name)
        try:
            mathematician = db[key] # db.select(...)
        except KeyError:
            raise web.notfound()
        return web.template.Template("""$def with (name)
          <!doctype html>
          <html>
          <head>
            <meta charset=utf-8>
            <title>$name.first $name.last</title>
          </head>
          <body class=vcard>
            <p><a href=/mathematicians rel=up>Mathematicians</a> &#x25B8;</p>
            <h1 class=fn>$name.first $name.last</h1>
          </body>
          </html>""")(mathematician)
    
    
    if __name__ == "__main__":
      if sys.argv[-1] == '--test':
        doctest.testmod()
      else:
        app.run()
---
layout: default
title: RESTful doctesting using app.request
---

# RESTful doctesting using app.request

#!/usr/bin/env python
    
    """
    RESTful web.py testing
    
    usage: python webapp.py 8080 [--test]
    
    >>> req = app.request('/mathematicians', method='POST')
    >>> req.status
    '400 Bad Request'
    
    >>> name = {'first': 'Beno\xc3\xaet', 'last': 'Mandelbrot'}
    >>> data = urllib.urlencode(name)
    >>> req = app.request('/mathematicians', method='POST', data=data)
    >>> req.status
    '201 Created'
    >>> created_path = req.headers['Location']
    >>> created_path
    '/mathematicians/b-mandelbrot'
    >>> fn = '<h1 class=fn>{0} {1}</h1>'.format(name['first'], name['last'])
    >>> assert fn in app.request(created_path).data
    
    """
    
    import doctest
    import urllib
    import sys
    
    import web
    
    
    paths = (
      '/mathematicians(/)?', 'Mathematicians',
      '/mathematicians/([a-z])-([a-z]{2,})', 'Mathematician'
    )
    app = web.application(paths, globals())
    
    dbname = {True: 'test', False: 'production'}[sys.argv[-1] == '--test']
    db = {} # db = web.database(..., db='math_{0}'.format(dbname))
    
    
    class Mathematicians:
    
      def GET(self, slash=False):
        """list all mathematicians and form to create new one"""
        if slash:
            raise web.seeother('/mathematicians')
        mathematicians = db.items() # db.select(...)
        return web.template.Template("""$def with (mathematicians)
          <!doctype html>
          <html>
          <head>
            <meta charset=utf-8>
            <title>Mathematicians</title>
          </head>
          <body>
            <h1>Mathematicians</h1>
            $if mathematicians:
              <ul class=blogroll>
                $for path, name in mathematicians:
                  <li class=vcard><a class="fn url"
                  href=/mathematicians/$path>$name.first $name.last</a></li>
              </ul>
            <form action=/mathematicians method=post>
              <label>First <input name=first type=text></label>
              <label>Last <input name=last type=text></label>
              <input type=submit value=Add>
            </form>
          </body>
          </html>""")(mathematicians)
    
      def POST(self, _):
        """create new mathematician"""
        name = web.input('first', 'last')
        key = '{0}-{1}'.format(name.first[0].lower(), name.last.lower())
        name.first, name.last = name.first.capitalize(), name.last.capitalize()
        db[key] = name # db.insert(...)
        path = '/mathematicians/{0}'.format(key)
        web.ctx.status = '201 Created'
        web.header('Location', path)
        return web.template.Template("""$def with (path, name)
          <!doctype html>
          <html>
          <head>
            <meta charset=utf-8>
            <title>Profile Created</title>
          </head>
          <body>
            <p>Profile created for <a href=$path>$name.first $name.last</a>.</p>
          </body>
          </html>""")(path, name)
    
    
    class Mathematician:
    
      def GET(self, first_initial, last_name):
        """display mathematician"""
        key = '{0}-{1}'.format(first_initial, last_name)
        try:
            mathematician = db[key] # db.select(...)
        except KeyError:
            raise web.notfound()
        return web.template.Template("""$def with (name)
          <!doctype html>
          <html>
          <head>
            <meta charset=utf-8>
            <title>$name.first $name.last</title>
          </head>
          <body class=vcard>
            <p><a href=/mathematicians rel=up>Mathematicians</a> &#x25B8;</p>
            <h1 class=fn>$name.first $name.last</h1>
          </body>
          </html>""")(mathematician)
    
    
    if __name__ == "__main__":
      if sys.argv[-1] == '--test':
        doctest.testmod()
      else:
        app.run()
---
layout: default
title: Run-time language switch
---

# Run-time language switch

## Problem:
How to implement run-time language switch?

## Solution:

 * You must read [i18n support in template file](i18n_support_in_template_file) first, and then try below code.

File: code.py

    import os
    import sys
    import gettext
    import web
    
    # File location directory.
    rootdir = os.path.abspath(os.path.dirname(__file__))
    
    # i18n directory.
    localedir = rootdir + '/i18n'
    
    # Object used to store all translations.
    allTranslations = web.storage()
    
    def get_translations(lang='en_US'):
        # Init translation.
        if allTranslations.has_key(lang):
            translation = allTranslations[lang]
        elif lang is None:
            translation = gettext.NullTranslations()
        else:
            try:
                translation = gettext.translation(
                        'messages',
                        localedir,
                        languages=[lang],
                        )
            except IOError:
                translation = gettext.NullTranslations()
        return translation
    
    def load_translations(lang):
        """Return the translations for the locale."""
        lang = str(lang)
        translation  = allTranslations.get(lang)
        if translation is None:
            translation = get_translations(lang)
            allTranslations[lang] = translation
    
            # Delete unused translations.
            for lk in allTranslations.keys():
                if lk != lang:
                    del allTranslations[lk]
        return translation
    
    def custom_gettext(string):
        """Translate a given string to the language of the application."""
        translation = load_translations(session.get('lang'))
        if translation is None:
            return unicode(string)
        return translation.ugettext(string)
    
    urls = (
    '/', 'index'
    )
    
    render = web.template.render('templates/',
            globals={
                '_': custom_gettext,
                }
            )
    
    app = web.application(urls, globals())
    
    # Init session.
    session = web.session.Session(app,
            web.session.DiskStore('sessions'),
            initializer={
                'lang': 'en_US',
                }
            )
    
    class index:
        def GET(self):
            i = web.input()
            lang = i.get('lang', 'en_US')

            # Debug.
            print >> sys.stderr, 'Language:', lang

            session['lang'] = lang
            return render.index()
    
    if __name__ == "__main__": app.run()


Template file: templates/index.html.

    $_('Hello')

Don't forget to generate necessary po & mo files which used for translations. Reference: [i18n support in template file](/i18n_support_in_template_file)

Now run code.py in terminal:

    $ python code.py
    http://0.0.0.0:8080/

Now visit below addresses with your favourite web browser, check whether language changed:

    http://your_server:8080/
    http://your_server:8080/?lang=en_US
    http://your_server:8080/?lang=zh_CN

You should:

 * Make sure language code (en_US, zh_CN, etc) will be dynamic changed.
 * Make sure custom_gettext() calling  is as cheap as possible.

Reference:

 * Here is [another solution](http://groups.google.com/group/webpy/browse_thread/thread/a215837aa30e8f80 ) which use app.app_processor().
---
layout: default
title: 实时语言切换
---

# 实时语言切换

## 问题:
如何实现实时语言切换？

## 解法:

 * 首先你必须阅读 [模板语言中的i18n支持](i18n_support_in_template_file.zh-cn), 然后尝试下面的代码。

文件: code.py

    import os
    import sys
    import gettext
    import web
    
    # File location directory.
    rootdir = os.path.abspath(os.path.dirname(__file__))
    
    # i18n directory.
    localedir = rootdir + '/i18n'
    
    # Object used to store all translations.
    allTranslations = web.storage()
    
    def get_translations(lang='en_US'):
        # Init translation.
        if allTranslations.has_key(lang):
            translation = allTranslations[lang]
        elif lang is None:
            translation = gettext.NullTranslations()
        else:
            try:
                translation = gettext.translation(
                        'messages',
                        localedir,
                        languages=[lang],
                        )
            except IOError:
                translation = gettext.NullTranslations()
        return translation
    
    def load_translations(lang):
        """Return the translations for the locale."""
        lang = str(lang)
        translation  = allTranslations.get(lang)
        if translation is None:
            translation = get_translations(lang)
            allTranslations[lang] = translation
    
            # Delete unused translations.
            for lk in allTranslations.keys():
                if lk != lang:
                    del allTranslations[lk]
        return translation
    
    def custom_gettext(string):
        """Translate a given string to the language of the application."""
        translation = load_translations(session.get('lang'))
        if translation is None:
            return unicode(string)
        return translation.ugettext(string)
    
    urls = (
    '/', 'index'
    )
    
    render = web.template.render('templates/',
            globals={
                '_': custom_gettext,
                }
            )
    
    app = web.application(urls, globals())
    
    # Init session.
    session = web.session.Session(app,
            web.session.DiskStore('sessions'),
            initializer={
                'lang': 'en_US',
                }
            )
    
    class index:
        def GET(self):
            i = web.input()
            lang = i.get('lang', 'en_US')

            # Debug.
            print >> sys.stderr, 'Language:', lang

            session['lang'] = lang
            return render.index()
    
    if __name__ == "__main__": app.run()


模板文件: templates/index.html.

    $_('Hello')

不要忘记生成必要的po&mo语言文件。参考: [模板语言中的i18n支持](i18n_support_in_template_file.zh-cn)

现在运行code.py:

    $ python code.py
    http://0.0.0.0:8080/

然后用你喜欢的浏览器访问下面的地址，检查语言是否改变:

    http://your_server:8080/
    http://your_server:8080/?lang=en_US
    http://your_server:8080/?lang=zh_CN

你必须:

 * 确保语言文件(en_US、zh_CN等)可以动态改变。
 * 确保custom_gettext()调用越省资源约好。

参考:

 * 这里有使用app.app_processor()的 [另一个方案](http://groups.google.com/group/webpy/browse_thread/thread/a215837aa30e8f80 )。
---
layout: default
title: db.select
---

# db.select

##Problem:

You want to select data from a database

##Solution: 

With version 0.3, databases are defined like this:

    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')

Once the database is defined as such, performing selects can be performed like this:
    
    # Select all entries from table 'mytable'
    entries = db.select('mytable')

The select statement takes the following keyword arguments:

* vars
* what
* where
* order
* group
* limit
* offset
* _test

###vars
The vars variable is used to populate the rest of the statements.  For example:

    myvar = dict(name="Bob")
    results = db.select('mytable', myvar, where="name = $name")

###what
The what variable defaults to *, but can take a list of items you want selected if the entire entry isn't desired.

    results = db.select('mytable', what="id,name")

###where
The where variable lets you pass where clauses to the SQL select, such as:

    results = db.select('mytable', where="id>100")

###order
The order variable lets the order be specified.  For instance:

    results = db.select('mytable', order="post_date DESC")

###group
Grouping lets you combine things that are common.

    results = db.select('mytable', group="color")    

###limit
Limits set how many results are returned. 
 
    results = db.select('mytable', limit=10) 

###offset
Offsets start returning results after a certain point; they're often used with limits to do something like show 10 entries per page, and then see the next 10.   

    results = db.select('mytable', offset=10) 

###_test
The _test variable lets you see the SQL produced by the statement:

    results = db.select('mytable', offset=10, _test=True) 
    <sql: 'SELECT * FROM mytable OFFSET 10'>
---
layout: default
title: db.select 查询
---

# db.select 查询

##问题:

怎样执行数据库查询？

##解决方案: 

如果是0.3版本, 连接部分大致如下:

    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')

当获取数据库连接后, 可以这样执行查询数据库:
    
    # Select all entries from table 'mytable'
    entries = db.select('mytable')

select方法有下面几个参数:

* vars
* what
* where
* order
* group
* limit
* offset
* _test

###vars
vars变量用来填充查询条件.  如:

    myvar = dict(name="Bob")
    results = db.select('mytable', myvar, where="name = $name")

###what
what是标明需要查询的列名, 默认是*, 但是你可以标明需要查询哪些列.

    results = db.select('mytable', what="id,name")

###where
where查询条件, 如:

    results = db.select('mytable', where="id>100")

###order
排序方式:

    results = db.select('mytable', order="post_date DESC")

###group
按group组排列.

    results = db.select('mytable', group="color")    

###limit
从多行中返回limit查询. 
 
    results = db.select('mytable', limit=10) 

###offset
偏移量, 从第几行开始.   

    results = db.select('mytable', offset=10) 

###_test
查看运行时执行的SQL语句:

    results = db.select('mytable', offset=10, _test=True) 
    <sql: 'SELECT * FROM mytable OFFSET 10'>
---
layout: default
title: Sending mail
---

# Sending mail

### Problem

How to send mails from web.py

### Solution

`web.sendmail` function can be used to send mail from web.py. 

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message')

If any mail server is specified in `web.config` it uses that to send the mail or it uses the traditional sendmail from `/usr/lib/sendmail`. 

    web.config.smtp_server = 'mail.mydomain.com'

To send a mail to multiple recipients, a list can be passed for `to_address`.

    web.sendmail('cookbook@webpy.org', ['user1@example.com', 'user2@example.com'], 'subject', 'message')

Optinal cc and bcc keyword arguments can be passed to `web.sendmail` to add Cc and Bcc recipients.
Values of cc and bcc can be list as well.

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message', cc='user1@example.com', bcc='user2@example.com')

Addition headers can be passed to `web.sendmail` via `headers` tuple.

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message',
            cc='user1@example.com', bcc='user2@example.com',
            headers=({'User-Agent': 'webpy.sendmail', 'X-Mailer': 'webpy.sendmail',})
            )
---
layout: default
title: 发送邮件
---

# 发送邮件

### 问题

在web.py中，如何发送邮件？

### 解法

在web.py中使用`web.sendmail()`发送邮件. 

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message')

如果在`web.config`中指定了邮件服务器，就会使用该服务器发送邮件，否则，就根据`/usr/lib/sendmail`中的设置发送邮件。

    web.config.smtp_server = 'mail.mydomain.com'

如果要发送邮件给多个收件人，就给to_address赋值一个邮箱列表。

    web.sendmail('cookbook@webpy.org', ['user1@example.com', 'user2@example.com'], 'subject', 'message')

`cc`和`bcc`关键字参数是可选的，分别表示抄送和暗送接收人。这两个参数也可以是列表，表示抄送/暗送多人。

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message', cc='user1@example.com', bcc='user2@example.com')

`headers`参数是一个元组，表示附加标头信息(Addition headers)

    web.sendmail('cookbook@webpy.org', 'user@example.com', 'subject', 'message',
            cc='user1@example.com', bcc='user2@example.com',
            headers=({'User-Agent': 'webpy.sendmail', 'X-Mailer': 'webpy.sendmail',})
            )
---
layout: default
title: Envoi de mails en utilisant Gmail
---

# Envoi de mails en utilisant Gmail

Autre langages: [english](/../sendmail_using_gmail) | ...


##Problème: 

Comment envoyer un mail en utilisant Gmail ?

##Solution:

Il est souvent fastidieux de configurer et de maintenir un serveur de messagerie. Si vous possédez un compte Gmail, vous pouvez utiliser Gmail comme serveur SMTP pour envoyer des mails. Pour cela, vous aurez besoin de spécifier le nom d'utilisateur et le mot de passe du compte Gmail dans `web.config`.


    web.config.smtp_server = 'smtp.gmail.com'
    web.config.smtp_port = 587
    web.config.smtp_username = 'cookbook@gmail.com'
    web.config.smtp_password = 'secret'
    web.config.smtp_starttls = True


Une fois la configuration définie, `web.sendmail` peut être employé pour envoyer des mails en utilisant le compte Gmail. Gmail signe tous ces mails.

    web.sendmail('cookbook@gmail.com', 'user@example.com', 'subject', 'message')

Veuillez lire [GMail: Configuring other mail clients][1] pour plus de détails.

[1]: http://mail.google.com/support/bin/answer.py?hl=en&answer=13287
---
layout: default
title: Sending mail using gmail
---

# Sending mail using gmail

Other languages: [français](/../cookbook/sendmail_using_gmail/fr) | ...

##Problem: 

How to send mail using gmail.

##Solution:

Often it is tedious to setup and maintain a mail server. If you have a
gmail accout, you can use gmail as SMTP server to send mail. To do
that we need to specify username and password of gmail account in
`web.config`.

    web.config.smtp_server = 'smtp.gmail.com'
    web.config.smtp_port = 587
    web.config.smtp_username = 'cookbook@gmail.com'
    web.config.smtp_password = 'secret'
    web.config.smtp_starttls = True

Once this configuration is set, `web.sendmail` can be used to send
mail using the gmail account. Gmail signs all these mails.

    web.sendmail('cookbook@gmail.com', 'user@example.com', 'subject', 'message')

Read [GMail: Configuring other mail clients][1] for more details.

[1]: http://mail.google.com/support/bin/answer.py?hl=en&answer=13287
---
layout: default
title: 如何用Gmail发送邮件
---

# 如何用Gmail发送邮件

### 问题 

如何用Gmail发送邮件？

### 解法

安装和维护邮件服务器通常是沉闷乏味的。所以如果你有Gmail帐号，就可以使用Gmail做为SMTP服务器来发送邮件，我们唯一要做的就只是在`web.config`中指定Gmail的用户名和密码。

    web.config.smtp_server = 'smtp.gmail.com'
    web.config.smtp_port = 587
    web.config.smtp_username = 'cookbook@gmail.com'
    web.config.smtp_password = 'secret'
    web.config.smtp_starttls = True

设置好之后，web.sendmail就能使用Gmail帐号来发送邮件了，用起来和其他邮件服务器没有区别。

    web.sendmail('cookbook@gmail.com', 'user@example.com', 'subject', 'message')

可以在这里了解有关Gmail设置的更多信息 [GMail: Configuring other mail clients][1] 

[1]: http://mail.google.com/support/bin/answer.py?hl=en&answer=13287
---
layout: default
title: Travailler avec les sessions
---

# Travailler avec les sessions

Autre langages: [english](/../sessions) | ...

### Problème

Comment utiliser les sessions dans web.py.

### Solution

*Les sessions ne fonctionnent pas en mode [debug](/tutorial3.fr#debug) parce qu'elles interfèrent avec reloading. Veuillez lire [session_with_reloader](/session_with_reloader) pour plus de détail.*

Le module `web.session` fournit un support session. Voici une application simple de compteur utilisant les sessions.

    import web
    web.config.debug = False
    urls = (
        "/count", "count",
        "/reset", "reset"
    )
    app = web.application(urls, locals())
    session = web.session.Session(app, web.session.DiskStore('sessions'), initializer={'count': 0})

    class count:
        def GET(self):
            session.count += 1
            return str(session.count)
            
    class reset:
        def GET(self):
            session.kill()
            return ""

    if __name__ == "__main__":
        app.run()

L'objet session est chargé avec des données session avant le traitement de la requête et sauve des données session après avoir traité la requête, si il est modifié. Notez que dans la version du 22-11-2008 de web.py, il faut désactiver le [débogage](/tutorial3.fr#debug) pour utiliser le serveur de développement avec les sessions.

L'argument optionnel `initializer` de Session spécifie la session initiale.


Vous pouvez utiliser `DBStore` à la place de `DiskStore` si vous préférez stocker les sessions dans une base de donnée au lieu du disque. Pour utiliser DBStore, vous avez besoin d'une table avec la structure suivante:

     create table sessions (
        session_id char(128) UNIQUE NOT NULL,
        atime timestamp NOT NULL default current_timestamp,
        data text
    );

Puis vous devez passer l'objet `db` et le nom de la table de session au constucteur de `DBStore`.

    db = web.database(dbn='postgres', db='mydatabase', user='myname', pw='')
    store = web.session.DBStore(db, 'sessions')
    session = web.session.Session(app, store, initializer={'count': 0})


Des options relatives aux sessions peuvent être modifiées en utilisant le dictionnaire `sessions_parameters` dans `web.config`. Les valeurs par défaut sont montrées ci-dessous:

    web.config.session_parameters['cookie_name'] = 'webpy_session_id'
    web.config.session_parameters['cookie_domain'] = None
    web.config.session_parameters['timeout'] = 86400, #24 * 60 * 60, # 24 heures en secondes
    web.config.session_parameters['ignore_expiry'] = True
    web.config.session_parameters['ignore_change_ip'] = True
    web.config.session_parameters['secret_key'] = 'fLjUfxqXtfNoIldA0A0J'
    web.config.session_parameters['expired_message'] = 'La session expire.'

 * `cookie_name` - nom du cookie utilisé pour stocker la session id
 * `cookie_domain` - domaine du cookie utilisé pour stocker l'ID de session
 * `timeout` - nombre de secondes d'inactivité autorisées avant que la session expire
 * `ignore_expiry` - si `True`, l'expiration de la session est ignoré
 * `ignore_change_ip` - si `False`, la session est valide uniquement quand elle est accessible à partir de la même adresse IP qui l'a créé
 * `secret_key`       - clef utilisée dans la génération du hachage session id (demande d'explications plus détaillées))
 * `expired_message`  - message affiché lorsque la session a expiré
---
layout: default
title: Sessions
---

# Sessions

Other languages: [français](/../cookbook/sessions/fr) | ...

### Problem

How to use sessions in web.py.

### Solution

*sessions doesn't work in [debug](/tutorial3.en#developing) mode because it interfere with reloading. see [session_with_reloader](session_with_reloader) for more details.*

The `web.session` module provides session support. Here is a simple application to count using sessions.

    import web
    web.config.debug = False
    urls = (
        "/count", "count",
        "/reset", "reset"
    )
    app = web.application(urls, locals())
    session = web.session.Session(app, web.session.DiskStore('sessions'), initializer={'count': 0})

    class count:
        def GET(self):
            session.count += 1
            return str(session.count)
            
    class reset:
        def GET(self):
            session.kill()
            return ""

    if __name__ == "__main__":
        app.run()

The session object is loaded with the session data before handling the request and saves the session data after handling the request, if modified. Note in the current (11-22-2008) version of web.py, one must turn off debug to use the development server with sessions.

The optional `initializer` argument to Session specifies the initial session.

You can use `DBStore` instead of `DiskStore` if you prefer to store sessions in database instead of disk. For using DBStore you need to have a table with the following schema.

     create table sessions (
        session_id char(128) UNIQUE NOT NULL,
        atime timestamp NOT NULL default current_timestamp,
        data text
    );

And you need to pass `db` object and session table name to the constructor of `DBStore`.

    db = web.database(dbn='postgres', db='mydatabase', user='myname', pw='')
    store = web.session.DBStore(db, 'sessions')
    session = web.session.Session(app, store, initializer={'count': 0})


Options related to sessions can be modified using the `sessions_parameters` dict in `web.config`. The default values are shown below.

    web.config.session_parameters['cookie_name'] = 'webpy_session_id'
    web.config.session_parameters['cookie_domain'] = None
    web.config.session_parameters['timeout'] = 86400, #24 * 60 * 60, # 24 hours   in seconds
    web.config.session_parameters['ignore_expiry'] = True
    web.config.session_parameters['ignore_change_ip'] = True
    web.config.session_parameters['secret_key'] = 'fLjUfxqXtfNoIldA0A0J'
    web.config.session_parameters['expired_message'] = 'Session expired'

 * `cookie_name` - name of the cookie used to store the session id
 * `cookie_domain` - domain for the cookie used to store the session id
 * `timeout` - number of second of inactivity that is allowed before the session expires
 * `ignore_expiry` - if `True`, the session timeout is ignored
 * `ignore_change_ip` - if `False`, the session is only valid when it is accessed from the same ip address that created the session
 * `secret_key`       - [salt](http://en.wikipedia.org/wiki/Salt_%28cryptography%29) used in session id hash generation
 * `expired_message`  - message displayed when the session expires
---
layout: default
title: Sessions
---

# Sessions

### 问题

如何在web.py中使用session

### 解法

*注意！！！：session并不能在调试模式(Debug mode)下正常工作，这是因为session与调试模试下的重调用相冲突(有点类似firefox下著名的Firebug插件，使用Firebug插件分析网页时，会在火狐浏览器之外单独对该网页发起请求，所以相当于同时访问该网页两次)，下一节中我们会给出在调试模式下使用session的解决办法。*

`web.session`模块提供session支持。下面是一个简单的例子－－统计有多少人正在使用session(session计数器)：

    import web
    web.config.debug = False
    urls = (
        "/count", "count",
        "/reset", "reset"
    )
    app = web.application(urls, locals())
    session = web.session.Session(app, web.session.DiskStore('sessions'), initializer={'count': 0})

    class count:
        def GET(self):
            session.count += 1
            return str(session.count)
            
    class reset:
        def GET(self):
            session.kill()
            return ""

    if __name__ == "__main__":
        app.run()

web.py在处理请求之前，就加载session对象及其数据；在请求处理完之后，会检查session数据是否被改动。如果被改动，就交由session对象保存。

上例中的`initializer`参数决定了session初始化的值，它是个可选参数。

如果用数据库代替磁盘文件来存储session信息，只要用`DBStore`代替`DiskStore`即可。使用DBStore需要建立一个表，结构如下：

     create table sessions (
        session_id char(128) UNIQUE NOT NULL,
        atime timestamp NOT NULL default current_timestamp,
        data text
    );

`DBStore`被创建要传入两个参数：`db`对象和session的表名。

    db = web.database(dbn='postgres', db='mydatabase', user='myname', pw='')
    store = web.session.DBStore(db, 'sessions')
    session = web.session.Session(app, store, initializer={'count': 0})


｀web.config｀中的`sessions_parameters`保存着session的相关设置，`sessions_parameters`本身是一个字典，可以对其修改。默认设置如下：

    web.config.session_parameters['cookie_name'] = 'webpy_session_id'
    web.config.session_parameters['cookie_domain'] = None
    web.config.session_parameters['timeout'] = 86400, #24 * 60 * 60, # 24 hours   in seconds
    web.config.session_parameters['ignore_expiry'] = True
    web.config.session_parameters['ignore_change_ip'] = True
    web.config.session_parameters['secret_key'] = 'fLjUfxqXtfNoIldA0A0J'
    web.config.session_parameters['expired_message'] = 'Session expired'

 * cookie_name - 保存session id的Cookie的名称
 * cookie_domain - 保存session id的Cookie的domain信息
 * timeout - session的有效时间 ，以秒为单位
 * ignore_expiry - 如果为True，session就永不过期
 * ignore_change_ip - 如果为False，就表明只有在访问该session的IP与创建该session的IP完全一致时，session才被允许访问。
 * secret_key       - 密码种子，为session加密提供一个字符串种子
 * expired_message  - session过期时显示的提示信息。

---
layout: default
title: Utiliser les sessions avec les sous-applications
---

# Utiliser les sessions avec les sous-applications

Autre langages: [english](/../sessions_with_subapp) | ...

###Note

*Cette solution est issue de ce [post](http://www.mail-archive.com/webpy@googlegroups.com/msg02557.html) de la mailing liste de web.py.*

##Problème:

Dans le comportement par défaut, les informations de session ne peuvent être partagées qu'au sein de l'application principale, même si vous «importez» la session depuis d'autres modules. Vous devez être en mesure d'accéder aux informations de session depuis une sous-application, mais comment?

##Solution:

Dans votre application principale (code.py par defaut), initialisez votre session de cette façon:

    session = web.session.Session(app, web.session.DiskStore('sessions'),
    initializer = {'test': 'woot', 'foo':''})

.. puis créez un processor via web.loadhook

    def session_hook():
        web.ctx.session = session

    app.add_processor(web.loadhook(session_hook))

.. et maintenant dans votre sous-application (par exemple sub-app.py) vous pouvez accèder aux informations de session de cette manière:

    print web.ctx.session.test
    web.ctx.session.foo = 'bar'
---
layout: default
title: Sessions with Sub-apps
---

# Sessions with Sub-apps

Other languages: [français](/../cookbook/sessions_with_subapp/fr) | ...

###Note
*This solutions is taken from [this](http://www.mail-archive.com/webpy@googlegroups.com/msg02557.html) post on the web.py mailing list.*

##Problem
In its default behavior, session information can only be shared from within the main application, even if you 'import' the session from other modules. You need to be able to access session information from 'sub applications' but how?

##Solution

In your app.py (or main.py) initialize your session like this:

    session = web.session.Session(app, web.session.DiskStore('sessions'),
    initializer = {'test': 'woot', 'foo':''})

.. and create a processor via web.loadhook:

    def session_hook():
        web.ctx.session = session

    app.add_processor(web.loadhook(session_hook))

.. and now in your 'sub-apps' (like sub-app.py) you can access the the session information like this:

    print web.ctx.session.test
    web.ctx.session.foo = 'bar'

.. if you want to make sessions avaible in templates you should change session_hook function like this:

    def session_hook():
        web.ctx.session = session
        web.template.Template.globals['session'] = session

.. and now you can write in template something like this:

    $session.get('logged_in', ''):
        <p>You are $session.username</p>
    $else:
        <p>You are not logged in</p>
---
layout: default
title: 在子应用下使用session
---

# 在子应用下使用session

#提示
这个解决方案是来自web.py邮件列表。[this](http://www.mail-archive.com/webpy@googlegroups.com/msg02557.html)

##问题
如何在子应用中使用session？

##解法

web.py默认session信息只能在主应用中共享，即便在其他模块中import Session都不行。在app.py（或main.py）可以这样初始化session：

    session = web.session.Session(app, web.session.DiskStore('sessions'),
    initializer = {'test': 'woot', 'foo':''})

.. 接下来创建一个被web.loadhook加载的处理器(processor)

    def session_hook():
        web.ctx.session = session

    app.add_processor(web.loadhook(session_hook))

.. 在子应用(假设是sub-app.py)中，可以这样操作session:

    print web.ctx.session.test
    web.ctx.session.foo = 'bar'
---
layout: default
title: Utiliser session dans les gabarits
---

# Utiliser session dans les gabarits

Autre langages: [english](/../session_in_template) | ...


##Problème: 

Vous souhaitez utiliser session dans votre gabarit (par exemple pour obtenir session.username et l'afficher)

##Solution:

Dans le code de votre application:

    render = web.template.render('templates', globals={'context': session})

Dans le gabarit:

    <span>Vous êtes connecté en tant que:  <b>$context.username</b></span>

Vous pouvez littéralement utiliser n'importe quel nom de variables python valides, comme les _context_ utilisés ci-dessus. *I would prefer just use 'session' in real applications.*

[Note traducteur: la dernière phrase n'a pas été comprise]
---
layout: default
title: Using session in template
---

# Using session in template

Other languages: [français](/../cookbook/session_in_template/fr) | ...

##Problem: 

I want to use session in template (e.g. get session.username to display)

##Solution:

In your application code:

    render = web.template.render('templates', globals={'context': session})

In the template:

    <span>You are logged in as <b>$context.username</b></span>

You can literally use any valid python variable names, like the _context_ used above. I would prefer just use 'session' in real applications.
---
layout: default
title: 在template中使用session
---

# 在template中使用session

`问题`: 我想在模板中使用session（比如：读取并显示session.username）

`解决`:

在应用程序中的代码:

    render = web.template.render('templates', globals={'context': session})

在模板中的代码:

    <span>You are logged in as <b>$context.username</b></span>

你可以真正的使用任何符合语法的python变量名，比如上面用的_context_。我更喜欢在应用中直接使用'session'。
---
layout: default
title: Utiliser les sessions avec reloader
---

# Utiliser les sessions avec reloader

Autre langages: [english](/../session_with_reloader) | ...

# Probleme

Il ya quelques problèmes en utilisant les sessions lors de l'exécution de l'application en mode [débogage](/tutorial3.fr#debug). Existe-t-il une  méthode permettant de les contourner?

# Solution

web.py fait tourner le programme en mode débogage lorsqu'il fonctionne en utilisant le serveur intégré.

Un simple correctif pour ceci, est de désactiver le mode debug, ce qui peut être réalisé en déterminant `web.config.debug = False`.

    import web
    web.config.debug = False

    # Le reste de votre code


Si vous voulez utiliser les sessions en mode debug, voici une solution de fortune.

Depuis que le mode de débogage permet le module reloading, le reloader charge le module principal à deux reprises (une fois comme __main__ et une fois avec son nom), deux objets session sont créés. Cela peut être évité en stockant la session dans un emplacement global afin d'éviter la création de la seconde.

Voici un exemple de code qui sauve la session dans «web.config».

    import web
    urls = ("/", "hello")

    app = web.application(urls, globals())

    if web.config.get('_session') is None:
        session = web.session.Session(app, web.session.DiskStore('sessions'), {'count': 0})
        web.config._session = session
    else:
        session = web.config._session

    class hello:
       def GET(self):
           print 'session', session
           session.count += 1
           return 'Hello, %s!' % session.count

    if __name__ == "__main__":
       app.run()
---
layout: default
title: Using session with reloader
---

# Using session with reloader

Other languages: [français](/../cookbook/session_with_reloader/fr) | ...

# Problem

There are some issues in using sessions when running the application in debug mode. Is there any work-around?

# Solution

web.py runs the program in debug mode when run using the builtin webserver.
Simplest fix for this is to disable debug mode, which can be done by setting `web.config.debug = False`.

    import web
    web.config.debug = False

    # rest of your code


If you want to use sessions in debug mode then here is a work-around.

Since debug mode enables module reloading, the reloader loads the main module twice (once as __main__ and once with its name), 2 session objects will be created. This can be avoided by storing the session in some global place to avoid creating the second one. 

Here is a sample code which saves session in `web.config`.

    import web
    urls = ("/", "hello")

    app = web.application(urls, globals())

    if web.config.get('_session') is None:
        session = web.session.Session(app, web.session.DiskStore('sessions'), {'count': 0})
        web.config._session = session
    else:
        session = web.config._session

    class hello:
       def GET(self):
           print 'session', session
           session.count += 1
           return 'Hello, %s!' % session.count

    if __name__ == "__main__":
       app.run()
---
layout: default
title: 在调试模式下使用session
---

# 在调试模式下使用session

# 问题

如何在调试模式下使用session?

# 解法

使用web.py自带的webserver提供web服务时，web.py就运行在调试模式下。当然最简单的办法就是禁用调试，只要令`web.config.debug = False`即可。

    import web
    web.config.debug = False

    # rest of your code


如果非要用调试模式下使用session，可以用非主流的一些办法。哈哈

因为调试模式支持模块重载入(重载入，绝非重载。是reload,而非override)，所以reloader会载入主模块两次，因此，就会创建两个session对象。但我们只要把session存储在全局的数据容器中，就能避免二次创建session。

下面这个例子就是把session保存在 `web.config`中：

    import web
    urls = ("/", "hello")

    app = web.application(urls, globals())

    if web.config.get('_session') is None:
        session = web.session.Session(app, web.session.DiskStore('sessions'), {'count': 0})
        web.config._session = session
    else:
        session = web.config._session

    class hello:
       def GET(self):
           print 'session', session
           session.count += 1
           return 'Hello, %s!' % session.count

    if __name__ == "__main__":
       app.run()
---
layout: default
title: sqlalchemy
---

# sqlalchemy

## Problem

How to use sqlalchemy with web.py

## Solution

create a load hook and use sqlalchemy's [scoped session] (http://www.sqlalchemy.org/docs/05/session.html#unitofwork_contextual)


    import string
    import random
    import web

    from sqlalchemy.orm import scoped_session, sessionmaker
    from models import *

    urls = (
        "/", "add",
        "/view", "view"
    )

    def load_sqla(handler):
        web.ctx.orm = scoped_session(sessionmaker(bind=engine))
        try:
            return handler()
        except web.HTTPError:
           web.ctx.orm.commit()
           raise
        except:
            web.ctx.orm.rollback()
            raise
        finally:
            web.ctx.orm.commit()
            # If the above alone doesn't work, uncomment 
            # the following line:
            #web.ctx.orm.expunge_all() 


    app = web.application(urls, locals())
    app.add_processor(load_sqla)


    class add:
        def GET(self):
            web.header('Content-type', 'text/html')
            fname = "".join(random.choice(string.letters) for i in range(4))
            lname = "".join(random.choice(string.letters) for i in range(7))
            u = User(name=fname
                    ,fullname=fname + ' ' + lname
                    ,password =542)
            web.ctx.orm.add(u)
            return "added:" + web.websafe(str(u)) \
                                + "<br/>" \
                                + '<a href="/view">view all</a>'

    class view:
        def GET(self):
            web.header('Content-type', 'text/plain')
            return "\n".join(map(str, web.ctx.orm.query(User).all()))


    if __name__ == "__main__":
        app.run()


###models.py

    from sqlalchemy import create_engine
    from sqlalchemy import Column, Integer, String

    engine = create_engine('sqlite:///mydatabase.db', echo=True)

    from sqlalchemy.ext.declarative import declarative_base

    Base = declarative_base()
    class User(Base):
        __tablename__ = 'users'

        id = Column(Integer, primary_key=True)
        name = Column(String)
        fullname = Column(String)
        password = Column(String)

        def __init__(self, name, fullname, password):
            self.name = name
            self.fullname = fullname
            self.password = password

        def __repr__(self):
           return "<User('%s','%s', '%s')>" % (self.name, self.fullname, self.password)


    users_table = User.__table__
    metadata = Base.metadata


    if __name__ == "__main__":
        metadata.create_all(engine)



before running the application. run `python models.py` to setup the sqlite database.
---
layout: default
title: sqlalchemy
---

# sqlalchemy

## 问题

如何在web.py中使用sqlalchemy

## 方案

创建一个钩子并使用sqlalchemy的scoped session
(http://www.sqlalchemy.org/docs/05/session.html#unitofwork_contextual)


    import string
    import random
    import web

    from sqlalchemy.orm import scoped_session, sessionmaker
    from models import *

    urls = (
        "/", "add",
        "/view", "view"
    )

    def load_sqla(handler):
        web.ctx.orm = scoped_session(sessionmaker(bind=engine))
        try:
            return handler()
        except web.HTTPError:
           web.ctx.orm.commit()
           raise
        except:
            web.ctx.orm.rollback()
            raise
        finally:
            web.ctx.orm.commit()


    app = web.application(urls, locals())
    app.add_processor(load_sqla)


    class add:
        def GET(self):
            web.header('Content-type', 'text/html')
            fname = "".join(random.choice(string.letters) for i in range(4))
            lname = "".join(random.choice(string.letters) for i in range(7))
            u = User(name=fname
                    ,fullname=fname + ' ' + lname
                    ,password =542)
            web.ctx.orm.add(u)
            return "added:" + web.websafe(str(u)) \
                                + "<br/>" \
                                + '<a href="/view">view all</a>'

    class view:
        def GET(self):
            web.header('Content-type', 'text/plain')
            return "\n".join(map(str, web.ctx.orm.query(User).all()))


    if __name__ == "__main__":
        app.run()


###models.py

    from sqlalchemy import create_engine
    from sqlalchemy import Column, Integer, String

    engine = create_engine('sqlite:///mydatabase.db', echo=True)

    from sqlalchemy.ext.declarative import declarative_base

    Base = declarative_base()
    class User(Base):
        __tablename__ = 'users'

        id = Column(Integer, primary_key=True)
        name = Column(String)
        fullname = Column(String)
        password = Column(String)

        def __init__(self, name, fullname, password):
            self.name = name
            self.fullname = fullname
            self.password = password

        def __repr__(self):
           return "<User('%s','%s', '%s')>" % (self.name, self.fullname, self.password)


    users_table = User.__table__
    metadata = Base.metadata


    if __name__ == "__main__":
        metadata.create_all(engine)


在跑程序之前,运行'python models.py'来初始化一次数据库.
---
layout: default
title: Integrating SQLite UDF (user-defined-functions) with webpy database layer
---

# Integrating SQLite UDF (user-defined-functions) with webpy database layer

A user asked at the mailing list and I thought of putting it here for future use and reference. 

You can add python functions to sqlite and have them called within your queries.

Example:
<pre>
>>> import sqlite3 as db
>>> conn = db.connect(":memory:")
>>> conn.create_function("sign", 1, lambda val: val and (val > 0 and 1 or -1))
>>> cur = conn.cursor()
>>> cur.execute("select 1, -1")
&lt;sqlite3.Cursor object at 0xb759f2c0&gt;
>>> print cur.fetchall()
[(1, -1)]
>>> cur.execute("select sign(1), sign(-1), sign(0), sign(-99), sign(99)")
&lt;sqlite3.Cursor object at 0xb759f2c0&gt;
>>> print cur.fetchall()
[(1, -1, 0, -1, 1)]
>>> conn.close()</pre>

In webpy, you can get a reference to the connection object via the cursor
i.e. db._db_cursor().connection

Example:
<pre>
>>> import web
>>> db = web.database(dbn="sqlite", db=":memory:")
>>> db._db_cursor().connection.create_function("sign", 1, lambda val: val and (val > 0 and 1 or -1))
>>> print db.query("select sign(1), sign(-1), sign(0), sign(-99), sign(99)").list()
[&lt;Storage {'sign(1)': 1, 'sign(-1)': -1, 'sign(99)': 1, 'sign(-99)': -1, 'sign(0)': 0}&gt;]
</pre>
---
layout: default
title: 整合 SQLite UDF (用户定义函数) 到 webpy 数据库层
---

# 整合 SQLite UDF (用户定义函数) 到 webpy 数据库层

问题：

用户在邮件列表中询问，我把它放在这里作为将来使用和参考。

解决：

您可以添加到Python函数到SQLite，并让它们在您的查询调用。

示例：

<pre>
>>> import sqlite3 as db
>>> conn = db.connect(":memory:")
>>> conn.create_function("sign", 1, lambda val: val and (val > 0 and 1 or -1))
>>> cur = conn.cursor()
>>> cur.execute("select 1, -1")
&lt;sqlite3.Cursor object at 0xb759f2c0&gt;
>>> print cur.fetchall()
[(1, -1)]
>>> cur.execute("select sign(1), sign(-1), sign(0), sign(-99), sign(99)")
&lt;sqlite3.Cursor object at 0xb759f2c0&gt;
>>> print cur.fetchall()
[(1, -1, 0, -1, 1)]
>>> conn.close()</pre>

在webpy中，你可以通过游标如db._db_cursor().connection 取得连接对象的引用。

示例：
<pre>
>>> import web
>>> db = web.database(dbn="sqlite", db=":memory:")
>>> db._db_cursor().connection.create_function("sign", 1, lambda val: val and (val > 0 and 1 or -1))
>>> print db.query("select sign(1), sign(-1), sign(0), sign(-99), sign(99)").list()
[&lt;Storage {'sign(1)': 1, 'sign(-1)': -1, 'sign(99)': 1, 'sign(-99)': -1, 'sign(0)': 0}&gt;]
</pre>
---
layout: default
title: Configurer le support SSL dans le serveur intégré
---

# Configurer le support SSL dans le serveur intégré

Autre langages: [english](/../ssl) | ...

## Probleme

Comment configurer le support SSL dans le serveur intégré de web.py, cherrypy. [Note traducteur: A préciser]

## Solution

    import web
    
    from web.wsgiserver import CherryPyWSGIServer

    CherryPyWSGIServer.ssl_certificate = "path/to/ssl_certificate"
    CherryPyWSGIServer.ssl_private_key = "path/to/ssl_private_key"

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()
---
layout: default
title: SSL support in built-in cherrypy server
---

# SSL support in built-in cherrypy server

Other languages: [français](/../cookbook/ssl/fr) | ...

## Problem

How to set SSL support in built-in cherrypy server web.py

## Solution (Requires latest web.py version [0.37 installed from source as of this writing])
    import web
    from web.wsgiserver import CherryPyWSGIServer
    
    CherryPyWSGIServer.ssl_certificate = "/path/to/ssl_certificate"
    CherryPyWSGIServer.ssl_private_key = "/path/to/ssl_private_key"
       
    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()

## For version 0.36 and earlier (somewhat broken implementation, will crash on SSLException)

    import web
    from web.wsgiserver import CherryPyWSGIServer
    from web.wsgiserver.ssl_builtin import BuiltinSSLAdapter
    
    ssl_cert = "path/to/ssl_certificate"
    ssl_key = "path/to/ssl_private_key"
    
    CherryPyWSGIServer.ssl_adapter = BuiltinSSLAdapter(ssl_cert,ssl_key,None)


    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()
---
layout: default
title: 用cherrypy提供SSL支持
---

# 用cherrypy提供SSL支持

## 问题

如何用内置的cheerypy提供SSL支持？

## 解法

    import web
    
    from web.wsgiserver import CherryPyWSGIServer

    CherryPyWSGIServer.ssl_certificate = "path/to/ssl_certificate"
    CherryPyWSGIServer.ssl_private_key = "path/to/ssl_private_key"

    urls = ("/.*", "hello")
    app = web.application(urls, globals())

    class hello:
        def GET(self):
            return 'Hello, world!'

    if __name__ == "__main__":
        app.run()
---
layout: default
title: Servir des fichiers statiques (tels que .js, .css et des images)
---

# Servir des fichiers statiques (tels que .js, .css et des images)

Autre langages : [english](/../staticfiles) | ...

Probleme
-------
Comment servir des fichiers statiques ?

Solution
--------

### Serveur web.py

Créez un répertoire (ou dossier) que vous nommerez <code>static</code> au même endroit ou se situe le script qui fait tourner web.py (par defaut code.py). Puis plaçez les fichiers statiques que vous servirez dans le repertoire "static".

Par exemple, l'url <code>http://localhost/static/logo.png</code> enverra l'image <code>./static/logo.png</code> au client.

### Apache

Pour servir des fichiers statiques une directive [Alias](http://httpd.apache.org/docs/2.2/mod/mod_alias.html#alias) peut être utilisée pour mapper la requête d'url vers un répertoire choisi, avant qu'il soit traité par web.py.

Voici un exemple d'Hôte Virtuel configuré sur un système de type Unix avec une Directive Alias en vigueur:

    <VirtualHost *:80>
        ServerName example.com:80
        DocumentRoot /doc/root/
        # Monte votre application si mod_wsgi est utilisé
        WSGIScriptAlias / /script/root/code.py
        # La Directive Alias
        Alias /static /doc/root/static
        
        <Directory />
            Order Allow,Deny
            Allow From All
            Options -Indexes
        </Directory>
        
	# Parce que l'Alias peut être utilisé pour référencer les ressources en dehors de docroot,
	# vous devez référencer le repertoire avec un chemin absolu.
        <Directory /doc/root/static>
            # les directives ont pour effet le répertoire statique
            Options +Indexes
        </Directory>
    </VirtualHost>
---
layout: default
title: 静的ファイルの配置について (Javascript、CSS、画像など)
---

# 静的ファイルの配置について (Javascript、CSS、画像など)

### 問題点
web.pyのサーバーに静的ファイルを配置したいのですが？

### 解決手段

web.pyサーバを実行するスクリプトファイル(チュートリアルでは <code>code.py</code> を指す)のディレクトリに、新しく静的ファイル用のディレクトリ <code>static</code> を作成してください。
次に、作成したディレクトリに静的ファイル <code>logo.png</code> を配置してください。

たとえば、画像のURLが <code>http://localhost:8080/static/logo.png</code> ならば <code>./static/logo.png</code> がクライアントに送られます。
---
layout: default
title: Serving Static Files (such as js, css and images)
---

# Serving Static Files (such as js, css and images)

Other languages : [français](/staticfiles/fr) | ...

Problem
-------
How to serve static files?

Solution
--------

### web.py server

Create a directory (also known as a folder) called <code>static</code> in the location of the script that runs the web.py server. Then place the static files you wish to serve in the static folder.

For example, the URL <code>http://localhost/static/logo.png</code> will send the image <code>./static/logo.png</code> to the client.

### Apache

To serve static files with Apache an [Alias](http://httpd.apache.org/docs/2.2/mod/mod_alias.html#alias) directive can be used to map the request for a URL to a chosen directory, before it is handled by web.py.

Here is an example Virtual Host configured on a Unix like system with an Alias directive in effect:

    <VirtualHost *:80>
        ServerName example.com:80
        DocumentRoot /doc/root/
        # mounts your application if mod_wsgi is being used
        WSGIScriptAlias / /script/root/code.py
        # the Alias directive
        Alias /static /doc/root/static
        
        <Directory />
            Order Allow,Deny
            Allow From All
            Options -Indexes
        </Directory>
        
        # because Alias can be used to reference resources outside docroot, you
        # must reference the directory with an absolute path
        <Directory /doc/root/static>
            # directives to effect the static directory
            Options +Indexes
        </Directory>
    </VirtualHost>
---
layout: default
title: 提供静态文件 (诸如js脚本, css样式表和图象文件)
---

# 提供静态文件 (诸如js脚本, css样式表和图象文件)

## 问题
如何在web.py自带的web server中提供静态文件访问？

## 解法

### web.py 服务器
在当前应用的目录下，创建一个名为static的目录，把要提供访问的静态文件放在里面即可。

例如, 网址 <code>http://localhost/static/logo.png</code> 将发送 <code>./static/logo.png</code> 给客户端。

### Apache
在 Apache 中可以使用 [Alias](http://httpd.apache.org/docs/2.2/mod/mod_alias.html#alias) 指令，在处理 web.py 之前将请求映射到指定的目录。

这是一个在 Unix like 系统上虚拟主机配置的例子：

    <VirtualHost *:80>
        ServerName example.com:80
        DocumentRoot /doc/root/
        # mounts your application if mod_wsgi is being used
        WSGIScriptAlias / /script/root/code.py
        # the Alias directive
        Alias /static /doc/root/static
        
        <Directory />
            Order Allow,Deny
            Allow From All
            Options -Indexes
        </Directory>
        
        # because Alias can be used to reference resources outside docroot, you
        # must reference the directory with an absolute path
        <Directory /doc/root/static>
            # directives to effect the static directory
            Options +Indexes
        </Directory>
    </VirtualHost>

---
layout: default
title: test
---

# test

test
---
layout: default
title: Store an uploaded file
---

# Store an uploaded file

Other languages: [français](/../cookbook/storeupload/fr) | ...

## Problem

You want to upload a file and store it in a predefined folder.

## Solution

    import web
    
    urls = ('/upload', 'Upload')
    
    class Upload:
        def GET(self):
            web.header("Content-Type","text/html; charset=utf-8")
            return """<html><head></head><body>
    <form method="POST" enctype="multipart/form-data" action="">
    <input type="file" name="myfile" />
    <br/>
    <input type="submit" />
    </form>
    </body></html>"""
    
        def POST(self):
            x = web.input(myfile={})
            filedir = '/path/where/you/want/to/save' # change this to the directory you want to store the file in.
            if 'myfile' in x: # to check if the file-object is created
                filepath=x.myfile.filename.replace('\\','/') # replaces the windows-style slashes with linux ones.
                filename=filepath.split('/')[-1] # splits the and chooses the last part (the filename with extension)
                fout = open(filedir +'/'+ filename,'w') # creates the file where the uploaded file should be stored
                fout.write(x.myfile.file.read()) # writes the uploaded file to the newly created file.
                fout.close() # closes the file, upload complete.
            raise web.seeother('/upload')


    if __name__ == "__main__":
       app = web.application(urls, globals()) 
       app.run()

## Hang ups

A couple of things to watch out for:

* See [fileupload](fileupload).
* Don't put the file in a folder that is executable without any check of the extension and type of file.
* Actually, we need to open the fout file object in mode "wb"(in windows), ie. write binary mode, otherwise the image uploaded is broken.
---
layout: default
title: Stocker un fichier uploadé
---

# Stocker un fichier uploadé

Autre langages: [english](/../storeupload) | ...

## Problème

Vous voulez uploader un fichier et le stocker dans un dossier prédéfini.

## Solution

    import web
    
    urls = ('/upload', 'Upload')
    
    class Upload:
        def GET(self):
            web.header("Content-Type","text/html; charset=utf-8")
            return """<html><head></head><body>
    <form method="POST" enctype="multipart/form-data" action="">
    <input type="file" name="myfile" />
    <br/>
    <input type="submit" />
    </form>
    </body></html>"""
    
        def POST(self):
            x = web.input(myfile={})
            filedir = '/path/where/you/want/to/save' # modifiez ceci pour le répertoire dans lequel vous voulez stocker le fichier.
            if 'myfile' in x: # pour vérifier si le l'objet fichier est créé.
                filepath=x.myfile.filename.replace('\\','/') # Remplace les "slashs" de type windows par ceux de linux.
                filename=filepath.split('/')[-1] # scinde et choisit la dernière partie (le nom du fichier avec l'extension)
                fout = open(filedir +'/'+ filename,'w') # crée le fichier où le fichier téléchargé doit être stocké
                fout.write(x.myfile.file.read()) # écrit le fichier téléchargé vers le fichier nouvellement créé.
                fout.close() # clôt le fichier, upload terminé.
            raise web.seeother('/upload')


    if __name__ == "__main__":
       app = web.application(urls, globals()) 
       app.run()

## A savoir

Deux petites choses à surveiller:

* Voir [Uploader un fichier](/../fileupload/fr).
* Ne pas mettre le fichier dans un dossier qui est exécutable sans vérification de l'extension et du type de fichier.
* En fait, nous avons besoin d'ouvrir l'objet fichier 'fout' en mode "wb" (sous Windows) *mode d'écriture binaire, sinon l'image uploadée est cassée.*
---
layout: default
title: 保存上传的文件
---

# 保存上传的文件

## 问题

上传文件，并将其保存到预先设定的某个目录下。

## 方法

    import web
    
    urls = ('/upload', 'Upload')
    
    class Upload:
        def GET(self):
            web.header("Content-Type","text/html; charset=utf-8")
            return """<html><head></head><body>
    <form method="POST" enctype="multipart/form-data" action="">
    <input type="file" name="myfile" />
    <br/>
    <input type="submit" />
    </form>
    </body></html>"""
    
        def POST(self):
            x = web.input(myfile={})
            filedir = '/path/where/you/want/to/save' # change this to the directory you want to store the file in.
            if 'myfile' in x: # to check if the file-object is created
                filepath=x.myfile.filename.replace('\\','/') # replaces the windows-style slashes with linux ones.
                filename=filepath.split('/')[-1] # splits the and chooses the last part (the filename with extension)
                fout = open(filedir +'/'+ filename,'w') # creates the file where the uploaded file should be stored
                fout.write(x.myfile.file.read()) # writes the uploaded file to the newly created file.
                fout.close() # closes the file, upload complete.
            raise web.seeother('/upload')


    if __name__ == "__main__":
       app = web.application(urls, globals()) 
       app.run()

## Hang ups

同时还需要注意如下几点:

* 转到 [fileupload](/fileupload)。
* 千万不要让用户把文件上传到那些不经过文件后缀和类型检查而执行文件的文件夹下。
* 事实上，一定要以"mb"模式打开文件（在windows下）， 也就是二进制可写模式, 否则图片将无法上传。
---
layout: default
title: Comment streamer de gros fichiers
---

# Comment streamer de gros fichiers

Autre langages: [english](/../streaming_large_files) | ...

## Problème:

Vous souhaitez utiliser web.py pour streamer de gros fichiers.

## Solution:

Voici un exemple qui vous permettra d'utiliser web.py pour streamer de larges fichiers. Vous verrez qu'il fonctionne comme annoncé, mais vous devez vous assurer que vous avez ajouté 'chunked' dans l'en-tête Transfer-Encoding pour qu'il s'affiche correctement. Sinon, le navigateur va mettre en cache toutes les données avant de vous les afficher.


Vous ne pouvez pas mélanger une chaîne de base et les retours [ Yield](http://fr.wikipedia.org/wiki/Yield_(instruction)) dans la même méthode. Si vous utilisez [ Yield](http://fr.wikipedia.org/wiki/Yield_(instruction)), vous devrez utiliser [ Yield](http://fr.wikipedia.org/wiki/Yield_(instruction)) pour tout, parce que votre fonction devient un générateur.

##Simple exemple

    # Simple démonstration d'un serveur de streaming 
    # Il utilise time.sleep la lecture d'un gros fichier
    import web
    import time
     
    urls = (
        "/",    "count_holder",
        "/(.*)",  "count_down",
        )
    app = web.application(urls, globals())
     

    class count_down:
        def GET(self,count):
            # Ces en-têtes le font fonctionner dans les navigateurs
            web.header('Content-type','text/html')
            web.header('Transfer-Encoding','chunked')        
            yield '<h2>Prepare for Launch!</h2>'
            j = '<li>Liftoff in %s...</li>'
            yield '<ul>'
            count = int(count)
            for i in range(count,0,-1):
                out = j % i
                time.sleep(1)
                yield out
            yield '</ul>'
            time.sleep(1)
            yield '<h1>Lift off</h1>'
            
    class count_holder:
        def GET(self):
            web.header('Content-type','text/html')
            web.header('Transfer-Encoding','chunked')        
            boxes = 4
            delay = 3
            countdown = 10
            for i in range(boxes):
                output = '<iframe src="/%d" width="200" height="500"></iframe>' % (countdown - i)
                yield output
                time.sleep(delay)
            
    if __name__ == "__main__":
        app.run()
---
layout: default
title: How to Stream Large Files
---

# How to Stream Large Files

Other languages: [français](/../cookbook/streaming_large_files/fr) | ...

## Problem:

You want to use web.py to stream large files.

##Solution:

This is an example of how you can use web.py to stream large files.  You'll find it DOES work as advertised, but you need to make sure you add the Transfer-Encoding chunked header for it to display properly.  Otherwise the browser will buffer all data before displaying it to you.

You can't mix basic string and Yield returns in the same method.  If you use Yield, you'll have to use yield for everything because your function becomes a generator.


##Simple Example:

    # Simple streaming server demonstration
    # Uses time.sleep to emulate a large file read
    import web
    import time
     
    urls = (
        "/",    "count_holder",
        "/(.*)",  "count_down",
        )
    app = web.application(urls, globals())
     

    class count_down:
        def GET(self,count):
            # These headers make it work in browsers
            web.header('Content-type','text/html')
            web.header('Transfer-Encoding','chunked')        
            yield '<h2>Prepare for Launch!</h2>'
            j = '<li>Liftoff in %s...</li>'
            yield '<ul>'
            count = int(count)
            for i in range(count,0,-1):
                out = j % i
                time.sleep(1)
                yield out
            yield '</ul>'
            time.sleep(1)
            yield '<h1>Lift off</h1>'
            
    class count_holder:
        def GET(self):
            web.header('Content-type','text/html')
            web.header('Transfer-Encoding','chunked')        
            boxes = 4
            delay = 3
            countdown = 10
            for i in range(boxes):
                output = '<iframe src="/%d" width="200" height="500"></iframe>' % (countdown - i)
                yield output
                time.sleep(delay)
            
    if __name__ == "__main__":
        app.run()
---
layout: default
title: 如何流传输大文件
---

# 如何流传输大文件

### 问题

如何流传输大文件？

### 解法

要流传输大文件，需要添加传输译码(Transfer-Encoding)区块头，这样才能一边下载一边显示。否则，浏览器将缓冲所有数据直到下载完毕才显示。

如果这样写：直接修改基础字符串(例中就是j)，然后用Yield返回－－是没有效果的。如果要使用Yield,就要向对所有内容使用yield。因为这个函式此时是一个产生器。(注：请处请详看Yield文档，在此不做过多论述。)


例子

    # Simple streaming server demonstration
    # Uses time.sleep to emulate a large file read
    import web
    import time
     
    urls = (
        "/",    "count_holder",
        "/(.*)",  "count_down",
        )
    app = web.application(urls, globals())
     

    class count_down:
        def GET(self,count):
            # These headers make it work in browsers
            web.header('Content-type','text/html')
            web.header('Transfer-Encoding','chunked')        
            yield '<h2>Prepare for Launch!</h2>'
            j = '<li>Liftoff in %s...</li>'
            yield '<ul>'
            count = int(count)
            for i in range(count,0,-1):
                out = j % i
                time.sleep(1)
                yield out
            yield '</ul>'
            time.sleep(1)
            yield '<h1>Lift off</h1>'
            
    class count_holder:
        def GET(self):
            web.header('Content-type','text/html')
            web.header('Transfer-Encoding','chunked')        
            boxes = 4
            delay = 3
            countdown = 10
            for i in range(boxes):
                output = '<iframe src="/%d" width="200" height="500"></iframe>' % (countdown - i)
                yield output
                time.sleep(delay)
            
    if __name__ == "__main__":
        app.run()
---
layout: default
title: Utiliser les sous-applications
---

# Utiliser les sous-applications

Autre langages: [english](/../subapp) | ...

## Probleme

Comment inclure une application définie dans un autre fichier dans votre application principale ?

## Solution

Dans `blog.py`:

    import web
    urls = (
      "", "reblog",
      "/(.*)", "blog"
    )

    class reblog:
        def GET(self): raise web.seeother('/')

    class blog:
        def GET(self, path):
            return "blog " + path

    app_blog = web.application(urls, locals())

Dans votre application principale `code.py`:

    import web
    import blog
    urls = (
      "/blog", blog.app_blog,
      "/(.*)", "index"
    )
    
    class index:
        def GET(self, path):
            return "hello " + path
    
    app = web.application(urls, locals())

    if __name__ == "__main__":
        app.run()
---
layout: default
title: サブアプリケーションの使い方について(別ファイルのインクルード)
---

# サブアプリケーションの使い方について(別ファイルのインクルード)

## 問題点

別ファイルのWebアプリケーション(ここではblog.py)をインクルードするにはどうすればいいですか？


## 解決手段

In `blog.py`:

    urls = (
      "", "reblog,
      "/(.*)", "blog"
    )

    class reblog:
        def GET(self): raise web.seeother('/')

    class blog:
        def GET(self, path):
            return "blog " + path

    app_blog = web.application(urls, locals())

メインファイル `code.py`:

    import blog
    urls = (
      "/blog", blog.app_blog,
      "/(.*)", "index"
    )
    
    class index:
        def GET(self, path):
            return "hello " + path
    
    app = web.application(urls, locals())
---
layout: default
title: using subapplications
---

# using subapplications

Other languages [français](/../cookbook/subapp/fr) | ...

## Problem

How do you include an application defined in another file in your application?

## Solution

In `blog.py`:

    import web
    urls = (
      "", "reblog",
      "/(.*)", "blog"
    )

    class reblog:
        def GET(self): raise web.seeother('/')

    class blog:
        def GET(self, path):
            return "blog " + path

    app_blog = web.application(urls, locals())

In your main `code.py`:

    import web
    import blog
    urls = (
      "/blog", blog.app_blog,
      "/(.*)", "index"
    )
    
    class index:
        def GET(self, path):
            return "hello " + path
    
    app = web.application(urls, locals())

    if __name__ == "__main__":
        app.run()
---
layout: default
title: 使用子应用
---

# 使用子应用

## 问题

如何在当前应用中包含定义在其他文件中的某个应用？

## 解法

在`blog.py`中:

    import web
    urls = (
      "", "reblog",
      "/(.*)", "blog"
    )

    class reblog:
        def GET(self): raise web.seeother('/')

    class blog:
        def GET(self, path):
            return "blog " + path

    app_blog = web.application(urls, locals())

当前的主应用`code.py`:

    import web
    import blog
    urls = (
      "/blog", blog.app_blog,
      "/(.*)", "index"
    )
    
    class index:
        def GET(self, path):
            return "hello " + path
    
    app = web.application(urls, locals())

    if __name__ == "__main__":
        app.run()
---
layout: default
title: How to use templates on Google App Engine
---

# How to use templates on Google App Engine

## Problem

How to use templates on Google App Engine

## Solution

web.py templetor compiles the templates to python source, which requires accessing parser module of python standard library. Unfortunately that module is blocked in GAE for security reasons. 

To overcome that situation, web.py supports compiling the templates to python code so that the compiled sources can be used on GAE instead of the original templates. web.py makes sure that no code changes are required to use templates in this way.

To compile all templates in a template dir (has to be redone each time a template has changed):

    $ python web/template.py --compile templates

This compiles all templates in templates/ dir recursively and creates `__init__.py` with all the templates in that dir. On GAE, `web.template.render` is re-written to treat `templates/` as python module. 


---
layout: default
title: How to use templates on Google App Engine
---

# How to use templates on Google App Engine

## 问题

如何在 Google App Engine 上使用模板

## 解答

web.py templetor 把模板编译成 python 字节码，这需要访问标准库中的 parser 模块。不幸的是，由于安全原因 GAE 禁用了这个模块。
 
为了克服这个状况，web.py 支持把模板编译成 python 代码，从而避免在 GAE 上使用原来的模板。web.py 确保在应用这种方法的时候模板中的代码不需要任何改变。

为了编译一个文件夹中所有的模板（一旦有模板改动，就需要重新运行），运行：

    $ python web/template.py --compile templates

以上命令把 templates/ 目录下的模板文件递归地全部编译，并且生产 `__init__.py`， 'web.template.render` 重新编写过，它将视 templates 为一个 python 模块。
---
layout: default
title: Cheetahテンプレートエンジンの使用について
---

# Cheetahテンプレートエンジンの使用について

### 問題点
webpyでCheetahテンプレートエンジンを使用するにはどうすればいいですか？

### 解決手段

まず、[Cheetah](http://www.cheetahtemplate.org/) と webpy(0.3)をインストールする必要があります。その後以下のコードを実行してみてください。

    # encoding: utf-8
    # ファイル: code.py

    import web
    from web.contrib.template import render_cheetah

    render = render_cheetah('templates/')

    urls = (
        '/(first)', 'first',
        '/(second)', 'second'
        )

    app = web.application(urls, globals(), web.reloader)

    class first:
        def GET(self, name):
            # cheetah template takes only keyword arguments,
            # you should call it as:
            #   return render.hello(name=name)
            # Below is incorrect:
            #   return render.hello(name)
            return render.first(name=name)

    class second:
        def GET(self, name):
            return render.first(**locals())

    if __name__ == "__main__":
        app.run()

テンプレートファイル:

    ## ファイル: templates/first.html

    hello, $name.
---
layout: default
title: Use Cheetah template engine in webpy
---

# Use Cheetah template engine in webpy

### Problem
How to use Cheetah template engine in webpy?

### Solution

You need to install both Cheetah and webpy(0.3) first: [http://www.cheetahtemplate.org/](http://www.cheetahtemplate.org/). And then try out the following code snippet:

    # encoding: utf-8
    # File: code.py

    import web
    from web.contrib.template import render_cheetah

    render = render_cheetah('templates/')

    urls = (
        '/(first)', 'first',
        '/(second)', 'second'
        )

    app = web.application(urls, globals(), web.reloader)

    class first:
        def GET(self, name):
            # cheetah template takes only keyword arguments,
            # you should call it as:
            #   return render.hello(name=name)
            # Below is incorrect:
            #   return render.hello(name)
            return render.first(name=name)

    class second:
        def GET(self, name):
            return render.first(**locals())

    if __name__ == "__main__":
        app.run()

Template file:

    ## File: templates/first.html

    hello, $name.
---
layout: default
title: 在webpy中使用Cheetah模板引擎
---

# 在webpy中使用Cheetah模板引擎

### 问题：
怎样在webpy中使用Cheetah模板引擎？

### 解决：

您需要先安装webpy(0.3)和Cheetah：[http://www.cheetahtemplate.org/](http://www.cheetahtemplate.org/). 然后尝试使用下面的代码段：

    # encoding: utf-8
    # File: code.py

    import web
    from web.contrib.template import render_cheetah

    render = render_cheetah('templates/')

    urls = (
        '/(first)', 'first',
        '/(second)', 'second'
        )

    app = web.application(urls, globals(), web.reloader)

    class first:
        def GET(self, name):
            # cheetah template takes only keyword arguments,
            # you should call it as:
            #   return render.hello(name=name)
            # Below is incorrect:
            #   return render.hello(name)
            return render.first(name=name)

    class second:
        def GET(self, name):
            return render.first(**locals())

    if __name__ == "__main__":
        app.run()

模板文件

    ## File: templates/first.html

    hello, $name.
---
layout: default
title: Import functions into templates
---

# Import functions into templates

`Problem`: How can I import a python module in template?

`Solution`:

While you write templates, inevitably you will need to write some functions which is related to display logic only.  web.py gives you the flexibility to write large blocks of code, including defining functions, directly in the template using `$code` blocks (if you don't know what is $code block, please read the [tutorial for Templator](/docs/0.3/templetor) first).  For example, the following code block will translate a status code from database to a human readable status message:

    def status(c):
        st = {}
        st[0] = 'Not Started'
        st[1] = 'In Progress'
        st[2] = 'Finished'
        return st[c]

As you do more web.py development, you will write more such functions here and there in your templates. This makes the template messy and is a violation of the DRY (Don't Repeat Yourself) principle.

Naturally, you will want to write a module, say _displayLogic.py_ and import that module into every templates that needs such functionalities.  Unfortunately, `import` is disabled in template for security reason.  However, it is easy to solve this problem, you can import any function via the global namespace into the template:

    #in your application.py:
    def status(c):
        st = {}
        st[0] = 'Not Started'
        st[1] = 'In Progress'
        st[2] = 'Finished'
        return st[c]

    render = web.template.render('templates', globals={'stat':status})

    #in the template:
    $def with(status)
    ... ...
    <div>Status: $stat(status)</div>

Remember that you can import more than one name into the _globals_ dict. This trick is also used in [importing session variable into template](/cookbook/session_in_template).
---
layout: default
title: Import functions into templates
---

# Import functions into templates

`Problem`: How can I import a python module in template?

`Solution`:

While you write templates, inevitably you will need to write some functions which is related to display logic only.  web.py gives you the flexibility to write large blocks of code, including defining functions, directly in the template using `$code` blocks (if you don't know what is $code block, please read the [tutorial for Templator](/docs/0.3/templetor) first).  For example, the following code block will translate a status code from database to a human readable status message:

    def status(c):
        st = {}
        st[0] = 'Not Started'
        st[1] = 'In Progress'
        st[2] = 'Finished'
        return st[c]

As you do more web.py development, you will write more such functions here and there in your templates. This makes the template messy and is a violation of the DRY (Don't Repeat Yourself) principle.

Naturally, you will want to write a module, say _displayLogic.py_ and import that module into every templates that needs such functionalities.  Unfortunately, `import` is disabled in template for security reason.  However, it is easy to solve this problem, you can import any function via the global namespace into the template:

    #in your application.py:
    def status(c):
        st = {}
        st[0] = 'Not Started'
        st[1] = 'In Progress'
        st[2] = 'Finished'
        return st[c]

    render = web.template.render('templates', globals={'stat':status})

    #in the template:
    $def with(status)
    ... ...
    <div>Status: $stat(status)</div>

Remember that you can import more than one name into the _globals_ dict. This trick is also used in [importing session variable into template](session_in_template.zh-cn).
---
layout: default
title: Use Jinja2 template engine in webpy
---

# Use Jinja2 template engine in webpy

### Problem
How to use Jinja2 (http://jinja.pocoo.org/2/) template engine in webpy?

### Solution 1

You need to install both Jinja2 and webpy(0.3) first, and then try out the following code snippet:

    import web
    from web.contrib.template import render_jinja

    urls = (
            '/(.*)', 'hello'
            )
    
    app = web.application(urls, globals())
    
    render = render_jinja(
            'templates',   # Set template directory.
            encoding = 'utf-8',                         # Encoding.
        )

    # Add/override some global functions.
    #render._lookup.globals.update(
    #       var=newvar,
    #       var2=newvar2,
    #)

    class hello:
        def GET(self, name):
            return render.hello(name=name)
    
    if __name__ == "__main__":
        app.run()

### Template file: templates/hello.html

    Hello, {{ name }}.

### Solution 2

With this solution, you have to specify template name, it's useful if template files are organized in different directories.

    import os
    import web
    from jinja2 import Environment,FileSystemLoader
    
    urls = ("/.*", "hello")
    app = web.application(urls, globals())
    
    def render_template(template_name, **context):
        extensions = context.pop('extensions', [])
        globals = context.pop('globals', {})
    
        jinja_env = Environment(
                loader=FileSystemLoader(os.path.join(os.path.dirname(__file__), 'templates')),
                extensions=extensions,
                )
        jinja_env.globals.update(globals)
    
        #jinja_env.update_template_context(context)
        return jinja_env.get_template(template_name).render(context)
    
    class hello:
        def GET(self):
            # You can use a relative path as template name, for example, 'ldap/hello.html'.
            return render_template('hello.html', name='world',)
    
    if __name__ == "__main__":
        app.run()
---
layout: default
title: Use Jinja2 template engine in webpy
---

# Use Jinja2 template engine in webpy

### 问题

如何在web.py中使用Jinja2 (http://jinja.pocoo.org/2/) 模板引擎?

### 方案

首先需要安装Jinja2和webpy(0.3), 然后使用下面的代码做测试:

    import web
    from web.contrib.template import render_jinja

    urls = (
            '/(.*)', 'hello'
            )
    
    app = web.application(urls, globals())
    
    render = render_jinja(
            'templates',   # 设置模板路径.
            encoding = 'utf-8', # 编码.
        )

    #添加或者修改一些全局方法.
    #render._lookup.globals.update(
    #       var=newvar,
    #       var2=newvar2,
    #)

    class hello:
        def GET(self, name):
            return render.hello(name=name)
    
    if __name__ == "__main__":
        app.run()

### 模板文件: templates/hello.html

    Hello, {{ name }}.
---
layout: default
title: makoテンプレートエンジンの使用について
---

# makoテンプレートエンジンの使用について

### 問題点
webpyでMakoテンプレートエンジンを使用するにはどうすればいいですか？

### 解決手段

まず、[Mako](http://www.makotemplates.org/) と webpy(0.3)をインストールする必要があります。その後以下のコードを実行してみてください。

    # encoding: utf-8
    # ファイル code.py

    import web

    from web.contrib.template import render_mako

    urls = (
            '/(.*)', 'hello'
            )

    app = web.application(urls, globals(), autoreload=True)

    # input_encoding and output_encoding is important for unicode
    # template file.
    # Reference:
    # http://www.makotemplates.org/docs/documentation.html#unicode
    render = render_mako(
            directories=['templates'],
            input_encoding='utf-8',
            output_encoding='utf-8',
            )

    class hello:
        def GET(self, name):
            return render.hello(name=name)
            # Another way:
            #return render.hello(**locals())

    if __name__ == "__main__":
        app.run()

テンプレートファイル:

    ## ファイル: templates/hello.html

    您好：${name}

###ノート:

webpyアプリケーションを Apache + mod_wsgi で稼動させた場合、テンプレート(Mako)のエラーは Apacheのエラーログに出力されます。

    [Sat Jun 21 21:56:22 2008] [error] [client 192.168.122.1] TopLevelLookupException: Cant locate template for uri 'index.html'

テンプレートディレクトリが相対パスで指定できないもしくはわからない場合は、絶対パスで指定してください。

アプリケーションの作業ディレクトリについてはこちらを参照してください。

    http://code.google.com/p/modwsgi/wiki/ApplicationIssues

たとえば以下のような書き方で、絶対パスをより簡単にする書くことができます。

    import os

    render = render_mako(
            directories=[os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),],
            input_encoding='utf-8',
            output_encoding='utf-8',
            )
---
layout: default
title: Use Mako template engine in webpy
---

# Use Mako template engine in webpy

### Problem
How to use Mako template engine in webpy?

### Solution

You need to install both Mako and webpy(0.3) first: [http://www.makotemplates.org/](http://www.makotemplates.org) and then try out the following code snippet:

    # encoding: utf-8
    # File: code.py

    import web

    from web.contrib.template import render_mako

    urls = (
            '/(.*)', 'hello'
            )

    app = web.application(urls, globals(), autoreload=True)

    # input_encoding and output_encoding is important for unicode
    # template file. Reference:
    # http://www.makotemplates.org/docs/documentation.html#unicode
    render = render_mako(
            directories=['templates'],
            input_encoding='utf-8',
            output_encoding='utf-8',
            )

    class hello:
        def GET(self, name):
            return render.hello(name=name)
            # Another way:
            #return render.hello(**locals())

    if __name__ == "__main__":
        app.run()

Template file:

    ## File: templates/hello.html

    Hello, ${name}.

###Note:

if you use Apache + mod_wsgi to deploy webpy apps, you may get the similar error msg in your apache error log:

    [Sat Jun 21 21:56:22 2008] [error] [client 192.168.122.1] TopLevelLookupException: Cant locate template for uri 'index.html'

You have to specify location of templates as absolute path as no
guarantees as to what current working directory will be.

You can use relative paths in order to make it easier too. e.g.

    import os

    render = render_mako(
            directories=[os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),],
            input_encoding='utf-8',
            output_encoding='utf-8',
            )


#Reference:
* http://code.google.com/p/modwsgi/wiki/ApplicationIssues

#i18n support in Mako template file:
Please refer to cookbook 'i18n support in webpy template file' for i18n support in mako template file:

* Cookbook: [i18n support in webpy template file](i18n_support_in_template_file )

#Note:
Babel is only needed to generate the .mo files.
---
layout: default
title: 在webpy中使用Mako模板引擎
---

# 在webpy中使用Mako模板引擎

### 问题
如何在webpy中使用Mako模板引擎?
### 解决方案
首先需要安装Mako和web.py(0.3):http://www.makotemplates.org/ 然后尝试下面的代码:
<pre>
# encoding: utf-8
# File: code.py
import web
from web.contrib.template import render_mako
urls = (
        '/(.*)', 'hello'
        )
app = web.application(urls, globals(), autoreload=True)
# input_encoding and output_encoding is important for unicode
# template file. Reference:
# http://www.makotemplates.org/docs/documentation.html#unicode
render = render_mako(
        directories=['templates'],
        input_encoding='utf-8',
        output_encoding='utf-8',
        )

class hello:
    def GET(self, name):
        return render.hello(name=name)
        # Another way:
        #return render.hello(**locals())

if __name__ == "__main__":
    app.run()
</pre>

### 模板文件

<pre>
## File: templates/hello.html

Hello, ${name}.
</pre>

### 注意:
如果你使用Apache+mod_wsgi来部署webpy程序, 你也许会在Apache错误日志中得到下面的错误信息:
[Sat Jun 21 21:56:22 2008] [error] [client 192.168.122.1] TopLevelLookupException: Cant locate template for uri 'index.html'

你必须使用绝对路径指出模板的位置.
你也可以使用相对路径来让它更简单一些:
<pre>
import os

render = render_mako(
        directories=[os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),],
        input_encoding='utf-8',
        output_encoding='utf-8',
        )
</pre>
### 参考:
http://code.google.com/p/modwsgi/wiki/ApplicationIssues
---
layout: default
title: Testing with Paste and Nose
---

# Testing with Paste and Nose

## Problem

You want to test your web.py application.

## Solution

    from paste.fixture import TestApp
    from nose.tools import *
    from code import app

    class TestCode():
        def test_index(self):
            middleware = []
            testApp = TestApp(app.wsgifunc(*middleware))
            r = testApp.get('/')
            assert_equal(r.status, 200)
            r.mustcontain('Hello, world!')

## Background

This example makes use of the Paste and Nose libraries. [Paste](http://pythonpaste.org/) lets you throw test requests at your application, and adds some helpful [custom methods to the response objects](http://pythonpaste.org/webtest/#the-response-object), such as mustcontain(), seen above. [Nose](http://somethingaboutorange.com/mrl/projects/nose/) makes writing and running your tests dead simple. When run from the base of your tree, it automatically finds and runs anything which is named like a test, adding necessary modules to your PYTHONPATH. This gives you the flexibility to run your tests from other directories, as well. Another benefit of Nose is that you no longer need to have every test class inherit from unittest.TestCase. Many more details are outlined on the project page.

## Explanation

This code resides in a file called test_code.py. The directory layout of the application looks like this:

    ./
    code.py
    ./test
        test_code.py        

Most of the code example above should be fairly self-explanatory. From our main module, code, we import app, which is defined in the usual way:

    app = web.application(urls, globals())

To set up the test, we pass its wsgifunc() to Paste's TestApp, as you have already seen in the example.

    testApp = TestApp(app.wsgifunc(*middleware))

assert_equal() is one of the methods provided by nose's utils, and works just like unittest's assertEqual().

## Setting Up the Test Environment

In order to avoid kicking off web.py's webserver when we run our tests, a change is required to the line which calls run(). It normally looks something like this:

    if __name__ == "__main__": app.run()

We can define an environment variable, such as WEBPY_ENV=test, when we run our tests. In that case, the above line becomes the following:

    import os

    def is_test():
        if 'WEBPY_ENV' in os.environ:
            return os.environ['WEBPY_ENV'] == 'test'

    if (not is_test()) and __name__ == "__main__": app.run()

Then, it's simply a matter of running nosetests like so:

    WEBPY_ENV=test nosetests

The is_test() function comes in handy for other things, such as doing conditional database commits to avoid test database pollution.
---
layout: default
title: Testing with Paste and Nose
---

# Testing with Paste and Nose

## Problem

You want to test your web.py application.

## Solution

    from paste.fixture import TestApp
    from nose.tools import *
    from code import app

    class TestCode():
        def test_index(self):
            middleware = []
            app = TestApp(app.wsgifunc(*middleware))
            r = app.get('/')
            assert_equal(r.status, 200)
            r.mustcontain('Hello, world!')

## Background

This example makes use of the Paste and Nose libraries. [Paste](http://pythonpaste.org/) lets you throw test requests at your application, and adds some helpful [custom methods to the response objects](http://pythonpaste.org/webtest/#the-response-object), such as mustcontain(), seen above. [Nose](http://somethingaboutorange.com/mrl/projects/nose/) makes writing and running your tests dead simple. When run from the base of your tree, it automatically finds and runs anything which is named like a test, adding necessary modules to your PYTHONPATH. This gives you the flexibility to run your tests from other directories, as well. Another benefit of Nose is that you no longer need to have every test class inherit from unittest.TestCase. Many more details are outlined on the project page.

## Explanation

This code resides in a file called test_code.py. The directory layout of the application looks like this:

    ./
    code.py
    ./test
        test_code.py        

Most of the code example above should be fairly self-explanatory. From our main module, code, we import app, which is defined in the usual way:

    app = web.application(urls, globals())

To set up the test, we pass its wsgifunc() to Paste's TestApp, as you have already seen in the example.

    app = TestApp(app.wsgifunc(*middleware))

assert_equal() is one of the methods provided by nose's utils, and works just like unittest's assertEqual().

## Setting Up the Test Environment

In order to avoid kicking off web.py's webserver when we run our tests, a change is required to the line which calls run(). It normally looks something like this:

    if __name__ == "__main__": app.run()

We can define an environment variable, such as WEBPY_ENV=test, when we run our tests. In that case, the above line becomes the following:

    import os

    def is_test():
        if 'WEBPY_ENV' in os.environ:
            return os.environ['WEBPY_ENV'] == 'test'

    if (not is_test()) and __name__ == "__main__": app.run()

Then, it's simply a matter of running nosetests like so:

    WEBPY_ENV=test nosetests

The is_test() function comes in handy for other things, such as doing conditional database commits to avoid test database pollution.
---
layout: default
title: How to use database transactions
---

# How to use database transactions

### Problem

How to use database transactions


### Solution

The database object has a method `transaction` which starts a new transaction and returns the transaction object. The transaction object can be used to commit or rollback that transaction.

    import web

    db = web.database(dbn="postgres", db="webpy", user="foo", pw="")
    t = db.transaction()
    try:
        db.insert('person', name='foo')
        db.insert('person', name='bar')
    except:
        t.rollback()
        raise
    else:
        t.commit()

With python 2.5+, transaction can be used as with statement also.  

    from __future__ import with_statement
    
    db = web.databse(dbn="postgres", db="webpy", user="foo", pw="")
     
    with db.transaction():
        db.insert('person', name='foo')
        db.insert('person', name='bar')
        

It is also possible to have nested transactions.

    def post(title, body, tags):
        t = db.transaction()
        try:
            post_id = db.insert('post', title=title, body=body)
            add_tags(post_id, tags)
        except:
            t.rollback()
        else:
            t.commit()

    def add_tags(post_id, tags):
        t = db.transaction()
        try:
            for tag in tags:
                db.insert('tag', post_id=post_id, tag=tag)
        except:
            t.rollback()
        else:
            t.commit()


Nested transactions are ignored for sqlite as they are not supported.
---
layout: default
title: 怎样使用数据库事务处理
---

# 怎样使用数据库事务处理

### 问题：

怎样使用数据库事务处理？

### 解决：

数据库对象有一个方法“transaction”,将启动一个新的事务，并返回事务对象。这个事务对象可以使用commit提交事务或rollback来回滚事务。

    import web

    db = web.database(dbn="postgres", db="webpy", user="foo", pw="")
    t = db.transaction()
    try:
        db.insert('person', name='foo')
        db.insert('person', name='bar')
    except:
        t.rollback()
        raise
    else:
        t.commit()

在python 2.5+以上的版本，事务同样可以在段中使用：

    from __future__ import with_statement
    
    db = web.databse(dbn="postgres", db="webpy", user="foo", pw="")
     
    with db.transaction():
        db.insert('person', name='foo')
        db.insert('person', name='bar')
        
它同样可能有一个嵌套的事务：

    def post(title, body, tags):
        t = db.transaction()
        try:
            post_id = db.insert('post', title=title, body=body)
            add_tags(post_id, tags)
        except:
            t.rollback()
        else:
            t.commit()

    def add_tags(post_id, tags):
        t = db.transaction()
        try:
            for tag in tags:
                db.insert('tag', post_id=post_id, tag=tag)
        except:
            t.rollback()
        else:
            t.commit()

嵌套的事务在sqlite中将被忽略，因为此特性不被sqlite支持。
---
layout: default
title: How to use database transactions
---

# How to use database transactions

### Problem

How to use database transactions


### Solution

The web.DB class has a method `transaction` which returns a transaction object. The transaction object can be used to commit or rollback a transaction.

    import web

    db = web.databse(dbn="postgres", db="webpy", user="foo", pw="")
    t = db.transaction()
    try:
        db.insert('person', name='foo')
        db.insert('person', name='bar')
    except:
        t.rollback()
        raise
    else:
        t.commit()

With python 2.5+, transaction can be used as with statement also.

    db = web.databse(dbn="postgres", db="webpy", user="foo", pw="")
     
    with db.transaction():
        db.insert('person', name='foo')
        db.insert('person', name='bar')
        

It is also possible to have nested transactions.

    def post(title, body, tags):
        t = db.transaction()
        try:
            post_id = db.insert('post', title=title, body=body)
            add_tags(post_id, tags)
        except:
            t.rollback()
        else:
            t.commit()

    def add_tags(post_id, tags):
        t = db.transaction()
        try:
            for tag in tags:
                db.insert('tag', post_id=post_id, tag=tag)
        except:
            t.rollback()
        else:
            t.commit()


Nested transactions are ignored for sqlite as they are not supported.

---
layout: default
title: Exploit sessions stored in a postgresql database.
---

# Exploit sessions stored in a postgresql database.

##Problem:

When using session and storing some ids or any kind of stuff referencing a database, you'll do a lot of queries like this one:
"select foo, bar from foobar_table where id=%s and id_foor=%s" % (session.id, session.id_foo)

That's not a real problem, but if your session is stored in a postgresql database, this is wierd to take these fields in your database to unpack them in web.py and then re-use them in your queries. 

At the other end, this is also weird to take data in your database to bring them in web.py and then repack them in your database.

A cleaner approach would be to access directly these informations in postgresql to read and/or write them.


##Solution:

To apply this recipe, you'll need to use postgresql DBStore for your sessions. 
You'll also need to install the plpythonu in your database.
Web.py installed as a system python library is also needed, session objects are defined in web.utils and pickle asks for these classes to work.

First, take a quick look to postgresql storage of sessions with some obvious code: :

##
    db = web.database(dbn='postgres', db='db_name', user='db_user', pw='db_pw')
    
    store = web.session.DBStore(db, 'sessions')
    
    session = web.session.Session(app, store, initializer={'uid': 0,
                                                  'username': '',
                                                  'current_page': 'index',
                                                  'user_role': 'invited'
                                                  })
##

You'll also need a table to handle this, here's a reminder:

##
    CREATE TABLE sessions
                (
                 session_id CHARACTER(40) PRIMARY KEY,
                 atime TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
                 data TEXT
                );
##

With that, you should be able to have working sessions stored in postgresql.
When a client connects to web.py, sessions are automatically started and stored in the sessions table. A quick look into it will show something like this:

    session_id        |atime                      | data
    8982d61dblabla... |2010-08-04 15:13:34.889288 | KGRwMQpTJ3VzZblablabla...

The session_id is quite obvious to understand, atime is the timestamp of last access and data is a base64 packed version of the pickled session instance.

With a plpythonu function, we are able to unpack these informations and use them. Here's an example of function:

    We need this to make a function return a set of fields instead of a single value, execute once:
    create type read_session_type as (uid integer, current_page varchar(20), user_role varchar(20));

    create function unpack_this_session(session_id varchar(128)) returns read_session_type as
    $$
    import base64, pickle, sys
    sys.argv=[] # pickle needs sys.argv... workaround !
    data = plpy.execute("select data from sessions where session_id='%s'" % (session_id))[0]['data']

    pickled = base64.decodestring(data)
    session_instance = pickle.loads(pickled)

    uid = session_instance['uid']
    current_page = session_instance['current_page']
    user_role = session_instance['user_role']

    return (uid, current_page, user_role)
    $$
    language plpythonu;


This function should be as simple as this to use:

    select * from unpack_this_session('8982d61db185462b983242beb7009ad12a716aef')

now, if you didn't already managed to understand what that mean:

    "select * from unpack_this_session('%s') ss \
      inner join users u on u.id=ss.uid \
      inner join user_rules ur on ur.role = ss.user_role" % (session.id)

You also can imagine modifying session information and repack it within a python function, taking informations directly in the database and making them accessible in web.py session object without any code in your web.py classes.

Exciting, isn't it ?

Technically, as it uses the primary key indexes to match the session_id, seeking data should not be a problem, but postgresql won't be able to use indexes with unpacked data as it comes from a procedure. 

But, we can easily consider using general functions which unpack every session at once, making all of them readable in a view. The temptation is huge, but this is overkill because you shouldn't have to use every sessions data for one client handling only one session, and, more important, this would be an awful CPU and Memory killer. Don't do it ! 

If you think of doing a lot of these operations, consider using triggers to unpack these fields when they're updated or inserted, this is quite better for database performance, opening the window to indexes and foreign keys... 
Can you imagine the simplicity, and performance, you gain with a session instance raising a database exception when you try to set a value in your sessions that violates a database foreign key, with a synchronous and transactional behavior, and no more SQL to verify them ?

This function is quite obvious, to demonstrate how to access session data, but it doesn't handle any kind of exceptions. So, don't use it as this for production matters, it needs enlightenment to be as stable and functionnal as needed ;)

I didn't managed to test this procedure with exact keywords, so If you encounter problems, feel free to mention it !
---
layout: default
title: db.update
---

# db.update

### Problem

You want to update data that's been entered into a database.

### Solution

    import web
    
    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')
    db.update('mytable', where="id = 10", value1 = "foo")

See the [select](/cookbook/select) for more information on arguments that are accepted by update.


The update method returns the number of rows updated.
---
layout: default
title: db.upate 数据更新
---

# db.upate 数据更新

### 问题

向数据库中更新数据。

### 解决方案

    import web
    
    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')
    db.update('mytable', where="id = 10", value1 = "foo")

在 [查询](/cookbook/select/zh-cn) 中有更多关于可用参数的信息。


该更新操作会返回更新的影响行数。
---
layout: default
title: Comprendre la gestion des urls
---

# Comprendre la gestion des urls

Autres langages [english](/../url_handling) | ...

##Probleme: Comment conçevoir un gestionnaire d'url / distribuer un schéma pour l'ensemble du site


##Solution:

Le schéma de traitement des urls de web.py est simple, mais puissant et flexible. Au sommet de chaque application, vous trouverez habituellement le schéma complet de distribution des urls défini comme un tuple:


    urls = (
        "/tasks/?", "signin",
        "/tasks/list", "listing",
        "/tasks/post", "post",
        "/tasks/chgpass", "chgpass",
        "/tasks/act", "actions",
        "/tasks/logout", "logout",
        "/tasks/signup", "signup"
    )


Le format de ce tuple est: _motif du chemin url_, _gestionnaire de classe_ ce modèle se répètera tant que des motifs de chemins urls sont définis. Si vous ne comprenez pas la relation entre les motifs des chemins urls et les gestionnaire de classe, veuillez lire l'exemple [Hello World](/../helloworld/fr) ou le [rapide tutorial](/tutorial3.fr) avant de lire d'autres astuces cookbook.

## Correspondance des chemins


Vous pouvez utiliser la puissance des expressions régulières pour conçevoir des modèles urls plus flexibles. Par exemple,
/(test1|test2) capturera soit /test1, soit /test2. Le point clef à comprendre est que ce filtrage se déroule sur le 'chemin' même de l'url. Par exemple, pour l'url suivante:

    http://localhost/myapp/greetings/hello?name=Joe


Le chemin de cette URL est _/myapp/greetings/hello_. web.py ajoutera en interne ^ et $ à la structure de l'url, ce qui fait que le motif _/task/_ ne filtrera pas _/tasks/addnew_. Tandis qu'il filtre le chemin, vous ne pouvez pas utiliser un motif de type: _/tasks/delete?name=(.+)_ alors que la partie après ? appelée 'requête' n'est pas filtrée. Pour une description détaillée des éléments d'URL, veuillez lire [web.ctx](/cookbook/ctx).


##Capture de paramètres

Dans un motif url vous pouvez capturer des paramètres qui peuvent être utilisés dans votre gestionnaire de classe:

    /users/list/(.+), "list_users"

Les blocs après _list/_  sont capturés et peuvent être utilisés comme paramètres dans GET et POST:

    class list_users:
        def GET(self, name):
            return "Liste des infos conçernant l'utilisateur: {0}".format(name)

Vous pouvez définir plusieurs paramètres si vous le souhaitez. Notez simplement, que les paramètres de requête URL (qui apparaissent après le ?) peuvent être obtenues à l'aide de [web.input()](/cookbook/input)

##Note sur les sous_applications

Afin de mieux traiter de grandes applications Web, web.py encourage l'utilisation des [sous-applications](/cookbook/subapp/fr). Tout en concevant des mécanismes d'URL avec des sous-applications, gardez à l'esprit que le chemin (web.ctx.path) trouvera un  chemin parent dépouillé. 
Par exemple, si dans l'application principale, vous transmettez un format d'url "/blog" à la sous-application 'blog', dans votre sous-application blog, tous les formats d'url commençeront avec "/", et non avec /blog. Lisez les astuces cookbook [web.ctx](/cookbook/ctx) pour plus de détails.
---
layout: default
title: Understanding URL Handling
---

# Understanding URL Handling

Other languages : [français](/../cookbook/url_handling/fr) | ...

`Problem`: how to design a url handling / dispatching scheme for the entire site

`Solution`:

web.py's URL handling scheme is simple yet powerful and flexible.  at the top of each application, you usually see the full URL dispatching scheme defined as a tuple:

    urls = (
        "/tasks/?", "signin",
        "/tasks/list", "listing",
        "/tasks/post", "post",
        "/tasks/chgpass", "chgpass",
        "/tasks/act", "actions",
        "/tasks/logout", "logout",
        "/tasks/signup", "signup"
    )

The format of this tuple is: _url-path-pattern_, _handler-class_ this pattern will repeat as more url patterns are defined.  If you don't understand the relationship between url pattern and handler classes, please read the [Hello World example](/cookbook/helloworld) or [Quick Start Tutorial](/tutorial3.en) before reading any other cookbook recipes.

`Path Matching`

You can utilize the power of regular expressions to design more flexible url patterns. For example, /(test1|test2) will catch either /test1 or /test2.  The key point to understand is that this matching happens on the `path` of your URL. For example, the following URL:

    http://localhost/myapp/greetings/hello?name=Joe

The path of this URL is _/myapp/greetings/hello_.  web.py will internally add ^ and $ to the url pattern so that the pattern _/tasks/_ will not match _/tasks/addnew_.  As it matches against the path, you can not use a pattern like: _/tasks/delete?name=(.+)_ as the part after ? is called `query` and is not matched against.  For a detailed description of URL components, please read [web.ctx](/cookbook/ctx).

`Capture Parameters`

In the url pattern you can catch parameters which can be used in your handler class:

    "/users/list/(.+)", "list_users"

The chunk after _list/_ are captured and can be used as a parameter in GET or POST:

    class list_users:
        def GET(self, name):
            return "Listing info about user: {0}".format(name)

You can define more than one parameters as you wish.  Also note that URL query parameters (which appears after the ?) can be obtained using [web.input()](/cookbook/input)

`Note on sub-applications`

To better handle larger web applications, web.py support [sub-applications](/cookbook/subapp).  While designing url scheme with sub applications, keep in mind that the path (web.ctx.path) will get the parent path stripped off. e.g. if in the main application, you define to forward url pattern "/blog" to the 'blog' sub-application, in your blog sub-application all url patterns starts with "/", `not` /blog.  Read the [web.ctx](/cookbook/ctx) cookbook recipe for more details.
---
layout: default
title: 理解URL控制
---

# 理解URL控制

`问题`: 如何为整个网站设计一个URL控制方案 / 调度模式

`解决`:

web.py的URL控制模式是简单的、强大的、灵活的。在每个应用的最顶部，你通常会看到整个URL调度模式被定义在元组中:

    urls = (
        "/tasks/?", "signin",
        "/tasks/list", "listing",
        "/tasks/post", "post",
        "/tasks/chgpass", "chgpass",
        "/tasks/act", "actions",
        "/tasks/logout", "logout",
        "/tasks/signup", "signup"
    )

这些元组的格式是: _URL路径_, _处理类_ 这组定义有多少可以定义多少。如果你并不知道URL路径和处理类之间的关系，请在阅读cookbook之前先阅读[Hello World example](/helloworld)，或者[快速入门](/tutorial3.zh-cn)。

`路径匹配`

你可以利用强大的正则表达式去设计更灵活的URL路径。比如 /(test1|test2) 可以捕捉 /test1 或 /test2。要理解这里的关键，匹配是依据URL路径的。比如下面的URL:

    http://localhost/myapp/greetings/hello?name=Joe

这个URL的路径是 _/myapp/greetings/hello_。web.py会在内部给URL路径加上^ 和$ ，这样 _/tasks/_ 不会匹配 _/tasks/addnew_。URL匹配依赖于“路径”，所以不能这样使用，如： _/tasks/delete?name=(.+)_ ,?之后部分表示是“查询”，并不会被匹配。阅读URL组件的更多细节，请访问[web.ctx](ctx.zh-cn)。

`捕捉参数`

你可以捕捉URL的参数，然后用在处理类中:

    /users/list/(.+), "list_users"

在 _list/_后面的这块会被捕捉，然后作为参数被用在GET或POST:

    class list_users:
        def GET(self, name):
            return "Listing info about user: {0}".format(name)

你可以根据需要定义更多参数。同时要注意URL查询的参数(?后面的内容)也可以用[web.input()](input.zh-cn)取得。

`开发子程序的时候注意`

为了更好的控制大型web应用，web.py支持[子程序](subapp.zh-cn)。在为子程序设计URL模式的时候，记住取到的路径(web.ctx.path)是父应用剥离后的。比如，你在主程序定义了URL"/blog"跳转到'blog'子程序，那没在你blog子程序中所有URL都是以"/"开头的，而不是"/blog"。查看[web.ctx](ctx.zh-cn)取得更多信息。

---
layout: default
title: Authentification des utilisateurs
---

# Authentification des utilisateurs

Autres langages : [english](/../userauth) | ...



##Problème

Vous souhaitez mettre en place un système pour authentifier les utilisateurs.


##Solution

Un système d'authentification des utilisateurs est constitué de plusieurs éléments. L'ajout d'utilisateurs, la connexion des utilisateurs, leurs déconnexion, et vérifier s'ils sont déjà enregistrés. Cela nécessite aussi une base de données. Dans cet exemple nous allons utiliser MD5 et SQLite.

##
    import hashlib
    import web    

    def POST(self):
        i = web.input()

        authdb = sqlite3.connect('users.db')
        pwdhash = hashlib.md5(i.password).hexdigest()
        check = authdb.execute('select * from users where username=? and password=?', (i.username, pwdhash))
        if check: 
            session.loggedin = True
            session.username = i.username
            raise web.seeother('/results')   
        else: return render.base("Ces données de connexion ne fonctionnent pas.")   

##Notes

N'utilisez pas ce code sur un site réel. Il n'est là que pour illustrer.
---
layout: default
title: user authentication
---

# user authentication

#I'm still working on this page, please no body else edit

Other languages : [français](/userauth/fr) | ...

##Problem
You want a system to authenticate users.

##Solution
A user authentication system is made up of a few parts. Adding users, logging users in, logging users out and checking if users are logged in. It also requires a database. For this example we'll be using MD5 and SQLite.

##
    import hashlib
    import web    

    def POST(self):
        i = web.input()

        authdb = sqlite3.connect('users.db')
        pwdhash = hashlib.md5(i.password).hexdigest()
        check = authdb.execute('select * from users where username=? and password=?', (i.username, pwdhash))
        if check: 
            session.loggedin = True
            session.username = i.username
            raise web.seeother('/results')   
        else: return render.base("Those login details don't work.")   

##Notes
Do not use this code on real site - this is only for illustration.
---
layout: default
title: 用户认证
---

# 用户认证

#原作者没有写完，但是可以参照下一节，写得很详细

##问题
如何完成一个用户认证系统？

##解法
用户认证系统由这几个部分组成：用户添加，用户登录，用户注销以及验证用户是否已登录。用户认证系统一般都需要一个数据库。在这个例子中，我们要用到MD5和SQLite。

##
    import hashlib
    import web    

    def POST(self):
        i = web.input()

        authdb = sqlite3.connect('users.db')
        pwdhash = hashlib.md5(i.password).hexdigest()
        check = authdb.execute('select * from users where username=? and password=?', (i.username, pwdhash))
        if check: 
            session.loggedin = True
            session.username = i.username
            raise web.seeother('/results')   
        else: return render.base("Those login details don't work.")   

##注意
这仅仅是个例子，可不要在真实的生产环境中应用哦。
---
layout: default
title: Basic authentication
---

# Basic authentication

##Problem
This is a proof of concept implementation of doing basic authentication
with web.py.
You may want to read [RFC 2617](http://www.ietf.org/rfc/rfc2617.txt) or
[http://en.wikipedia.org/wiki/Basic_access_authentication](http://en.wikipedia.org/wiki/Basic_access_authentication) for reference.

##Solution
Create a python file containing the code below and start the script.
When you enter the url [http://localhost:8080/](http://localhost:8080/) you will be redirected
to the url [http://localhost:8080/login](http://localhost:8080/login).
When you are successfully authenticated, you will be redirected to the
index page.

##
    import web
    import re
    import base64
    
    urls = (
        '/','Index',
        '/login','Login'
    )
    
    app = web.application(urls,globals())
    
    allowed = (
        ('jon','pass1'),
        ('tom','pass2')
    )
    
    
    class Index:
        def GET(self):
            if web.ctx.env.get('HTTP_AUTHORIZATION') is not None:
                return 'This is the index page'
            else:
                raise web.seeother('/login')
    
    class Login:
        def GET(self):
            auth = web.ctx.env.get('HTTP_AUTHORIZATION')
            authreq = False
            if auth is None:
                authreq = True
            else:
                auth = re.sub('^Basic ','',auth)
                username,password = base64.decodestring(auth).split(':')
                if (username,password) in allowed:
                    raise web.seeother('/')
                else:
                    authreq = True
            if authreq:
                web.header('WWW-Authenticate','Basic realm="Auth example"')
                web.ctx.status = '401 Unauthorized'
                return
    
    if __name__=='__main__':
        app.run()
  
##Notes
Do not use this code on real site - this is only for illustration.
---
layout: default
title: User Authentication with PostgreSQL database
---

# User Authentication with PostgreSQL database

##Problem
- You want a system to authenticate users, with a postgresql database.

##Solution
- A user authentication system could have a lot of functions. For this example, we're only going to manage the authentication process, through a postgresql database.

##Needed
- web.py for all the web functions, and hashlib to store the passwords securely:

	import web
	import hashlib

## 1st: The database
First of all, we need a table for the users. This scheme is very simple, but is enough for a lot of projects.

##
	CREATE TABLE example_users
	(
	  id serial NOT NULL,
	  user character varying(80) NOT NULL,
	  pass character(40) NOT NULL,
	  email character varying(100) NOT NULL,
	  privilege integer NOT NULL DEFAULT 0,
	  CONSTRAINT utilisateur_pkey PRIMARY KEY (id)
	)

## 2nd: the urls
There will be 2 states during the login/logout session:

- "Login" is for the login page

- "Reset" for the logout page.

*sessions doesn't work in [debug](/tutorial3.en#developing) mode because it interfere with reloading. see [session_with_reloader](session_with_reloader) for more details.*

##
	web.config.debug = False
	
	urls = (
	  '/login', 'Login',
	  '/reset', 'Reset',
	)
	app = web.application(urls, locals())
	db = web.database(dbn='postgres', db='YOURDB', user='USERNAME', pw='PASSWORD')
	
	store = web.session.DiskStore('sessions')
	session = web.session.Session(app, store,
	                              initializer={'login': 0, 'privilege': 0})


## 3rd: Logged or not logged ?
To manage the access for people who are logged or not is very easy. Just define the logged expression like this, and use it for your login/reset classes:

##
	def logged():
		if session.login==1:
			return True
		else:
			return False

## 4th: Easy Privleges Management
I manage my users in 4 categories: admin+user+reader (logged), and visitors (not logged). The directory template is choosing according to the privilege specified in the table example_users.

##
	def create_render(privilege):
	    if logged():
	        if privilege == 0:
	            render = web.template.render('templates/reader')
	        elif privilege == 1:
	            render = web.template.render('templates/user')
	        elif privilege == 2:
	            render = web.template.render('templates/admin')
	        else:
	            render = web.template.render('templates/communs')
	    else:
	        render = web.template.render('templates/communs')
	    return render

	
## 5th: Login and Reset Python Classes
Now, let's have fun:
- If you are already logged, you are redirecting to the login_double.html template file
- Else, to the login.html.

##
	class Login:
	
	    def GET(self):
	        if logged():
	            render = create_render(session.privilege)
	            return '%s' % render.login_double()
	        else:
	            render = create_render(session.privilege)
	            return '%s' % render.login()

- Ok, ok. Now, for the POST(). According to the .html file, we recover the variables posted in the form (see the login.html), and we compare it to the example_users.user row.
- For security, we don't store passwords in the database directly, but store the hash of the password + salt; this is kind of line one-way encryption, so we can tell if the user's passwords match, but an attacker couldn't figure out what the password was to start with.
- If the login/pass is ok, redirect to the login_ok.html.
- If not, redirect to the login_error.html.

##	
	    def POST(self):
	        name, passwd = web.input().name, web.input().passwd
	        ident = db.select('example_users', where='name=$name', vars=locals())[0]
	        try:
	            if hashlib.sha1("sAlT754-"+passwd).hexdigest() == ident['pass']:
	                session.login = 1
	                session.privilege = ident['privilege']
	                render = create_render(session.privilege)
	                return render.login_ok()
	            else:
	                session.login = 0
	                session.privilege = 0
	                render = create_render(session.privilege)
	                return render.login_error()
	        except:
	            session.login = 0
	            session.privilege = 0
	            render = create_render(session.privilege)
	            return render.login_error()


For the reset function, we just kill the session, and redirect to the logout.html template file.
##
	class Reset:
	
	    def GET(self):
	        session.login = 0
	        session.kill()
	        render = create_render(session.privilege)
	        return render.logout()


## 6th: HTML templates help
Well, I think that nobody will need this, but, I prefer to give all the informations. The most important is the login.html.

##
	<form action="/login" method="POST">
		<table id="login">
			<tr>
				<td>User: </td>
				<td><input type="text" name="user"></td>
			</tr>
			<tr>
				<td>Password: </td>
				<td><input type="password" name="passwd"></td>
			</tr>
			<tr>
				<td></td>
				<td><input type="submit" value="LOGIN"></td>
			</tr>
		</table>
	</form>

## 7th: Some problems or questions ?
- Mail: you can contact me at guillaume(at)process-evolution(dot)fr
- IRC: #webpy on irc.freenode.net (pseudo: Ephedrax)
- Translations: I'm french, and my english is bad...you can edit my work
- Revision: Vayn <vayn at vayn dot de>
---
layout: default
title: 在PostgreSQL下实现用户认证
---

# 在PostgreSQL下实现用户认证

##问题
- 如何利用PostgreSQL数据库实现一个用户认证系统？

##解法
- 用户认证系统有很多功能。在这个例子中，将展示如何在PostgreSQL数据库环境下一步一步完成一个用户认证系统

##必需
- 因为要用到make模板和postgreSQL数据库，所以要:
	import web
	from web.contrib.template import render_mako
	import pg

## 第一步：创建数据库
首先，为创建一个用户表。虽然这个表结构非常简单，但对于大部分项目来说都足够用了。

##
	CREATE TABLE example_users
	(
	  id serial NOT NULL,
	  user character varying(80) NOT NULL,
	  pass character varying(80) NOT NULL,
	  email character varying(100) NOT NULL,
	  privilege integer NOT NULL DEFAULT 0,
	  CONSTRAINT utilisateur_pkey PRIMARY KEY (id)
	)

## 第二步：确定网址
登录和注销对应两个网址：

- "Login" 对应登录页

- "Reset" 对应注销页

##
	urls = (
	 	'/login', 'login',
		'/reset', 'reset',
		 )



## 第三步：判断用户是否登录
要判断用户是否已登录，是非常简单的，只要有个变量记录用户登录的状态即可。在login/reset类中使用这段代码:

##
	def logged():
		if session.login==1:
			return True
		else:
			return False

## 第四步：简单的权限管理
我把我的用户划为四类：管理员，用户，读者（已登录），访客（未登录）。根据example_users表中定义的不同权限，选择不同的模板路径。

##
	def create_render(privilege):
		if logged():
			if privilege==0:
				render = render_mako(
					directories=['templates/reader'],
					input_encoding='utf-8',
					output_encoding='utf-8',
					)
			elif privilege==1:
				render = render_mako(
					directories=['templates/user'],
					input_encoding='utf-8',
					output_encoding='utf-8',
					)
			elif privilege==2:
				render = render_mako(
					directories=['templates/admin'],
					input_encoding='utf-8',
					output_encoding='utf-8',
					)
		else:
			render = render_mako(
				directories=['templates/communs'],
				input_encoding='utf-8',
				output_encoding='utf-8',
				)
		return render
	
## 第五：登录(Login)和注销(Reset)的python类
现在，让我们用个轻松的方法来解决：
- 如果你已登录，就直接重定向到login_double.html模板文件
- 否则，还是到login.html。

##
	class login:
		def GET(self):
			if logged():
				render = create_render(session.privilege)
				return "%s" % (
					render.login_double()				)
			else:
				render = create_render(session.privilege)
				return "%s" % (
					render.login()
					)

- 好了。现在写POST()方法。从.html文件中，我们得到表单提交的变量值(见login.html)，并根据变量值得到example_users表中对应的user数据
- 如果登录通过了，就重定向到login_ok.html。
- 如果没通过，就重定向到login_error.html。

##	
		def POST(self):
			user, passwd = web.input().user, web.input().passwd
			ident = db.query("select * from example_users where user = '%s'" % (user)).getresult()
			try:
				if passwd==ident[0][2]:
					session.login=1
					session.privilege=ident[0][4]
					render = create_render(session.privilege)
					return "%s" % (
							render.login_ok()
							)
				else:
					session.login=0
					session.privilege=0
					render = create_render(session.privilege)
					return "%s" % (
						render.login_error()
						)
			except:
				session.login=0
				session.privilege=0
				render = create_render(session.privilege)
				return "%s" % (
					render.login_error()
					)

对于reset方法，只要清除用户session，再重定向到logout.html模板页即可。
##
	class reset:
		def GET(self):
			session.login=0
			session.kill()
			render = create_render(session.privilege)
			return "%s" % (
				render.logout()
			 	)

## 6th: 第六步：HTML模板帮助
嗯，我认为没有人想看这个，但我喜欢把所有的信息都提供出来。最重要的就是login.html。

##
	<FORM action=/login method=POST>
		<table id="login">
			<tr>
				<td>User: </td>
				<td><input type=text name='user'></td>
			</tr>
			<tr>
				<td>Password: </td>
				<td><input type="password" name=passwd></td>
			</tr>
			<tr>
				<td></td>
				<td><input type=submit value=LOGIN></td>
			</tr>
		</table>
	</form>

## 第七：问题或疑问？
- 邮件：您可以联想我，我的邮箱是guillaume(at)process-evolution(dot)fr
- IRC：#webpy on irc.freenode.net (pseudo: Ephedrax) 
- 翻译：我是法国人，我的英文不好...你可以修改我的文档(译注：哈哈，谦虚啥，你那是没见过wrongway的山东英文...)
---
layout: default
title: Webservice + WSDL
---

# Webservice + WSDL

Optio's  [soaplib](http://trac.optio.webfactional.com/) makes it really straightforward to write SOAP web service views by using a decorator to specify types. Plus it's the only Python library, as of today, which is able to generate WSDL documents for your web service. 



    import web 
    from soaplib.wsgi_soap import SimpleWSGISoapApp
    from soaplib.service import soapmethod
    from soaplib.serializers import primitive as soap_types

    urls = ("/hello", "HelloService",
            "/hello.wsdl", "HelloService",
            )
    render = web.template.Template("$def with (var)\n$:var")


    
    class SoapService(SimpleWSGISoapApp):
        """Class for webservice """

        #__tns__ = 'http://test.com'
    
        @soapmethod(soap_types.String,_returns=soap_types.String)
        def hello(self,message):
            """ Method for webservice"""
            return "Hello world "+message
     


    class HelloService(SoapService):
        """Class for web.py """
        def start_response(self,status, headers):
            web.ctx.status = status
            for header, value in headers:
                web.header(header, value)
    
    
        def GET(self):
            response = super(SimpleWSGISoapApp, self).__call__(web.ctx.environ, self.start_response)
            return render("\n".join(response))
    
    
        def POST(self):
            response = super(SimpleWSGISoapApp, self).__call__(web.ctx.environ, self.start_response)
            return render("\n".join(response))
     
    app=web.application(urls, globals())
    
    if __name__ == "__main__":
        app.run()




You can test it with a soaplib client: 

    >>> from soaplib.client import make_service_client
    >>> from test import HelloService
    >>> client = make_service_client('http://localhost:8080/hello', HelloService())
    >>> client.hello('John')
    'Hello world John'

And you can view the WSDL in [http://localhost:8080/hello.wsdl](http://localhost:8080/hello.wsdl)

For more information of webservice see: [soaplib](http://trac.optio.webfactional.com/),
---
layout: default
title: 用soaplib实现webservice
---

# 用soaplib实现webservice

### 问题

如何用soaplib实现webservice?

### 解法
Optio的[soaplib](http://trac.optio.webfactional.com/)通过用装饰器指定类型，从而直接编写SOAP web service。而且它也是到目前为止，唯一为web service提供WSDL文档的Python类库。



    import web 
    from soaplib.wsgi_soap import SimpleWSGISoapApp
    from soaplib.service import soapmethod
    from soaplib.serializers import primitive as soap_types

    urls = ("/hello", "HelloService",
            "/hello.wsdl", "HelloService",
            )
    render = web.template.Template("$def with (var)\n$:var")


    
    class SoapService(SimpleWSGISoapApp):
        """Class for webservice """

        #__tns__ = 'http://test.com'
    
        @soapmethod(soap_types.String,_returns=soap_types.String)
        def hello(self,message):
            """ Method for webservice"""
            return "Hello world "+message
     


    class HelloService(SoapService):
        """Class for web.py """
        def start_response(self,status, headers):
            web.ctx.status = status
            for header, value in headers:
                web.header(header, value)
    
    
        def GET(self):
            response = super(SimpleWSGISoapApp, self).__call__(web.ctx.environ, self.start_response)
            return render("\n".join(response))
    
    
        def POST(self):
            response = super(SimpleWSGISoapApp, self).__call__(web.ctx.environ, self.start_response)
            return render("\n".join(response))
     
    app=web.application(urls, globals())
    
    if __name__ == "__main__":
        app.run()




可以用soaplib客户端测试一下：

    >>> from soaplib.client import make_service_client
    >>> from test import HelloService
    >>> client = make_service_client('http://localhost:8080/hello', HelloService())
    >>> client.hello('John')
    'Hello world John'

可以在[http://localhost:8080/hello.wsdl](http://localhost:8080/hello.wsdl)查看WSDL。

欲了解更多，请查看 [soaplib](http://trac.optio.webfactional.com/),
---
layout: default
title: Using a dictionary as where clause
---

# Using a dictionary as where clause

Problem
-------

You want to create a dictionary of where clauses dynamically and use it in a query.

Solution
--------

    >>> import web
    >>> db = web.database(dbn='postgres', db='mydb', user='postgres')
    >>> where_dict = {'col1': 1, col2: 'sometext'}
    >>> db.delete('mytable', where=web.db.sqlwhere(where_dict), _test=True)
    <sql: "DELETE FROM mytable WHERE col1 = 1 AND col2 = 'sometext'">

Explanation
-----------

`web.db.sqlwhere` takes a Python dictionary as an argument and converts it into a string useful for where clause in different queries. You can also use an optional `grouping` argument to define the exact gouping of the individual keys. For instance:

    >>> import web
    >>> web.db.sqlwhere({'a': 1, 'b': 2}, grouping=' OR ')
    'a = 1 OR b = 2'

Default for `grouping` is `' AND '`.
---
layout: default
title: 使用字典动态构造where子句
---

# 使用字典动态构造where子句

问题
-------

你希望创建一个字典来构造动态的where子句并且希望能够在查询语句中使用。

解决
--------

    >>> import web
    >>> db = web.database(dbn='postgres', db='mydb', user='postgres')
    >>> where_dict = {'col1': 1, col2: 'sometext'}
    >>> db.delete('mytable', where=web.db.sqlwhere(where_dict), _test=True)
    <sql: "DELETE FROM mytable WHERE col1 = 1 AND col2 = 'sometext'">

解释
-----------

`web.db.sqlwhere` takes a Python dictionary as an argument and converts it into a string useful for where clause in different queries. You can also use an optional `grouping` argument to define the exact gouping of the individual keys. For instance:

`web.db.sqlwhere`将Python的字典作为参数并且转换为适用于不同的查询语句的where子句的string类型数据。你也可以使用`grouping`参数来定义链接字典中的key的链接字符。例子如下。

    >>> import web
    >>> web.db.sqlwhere({'a': 1, 'b': 2}, grouping=' OR ')
    'a = 1 OR b = 2'

`grouping` 的默认值为 `' AND '`.
---
layout: default
title: Servir du XML
---

# Servir du XML

Autres langages [english](/../xmlfiles) | ...

### Probleme

Comment servir des fichiers XML correctement?


Cela est nécessaire lorsque vous avez une application tierce postant des données au service et attendant une réponse XML.

### Solution

Créez votre gabarit XML avec le fichier XML que vous souhaitez servir (par exemple : response.xml). Si le XML a des variables, utilisez le code gabarit  correspondant de web.py comme dans cet exemple:


    $def with (code)
    <?xml version="1.0"?>
    <RequestNotification-Response>
    <Status>$code</Status>
    </RequestNotification-Response>


Pour servir ce fichier, créez un programme standard web.py ( par exemple: response.py) et utilisez le code suivant. Soyez conscient que vous devez utiliser <code>web.header('Content-Type', 'text/xml')</code> pour dire au client que vous envoyez un fichier XML. (Vous n'avez pas besoin de définir explicitement l'en-tête des fichiers XML si votre fichier gabarit a l'extension '.xml' )

    import web

    render = web.template.render('templates/', cache=False)

    urls = (
        '/(.*)', 'index'
    )

    app = web.application(urls, globals())

    class index:
        def GET(self, code):
            web.header('Content-Type', 'text/xml')
            return render.index(code)

    web.webapi.internalerror = web.debugerror
    if __name__ == '__main__': app.run()
---
layout: default
title: Serving XML
---

# Serving XML

Other languages:  [français](/../cookbook/xmlfiles/fr) | ...

### Problem

How to serve XML files correctly?

This is needed when you have a third-party application posting data to your service and expecting some kind of XML response.

### Solution

Create your XML template with the XML file you want to serve (i.e. response.xml). If the XML has any variables, use the corresponding web.py templating code. This is just an example:

    $def with (code)
    <?xml version="1.0"?>
    <RequestNotification-Response>
    <Status>$code</Status>
    </RequestNotification-Response>

To serve this file, create a standard Web.Py program (i.e. response.py) and use the following code. Be aware that you should use <code>web.header('Content-Type', 'text/xml')</code> to tell the client that you are sending a XML file. (You don't need to set the header explicitly for XML files if your template file has the ``.xml`` extension.)


    import web

    render = web.template.render('templates/', cache=False)

    urls = (
        '/(.*)', 'index'
    )

    app = web.application(urls, globals())

    class index:
        def GET(self, code):
            web.header('Content-Type', 'text/xml')
            return render.response(code)

    web.webapi.internalerror = web.debugerror
    if __name__ == '__main__': app.run()
---
layout: default
title: 提供XML访问
---

# 提供XML访问

### 问题

如何在web.py中提供XML访问？

如果需要为第三方应用收发数据，那么提供xml访问是很有必要的。

### 解法

根据要访问的xml文件(如response.xml)创建一个XML模板。如果XML中有变量，就使用相应的模板标签进行替换。下面是一个例子：

    $def with (code)
    <?xml version="1.0"?>
    <RequestNotification-Response>
    <Status>$code</Status>
    </RequestNotification-Response>

为了提供这个XML，需要创建一个单独的web.py程序(如response.py)，它要包含下面的代码。注意：要用"web.header('Content-Type', 'text/xml')"来告知客户端－－正在发送的是一个XML文件。


    import web

    render = web.template.render('templates/', cache=False)

    urls = (
        '/(.*)', 'index'
    )

    app = web.application(urls, globals())

    class index:
        def GET(self, code):
            web.header('Content-Type', 'text/xml')
            return render.response(code)

    web.webapi.internalerror = web.debugerror
    if __name__ == '__main__': app.run()

---
layout: default
title: Deployment
---

# Deployment

The web server that gets started when you run a web.py program is nice, but for popular sites you're going to want something a little more serious. web.py implements WSGI and runs with everything that is compatible to it. WSGI is a common API between web servers and applications, analogous to Java's Servlet Interface. To run web.py with CGI, FastCGI or SCGI you will need to install flup (download here), which provides WSGI interfaces for those APIs.

For all the CGI variants, add this to the top of your `code.py`:

    #!/usr/bin/env python

And run `chmod +x code.py` to make it executable.

### LightTPD

#### .. with FastCGI

FastCGI with lighttpd is the recommended way of using web.py in production. [reddit.com][3] handles millions of hits this way.

   [3]: http://reddit.com/

Your lighttpd config can be something like:
    
     server.modules = ("mod_fastcgi", "mod_rewrite")
     server.document-root = "/path/to/root/"     
     fastcgi.server = ( "/code.py" =>     
     (( "socket" => "/tmp/fastcgi.socket",
        "bin-path" => "/path/to/root/code.py",
        "max-procs" => 1
     ))
     )
    
     url.rewrite-once = (
       "^/favicon.ico$" => "/static/favicon.ico",
       "^/static/(.*)$" => "/static/$1",
       "^/(.*)$" => "/code.py/$1"
     )
    
With some versions of lighttpd, it is important to ensure the "check-local" property of the fastcgi.server entry is set to "false", especially if your `code.py` is located outside of the document root.

If you get error messages about not being able to import flup, install it by typing "easy_install flup" at the command line.

Since revision 145, it is necessary to set a bin-environment variable on the fastcgi configuration if your code uses redirects.  If when your code redirects to http://domain.com/ and in the url bar you see http://domain.com/code.py/, you'll need to set the environment variable. This will cause your fastcgi.server configuration above to look something like this:
     
    fastcgi.server = ( "/code.py" =>
    ((
       "socket" => "/tmp/fastcgi.socket",
       "bin-path" => "/path/to/root/code.py",
       "max-procs" => 1,
       "bin-environment" => (
         "REAL_SCRIPT_NAME" => ""
       ),
       "check-local" => "disable"
    ))
    )
    

### Apache

#### .. with CGI


Add the following to `httpd.conf` or `apache2.conf`.

    Alias /foo/static/ /path/to/static
    ScriptAlias /foo/ /path/to/code.py


#### .. with CGI using .htaccess

CGI is easy to configure, but is not suitable for high-performance websites.
Add this to your `.htaccess`:

    Options +ExecCGI
    AddHandler cgi-script .py

and point your browser to `http://example.com/code.py/`. Don't forget the trailing slash, otherwise you'll see a `not found` message (because the `urls` list you defined do not match anything). To make things work without having to enter `code.py`, enable mod_rewrite rules (see below).

Note: The way `web.py` is implemented breaks the `cgitb` module because it captures `stdout`. I worked around the issue by using this:
    
    import cgitb; cgitb.enable()
    import sys
    
    # ... import web etc here...
    
    def cgidebugerror():
        """                                                                         
        """        _wrappedstdout = sys.stdout
    
        sys.stdout = web._oldstdout
        cgitb.handler()
    
        sys.stdout = _wrappedstdout
    
    web.internalerror = cgidebugerror

#### .. with FastCGI

FastCGI is easy to configure and performs as well as mod_python.

Add this to your `.htaccess`:
    
    <Files code.py>      SetHandler fastcgi-script
    </Files>

Unfortunately, unlike lighttpd, Apache gives no hint that it wants your web.py script to act as a FastCGI server so you have to tell web.py explicitly. Add this to `code.py` before your `if __name__ == "__main__":` line:
    
    web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
    
and point your browser to `http://example.com/code.py/`. Don't forget the trailing slash, otherwise you'll see a `not found` message (because the `urls` list you defined do not match anything). To make things work without having to enter `code.py`, enable mod_rewrite rules (see below).

[Walter has some additional advice](http://lemurware.blogspot.com/2006/05/webpy-apache-configuration-and-you.html).

#### .. with SCGI
https://www.mems-exchange.org/software/scgi/
download `mod_scgi` source here: http://www.mems-exchange.org/software/files/mod_scgi/
windows apache user: 
edit your httpd.conf:

    LoadModule scgi_module Modules/mod_scgi.so
    SCGIMount / 127.0.0.1:8080

restart apache and then start your code.py in the command below:

    python code.py 127.0.0.1:8080 scgi

and open you browser,visit 127.0.0.1
It's ok! 

#### .. with mod_python

mod_python performs as well as FastCGI, but is not as straight-forward to configure.

For Python 2.5 do this:

    cd /usr/lib/python2.5/wsgiref
    # or in windows: cd /python2.5/lib/wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # or fetch the file from that address using your browser

For Python <2.5 do this:

    cd /usr/lib/python2.4/site-packages
    # or in windows: cd /python2.4/lib/site-packages
    svn co svn://svn.eby-sarna.com/svnroot/wsgiref/wsgiref
    cd wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # or fetch the file from that address using your browser  


Rename your `code.py` to something like `codep.py` and add:
    
    main = web.wsgifunc(web.webpyfunc(urls, globals()))

In your `.htaccess`, add:
    
    
    AddHandler python-program .py
    PythonHandler wsgiref.modpython_gateway::handler
    PythonOption wsgi.application codep::main
    

You also probably want to add a `RewriteRule` pointing `/` to `/codep.py/`

Be sure to visit `/codep.py/` with the extra `/` on the end. Otherwise, you'll see an error message like `A server error occurred. Please contact the administrator.`

#### .. with mod_wsgi

mod\_wsgi is a new Apache module which [typically outperforms mod_python](http://code.google.com/p/modwsgi/wiki/PerformanceEstimates) for hosting WSGI applications, and is very easy to set up.

At the end of your `code.py`, add:

    app = web.application(urls, globals(), autoreload=False)
    application = app.wsgifunc()

mod\_wsgi offers [many possible ways](http://code.google.com/p/modwsgi/wiki/ConfigurationDirectives) to expose a WSGI application in Apache's URL hierarchy, but one simple way would be to add the following to your .htaccess:

    <Files code.py>
        SetHandler wsgi-script
        Options ExecCGI FollowSymLinks
    </Files>

If you get an "ImportError: No module named web" in your apache error.log file, you could try setting the absolute path in code.py before importing web:

    import sys, os
    abspath = os.path.dirname(__file__)
    sys.path.append(abspath)
    os.chdir(abspath)
    import web

Also, you might want to read the "Application Working Directory" section from [Common problems with WSGI application](http://code.google.com/p/modwsgi/wiki/ApplicationIssues).

It should then be accessible at `http://example.com/code.py/` as usual.

#### mod_rewrite Rules for Apache

If you want web.py to be accessible at 'http://example.com' instead of 'http://example.com/code.py/' add the following rules to the `.htaccess` file:

    <IfModule mod_rewrite.c>      
      RewriteEngine on
      RewriteBase /
      RewriteCond %{REQUEST_URI} !^/icons
      RewriteCond %{REQUEST_URI} !^/favicon.ico$
      RewriteCond %{REQUEST_URI} !^(/.*)+code.py/
      RewriteRule ^(.*)$ code.py/$1 [PT]
    </IfModule>

If the `code.py` is in the subfolder `myapp/`, adjust the RewriteBase to `RewriteBase /myapp/`. If you have static files like CSS files and images to pass through, duplicate the line with the icons for each path you want to allow.
---
layout: default
title: DevelopmentIsland
---

# DevelopmentIsland

[http://www.devisland.net](http://www.devisland.net/)

We support web.py in our [CGI](http://www.devisland.net/packages/cgidetails.shtml) and [Python](http://www.devisland.net/packages/pythondetails.shtml) hosting packages.

For more information on how to setup your application see:

[CGI Setup](http://www.devisland.net/help/webpycgi.shtml)

[Mod_python Setup](http://www.devisland.net/help/webpy.shtml)


---
layout: default
title: web.py 0.2 API documentation
---

# web.py 0.2 API documentation

## __init__.py

`main()`
   : 


## cheetah.py

`upvars(level=2)`
   : Guido van Rossum sez: don't use this function.

`render(template, terms=None, asTemplate=False, base=None, isString=False):`
   : Renders a template, caching where it can.
     
     `template` is the name of a file containing the a template in
     the `templates/` folder, unless `isString`, in which case it's the 
     template itself.
 
     `terms` is a dictionary used to fill the template. If it's None, then
     the caller's local variables are used instead, plus context, if it's not 
     already set, is set to `context`.
 
     If asTemplate is False, it `output`s the template directly. Otherwise,
     it returns the template object.
 
     If the template is a potential base template (that is, something other templates)
     can extend, then base should be a string with the name of the template. The
     template will be cached and made available for future calls to `render`.
 
     Requires [Cheetah](http://cheetahtemplate.org/).

`class WebSafe(Filter)`
   : 


## db.py

Supports Firebird, MySQL, PostgreSQL, and SQLite.

`class UnknownParamstyle(Exception)`
   : raised for unsupported db paramstyles
     
     (currently supported: qmark, numeric, format, pyformat)

`aparam()`
   : Returns the appropriate string to be used to interpolate
     a value with the current `web.ctx.db_module` or simply %s
     if there isn't one.
     
         >>> aparam()
         '%s'

`reparam(string_, dictionary)`
   : Takes a string and a dictionary and interpolates the string
     using values from the dictionary. Returns an `SQLQuery` for the result.
     
         >>> reparam("s = $s", dict(s=True))
         <sql: "s = 't'">

`sqlify(obj)`
   : converts `obj` to its proper SQL version
     
         >>> sqlify(None)
         'NULL'
         >>> sqlify(True)
         "'t'"
         >>> sqlify(3)
         '3'

`class SQLQuery`
   : You can pass this sort of thing as a clause in any db function.
     Otherwise, you can pass a dictionary to the keyword argument `vars`
     and the function will call reparam for you.

`class SQLLiteral`
   : Protects a string from `sqlquote`.
 
         >>> insert('foo', time=SQLLiteral('NOW()'), _test=True)
         <sql: 'INSERT INTO foo (time) VALUES (NOW())'>

`sqlquote(a)`
   : Ensures `a` is quoted properly for use in a SQL query.
     
         >>> 'WHERE x = ' + sqlquote(True) + ' AND y = ' + sqlquote(3)
         <sql: "WHERE x = 't' AND y = 3">

`class UnknownDB(Exception)`
   : raised for unsupported dbms

`connect(dbn, **keywords)`
   : Connects to the specified database. 
     
     `dbn` currently must be "postgres", "mysql", or "sqlite". 
     
     If DBUtils is installed, connection pooling will be used.

`class TransactionError(Exception): pass  class transaction:`
   : A context that can be used in conjunction with "with" statements
     to implement SQL transactions. Starts a transaction on enter,
     rolls it back if there's an error; otherwise it commits it at the
     end.

`transact()`
   : Start a transaction.

`commit()`
   : Commits a transaction.

`rollback(care=True)`
   : Rolls back a transaction.

`query(sql_query, vars=None, processed=False, _test=False)`
   : Execute SQL query `sql_query` using dictionary `vars` to interpolate it.
     If `processed=True`, `vars` is a `reparam`-style list to use 
     instead of interpolating.
     
         >>> query("SELECT * FROM foo", _test=True)
         <sql: 'SELECT * FROM foo'>
         >>> query("SELECT * FROM foo WHERE x = $x", vars=dict(x='f'), _test=True)
         <sql: "SELECT * FROM foo WHERE x = 'f'">
         >>> query("SELECT * FROM foo WHERE x = " + sqlquote('f'), _test=True)
         <sql: "SELECT * FROM foo WHERE x = 'f'">

`sqllist(lst)`
   : Converts the arguments for use in something like a WHERE clause.
     
         >>> sqllist(['a', 'b'])
         'a, b'
         >>> sqllist('foo')
         'foo'
         >>> sqllist(u'foo')
         u'foo'

`sqlors(left, lst)`
   : `left is a SQL clause like `tablename.arg = ` 
     and `lst` is a list of values. Returns a reparam-style
     pair featuring the SQL that ORs together the clause
     for each item in the lst.
 
         >>> sqlors('foo = ', [])
         <sql: '2+2=5'>
         >>> sqlors('foo = ', [1])
         <sql: 'foo = 1'>
         >>> sqlors('foo = ', 1)
         <sql: 'foo = 1'>
         >>> sqlors('foo = ', [1,2,3])
         <sql: '(foo = 1 OR foo = 2 OR foo = 3)'>

`sqlwhere(dictionary, grouping=' AND ')`
   : Converts a `dictionary` to an SQL WHERE clause `SQLQuery`.
     
         >>> sqlwhere({'cust_id': 2, 'order_id':3})
         <sql: 'order_id = 3 AND cust_id = 2'>
         >>> sqlwhere({'cust_id': 2, 'order_id':3}, grouping=', ')
         <sql: 'order_id = 3, cust_id = 2'>

`select(tables, vars=None, what='*', where=None, order=None, group=None, limit=None, offset=None, _test=False):`
   : Selects `what` from `tables` with clauses `where`, `order`, 
     `group`, `limit`, and `offset`. Uses vars to interpolate. 
     Otherwise, each clause can be a SQLQuery.
     
         >>> select('foo', _test=True)
         <sql: 'SELECT * FROM foo'>
         >>> select(['foo', 'bar'], where="foo.bar_id = bar.id", limit=5, _test=True)
         <sql: 'SELECT * FROM foo, bar WHERE foo.bar_id = bar.id LIMIT 5'>

`insert(tablename, seqname=None, _test=False, **values)`
   : Inserts `values` into `tablename`. Returns current sequence ID.
     Set `seqname` to the ID if it's not the default, or to `False`
     if there isn't one.
     
         >>> insert('foo', joe='bob', a=2, _test=True)
         <sql: "INSERT INTO foo (a, joe) VALUES (2, 'bob')">

`update(tables, where, vars=None, _test=False, **values)`
   : Update `tables` with clause `where` (interpolated using `vars`)
     and setting `values`.
     
         >>> joe = 'Joseph'
         >>> update('foo', where='name = $joe', name='bob', age=5,
         ...   vars=locals(), _test=True)
         <sql: "UPDATE foo SET age = 5, name = 'bob' WHERE name = 'Joseph'">

`delete(table, where=None, using=None, vars=None, _test=False)`
   : Deletes from `table` with clauses `where` and `using`.
     
         >>> name = 'Joe'
         >>> delete('foo', where='name = $name', vars=locals(), _test=True)
         <sql: "DELETE FROM foo WHERE name = 'Joe'">


## debugerror.py

`djangoerror()`
   : 

`debugerror()`
   : A replacement for `internalerror` that presents a nice page with lots
     of debug information for the programmer.
 
     (Based on the beautiful 500 page from [Django](http://djangoproject.com/), 
     designed by [Wilson Miner](http://wilsonminer.com/).)

`emailerrors(email_address, olderror)`
   : Wraps the old `internalerror` handler (pass as `olderror`) to 
     additionally email all errors to `email_address`, to aid in 
     debugging production websites.
     
     Emails contain a normal text traceback as well as an
     attachment containing the nice `debugerror` page.


## form.py

`attrget(obj, attr, value=None)`
   : 

`class Form`
   : __init__(self, *inputs, **kw)
     `inputs` is a list of form objects.
     The only keyword accepted is "validators" which is a list of Validator objects.

`class Input(object)`
   : __init__(self, name, *validators, **attrs)
     `name` is the name of the object. It is the default value for the "description" attribute for the HTML form element.
     The keywords, stored in the dictionary `attrs`, accepted are: "description", "value", "pre", "post", "id", and "class_"

`class Textbox(Input)`
   : 

`class Password(Input)`
   : 

`class Textarea(Input)`
   : 

`class Dropdown(Input)`
   : 

`class Radio(Input)`
   : 

`class Checkbox(Input)`
   : 

`class Button(Input)`
   : 

`class Hidden(Input)`
   : 

`class File(Input)`
   : 

`class Validator`
   : 

`class regexp(Validator)`
   : 


## http.py

`prefixurl(base='')`
   : Sorry, this function is really difficult to explain.
     Maybe some other time.

`expires(delta)`
   : Outputs an `Expires` header for `delta` from now. 
     `delta` is a `timedelta` object or a number of seconds.

`lastmodified(date_obj)`
   : Outputs a `Last-Modified` header for `datetime`.

`modified(date=None, etag=None)`
   : 

`redirect(url, status='301 Moved Permanently')`
   : Returns a `status` redirect to the new URL. 
     `url` is joined with the base URL so that things like 
     `redirect("about")` will work properly.

`found(url)`
   : A `302 Found` redirect.

`seeother(url)`
   : A `303 See Other` redirect.

`tempredirect(url)`
   : A `307 Temporary Redirect` redirect.

`write(cgi_response)`
   : Converts a standard CGI-style string response into `header` and 
     `output` calls.

`urlencode(query)`
   : Same as urllib.urlencode, but supports unicode strings.
     
         >>> urlencode({'text':'foo bar'})
         'text=foo+bar'

`changequery(query=None, **kw)`
   : Imagine you're at `/foo?a=1&b=2`. Then `changequery(a=3)` will return
     `/foo?a=3&b=2` -- the same URL but with the arguments you requested
     changed.

`url(path=None, **kw)`
   : Makes url by concatinating web.ctx.homepath and path and the 
     query string created using the arguments.

`background(func)`
   : A function decorator to run a long-running function as a background thread. 
     GOTCHA in postgres: Until the foreground task ends, any db access by background 
     task will necessarily get old data from before the foreground task started
     because psycopg2 begins a transaction in the foreground task until it quits.

`backgrounder(func)`
   : 

`class Reloader`
   : Before every request, checks to see if any loaded modules have changed on 
     disk and, if so, reloads them.

`profiler(app)`
   : Outputs basic profiling information at the bottom of each response.


## httpserver.py

`runbasic(func, server_address=("0.0.0.0", 8080))`
   : Runs a simple HTTP server hosting WSGI app `func`. The directory `static/` 
     is hosted statically.
 
     Based on [WsgiServer][ws] from [Colin Stewart][cs].
     
   [ws]: http://www.owlfish.com/software/wsgiutils/documentation/wsgi-server-api.html
   [cs]: http://www.owlfish.com/

`runsimple(func, server_address=("0.0.0.0", 8080))`
   : Runs [CherryPy][cp] WSGI server hosting WSGI app `func`. 
     The directory `static/` is hosted statically.
 
     [cp]: http://www.cherrypy.org


## net.py

`validipaddr(address)`
   : returns True if `address` is a valid IPv4 address

`validipport(port)`
   : returns True if `port` is a valid IPv4 port

`validip(ip, defaultaddr="0.0.0.0", defaultport=8080)`
   : returns `(ip_address, port)` from string `ip_addr_port`

`validaddr(string_)`
   : returns either (ip_address, port) or "/path/to/socket" from string_
     
         >>> validaddr('/path/to/socket')
         '/path/to/socket'
         >>> validaddr('8000')
         ('0.0.0.0', 8000)
         >>> validaddr('127.0.0.1')
         ('127.0.0.1', 8080)
         >>> validaddr('127.0.0.1:8000')
         ('127.0.0.1', 8000)
         >>> validaddr('fff')
         Traceback (most recent call last):
             ...
         ValueError: fff is not a valid IP address/port

`urlquote(val)`
   : Quotes a string for use in a URL.
     
         >>> urlquote('://?f=1&j=1')
         '%3A//%3Ff%3D1%26j%3D1'
         >>> urlquote(None)
         ''
         >>> urlquote(u'\u203d')
         '%E2%80%BD'

`httpdate(date_obj)`
   : Formats a datetime object for use in HTTP headers.
     
         >>> import datetime
         >>> httpdate(datetime.datetime(1970, 1, 1, 1, 1, 1))
         'Thu, 01 Jan 1970 01:01:01 GMT'

`parsehttpdate(string_)`
   : Parses an HTTP date into a datetime object.
 
         >>> parsehttpdate('Thu, 01 Jan 1970 01:01:01 GMT')
         datetime.datetime(1970, 1, 1, 1, 1, 1)

`htmlquote(text)`
   : Encodes `text` for raw use in HTML.
     
         >>> htmlquote("<'&\\">")
         '&lt;&#39;&amp;&quot;&gt;'

`htmlunquote(text)`
   : Decodes `text` that's HTML quoted.
 
         >>> htmlunquote('&lt;&#39;&amp;&quot;&gt;')
         '<\\'&">'

`websafe(val)`
   : Converts `val` so that it's safe for use in UTF-8 HTML.
     
         >>> websafe("<'&\\">")
         '&lt;&#39;&amp;&quot;&gt;'
         >>> websafe(None)
         ''
         >>> websafe(u'\u203d')
         '\\xe2\\x80\\xbd'


## request.py

`handle(mapping, fvars=None)`
   : Call the appropriate function based on the url to function mapping in `mapping`.
     If no module for the function is specified, look up the function in `fvars`. If
     `fvars` is empty, using the caller's context.
 
     `mapping` should be a tuple of paired regular expressions with function name
     substitutions. `handle` will import modules as necessary.

`nomethod(cls)`
   : Returns a `405 Method Not Allowed` error for `cls`.

`autodelegate(prefix='')`
   : Returns a method that takes one argument and calls the method named prefix+arg,
     calling `notfound()` if there isn't one. Example:
 
         urls = ('/prefs/(.*)', 'prefs')
 
         class prefs:
             GET = autodelegate('GET_')
             def GET_password(self): pass
             def GET_privacy(self): pass
 
     `GET_password` would get called for `/prefs/password` while `GET_privacy` for 
     `GET_privacy` gets called for `/prefs/privacy`.
     
     If a user visits `/prefs/password/change` then `GET_password(self, '/change')`
     is called.

`webpyfunc(inp, fvars, autoreload=False)`
   : If `inp` is a url mapping, returns a function that calls handle.

`run(inp, fvars, *middleware)`
   : Starts handling requests. If called in a CGI or FastCGI context, it will follow
     that protocol. If called from the command line, it will start an HTTP
     server on the port named in the first command line argument, or, if there
     is no argument, on port 8080.
 
     `input` is a callable, then it's called with no arguments.
     Otherwise, it's a `mapping` object to be passed to `handle(...)`.
 
     **Caveat:** So that `reloader` will work correctly, input has to be a variable,
     it can't be a tuple passed in directly.
 
     `middleware` is a list of WSGI middleware which is applied to the resulting WSGI
     function.


## template.py

`class ParseError(Exception): pass class Parser:`
   : 

`class TemplateParser(Parser)`
   : 

`class Stowage(storage)`
   : 

`class WTF(AssertionError): pass class SecurityError(Exception):`
   : The template seems to be trying to do something naughty.

`class Template`
   : 

`class Handle`
   : 

`class Fill(Handle)`
   : 

`class render`
   : 

`frender(fn, *a, **kw)`
   : 

`test()`
   : r"""Doctest for testing template module. 

         >>> t = Template
         >>> t('1')()
         '1\n'
         >>> t('$def with ()\n1')()
         '1\n'
         >>> t('$def with (a)\n$a')(1)
         '1\n'
         >>> t('$def with (a=0)\n$a')(1)
         '1\n'
         >>> t('$def with (a=0)\n$a')(a=1)
         '1\n'
         >>> t('$if 1: 1')()
         '1\n'
         >>> t('$if 1:\n    1')()
         '1\n'
         >>> t('$if 0: 0\n$elif 1: 1')()
         '1\n'
         >>> t('$if 0: 0\n$elif None: 0\n$else: 1')()
         '1\n'
         >>> t('$if (0 < 1) and (1 < 2): 1')()
         '1\n'
         >>> t('$for x in [1, 2, 3]: $x')()
         '1\n2\n3\n'
         >>> t('$for x in []: 0\n$else: 1')()
         '1\n'
         >>> t('$def with (a)\n$while a and a.pop(): 1')([1, 2, 3])
         '1\n1\n1\n'
         >>> t('$while 0: 0\n$else: 1')()
         '1\n'
         >>> t('$ a = 1\n$a')()
         '1\n'
         >>> t('$# 0')()
         ''
         >>> t('$def with (d)\n$for k, v in d.iteritems(): $k')({1: 1})
         '1\n'
         >>> t('$def with (a)\n$(a)')(1)
         '1\n'
         >>> t('$def with (a)\n$a')(1)
         '1\n'
         >>> t('$def with (a)\n$a.b')(storage(b=1))
         '1\n'
         >>> t('$def with (a)\n$a[0]')([1])
         '1\n'
         >>> t('${0 or 1}')()
         '1\n'
         >>> t('$ a = [1]\n$a[0]')()
         '1\n'
         >>> t('$ a = {1: 1}\n$a.keys()[0]')()
         '1\n'
         >>> t('$ a = []\n$if not a: 1')()
         '1\n'
         >>> t('$ a = {}\n$if not a: 1')()
         '1\n'
         >>> t('$ a = -1\n$a')()
         '-1\n'
         >>> t('$ a = "1"\n$a')()
         '1\n'
         >>> t('$if 1 is 1: 1')()
         '1\n'
         >>> t('$if not 0: 1')()
         '1\n'
         >>> t('$if 1:\n    $if 1: 1')()
         '1\n'
         >>> t('$ a = 1\n$a')()
         '1\n'
         >>> t('$ a = 1.\n$a')()
         '1.0\n'
         >>> t('$({1: 1}.keys()[0])')()
         '1\n'
         >>> t('$for x in [1, 2, 3]:\n\t$x')()
         '    1\n    2\n    3\n'
         >>> t('$def with (a)\n$:a')(1)
         '1\n'
         >>> t('$def with (a)\n$a')(u'\u203d')
         '\xe2\x80\xbd\n'
         >>> t(u'$def with (a)\n$a $:a')(u'\u203d')
         '\xe2\x80\xbd \xe2\x80\xbd\n'
         >>> t(u'$def with ()\nfoo')()
         'foo\n'
         >>> def f(x): return x
         ...
         >>> t(u'$def with (f)\n$:f("x")')(f)
         'x\n'
         >>> t(u'$def with (f)\n$:f(x="x")')(f)
         'x\n'
         >>> x = t('$var foo: bar')()
         >>> str(x)
         ''
         >>> x.foo
         'bar\n'

see also [template.py doc](/templetor)

## utils.py

`class Storage(dict)`
   : A Storage object is like a dictionary except `obj.foo` can be used
     in addition to `obj['foo']`.
     
         >>> o = storage(a=1)
         >>> o.a
         1
         >>> o['a']
         1
         >>> o.a = 2
         >>> o['a']
         2
         >>> del o.a
         >>> o.a
         Traceback (most recent call last):
             ...
         AttributeError: 'a'

`storify(mapping, *requireds, **defaults)`
   : Creates a `storage` object from dictionary `mapping`, raising `KeyError` if
     d doesn't have all of the keys in `requireds` and using the default 
     values for keys found in `defaults`.
 
     For example, `storify({'a':1, 'c':3}, b=2, c=0)` will return the equivalent of
     `storage({'a':1, 'b':2, 'c':3})`.
     
     If a `storify` value is a list (e.g. multiple values in a form submission), 
     `storify` returns the last element of the list, unless the key appears in 
     `defaults` as a list. Thus:
     
         >>> storify({'a':[1, 2]}).a
         2
         >>> storify({'a':[1, 2]}, a=[]).a
         [1, 2]
         >>> storify({'a':1}, a=[]).a
         [1]
         >>> storify({}, a=[]).a
         []
     
     Similarly, if the value has a `value` attribute, `storify will return _its_
     value, unless the key appears in `defaults` as a dictionary.
     
         >>> storify({'a':storage(value=1)}).a
         1
         >>> storify({'a':storage(value=1)}, a={}).a
         <Storage {'value': 1}>
         >>> storify({}, a={}).a
         {}

`rstrips(text, remove)`
   : removes the string `remove` from the right of `text`
 
         >>> rstrips("foobar", "bar")
         'foo'

`lstrips(text, remove)`
   : removes the string `remove` from the left of `text`
     
         >>> lstrips("foobar", "foo")
         'bar'

`strips(text, remove)`
   : removes the string `remove` from the both sides of `text` 
         >>> strips("foobarfoo", "foo")
         'bar'

`utf8(text)`
   : Encodes text in utf-8.         
         >> utf8(u'\u1234') # doctest doesn't seem to like utf-8
         '\xe1\x88\xb4'
 
         >>> utf8('hello')
         'hello'
         >>> utf8(42)
         '42'

`class TimeoutError(Exception): pass def timelimit(timeout):`
   : A decorator to limit a function to `timeout` seconds, raising `TimeoutError`
     if it takes longer.
     
         >>> import time
         >>> def meaningoflife():
         ...     time.sleep(.2)
         ...     return 42
         >>> 
         >>> timelimit(.1)(meaningoflife)()
         Traceback (most recent call last):
             ...
         TimeoutError: took too long
         >>> timelimit(1)(meaningoflife)()
         42
 
     _Caveat:_ The function isn't stopped after `timeout` seconds but continues 
     executing in a separate thread. (There seems to be no way to kill a thread.)
 
     inspired by <http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/473878>

`class Memoize`
   : 'Memoizes' a function, caching its return values for each input.
     
         >>> import time
         >>> def meaningoflife():
         ...     time.sleep(.2)
         ...     return 42
         >>> fastlife = memoize(meaningoflife)
         >>> meaningoflife()
         42
         >>> timelimit(.1)(meaningoflife)()
         Traceback (most recent call last):
             ...
         TimeoutError: took too long
         >>> fastlife()
         42
         >>> timelimit(.1)(fastlife)()
         42

`re_subm(pat, repl, string)`
   : Like re.sub, but returns the replacement _and_ the match object.
     
         >>> t, m = re_subm('g(oo+)fball', r'f\\1lish', 'goooooofball')
         >>> t
         'foooooolish'
         >>> m.groups()
         ('oooooo',)

`group(seq, size)`
   : Returns an iterator over a series of lists of length size from iterable.
 
         >>> list(group([1,2,3,4], 2))
         [1, 2], [3, 4](/1, 2], [3, 4)

`class IterBetter`
   : Returns an object that can be used as an iterator 
     but can also be used via __getitem__ (although it 
     cannot go backwards -- that is, you cannot request 
     `iterbetter[0]` after requesting `iterbetter[1]`).
     
         >>> import itertools
         >>> c = iterbetter(itertools.count())
         >>> c[1]
         1
         >>> c[5]
         5
         >>> c[3]
         Traceback (most recent call last):
             ...
         IndexError: already passed 3

`dictreverse(mapping)`
   : >>> dictreverse({1: 2, 3: 4})
         {2: 1, 4: 3}

`dictfind(dictionary, element)`
   : Returns a key whose value in `dictionary` is `element` 
     or, if none exists, None.
     
         >>> d = {1:2, 3:4}
         >>> dictfind(d, 4)
         3
         >>> dictfind(d, 5)

`dictfindall(dictionary, element)`
   : Returns the keys whose values in `dictionary` are `element`
     or, if none exists, [].
     
         >>> d = {1:4, 3:4}
         >>> dictfindall(d, 4)
         [1, 3]
         >>> dictfindall(d, 5)
         []

`dictincr(dictionary, element)`
   : Increments `element` in `dictionary`, 
     setting it to one if it doesn't exist.
     
         >>> d = {1:2, 3:4}
         >>> dictincr(d, 1)
         3
         >>> d[1]
         3
         >>> dictincr(d, 5)
         1
         >>> d[5]
         1

`dictadd(*dicts)`
   : Returns a dictionary consisting of the keys in the argument dictionaries.
     If they share a key, the value from the last argument is used.
     
         >>> dictadd({1: 0, 2: 0}, {2: 1, 3: 1})
         {1: 0, 2: 1, 3: 1}

`listget(lst, ind, default=None)`
   : Returns `lst[ind]` if it exists, `default` otherwise.
     
         >>> listget(['a'], 0)
         'a'
         >>> listget(['a'], 1)
         >>> listget(['a'], 1, 'b')
         'b'

`intget(integer, default=None)`
   : Returns `integer` as an int or `default` if it can't.
     
         >>> intget('3')
         3
         >>> intget('3a')
         >>> intget('3a', 0)
         0

`datestr(then, now=None)`
   : Converts a (UTC) datetime object to a nice string representation.
     
         >>> from datetime import datetime, timedelta
         >>> d = datetime(1970, 5, 1)
         >>> datestr(d, now=d)
         '0 microseconds ago'
         >>> for t, v in {
         ...   timedelta(microseconds=1): '1 microsecond ago',
         ...   timedelta(microseconds=2): '2 microseconds ago',
         ...   -timedelta(microseconds=1): '1 microsecond from now',
         ...   -timedelta(microseconds=2): '2 microseconds from now',
         ...   timedelta(microseconds=2000): '2 milliseconds ago',
         ...   timedelta(seconds=2): '2 seconds ago',
         ...   timedelta(seconds=2*60): '2 minutes ago',
         ...   timedelta(seconds=2*60*60): '2 hours ago',
         ...   timedelta(days=2): '2 days ago',
         ... }.iteritems():
         ...     assert datestr(d, now=d+t) == v
         >>> datestr(datetime(1970, 1, 1), now=d)
         'January  1'
         >>> datestr(datetime(1969, 1, 1), now=d)
         'January  1, 1969'
         >>> datestr(datetime(1970, 6, 1), now=d)
         'June  1, 1970'

`numify(string)`
   : Removes all non-digit characters from `string`.
     
         >>> numify('800-555-1212')
         '8005551212'
         >>> numify('800.555.1212')
         '8005551212'

`denumify(string, pattern)`
   : Formats `string` according to `pattern`, where the letter X gets replaced
     by characters from `string`.
     
         >>> denumify("8005551212", "(XXX) XXX-XXXX")
         '(800) 555-1212'

`dateify(datestring)`
   : Formats a numified `datestring` properly.

`class CaptureStdout`
   : Captures everything `func` prints to stdout and returns it instead.
     
         >>> def idiot():
         ...     print "foo"
         >>> capturestdout(idiot)()
         'foo\\n'
     
     **WARNING:** Not threadsafe!

`class Profile`
   : Profiles `func` and returns a tuple containing its output
     and a string with human-readable profiling information.
         
         >>> import time
         >>> out, inf = profile(time.sleep)(.001)
         >>> out
         >>> inf[:10].strip()
         'took 0.0'

`tryall(context, prefix=None)`
   : Tries a series of functions and prints their results. 
     `context` is a dictionary mapping names to values; 
     the value will only be tried if it's callable.
     
         >>> tryall(dict(j=lambda: True))
         j: True
         ----------------------------------------
         results:
            True: 1
 
     For example, you might have a file `test/stuff.py` 
     with a series of functions testing various things in it. 
     At the bottom, have a line:
 
         if __name__ == "__main__": tryall(globals())
 
     Then you can run `python test/stuff.py` and get the results of 
     all the tests.

`class ThreadedDict`
   : Takes a dictionary that maps threads to objects. 
     When a thread tries to get or set an attribute or item 
     of the threadeddict, it passes it on to the object 
     for that thread in dictionary.

`autoassign(self, locals)`
   : Automatically assigns local variables to `self`.
     
         >>> self = storage()
         >>> autoassign(self, dict(a=1, b=2))
         >>> self
         <Storage {'a': 1, 'b': 2}>
     
     Generally used in `__init__` methods, as in:
 
         def __init__(self, foo, bar, baz=1): autoassign(self, locals())

`to36(q)`
   : Converts an integer to base 36 (a useful scheme for human-sayable IDs).
     
         >>> to36(35)
         'z'
         >>> to36(119292)
         '2k1o'
         >>> int(to36(939387374), 36)
         939387374
         >>> to36(0)
         '0'
         >>> to36(-393)
         Traceback (most recent call last):
             ... 
         ValueError: must supply a positive integer

`safemarkdown(text)`
   : Converts text to HTML following the rules of Markdown, but blocking any
     outside HTML input, so that only the things supported by Markdown
     can be used. Also converts raw URLs to links.
 
     (requires [markdown.py](http://webpy.org/markdown.py))

`sendmail(from_address, to_address, subject, message, headers=None, **kw)`
   : Sends the email message `message` with mail and envelope headers
     for from `from_address_` to `to_address` with `subject`. 
     Additional email headers can be specified with the dictionary 
     `headers.
 
     If `web.config.smtp_server` is set, it will send the message
     to that SMTP server. Otherwise it will look for 
     `/usr/lib/sendmail`, the typical location for the sendmail-style
     binary.


## webapi.py

`badrequest()`
   : Return a `400 Bad Request` error.

`notfound()`
   : Returns a `404 Not Found` error.

`gone()`
   : Returns a `410 Gone` error.

`internalerror()`
   : Returns a `500 Internal Server` error.

`header(hdr, value, unique=False)`
   : Adds the header `hdr: value` with the response.
     
     If `unique` is True and a header with that name already exists,
     it doesn't add a new one.

`output(string_)`
   : Appends `string_` to the response.

`flush()`
   : 

`input(*requireds, **defaults)`
   : Returns a `storage` object with the GET and POST arguments. 
     See `storify` for how `requireds` and `defaults` work.

`data()`
   : Returns the data sent with the request.

`setcookie(name, value, expires="", domain=None, secure=False)`
   : Sets a cookie.

`cookies(*requireds, **defaults)`
   : Returns a `storage` object with all the cookies in it.
     See `storify` for how `requireds` and `defaults` work.

`debug(*args)`
   : Prints a prettyprinted version of `args` to stderr.

`load()`
   : Loads a new context for the thread.
     
     You can ask for a function to be run at loadtime by 
     adding it to the dictionary `loadhooks`.

`unload()`
   : Unloads the context for the thread.
     
     You can ask for a function to be run at loadtime by
     adding it ot the dictionary `unloadhooks`.

`wsgifunc(func, *middleware)`
   : Returns a WSGI-compatible function from a webpy-function.

`ctx`
   :     A `storage` object containing various information about the request:
      
    `environ` (aka `env`)
       : A dictionary containing the standard WSGI environment variables.
    
    `host`
       : The domain (`Host` header) requested by the user.
    
    `home`
       : The base path for the application.
    
    `ip`
       : The IP address of the requester.
    
    `method`
       : The HTTP method used.
    
    `path`
       : The path request.
       
    `query`
       : If there are no query arguments, the empty string. Otherwise, a `?` followed
         by the query string.
    
    `fullpath`
       : The full path requested, including query arguments (`== path + query`).
    
    ### Response Data
    
    `status` (default: "200 OK")
       : The status code to be used in the response.
    
    `headers`
       : A list of 2-tuples to be used in the response.
    
    `output`
       : A string to be used as the response.
## wsgi.py

`runfcgi(func, addr=('localhost', 8000))`
   : Runs a WSGI function as a FastCGI server.

`runscgi(func, addr=('localhost', 4000))`
   : Runs a WSGI function as an SCGI server.

`runwsgi(func)`
   : Runs a WSGI-compatible `func` using FCGI, SCGI, or a simple web server,
     as appropriate based on context and `sys.argv`.






































---
layout: default
title: web.py 0.2 documentation
---

# web.py 0.2 documentation


* [Tutorial](/tutorial2)
* [Templetor](/templetor)
* [API Docs](/docs/0.2/api)



---
layout: default
title: api docs
---

# api docs

<div>

<style type="text/css">
.module {
    font-size: 130%;
    font-weight: bold;
}

.function, .class, .type {
    font-size: 120%;
    font-weight: bold;
}

.method, .property {
    font-size: 115%;
    font-weight: bold;
}

.ts {
    font-size: small;
    font-weight: lighter;
    color: grey;
}

#contents_link {
    position: fixed;
    top: 0;
    right: 0;
    padding: 5px;
    background: rgba(255, 255, 255, 0.5);
}

#contents_link a:hover {
    font-weight: bold;
}
</style>


<div id="contents_link">
<a href="#top">Back to contents</a>
</div>

<ul>
<li><a href="#web.application">web.application</a></li>
<li><a href="#web.contrib.template">web.contrib.template</a></li>
<li><a href="#web.db">web.db</a></li>
<li><a href="#web.debugerror">web.debugerror</a></li>
<li><a href="#web.form">web.form</a></li>
<li><a href="#web.http">web.http</a></li>
<li><a href="#web.httpserver">web.httpserver</a></li>
<li><a href="#web.net">web.net</a></li>
<li><a href="#web.session">web.session</a></li>
<li><a href="#web.template">web.template</a></li>
<li><a href="#web.utils">web.utils</a></li>
<li><a href="#web.webapi">web.webapi</a></li>
<li><a href="#web.webopenid">web.webopenid</a></li>
<li><a href="#web.wsgi">web.wsgi</a></li>
</ul>
<p><span class="ts">module</span><code class="module"> <a name="web.application">web.application</a></code><br />
<div style="margin-left:15px"><p>Web application
(from web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> application(self, mapping=(), fvars={}, autoreload=None)</code><br />
<div style="margin-left:45px"><p>Application to delegate requests based on path.</p>

<pre><code>&gt;&gt;&gt; urls = ("/hello", "hello")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class hello:
...     def GET(self): return "hello"
&gt;&gt;&gt;
&gt;&gt;&gt; app.request("/hello").data
'hello'
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add_mapping(self, pattern, classname)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add_processor(self, processor)</code><br />
<div style="margin-left:75px"><p>Adds a processor to the application.</p>

<pre><code>&gt;&gt;&gt; urls = ("/(.*)", "echo")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class echo:
...     def GET(self, name): return name
...
&gt;&gt;&gt;
&gt;&gt;&gt; def hello(handler): return "hello, " +  handler()
...
&gt;&gt;&gt; app.add_processor(hello)
&gt;&gt;&gt; app.request("/web.py").data
'hello, web.py'
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> browser(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> cgirun(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Return a CGI handler. This is mostly useful with Google App Engine.
There you can just do:</p>

<pre><code>main = app.cgirun()
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_parent_app(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> handle(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> handle_with_processors(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> init_mapping(self, mapping)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> internalerror(self)</code><br />
<div style="margin-left:75px"><p>Returns HTTPError with '500 internal error' message</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> load(self, env)</code><br />
<div style="margin-left:75px"><p>Initializes ctx using env.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> notfound(self)</code><br />
<div style="margin-left:75px"><p>Returns HTTPError with '404 not found' message</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> request(self, localpart='/', method='GET', data=None, host='0.0.0.0:8080', headers=None, https=False, **kw)</code><br />
<div style="margin-left:75px"><p>Makes request to this application for the specified path and method.
Response will be a storage object with data, status and headers.</p>

<pre><code>&gt;&gt;&gt; urls = ("/hello", "hello")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class hello:
...     def GET(self): 
...         web.header('Content-Type', 'text/plain')
...         return "hello"
...
&gt;&gt;&gt; response = app.request("/hello")
&gt;&gt;&gt; response.data
'hello'
&gt;&gt;&gt; response.status
'200 OK'
&gt;&gt;&gt; response.headers['Content-Type']
'text/plain'
</code></pre>

<p>To use https, use https=True.</p>

<pre><code>&gt;&gt;&gt; urls = ("/redirect", "redirect")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class redirect:
...     def GET(self): raise web.seeother("/foo")
...
&gt;&gt;&gt; response = app.request("/redirect")
&gt;&gt;&gt; response.headers['Location']
'http://0.0.0.0:8080/foo'
&gt;&gt;&gt; response = app.request("/redirect", https=True)
&gt;&gt;&gt; response.headers['Location']
'https://0.0.0.0:8080/foo'
</code></pre>

<p>The headers argument specifies HTTP headers as a mapping object
such as a dict.</p>

<pre><code>&gt;&gt;&gt; urls = ('/ua', 'uaprinter')
&gt;&gt;&gt; class uaprinter:
...     def GET(self):
...         return 'your user-agent is ' + web.ctx.env['HTTP_USER_AGENT']
... 
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; app.request('/ua', headers = {
...      'User-Agent': 'a small jumping bean/1.0 (compatible)'
... }).data
'your user-agent is a small jumping bean/1.0 (compatible)'
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> run(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Starts handling requests. If called in a CGI or FastCGI context, it will follow
that protocol. If called from the command line, it will start an HTTP
server on the port named in the first command line argument, or, if there
is no argument, on port 8080.</p>

<p><code>middleware</code> is a list of WSGI middleware which is applied to the resulting WSGI
function.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> wsgifunc(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Returns a WSGI-compatible function for this application.</p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> auto_application(self)</code><br />
<div style="margin-left:45px"><p>Application similar to <code>application</code> but urls are constructed 
automatiacally using metaclass.</p>

<pre><code>&gt;&gt;&gt; app = auto_application()
&gt;&gt;&gt; class hello(app.page):
...     def GET(self): return "hello, world"
...
&gt;&gt;&gt; class foo(app.page):
...     path = '/foo/.*'
...     def GET(self): return "foo"
&gt;&gt;&gt; app.request("/hello").data
'hello, world'
&gt;&gt;&gt; app.request('/foo/bar').data
'foo'
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add_mapping(self, pattern, classname)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add_processor(self, processor)</code><br />
<div style="margin-left:75px"><p>Adds a processor to the application.</p>

<pre><code>&gt;&gt;&gt; urls = ("/(.*)", "echo")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class echo:
...     def GET(self, name): return name
...
&gt;&gt;&gt;
&gt;&gt;&gt; def hello(handler): return "hello, " +  handler()
...
&gt;&gt;&gt; app.add_processor(hello)
&gt;&gt;&gt; app.request("/web.py").data
'hello, web.py'
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> browser(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> cgirun(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Return a CGI handler. This is mostly useful with Google App Engine.
There you can just do:</p>

<pre><code>main = app.cgirun()
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_parent_app(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> handle(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> handle_with_processors(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> init_mapping(self, mapping)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> internalerror(self)</code><br />
<div style="margin-left:75px"><p>Returns HTTPError with '500 internal error' message</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> load(self, env)</code><br />
<div style="margin-left:75px"><p>Initializes ctx using env.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> notfound(self)</code><br />
<div style="margin-left:75px"><p>Returns HTTPError with '404 not found' message</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> request(self, localpart='/', method='GET', data=None, host='0.0.0.0:8080', headers=None, https=False, **kw)</code><br />
<div style="margin-left:75px"><p>Makes request to this application for the specified path and method.
Response will be a storage object with data, status and headers.</p>

<pre><code>&gt;&gt;&gt; urls = ("/hello", "hello")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class hello:
...     def GET(self): 
...         web.header('Content-Type', 'text/plain')
...         return "hello"
...
&gt;&gt;&gt; response = app.request("/hello")
&gt;&gt;&gt; response.data
'hello'
&gt;&gt;&gt; response.status
'200 OK'
&gt;&gt;&gt; response.headers['Content-Type']
'text/plain'
</code></pre>

<p>To use https, use https=True.</p>

<pre><code>&gt;&gt;&gt; urls = ("/redirect", "redirect")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class redirect:
...     def GET(self): raise web.seeother("/foo")
...
&gt;&gt;&gt; response = app.request("/redirect")
&gt;&gt;&gt; response.headers['Location']
'http://0.0.0.0:8080/foo'
&gt;&gt;&gt; response = app.request("/redirect", https=True)
&gt;&gt;&gt; response.headers['Location']
'https://0.0.0.0:8080/foo'
</code></pre>

<p>The headers argument specifies HTTP headers as a mapping object
such as a dict.</p>

<pre><code>&gt;&gt;&gt; urls = ('/ua', 'uaprinter')
&gt;&gt;&gt; class uaprinter:
...     def GET(self):
...         return 'your user-agent is ' + web.ctx.env['HTTP_USER_AGENT']
... 
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; app.request('/ua', headers = {
...      'User-Agent': 'a small jumping bean/1.0 (compatible)'
... }).data
'your user-agent is a small jumping bean/1.0 (compatible)'
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> run(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Starts handling requests. If called in a CGI or FastCGI context, it will follow
that protocol. If called from the command line, it will start an HTTP
server on the port named in the first command line argument, or, if there
is no argument, on port 8080.</p>

<p><code>middleware</code> is a list of WSGI middleware which is applied to the resulting WSGI
function.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> wsgifunc(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Returns a WSGI-compatible function for this application.</p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> subdir_application(self, mapping=(), fvars={}, autoreload=None)</code><br />
<div style="margin-left:45px"><p>Application to delegate requests based on path.</p>

<pre><code>&gt;&gt;&gt; urls = ("/hello", "hello")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class hello:
...     def GET(self): return "hello"
&gt;&gt;&gt;
&gt;&gt;&gt; app.request("/hello").data
'hello'
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add_mapping(self, pattern, classname)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add_processor(self, processor)</code><br />
<div style="margin-left:75px"><p>Adds a processor to the application.</p>

<pre><code>&gt;&gt;&gt; urls = ("/(.*)", "echo")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class echo:
...     def GET(self, name): return name
...
&gt;&gt;&gt;
&gt;&gt;&gt; def hello(handler): return "hello, " +  handler()
...
&gt;&gt;&gt; app.add_processor(hello)
&gt;&gt;&gt; app.request("/web.py").data
'hello, web.py'
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> browser(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> cgirun(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Return a CGI handler. This is mostly useful with Google App Engine.
There you can just do:</p>

<pre><code>main = app.cgirun()
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_parent_app(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> handle(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> handle_with_processors(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> init_mapping(self, mapping)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> internalerror(self)</code><br />
<div style="margin-left:75px"><p>Returns HTTPError with '500 internal error' message</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> load(self, env)</code><br />
<div style="margin-left:75px"><p>Initializes ctx using env.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> notfound(self)</code><br />
<div style="margin-left:75px"><p>Returns HTTPError with '404 not found' message</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> request(self, localpart='/', method='GET', data=None, host='0.0.0.0:8080', headers=None, https=False, **kw)</code><br />
<div style="margin-left:75px"><p>Makes request to this application for the specified path and method.
Response will be a storage object with data, status and headers.</p>

<pre><code>&gt;&gt;&gt; urls = ("/hello", "hello")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class hello:
...     def GET(self): 
...         web.header('Content-Type', 'text/plain')
...         return "hello"
...
&gt;&gt;&gt; response = app.request("/hello")
&gt;&gt;&gt; response.data
'hello'
&gt;&gt;&gt; response.status
'200 OK'
&gt;&gt;&gt; response.headers['Content-Type']
'text/plain'
</code></pre>

<p>To use https, use https=True.</p>

<pre><code>&gt;&gt;&gt; urls = ("/redirect", "redirect")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class redirect:
...     def GET(self): raise web.seeother("/foo")
...
&gt;&gt;&gt; response = app.request("/redirect")
&gt;&gt;&gt; response.headers['Location']
'http://0.0.0.0:8080/foo'
&gt;&gt;&gt; response = app.request("/redirect", https=True)
&gt;&gt;&gt; response.headers['Location']
'https://0.0.0.0:8080/foo'
</code></pre>

<p>The headers argument specifies HTTP headers as a mapping object
such as a dict.</p>

<pre><code>&gt;&gt;&gt; urls = ('/ua', 'uaprinter')
&gt;&gt;&gt; class uaprinter:
...     def GET(self):
...         return 'your user-agent is ' + web.ctx.env['HTTP_USER_AGENT']
... 
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; app.request('/ua', headers = {
...      'User-Agent': 'a small jumping bean/1.0 (compatible)'
... }).data
'your user-agent is a small jumping bean/1.0 (compatible)'
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> run(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Starts handling requests. If called in a CGI or FastCGI context, it will follow
that protocol. If called from the command line, it will start an HTTP
server on the port named in the first command line argument, or, if there
is no argument, on port 8080.</p>

<p><code>middleware</code> is a list of WSGI middleware which is applied to the resulting WSGI
function.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> wsgifunc(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Returns a WSGI-compatible function for this application.</p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> subdomain_application(self, mapping=(), fvars={}, autoreload=None)</code><br />
<div style="margin-left:45px"><p>Application to delegate requests based on the host.</p>

<pre><code>&gt;&gt;&gt; urls = ("/hello", "hello")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class hello:
...     def GET(self): return "hello"
&gt;&gt;&gt;
&gt;&gt;&gt; mapping = (r"hello\.example\.com", app)
&gt;&gt;&gt; app2 = subdomain_application(mapping)
&gt;&gt;&gt; app2.request("/hello", host="hello.example.com").data
'hello'
&gt;&gt;&gt; response = app2.request("/hello", host="something.example.com")
&gt;&gt;&gt; response.status
'404 Not Found'
&gt;&gt;&gt; response.data
'not found'
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add_mapping(self, pattern, classname)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add_processor(self, processor)</code><br />
<div style="margin-left:75px"><p>Adds a processor to the application.</p>

<pre><code>&gt;&gt;&gt; urls = ("/(.*)", "echo")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class echo:
...     def GET(self, name): return name
...
&gt;&gt;&gt;
&gt;&gt;&gt; def hello(handler): return "hello, " +  handler()
...
&gt;&gt;&gt; app.add_processor(hello)
&gt;&gt;&gt; app.request("/web.py").data
'hello, web.py'
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> browser(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> cgirun(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Return a CGI handler. This is mostly useful with Google App Engine.
There you can just do:</p>

<pre><code>main = app.cgirun()
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_parent_app(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> handle(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> handle_with_processors(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> init_mapping(self, mapping)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> internalerror(self)</code><br />
<div style="margin-left:75px"><p>Returns HTTPError with '500 internal error' message</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> load(self, env)</code><br />
<div style="margin-left:75px"><p>Initializes ctx using env.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> notfound(self)</code><br />
<div style="margin-left:75px"><p>Returns HTTPError with '404 not found' message</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> request(self, localpart='/', method='GET', data=None, host='0.0.0.0:8080', headers=None, https=False, **kw)</code><br />
<div style="margin-left:75px"><p>Makes request to this application for the specified path and method.
Response will be a storage object with data, status and headers.</p>

<pre><code>&gt;&gt;&gt; urls = ("/hello", "hello")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class hello:
...     def GET(self): 
...         web.header('Content-Type', 'text/plain')
...         return "hello"
...
&gt;&gt;&gt; response = app.request("/hello")
&gt;&gt;&gt; response.data
'hello'
&gt;&gt;&gt; response.status
'200 OK'
&gt;&gt;&gt; response.headers['Content-Type']
'text/plain'
</code></pre>

<p>To use https, use https=True.</p>

<pre><code>&gt;&gt;&gt; urls = ("/redirect", "redirect")
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; class redirect:
...     def GET(self): raise web.seeother("/foo")
...
&gt;&gt;&gt; response = app.request("/redirect")
&gt;&gt;&gt; response.headers['Location']
'http://0.0.0.0:8080/foo'
&gt;&gt;&gt; response = app.request("/redirect", https=True)
&gt;&gt;&gt; response.headers['Location']
'https://0.0.0.0:8080/foo'
</code></pre>

<p>The headers argument specifies HTTP headers as a mapping object
such as a dict.</p>

<pre><code>&gt;&gt;&gt; urls = ('/ua', 'uaprinter')
&gt;&gt;&gt; class uaprinter:
...     def GET(self):
...         return 'your user-agent is ' + web.ctx.env['HTTP_USER_AGENT']
... 
&gt;&gt;&gt; app = application(urls, globals())
&gt;&gt;&gt; app.request('/ua', headers = {
...      'User-Agent': 'a small jumping bean/1.0 (compatible)'
... }).data
'your user-agent is a small jumping bean/1.0 (compatible)'
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> run(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Starts handling requests. If called in a CGI or FastCGI context, it will follow
that protocol. If called from the command line, it will start an HTTP
server on the port named in the first command line argument, or, if there
is no argument, on port 8080.</p>

<p><code>middleware</code> is a list of WSGI middleware which is applied to the resulting WSGI
function.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> wsgifunc(self, *middleware)</code><br />
<div style="margin-left:75px"><p>Returns a WSGI-compatible function for this application.</p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> loadhook(h)</code><br />
<div style="margin-left:45px"><p>Converts a load hook into an application processor.</p>

<pre><code>&gt;&gt;&gt; app = auto_application()
&gt;&gt;&gt; def f(): "something done before handling request"
...
&gt;&gt;&gt; app.add_processor(loadhook(f))
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> unloadhook(h)</code><br />
<div style="margin-left:45px"><p>Converts an unload hook into an application processor.</p>

<pre><code>&gt;&gt;&gt; app = auto_application()
&gt;&gt;&gt; def f(): "something done after handling request"
...
&gt;&gt;&gt; app.add_processor(unloadhook(f))
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> autodelegate(prefix='')</code><br />
<div style="margin-left:45px"><p>Returns a method that takes one argument and calls the method named prefix+arg,
calling <code>notfound()</code> if there isn't one. Example:</p>

<pre><code>urls = ('/prefs/(.*)', 'prefs')

class prefs:
    GET = autodelegate('GET_')
    def GET_password(self): pass
    def GET_privacy(self): pass
</code></pre>

<p><code>GET_password</code> would get called for <code>/prefs/password</code> while <code>GET_privacy</code> for 
<code>GET_privacy</code> gets called for <code>/prefs/privacy</code>.</p>

<p>If a user visits <code>/prefs/password/change</code> then <code>GET_password(self, '/change')</code>
is called.</p></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.contrib.template">web.contrib.template</a></code><br />
<div style="margin-left:15px"><p>Interface to various templating engines.</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> render_cheetah(self, path)</code><br />
<div style="margin-left:45px"><p>Rendering interface to Cheetah Templates.</p>

<p>Example:</p>

<pre><code>render = render_cheetah('templates')
render.hello(name="cheetah")
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> render_genshi(self, *a, **kwargs)</code><br />
<div style="margin-left:45px"><p>Rendering interface genshi templates.
Example:</p>

<p>for xml/html templates.</p>

<pre><code>render = render_genshi(['templates/'])
render.hello(name='genshi')
</code></pre>

<p>For text templates:</p>

<pre><code>render = render_genshi(['templates/'], type='text')
render.hello(name='genshi')
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> render_mako(self, *a, **kwargs)</code><br />
<div style="margin-left:45px"><p>Rendering interface to Mako Templates.</p>

<p>Example:</p>

<pre><code>render = render_mako(directories=['templates'])
render.hello(name="mako")
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> cache(self, render)</code><br />
<div style="margin-left:45px"><p>Cache for any rendering interface.</p>

<p>Example:</p>

<pre><code>render = cache(render_cheetah("templates/"))
render.hello(name='cache')
</code></pre></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.db">web.db</a></code><br />
<div style="margin-left:15px"><p>Database API
(part of web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> UnknownParamstyle</code><br />
<div style="margin-left:45px"><p>raised for unsupported db paramstyles</p>

<p>(currently supported: qmark, numeric, format, pyformat)</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> UnknownDB</code><br />
<div style="margin-left:45px"><p>raised for unsupported dbms</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> TransactionError</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> sqllist(lst)</code><br />
<div style="margin-left:45px"><p>Converts the arguments for use in something like a WHERE clause.</p>

<pre><code>&gt;&gt;&gt; sqllist(['a', 'b'])
'a, b'
&gt;&gt;&gt; sqllist('a')
'a'
&gt;&gt;&gt; sqllist(u'abc')
u'abc'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> sqlors(left, lst)</code><br />
<div style="margin-left:45px"><p><code>left is a SQL clause like</code>tablename.arg = ` 
and <code>lst</code> is a list of values. Returns a reparam-style
pair featuring the SQL that ORs together the clause
for each item in the lst.</p>

<pre><code>&gt;&gt;&gt; sqlors('foo = ', [])
&lt;sql: '1=2'&gt;
&gt;&gt;&gt; sqlors('foo = ', [1])
&lt;sql: 'foo = 1'&gt;
&gt;&gt;&gt; sqlors('foo = ', 1)
&lt;sql: 'foo = 1'&gt;
&gt;&gt;&gt; sqlors('foo = ', [1,2,3])
&lt;sql: '(foo = 1 OR foo = 2 OR foo = 3 OR 1=2)'&gt;
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> reparam(string_, dictionary)</code><br />
<div style="margin-left:45px"><p>Takes a string and a dictionary and interpolates the string
using values from the dictionary. Returns an <code>SQLQuery</code> for the result.</p>

<pre><code>&gt;&gt;&gt; reparam("s = $s", dict(s=True))
&lt;sql: "s = 't'"&gt;
&gt;&gt;&gt; reparam("s IN $s", dict(s=[1, 2]))
&lt;sql: 's IN (1, 2)'&gt;
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> sqlquote(a)</code><br />
<div style="margin-left:45px"><p>Ensures <code>a</code> is quoted properly for use in a SQL query.</p>

<pre><code>&gt;&gt;&gt; 'WHERE x = ' + sqlquote(True) + ' AND y = ' + sqlquote(3)
&lt;sql: "WHERE x = 't' AND y = 3"&gt;
&gt;&gt;&gt; 'WHERE x = ' + sqlquote(True) + ' AND y IN ' + sqlquote([2, 3])
&lt;sql: "WHERE x = 't' AND y IN (2, 3)"&gt;
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> SQLQuery(self, items=None)</code><br />
<div style="margin-left:45px"><p>You can pass this sort of thing as a clause in any db function.
Otherwise, you can pass a dictionary to the keyword argument <code>vars</code>
and the function will call reparam for you.</p>

<p>Internally, consists of <code>items</code>, which is a list of strings and
SQLParams, which get concatenated to produce the actual query.</p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> append(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">function</span><code class="function"> join(items, sep=' ', prefix=None, suffix=None, target=None)</code><br />
<div style="margin-left:75px"><p>Joins multiple queries.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>SQLQuery.join(['a', 'b'], ', ')
      <sql: 'a, b'></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>Optinally, prefix and suffix arguments can be provided.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>SQLQuery.join(['a', 'b'], ', ', prefix='(', suffix=')')
      <sql: '(a, b)'></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>If target argument is provided, the items are appended to target instead of creating a new SQLQuery.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> query(self, paramstyle=None)</code><br />
<div style="margin-left:75px"><p>Returns the query part of the sql query.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>q = SQLQuery(["SELECT * FROM test WHERE name=", SQLParam('joe')])
      q.query()
          'SELECT * FROM test WHERE name=%s'
      q.query(paramstyle='qmark')
          'SELECT * FROM test WHERE name=?'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> values(self)</code><br />
<div style="margin-left:75px"><p>Returns the values of the parameters used in the sql query.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>q = SQLQuery(["SELECT * FROM test WHERE name=", SQLParam('joe')])
      q.values()
          ['joe']</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> SQLParam(self, value)</code><br />
<div style="margin-left:45px"><p>Parameter in SQLQuery.</p>

<pre><code>&gt;&gt;&gt; q = SQLQuery(["SELECT * FROM test WHERE name=", SQLParam("joe")])
&gt;&gt;&gt; q
&lt;sql: "SELECT * FROM test WHERE name='joe'"&gt;
&gt;&gt;&gt; q.query()
'SELECT * FROM test WHERE name=%s'
&gt;&gt;&gt; q.values()
['joe']
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_marker(self, paramstyle='pyformat')</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sqlquery(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> sqlparam(self, value)</code><br />
<div style="margin-left:45px"><p>Parameter in SQLQuery.</p>

<pre><code>&gt;&gt;&gt; q = SQLQuery(["SELECT * FROM test WHERE name=", SQLParam("joe")])
&gt;&gt;&gt; q
&lt;sql: "SELECT * FROM test WHERE name='joe'"&gt;
&gt;&gt;&gt; q.query()
'SELECT * FROM test WHERE name=%s'
&gt;&gt;&gt; q.values()
['joe']
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_marker(self, paramstyle='pyformat')</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sqlquery(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> SQLLiteral(self, v)</code><br />
<div style="margin-left:45px"><p>Protects a string from <code>sqlquote</code>.</p>

<pre><code>&gt;&gt;&gt; sqlquote('NOW()')
&lt;sql: "'NOW()'"&gt;
&gt;&gt;&gt; sqlquote(SQLLiteral('NOW()'))
&lt;sql: 'NOW()'&gt;
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> sqlliteral(self, v)</code><br />
<div style="margin-left:45px"><p>Protects a string from <code>sqlquote</code>.</p>

<pre><code>&gt;&gt;&gt; sqlquote('NOW()')
&lt;sql: "'NOW()'"&gt;
&gt;&gt;&gt; sqlquote(SQLLiteral('NOW()'))
&lt;sql: 'NOW()'&gt;
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> database(dburl=None, **params)</code><br />
<div style="margin-left:45px"><p>Creates appropriate database using params.</p>

<p>Pooling will be enabled if DBUtils module is available. 
Pooling can be disabled by passing pooling=False in params.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> DB(self, db_module, keywords)</code><br />
<div style="margin-left:45px"><p>Database</p></div></p>
<div style="margin-left:60px">
<p><span class="ts">property</span><code class="property"> ctx</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> delete(self, table, where, using=None, vars=None, _test=False)</code><br />
<div style="margin-left:75px"><p>Deletes from <code>table</code> with clauses <code>where</code> and <code>using</code>.</p>

<pre><code>&gt;&gt;&gt; db = DB(None, {})
&gt;&gt;&gt; name = 'Joe'
&gt;&gt;&gt; db.delete('foo', where='name = $name', vars=locals(), _test=True)
&lt;sql: "DELETE FROM foo WHERE name = 'Joe'"&gt;
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> gen_clause(self, sql, val, vars)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> insert(self, tablename, seqname=None, _test=False, **values)</code><br />
<div style="margin-left:75px"><p>Inserts <code>values</code> into <code>tablename</code>. Returns current sequence ID.
Set <code>seqname</code> to the ID if it's not the default, or to <code>False</code>
if there isn't one.</p>

<pre><code>&gt;&gt;&gt; db = DB(None, {})
&gt;&gt;&gt; q = db.insert('foo', name='bob', age=2, created=SQLLiteral('NOW()'), _test=True)
&gt;&gt;&gt; q
&lt;sql: "INSERT INTO foo (age, name, created) VALUES (2, 'bob', NOW())"&gt;
&gt;&gt;&gt; q.query()
'INSERT INTO foo (age, name, created) VALUES (%s, %s, NOW())'
&gt;&gt;&gt; q.values()
[2, 'bob']
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> multiple_insert(self, tablename, values, seqname=None, _test=False)</code><br />
<div style="margin-left:75px"><p>Inserts multiple rows into <code>tablename</code>. The <code>values</code> must be a list of dictioanries, 
one for each row to be inserted, each with the same set of keys.
Returns the list of ids of the inserted rows. <br />
Set <code>seqname</code> to the ID if it's not the default, or to <code>False</code>
if there isn't one.</p>

<pre><code>&gt;&gt;&gt; db = DB(None, {})
&gt;&gt;&gt; db.supports_multiple_insert = True
&gt;&gt;&gt; values = [{"name": "foo", "email": "foo@example.com"}, {"name": "bar", "email": "bar@example.com"}]
&gt;&gt;&gt; db.multiple_insert('person', values=values, _test=True)
&lt;sql: "INSERT INTO person (name, email) VALUES ('foo', 'foo@example.com'), ('bar', 'bar@example.com')"&gt;
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> query(self, sql_query, vars=None, processed=False, _test=False)</code><br />
<div style="margin-left:75px"><p>Execute SQL query <code>sql_query</code> using dictionary <code>vars</code> to interpolate it.
If <code>processed=True</code>, <code>vars</code> is a <code>reparam</code>-style list to use 
instead of interpolating.</p>

<pre><code>&gt;&gt;&gt; db = DB(None, {})
&gt;&gt;&gt; db.query("SELECT * FROM foo", _test=True)
&lt;sql: 'SELECT * FROM foo'&gt;
&gt;&gt;&gt; db.query("SELECT * FROM foo WHERE x = $x", vars=dict(x='f'), _test=True)
&lt;sql: "SELECT * FROM foo WHERE x = 'f'"&gt;
&gt;&gt;&gt; db.query("SELECT * FROM foo WHERE x = " + sqlquote('f'), _test=True)
&lt;sql: "SELECT * FROM foo WHERE x = 'f'"&gt;
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> select(self, tables, vars=None, what='*', where=None, order=None, group=None, limit=None, offset=None, _test=False)</code><br />
<div style="margin-left:75px"><p>Selects <code>what</code> from <code>tables</code> with clauses <code>where</code>, <code>order</code>, 
<code>group</code>, <code>limit</code>, and <code>offset</code>. Uses vars to interpolate. 
Otherwise, each clause can be a SQLQuery.</p>

<pre><code>&gt;&gt;&gt; db = DB(None, {})
&gt;&gt;&gt; db.select('foo', _test=True)
&lt;sql: 'SELECT * FROM foo'&gt;
&gt;&gt;&gt; db.select(['foo', 'bar'], where="foo.bar_id = bar.id", limit=5, _test=True)
&lt;sql: 'SELECT * FROM foo, bar WHERE foo.bar_id = bar.id LIMIT 5'&gt;
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sql_clauses(self, what, tables, where, group, order, limit, offset)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> transaction(self)</code><br />
<div style="margin-left:75px"><p>Start a transaction.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> update(self, tables, where, vars=None, _test=False, **values)</code><br />
<div style="margin-left:75px"><p>Update <code>tables</code> with clause <code>where</code> (interpolated using <code>vars</code>)
and setting <code>values</code>.</p>

<pre><code>&gt;&gt;&gt; db = DB(None, {})
&gt;&gt;&gt; name = 'Joseph'
&gt;&gt;&gt; q = db.update('foo', where='name = $name', name='bob', age=2,
...     created=SQLLiteral('NOW()'), vars=locals(), _test=True)
&gt;&gt;&gt; q
&lt;sql: "UPDATE foo SET age = 2, name = 'bob', created = NOW() WHERE name = 'Joseph'"&gt;
&gt;&gt;&gt; q.query()
'UPDATE foo SET age = %s, name = %s, created = NOW() WHERE name = %s'
&gt;&gt;&gt; q.values()
[2, 'bob', 'Joseph']
</code></pre></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> where(self, table, what='*', order=None, group=None, limit=None, offset=None, _test=False, **kwargs)</code><br />
<div style="margin-left:75px"><p>Selects from <code>table</code> where keys are equal to values in <code>kwargs</code>.</p>

<pre><code>&gt;&gt;&gt; db = DB(None, {})
&gt;&gt;&gt; db.where('foo', bar_id=3, _test=True)
&lt;sql: 'SELECT * FROM foo WHERE bar_id = 3'&gt;
&gt;&gt;&gt; db.where('foo', source=2, crust='dewey', _test=True)
&lt;sql: "SELECT * FROM foo WHERE source = 2 AND crust = 'dewey'"&gt;
&gt;&gt;&gt; db.where('foo', _test=True)
&lt;sql: 'SELECT * FROM foo'&gt;
</code></pre></div></p>
</div>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.debugerror">web.debugerror</a></code><br />
<div style="margin-left:15px"><p>pretty debug errors
(part of web.py)</p>

<p>portions adapted from Django <djangoproject.com> 
Copyright (c) 2005, the Lawrence Journal-World
Used under the modified BSD license:
http://www.xfree86.org/3.3.6/COPYRIGHT2.html#5</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> debugerror()</code><br />
<div style="margin-left:45px"><p>A replacement for <code>internalerror</code> that presents a nice page with lots
of debug information for the programmer.</p>

<p>(Based on the beautiful 500 page from <a href="http://djangoproject.com/">Django</a>, 
designed by <a href="http://wilsonminer.com/">Wilson Miner</a>.)</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> djangoerror()</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> emailerrors(to_address, olderror, from_address=None)</code><br />
<div style="margin-left:45px"><p>Wraps the old <code>internalerror</code> handler (pass as <code>olderror</code>) to 
additionally email all errors to <code>to_address</code>, to aid in
debugging production websites.</p>

<p>Emails contain a normal text traceback as well as an
attachment containing the nice <code>debugerror</code> page.</p></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.form">web.form</a></code><br />
<div style="margin-left:15px"><p>HTML forms
(part of web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> AttributeList</code><br />
<div style="margin-left:45px"><p>List of atributes of input.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>a = AttributeList(type='text', name='x', value=20)
      a
      <attrs: 'type="text" name="x" value="20"'></p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> copy(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Button(self, name, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p>HTML Button.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Button("save").render()
      '<button id="save" name="save">save</button>'
      Button("action", value="save", html="<b>Save Changes</b>").render()
      '<button id="action" value="save" name="action"><b>Save Changes</b></button>'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Checkbox(self, name, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p>Checkbox input.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Checkbox('foo', value='bar', checked=True).render()
      '<input checked="checked" type="checkbox" id="foo_bar" value="bar" name="foo"/>'
      Checkbox('foo', value='bar').render()
      '<input type="checkbox" id="foo_bar" value="bar" name="foo"/>'
      c = Checkbox('foo', value='bar')
      c.validate('on')
      True
      c.render()
      '<input checked="checked" type="checkbox" id="foo_bar" value="bar" name="foo"/>'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Dropdown(self, name, args, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p>Dropdown/select input.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Dropdown(name='foo', args=['a', 'b', 'c'], value='b').render()
      '<select id="foo" name="foo">\n  <option value="a">a</option>\n  <option selected="selected" value="b">b</option>\n  <option value="c">c</option>\n</select>\n'
      Dropdown(name='foo', args=[('a', 'aa'), ('b', 'bb'), ('c', 'cc')], value='b').render()
      '<select id="foo" name="foo">\n  <option value="a">aa</option>\n  <option selected="selected" value="b">bb</option>\n  <option value="c">cc</option>\n</select>\n'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> File(self, name, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p>File input.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>File(name='f').render()
      '<input type="file" id="f" name="f"/>'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Form(self, *inputs, **kw)</code><br />
<div style="margin-left:45px"><p>HTML form.</p>

<pre><code>&gt;&gt;&gt; f = Form(Textbox("x"))
&gt;&gt;&gt; f.render()
'&lt;table&gt;\n    &lt;tr&gt;&lt;th&gt;&lt;label for="x"&gt;x&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" id="x" name="x"/&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;'
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> fill(self, source=None, **kw)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get(self, i, default=None)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render_css(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validates(self, source=None, _validate=True, **kw)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Hidden(self, name, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p>Hidden Input.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Hidden(name='foo', value='bar').render()
      '<input type="hidden" id="foo" value="bar" name="foo"/>'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Input(self, name, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p></p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Password(self, name, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p>Password input.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Password(name='password', value='secret').render()
      '<input type="password" id="password" value="secret" name="password"/>'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Radio(self, name, args, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p></p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Textarea(self, name, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p>Textarea input.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Textarea(name='foo', value='bar').render()
      '<textarea id="foo" name="foo">bar</textarea>'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Textbox(self, name, *validators, **attrs)</code><br />
<div style="margin-left:45px"><p>Textbox input.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Textbox(name='foo', value='bar').render()
      '<input type="text" id="foo" value="bar" name="foo"/>'
      Textbox(name='foo', value=0).render()
      '<input type="text" id="foo" value="0" name="foo"/>'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> addatts(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_default_id(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_type(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get_value(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> is_hidden(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> render(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> rendernote(self, note)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> set_value(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> validate(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> Validator(self, msg, test, jstest=None)</code><br />
<div style="margin-left:45px"><p></p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> valid(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> attrget(obj, attr, value=None)</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> regexp(self, rexp, msg)</code><br />
<div style="margin-left:45px"><p></p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> valid(self, value)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.http">web.http</a></code><br />
<div style="margin-left:15px"><p>HTTP Utilities
(from web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> expires(delta)</code><br />
<div style="margin-left:45px"><p>Outputs an <code>Expires</code> header for <code>delta</code> from now. 
<code>delta</code> is a <code>timedelta</code> object or a number of seconds.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> lastmodified(date_obj)</code><br />
<div style="margin-left:45px"><p>Outputs a <code>Last-Modified</code> header for <code>datetime</code>.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> prefixurl(base='')</code><br />
<div style="margin-left:45px"><p>Sorry, this function is really difficult to explain.
Maybe some other time.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> modified(date=None, etag=None)</code><br />
<div style="margin-left:45px"><p>Checks to see if the page has been modified since the version in the
requester's cache.</p>

<p>When you publish pages, you can include <code>Last-Modified</code> and <code>ETag</code>
with the date the page was last modified and an opaque token for
the particular version, respectively. When readers reload the page, 
the browser sends along the modification date and etag value for
the version it has in its cache. If the page hasn't changed, 
the server can just return <code>304 Not Modified</code> and not have to 
send the whole page again.</p>

<p>This function takes the last-modified date <code>date</code> and the ETag <code>etag</code>
and checks the headers to see if they match. If they do, it returns 
<code>True</code>, or otherwise it raises NotModified error. It also sets 
<code>Last-Modified</code> and <code>ETag</code> output headers.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> changequery(query=None, **kw)</code><br />
<div style="margin-left:45px"><p>Imagine you're at <code>/foo?a=1&amp;b=2</code>. Then <code>changequery(a=3)</code> will return
<code>/foo?a=3&amp;b=2</code> -- the same URL but with the arguments you requested
changed.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> url(path=None, doseq=False, **kw)</code><br />
<div style="margin-left:45px"><p>Makes url by concatinating web.ctx.homepath and path and the 
query string created using the arguments.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> profiler(app)</code><br />
<div style="margin-left:45px"><p>Outputs basic profiling information at the bottom of each response.</p></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.httpserver">web.httpserver</a></code><br />
<div style="margin-left:15px"><p></p></div></p>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> runsimple(func, server_address=('0.0.0.0', 8080))</code><br />
<div style="margin-left:45px"><p>Runs <a href="http://www.cherrypy.org">CherryPy</a> WSGI server hosting WSGI app <code>func</code>. 
The directory <code>static/</code> is hosted statically.</p></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.net">web.net</a></code><br />
<div style="margin-left:15px"><p>Network Utilities
(from web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> validipaddr(address)</code><br />
<div style="margin-left:45px"><p>Returns True if <code>address</code> is a valid IPv4 address.</p>

<pre><code>&gt;&gt;&gt; validipaddr('192.168.1.1')
True
&gt;&gt;&gt; validipaddr('192.168.1.800')
False
&gt;&gt;&gt; validipaddr('192.168.1')
False
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> validipport(port)</code><br />
<div style="margin-left:45px"><p>Returns True if <code>port</code> is a valid IPv4 port.</p>

<pre><code>&gt;&gt;&gt; validipport('9000')
True
&gt;&gt;&gt; validipport('foo')
False
&gt;&gt;&gt; validipport('1000000')
False
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> validip(ip, defaultaddr='0.0.0.0', defaultport=8080)</code><br />
<div style="margin-left:45px"><p>Returns <code>(ip_address, port)</code> from string <code>ip_addr_port</code></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> validaddr(string_)</code><br />
<div style="margin-left:45px"><p>Returns either (ip<em>address, port) or "/path/to/socket" from string</em></p>

<pre><code>&gt;&gt;&gt; validaddr('/path/to/socket')
'/path/to/socket'
&gt;&gt;&gt; validaddr('8000')
('0.0.0.0', 8000)
&gt;&gt;&gt; validaddr('127.0.0.1')
('127.0.0.1', 8080)
&gt;&gt;&gt; validaddr('127.0.0.1:8000')
('127.0.0.1', 8000)
&gt;&gt;&gt; validaddr('fff')
Traceback (most recent call last):
    ...
ValueError: fff is not a valid IP address/port
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> urlquote(val)</code><br />
<div style="margin-left:45px"><p>Quotes a string for use in a URL.</p>

<pre><code>&gt;&gt;&gt; urlquote('://?f=1&amp;j=1')
'%3A//%3Ff%3D1%26j%3D1'
&gt;&gt;&gt; urlquote(None)
''
&gt;&gt;&gt; urlquote(u'\u203d')
'%E2%80%BD'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> httpdate(date_obj)</code><br />
<div style="margin-left:45px"><p>Formats a datetime object for use in HTTP headers.</p>

<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; httpdate(datetime.datetime(1970, 1, 1, 1, 1, 1))
'Thu, 01 Jan 1970 01:01:01 GMT'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> parsehttpdate(string_)</code><br />
<div style="margin-left:45px"><p>Parses an HTTP date into a datetime object.</p>

<pre><code>&gt;&gt;&gt; parsehttpdate('Thu, 01 Jan 1970 01:01:01 GMT')
datetime.datetime(1970, 1, 1, 1, 1, 1)
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> htmlquote(text)</code><br />
<div style="margin-left:45px"><p>Encodes <code>text</code> for raw use in HTML.</p>

<pre><code>&gt;&gt;&gt; htmlquote(u"&lt;'&amp;\"&gt;")
u'&amp;lt;&amp;#39;&amp;amp;&amp;quot;&amp;gt;'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> htmlunquote(text)</code><br />
<div style="margin-left:45px"><p>Decodes <code>text</code> that's HTML quoted.</p>

<pre><code>&gt;&gt;&gt; htmlunquote(u'&amp;lt;&amp;#39;&amp;amp;&amp;quot;&amp;gt;')
u'&lt;\'&amp;"&gt;'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> websafe(val)</code><br />
<div style="margin-left:45px"><p>Converts <code>val</code> so that it is safe for use in Unicode HTML.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>websafe("&lt;'&amp;\">")
      u'&lt;&#39;&amp;&quot;&gt;'
      websafe(None)
      u''
      websafe(u'\u203d')
      u'\u203d'
      websafe('\xe2\x80\xbd')
      u'\u203d'</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.session">web.session</a></code><br />
<div style="margin-left:15px"><p>Session Management
(from web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Session(self, app, store, initializer=None)</code><br />
<div style="margin-left:45px"><p>Session management for web.py</p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> expired(self)</code><br />
<div style="margin-left:75px"><p>Called when an expired session is atime</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> kill(self)</code><br />
<div style="margin-left:75px"><p>Kill the session, make it no longer available</p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> SessionExpired(self, message)</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> Store(self)</code><br />
<div style="margin-left:45px"><p>Base class for session stores</p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> cleanup(self, timeout)</code><br />
<div style="margin-left:75px"><p>removes all the expired sessions</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> decode(self, session_data)</code><br />
<div style="margin-left:75px"><p>decodes the data to get back the session dict</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> encode(self, session_dict)</code><br />
<div style="margin-left:75px"><p>encodes session dict as a string</p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> DiskStore(self, root)</code><br />
<div style="margin-left:45px"><p>Store for saving a session on disk.</p>

<pre><code>&gt;&gt;&gt; import tempfile
&gt;&gt;&gt; root = tempfile.mkdtemp()
&gt;&gt;&gt; s = DiskStore(root)
&gt;&gt;&gt; s['a'] = 'foo'
&gt;&gt;&gt; s['a']
'foo'
&gt;&gt;&gt; time.sleep(0.01)
&gt;&gt;&gt; s.cleanup(0.01)
&gt;&gt;&gt; s['a']
Traceback (most recent call last):
    ...
KeyError: 'a'
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> cleanup(self, timeout)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> decode(self, session_data)</code><br />
<div style="margin-left:75px"><p>decodes the data to get back the session dict</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> encode(self, session_dict)</code><br />
<div style="margin-left:75px"><p>encodes session dict as a string</p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> DBStore(self, db, table_name)</code><br />
<div style="margin-left:45px"><p>Store for saving a session in database
Needs a table with the following columns:</p>

<pre><code>session_id CHAR(128) UNIQUE NOT NULL,
atime DATETIME NOT NULL default current_timestamp,
data TEXT
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> cleanup(self, timeout)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> decode(self, session_data)</code><br />
<div style="margin-left:75px"><p>decodes the data to get back the session dict</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> encode(self, session_dict)</code><br />
<div style="margin-left:75px"><p>encodes session dict as a string</p></div></p>
</div>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.template">web.template</a></code><br />
<div style="margin-left:15px"><p>simple, elegant templating
(part of web.py)</p>

<p>Template design:</p>

<p>Template string is split into tokens and the tokens are combined into nodes. 
Parse tree is a nodelist. TextNode and ExpressionNode are simple nodes and 
for-loop, if-loop etc are block nodes, which contain multiple child nodes.</p>

<p>Each node can emit some python string. python string emitted by the 
root node is validated for safeeval and executed using python in the given environment.</p>

<p>Enough care is taken to make sure the generated code and the template has line to line match, 
so that the error messages can point to exact line number in template. (It doesn't work in some cases still.)</p>

<p>Grammar:</p>

<pre><code>template -&gt; defwith sections 
defwith -&gt; '$def with (' arguments ')' | ''
sections -&gt; section*
section -&gt; block | assignment | line

assignment -&gt; '$ ' &lt;assignment expression&gt;
line -&gt; (text|expr)*
text -&gt; &lt;any characters other than $&gt;
expr -&gt; '$' pyexpr | '$(' pyexpr ')' | '${' pyexpr '}'
pyexpr -&gt; &lt;python expression&gt;
</code></pre></div></p>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> Template(self, text, filename='<template>', filter=None, globals=None, builtins=None, extensions=None)</code><br />
<div style="margin-left:45px"><p></p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> compile_template(self, template_string, filename)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> create_parser(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">function</span><code class="function"> generate_code(text, filename, parser=None)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> make_env(self, globals, builtins)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">function</span><code class="function"> normalize_text(text)</code><br />
<div style="margin-left:75px"><p>Normalizes template text by correcting 
, tabs and BOM chars.</p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> Render(self, loc, *a, **kw)</code><br />
<div style="margin-left:45px"><p></p></div></p>
<div style="margin-left:60px">
<p><span class="ts">class</span><code class="class"> super(self, loc='templates', cache=None, base=None, **keywords)</code><br />
<div style="margin-left:75px"><p>The most preferred way of using templates.</p>

<pre><code>render = web.template.render('templates')
print render.foo()
</code></pre>

<p>Optional parameter can be <code>base</code> can be used to pass output of 
every template through the base template.</p>

<pre><code>render = web.template.render('templates', base='layout')
</code></pre></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> render(self, loc, *a, **kw)</code><br />
<div style="margin-left:45px"><p></p></div></p>
<div style="margin-left:60px">
<p><span class="ts">class</span><code class="class"> super(self, loc='templates', cache=None, base=None, **keywords)</code><br />
<div style="margin-left:75px"><p>The most preferred way of using templates.</p>

<pre><code>render = web.template.render('templates')
print render.foo()
</code></pre>

<p>Optional parameter can be <code>base</code> can be used to pass output of 
every template through the base template.</p>

<pre><code>render = web.template.render('templates', base='layout')
</code></pre></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> frender(path, **keywords)</code><br />
<div style="margin-left:45px"><p>Creates a template from the given file path.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> ParseError</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> SecurityError</code><br />
<div style="margin-left:45px"><p>The template seems to be trying to do something naughty.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> test()</code><br />
<div style="margin-left:45px"><p>Doctest for testing template module.</p>

<p>Define a utility function to run template test.</p>

<pre><code>&gt;&gt;&gt; class TestResult:
...     def __init__(self, t): self.t = t
...     def __getattr__(self, name): return getattr(self.t, name)
...     def __repr__(self): return repr(unicode(self))
...
&gt;&gt;&gt; def t(code, **keywords):
...     tmpl = Template(code, **keywords)
...     return lambda *a, **kw: TestResult(tmpl(*a, **kw))
...
</code></pre>

<p>Simple tests.</p>

<pre><code>&gt;&gt;&gt; t('1')()
u'1\n'
&gt;&gt;&gt; t('$def with ()\n1')()
u'1\n'
&gt;&gt;&gt; t('$def with (a)\n$a')(1)
u'1\n'
&gt;&gt;&gt; t('$def with (a=0)\n$a')(1)
u'1\n'
&gt;&gt;&gt; t('$def with (a=0)\n$a')(a=1)
u'1\n'
</code></pre>

<p>Test complicated expressions.</p>

<pre><code>&gt;&gt;&gt; t('$def with (x)\n$x.upper()')('hello')
u'HELLO\n'
&gt;&gt;&gt; t('$(2 * 3 + 4 * 5)')()
u'26\n'
&gt;&gt;&gt; t('${2 * 3 + 4 * 5}')()
u'26\n'
&gt;&gt;&gt; t('$def with (limit)\nkeep $(limit)ing.')('go')
u'keep going.\n'
&gt;&gt;&gt; t('$def with (a)\n$a.b[0]')(storage(b=[1]))
u'1\n'
</code></pre>

<p>Test html escaping.</p>

<pre><code>&gt;&gt;&gt; t('$def with (x)\n$x', filename='a.html')('&lt;html&gt;')
u'&amp;lt;html&amp;gt;\n'
&gt;&gt;&gt; t('$def with (x)\n$x', filename='a.txt')('&lt;html&gt;')
u'&lt;html&gt;\n'
</code></pre>

<p>Test if, for and while.</p>

<pre><code>&gt;&gt;&gt; t('$if 1: 1')()
u'1\n'
&gt;&gt;&gt; t('$if 1:\n    1')()
u'1\n'
&gt;&gt;&gt; t('$if 1:\n    1\\')()
u'1'
&gt;&gt;&gt; t('$if 0: 0\n$elif 1: 1')()
u'1\n'
&gt;&gt;&gt; t('$if 0: 0\n$elif None: 0\n$else: 1')()
u'1\n'
&gt;&gt;&gt; t('$if 0 &lt; 1 and 1 &lt; 2: 1')()
u'1\n'
&gt;&gt;&gt; t('$for x in [1, 2, 3]: $x')()
u'1\n2\n3\n'
&gt;&gt;&gt; t('$def with (d)\n$for k, v in d.iteritems(): $k')({1: 1})
u'1\n'
&gt;&gt;&gt; t('$for x in [1, 2, 3]:\n\t$x')()
u'    1\n    2\n    3\n'
&gt;&gt;&gt; t('$def with (a)\n$while a and a.pop():1')([1, 2, 3])
u'1\n1\n1\n'
</code></pre>

<p>The space after : must be ignored.</p>

<pre><code>&gt;&gt;&gt; t('$if True: foo')()
u'foo\n'
</code></pre>

<p>Test loop.xxx.</p>

<pre><code>&gt;&gt;&gt; t("$for i in range(5):$loop.index, $loop.parity")()
u'1, odd\n2, even\n3, odd\n4, even\n5, odd\n'
&gt;&gt;&gt; t("$for i in range(2):\n    $for j in range(2):$loop.parent.parity $loop.parity")()
u'odd odd\nodd even\neven odd\neven even\n'
</code></pre>

<p>Test assignment.</p>

<pre><code>&gt;&gt;&gt; t('$ a = 1\n$a')()
u'1\n'
&gt;&gt;&gt; t('$ a = [1]\n$a[0]')()
u'1\n'
&gt;&gt;&gt; t('$ a = {1: 1}\n$a.keys()[0]')()
u'1\n'
&gt;&gt;&gt; t('$ a = []\n$if not a: 1')()
u'1\n'
&gt;&gt;&gt; t('$ a = {}\n$if not a: 1')()
u'1\n'
&gt;&gt;&gt; t('$ a = -1\n$a')()
u'-1\n'
&gt;&gt;&gt; t('$ a = "1"\n$a')()
u'1\n'
</code></pre>

<p>Test comments.</p>

<pre><code>&gt;&gt;&gt; t('$# 0')()
u'\n'
&gt;&gt;&gt; t('hello$#comment1\nhello$#comment2')()
u'hello\nhello\n'
&gt;&gt;&gt; t('$#comment0\nhello$#comment1\nhello$#comment2')()
u'\nhello\nhello\n'
</code></pre>

<p>Test unicode.</p>

<pre><code>&gt;&gt;&gt; t('$def with (a)\n$a')(u'\u203d')
u'\u203d\n'
&gt;&gt;&gt; t('$def with (a)\n$a')(u'\u203d'.encode('utf-8'))
u'\u203d\n'
&gt;&gt;&gt; t(u'$def with (a)\n$a $:a')(u'\u203d')
u'\u203d \u203d\n'
&gt;&gt;&gt; t(u'$def with ()\nfoo')()
u'foo\n'
&gt;&gt;&gt; def f(x): return x
...
&gt;&gt;&gt; t(u'$def with (f)\n$:f("x")')(f)
u'x\n'
&gt;&gt;&gt; t('$def with (f)\n$:f("x")')(f)
u'x\n'
</code></pre>

<p>Test dollar escaping.</p>

<pre><code>&gt;&gt;&gt; t("Stop, $$money isn't evaluated.")()
u"Stop, $money isn't evaluated.\n"
&gt;&gt;&gt; t("Stop, \$money isn't evaluated.")()
u"Stop, $money isn't evaluated.\n"
</code></pre>

<p>Test space sensitivity.</p>

<pre><code>&gt;&gt;&gt; t('$def with (x)\n$x')(1)
u'1\n'
&gt;&gt;&gt; t('$def with(x ,y)\n$x')(1, 1)
u'1\n'
&gt;&gt;&gt; t('$(1 + 2*3 + 4)')()
u'11\n'
</code></pre>

<p>Make sure globals are working.</p>

<pre><code>&gt;&gt;&gt; t('$x')()
Traceback (most recent call last):
    ...
NameError: global name 'x' is not defined
&gt;&gt;&gt; t('$x', globals={'x': 1})()
u'1\n'
</code></pre>

<p>Can't change globals.</p>

<pre><code>&gt;&gt;&gt; t('$ x = 2\n$x', globals={'x': 1})()
u'2\n'
&gt;&gt;&gt; t('$ x = x + 1\n$x', globals={'x': 1})()
Traceback (most recent call last):
    ...
UnboundLocalError: local variable 'x' referenced before assignment
</code></pre>

<p>Make sure builtins are customizable.</p>

<pre><code>&gt;&gt;&gt; t('$min(1, 2)')()
u'1\n'
&gt;&gt;&gt; t('$min(1, 2)', builtins={})()
Traceback (most recent call last):
    ...
NameError: global name 'min' is not defined
</code></pre>

<p>Test vars.</p>

<pre><code>&gt;&gt;&gt; x = t('$var x: 1')()
&gt;&gt;&gt; x.x
u'1'
&gt;&gt;&gt; x = t('$var x = 1')()
&gt;&gt;&gt; x.x
1
&gt;&gt;&gt; x = t('$var x:  \n    foo\n    bar')()
&gt;&gt;&gt; x.x
u'foo\nbar\n'
</code></pre>

<p>Test BOM chars.</p>

<pre><code>&gt;&gt;&gt; t('\xef\xbb\xbf$def with(x)\n$x')('foo')
u'foo\n'
</code></pre>

<p>Test for with weird cases.</p>

<pre><code>&gt;&gt;&gt; t('$for i in range(10)[1:5]:\n    $i')()
u'1\n2\n3\n4\n'
&gt;&gt;&gt; t("$for k, v in {'a': 1, 'b': 2}.items():\n    $k $v")()
u'a 1\nb 2\n'
&gt;&gt;&gt; t("$for k, v in ({'a': 1, 'b': 2}.items():\n    $k $v")()
Traceback (most recent call last):
    ...
SyntaxError: invalid syntax
</code></pre>

<p>Test datetime.</p>

<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; t("$def with (date)\n$date.strftime('%m %Y')")(datetime.datetime(2009, 1, 1))
u'01 2009\n'
</code></pre></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.utils">web.utils</a></code><br />
<div style="margin-left:15px"><p>General Utilities
(part of web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Storage</code><br />
<div style="margin-left:45px"><p>A Storage object is like a dictionary except <code>obj.foo</code> can be used
in addition to <code>obj['foo']</code>.</p>

<pre><code>&gt;&gt;&gt; o = storage(a=1)
&gt;&gt;&gt; o.a
1
&gt;&gt;&gt; o['a']
1
&gt;&gt;&gt; o.a = 2
&gt;&gt;&gt; o['a']
2
&gt;&gt;&gt; del o.a
&gt;&gt;&gt; o.a
Traceback (most recent call last):
    ...
AttributeError: 'a'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> storify(mapping, *requireds, **defaults)</code><br />
<div style="margin-left:45px"><p>Creates a <code>storage</code> object from dictionary <code>mapping</code>, raising <code>KeyError</code> if
d doesn't have all of the keys in <code>requireds</code> and using the default 
values for keys found in <code>defaults</code>.</p>

<p>For example, <code>storify({'a':1, 'c':3}, b=2, c=0)</code> will return the equivalent of
<code>storage({'a':1, 'b':2, 'c':3})</code>.</p>

<p>If a <code>storify</code> value is a list (e.g. multiple values in a form submission), 
<code>storify</code> returns the last element of the list, unless the key appears in 
<code>defaults</code> as a list. Thus:</p>

<pre><code>&gt;&gt;&gt; storify({'a':[1, 2]}).a
2
&gt;&gt;&gt; storify({'a':[1, 2]}, a=[]).a
[1, 2]
&gt;&gt;&gt; storify({'a':1}, a=[]).a
[1]
&gt;&gt;&gt; storify({}, a=[]).a
[]
</code></pre>

<p>Similarly, if the value has a <code>value</code> attribute, `storify will return <em>its</em>
value, unless the key appears in <code>defaults</code> as a dictionary.</p>

<pre><code>&gt;&gt;&gt; storify({'a':storage(value=1)}).a
1
&gt;&gt;&gt; storify({'a':storage(value=1)}, a={}).a
&lt;Storage {'value': 1}&gt;
&gt;&gt;&gt; storify({}, a={}).a
{}
</code></pre>

<p>Optionally, keyword parameter <code>_unicode</code> can be passed to convert all values to unicode.</p>

<pre><code>&gt;&gt;&gt; storify({'x': 'a'}, _unicode=True)
&lt;Storage {'x': u'a'}&gt;
&gt;&gt;&gt; storify({'x': storage(value='a')}, x={}, _unicode=True)
&lt;Storage {'x': &lt;Storage {'value': 'a'}&gt;}&gt;
&gt;&gt;&gt; storify({'x': storage(value='a')}, _unicode=True)
&lt;Storage {'x': u'a'}&gt;
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Counter</code><br />
<div style="margin-left:45px"><p>Keeps count of how many times something is added.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('x')
      c.add('x')
      c.add('x')
      c.add('y')
      c
      &lt;Counter {'y': 1, 'x': 5}>
      c.most()
      ['x']</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add(self, n)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> least(self)</code><br />
<div style="margin-left:75px"><p>Returns the keys with mininum count.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> most(self)</code><br />
<div style="margin-left:75px"><p>Returns the keys with maximum count.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> percent(self, key)</code><br />
<div style="margin-left:75px"><p>Returns what percentage a certain key is of all entries.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('x')
      c.add('y')
      c.percent('x')
      0.75
      c.percent('y')
      0.25</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sorted_items(self)</code><br />
<div style="margin-left:75px"><p>Returns items sorted by value.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('y')
      c.sorted_items()
      [('x', 2), ('y', 1)]</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sorted_keys(self)</code><br />
<div style="margin-left:75px"><p>Returns keys sorted by value.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('y')
      c.sorted_keys()
      ['x', 'y']</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sorted_values(self)</code><br />
<div style="margin-left:75px"><p>Returns values sorted by value.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('y')
      c.sorted_values()
      [2, 1]</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> counter</code><br />
<div style="margin-left:45px"><p>Keeps count of how many times something is added.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('x')
      c.add('x')
      c.add('x')
      c.add('y')
      c
      &lt;Counter {'y': 1, 'x': 5}>
      c.most()
      ['x']</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> add(self, n)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> least(self)</code><br />
<div style="margin-left:75px"><p>Returns the keys with mininum count.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> most(self)</code><br />
<div style="margin-left:75px"><p>Returns the keys with maximum count.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> percent(self, key)</code><br />
<div style="margin-left:75px"><p>Returns what percentage a certain key is of all entries.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('x')
      c.add('y')
      c.percent('x')
      0.75
      c.percent('y')
      0.25</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sorted_items(self)</code><br />
<div style="margin-left:75px"><p>Returns items sorted by value.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('y')
      c.sorted_items()
      [('x', 2), ('y', 1)]</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sorted_keys(self)</code><br />
<div style="margin-left:75px"><p>Returns keys sorted by value.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('y')
      c.sorted_keys()
      ['x', 'y']</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> sorted_values(self)</code><br />
<div style="margin-left:75px"><p>Returns values sorted by value.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>c = counter()
      c.add('x')
      c.add('x')
      c.add('y')
      c.sorted_values()
      [2, 1]</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> rstrips(text, remove)</code><br />
<div style="margin-left:45px"><p>removes the string <code>remove</code> from the right of <code>text</code></p>

<pre><code>&gt;&gt;&gt; rstrips("foobar", "bar")
'foo'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> lstrips(text, remove)</code><br />
<div style="margin-left:45px"><p>removes the string <code>remove</code> from the left of <code>text</code></p>

<pre><code>&gt;&gt;&gt; lstrips("foobar", "foo")
'bar'
&gt;&gt;&gt; lstrips('http://foo.org/', ['http://', 'https://'])
'foo.org/'
&gt;&gt;&gt; lstrips('FOOBARBAZ', ['FOO', 'BAR'])
'BAZ'
&gt;&gt;&gt; lstrips('FOOBARBAZ', ['BAR', 'FOO'])
'BARBAZ'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> strips(text, remove)</code><br />
<div style="margin-left:45px"><p>removes the string <code>remove</code> from the both sides of <code>text</code></p>

<pre><code>&gt;&gt;&gt; strips("foobarfoo", "foo")
'bar'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> safeunicode(obj, encoding='utf-8')</code><br />
<div style="margin-left:45px"><p>Converts any given object to unicode string.</p>

<pre><code>&gt;&gt;&gt; safeunicode('hello')
u'hello'
&gt;&gt;&gt; safeunicode(2)
u'2'
&gt;&gt;&gt; safeunicode('\xe1\x88\xb4')
u'\u1234'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> safestr(obj, encoding='utf-8')</code><br />
<div style="margin-left:45px"><p>Converts any given object to utf-8 encoded string.</p>

<pre><code>&gt;&gt;&gt; safestr('hello')
'hello'
&gt;&gt;&gt; safestr(u'\u1234')
'\xe1\x88\xb4'
&gt;&gt;&gt; safestr(2)
'2'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> utf8(obj, encoding='utf-8')</code><br />
<div style="margin-left:45px"><p>Converts any given object to utf-8 encoded string.</p>

<pre><code>&gt;&gt;&gt; safestr('hello')
'hello'
&gt;&gt;&gt; safestr(u'\u1234')
'\xe1\x88\xb4'
&gt;&gt;&gt; safestr(2)
'2'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> TimeoutError</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> timelimit(timeout)</code><br />
<div style="margin-left:45px"><p>A decorator to limit a function to <code>timeout</code> seconds, raising <code>TimeoutError</code>
if it takes longer.</p>

<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; def meaningoflife():
...     time.sleep(.2)
...     return 42
&gt;&gt;&gt; 
&gt;&gt;&gt; timelimit(.1)(meaningoflife)()
Traceback (most recent call last):
    ...
TimeoutError: took too long
&gt;&gt;&gt; timelimit(1)(meaningoflife)()
42
</code></pre>

<p><em>Caveat:</em> The function isn't stopped after <code>timeout</code> seconds but continues 
executing in a separate thread. (There seems to be no way to kill a thread.)</p>

<p>inspired by <a href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/473878">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/473878</a></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> Memoize(self, func, expires=None, background=True)</code><br />
<div style="margin-left:45px"><p>'Memoizes' a function, caching its return values for each input.
If <code>expires</code> is specified, values are recalculated after <code>expires</code> seconds.
If <code>background</code> is specified, values are recalculated in a separate thread.</p>

<pre><code>&gt;&gt;&gt; calls = 0
&gt;&gt;&gt; def howmanytimeshaveibeencalled():
...     global calls
...     calls += 1
...     return calls
&gt;&gt;&gt; fastcalls = memoize(howmanytimeshaveibeencalled)
&gt;&gt;&gt; howmanytimeshaveibeencalled()
1
&gt;&gt;&gt; howmanytimeshaveibeencalled()
2
&gt;&gt;&gt; fastcalls()
3
&gt;&gt;&gt; fastcalls()
3
&gt;&gt;&gt; import time
&gt;&gt;&gt; fastcalls = memoize(howmanytimeshaveibeencalled, .1, background=False)
&gt;&gt;&gt; fastcalls()
4
&gt;&gt;&gt; fastcalls()
4
&gt;&gt;&gt; time.sleep(.2)
&gt;&gt;&gt; fastcalls()
5
&gt;&gt;&gt; def slowfunc():
...     time.sleep(.1)
...     return howmanytimeshaveibeencalled()
&gt;&gt;&gt; fastcalls = memoize(slowfunc, .2, background=True)
&gt;&gt;&gt; fastcalls()
6
&gt;&gt;&gt; timelimit(.05)(fastcalls)()
6
&gt;&gt;&gt; time.sleep(.2)
&gt;&gt;&gt; timelimit(.05)(fastcalls)()
6
&gt;&gt;&gt; timelimit(.05)(fastcalls)()
6
&gt;&gt;&gt; time.sleep(.2)
&gt;&gt;&gt; timelimit(.05)(fastcalls)()
7
&gt;&gt;&gt; fastcalls = memoize(slowfunc, None, background=True)
&gt;&gt;&gt; threading.Thread(target=fastcalls).start()
&gt;&gt;&gt; time.sleep(.01)
&gt;&gt;&gt; fastcalls()
9
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> re_subm(pat, repl, string)</code><br />
<div style="margin-left:45px"><p>Like re.sub, but returns the replacement <em>and</em> the match object.</p>

<pre><code>&gt;&gt;&gt; t, m = re_subm('g(oo+)fball', r'f\1lish', 'goooooofball')
&gt;&gt;&gt; t
'foooooolish'
&gt;&gt;&gt; m.groups()
('oooooo',)
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> group(seq, size)</code><br />
<div style="margin-left:45px"><p>Returns an iterator over a series of lists of length size from iterable.</p>

<pre><code>&gt;&gt;&gt; list(group([1,2,3,4], 2))
[[1, 2], [3, 4]]
&gt;&gt;&gt; list(group([1,2,3,4,5], 2))
[[1, 2], [3, 4], [5]]
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> uniq(seq, key=None)</code><br />
<div style="margin-left:45px"><p>Removes duplicate elements from a list while preserving the order of the rest.</p>

<pre><code>&gt;&gt;&gt; uniq([9,0,2,1,0])
[9, 0, 2, 1]
</code></pre>

<p>The value of the optional <code>key</code> parameter should be a function that
takes a single argument and returns a key to test the uniqueness.</p>

<pre><code>&gt;&gt;&gt; uniq(["Foo", "foo", "bar"], key=lambda s: s.lower())
['Foo', 'bar']
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> iterview(x)</code><br />
<div style="margin-left:45px"><p>Takes an iterable <code>x</code> and returns an iterator over it
which prints its progress to stderr as it iterates through.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> IterBetter(self, iterator)</code><br />
<div style="margin-left:45px"><p>Returns an object that can be used as an iterator 
but can also be used via <strong>getitem</strong> (although it 
cannot go backwards -- that is, you cannot request 
<code>iterbetter[0]</code> after requesting <code>iterbetter[1]</code>).</p>

<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; c = iterbetter(itertools.count())
&gt;&gt;&gt; c[1]
1
&gt;&gt;&gt; c[5]
5
&gt;&gt;&gt; c[3]
Traceback (most recent call last):
    ...
IndexError: already passed 3
</code></pre>

<p>For boolean test, IterBetter peeps at first value in the itertor without effecting the iteration.</p>

<pre><code>&gt;&gt;&gt; c = iterbetter(iter(range(5)))
&gt;&gt;&gt; bool(c)
True
&gt;&gt;&gt; list(c)
[0, 1, 2, 3, 4]
&gt;&gt;&gt; c = iterbetter(iter([]))
&gt;&gt;&gt; bool(c)
False
&gt;&gt;&gt; list(c)
[]
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> safeiter(it, cleanup=None, ignore_errors=True)</code><br />
<div style="margin-left:45px"><p>Makes an iterator safe by ignoring the exceptions occured during the iteration.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> safewrite(filename, content)</code><br />
<div style="margin-left:45px"><p>Writes the content to a temp file and then moves the temp file to 
given filename to avoid overwriting the existing file in case of errors.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> dictreverse(mapping)</code><br />
<div style="margin-left:45px"><p>Returns a new dictionary with keys and values swapped.</p>

<pre><code>&gt;&gt;&gt; dictreverse({1: 2, 3: 4})
{2: 1, 4: 3}
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> dictfind(dictionary, element)</code><br />
<div style="margin-left:45px"><p>Returns a key whose value in <code>dictionary</code> is <code>element</code> 
or, if none exists, None.</p>

<pre><code>&gt;&gt;&gt; d = {1:2, 3:4}
&gt;&gt;&gt; dictfind(d, 4)
3
&gt;&gt;&gt; dictfind(d, 5)
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> dictfindall(dictionary, element)</code><br />
<div style="margin-left:45px"><p>Returns the keys whose values in <code>dictionary</code> are <code>element</code>
or, if none exists, [].</p>

<pre><code>&gt;&gt;&gt; d = {1:4, 3:4}
&gt;&gt;&gt; dictfindall(d, 4)
[1, 3]
&gt;&gt;&gt; dictfindall(d, 5)
[]
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> dictincr(dictionary, element)</code><br />
<div style="margin-left:45px"><p>Increments <code>element</code> in <code>dictionary</code>, 
setting it to one if it doesn't exist.</p>

<pre><code>&gt;&gt;&gt; d = {1:2, 3:4}
&gt;&gt;&gt; dictincr(d, 1)
3
&gt;&gt;&gt; d[1]
3
&gt;&gt;&gt; dictincr(d, 5)
1
&gt;&gt;&gt; d[5]
1
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> dictadd(*dicts)</code><br />
<div style="margin-left:45px"><p>Returns a dictionary consisting of the keys in the argument dictionaries.
If they share a key, the value from the last argument is used.</p>

<pre><code>&gt;&gt;&gt; dictadd({1: 0, 2: 0}, {2: 1, 3: 1})
{1: 0, 2: 1, 3: 1}
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> requeue(queue, index=-1)</code><br />
<div style="margin-left:45px"><p>Returns the element at index after moving it to the beginning of the queue.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [1, 2, 3, 4]
      requeue(x)
      4
      x
      [4, 1, 2, 3]</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> restack(stack, index=0)</code><br />
<div style="margin-left:45px"><p>Returns the element at index after moving it to the top of stack.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [1, 2, 3, 4]
      restack(x)
      1
      x
      [2, 3, 4, 1]</p>
    </blockquote>
  </blockquote>
</blockquote></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> listget(lst, ind, default=None)</code><br />
<div style="margin-left:45px"><p>Returns <code>lst[ind]</code> if it exists, <code>default</code> otherwise.</p>

<pre><code>&gt;&gt;&gt; listget(['a'], 0)
'a'
&gt;&gt;&gt; listget(['a'], 1)
&gt;&gt;&gt; listget(['a'], 1, 'b')
'b'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> intget(integer, default=None)</code><br />
<div style="margin-left:45px"><p>Returns <code>integer</code> as an int or <code>default</code> if it can't.</p>

<pre><code>&gt;&gt;&gt; intget('3')
3
&gt;&gt;&gt; intget('3a')
&gt;&gt;&gt; intget('3a', 0)
0
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> datestr(then, now=None)</code><br />
<div style="margin-left:45px"><p>Converts a (UTC) datetime object to a nice string representation.</p>

<pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; d = datetime(1970, 5, 1)
&gt;&gt;&gt; datestr(d, now=d)
'0 microseconds ago'
&gt;&gt;&gt; for t, v in {
...   timedelta(microseconds=1): '1 microsecond ago',
...   timedelta(microseconds=2): '2 microseconds ago',
...   -timedelta(microseconds=1): '1 microsecond from now',
...   -timedelta(microseconds=2): '2 microseconds from now',
...   timedelta(microseconds=2000): '2 milliseconds ago',
...   timedelta(seconds=2): '2 seconds ago',
...   timedelta(seconds=2*60): '2 minutes ago',
...   timedelta(seconds=2*60*60): '2 hours ago',
...   timedelta(days=2): '2 days ago',
... }.iteritems():
...     assert datestr(d, now=d+t) == v
&gt;&gt;&gt; datestr(datetime(1970, 1, 1), now=d)
'January  1'
&gt;&gt;&gt; datestr(datetime(1969, 1, 1), now=d)
'January  1, 1969'
&gt;&gt;&gt; datestr(datetime(1970, 6, 1), now=d)
'June  1, 1970'
&gt;&gt;&gt; datestr(None)
''
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> numify(string)</code><br />
<div style="margin-left:45px"><p>Removes all non-digit characters from <code>string</code>.</p>

<pre><code>&gt;&gt;&gt; numify('800-555-1212')
'8005551212'
&gt;&gt;&gt; numify('800.555.1212')
'8005551212'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> denumify(string, pattern)</code><br />
<div style="margin-left:45px"><p>Formats <code>string</code> according to <code>pattern</code>, where the letter X gets replaced
by characters from <code>string</code>.</p>

<pre><code>&gt;&gt;&gt; denumify("8005551212", "(XXX) XXX-XXXX")
'(800) 555-1212'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> commify(n)</code><br />
<div style="margin-left:45px"><p>Add commas to an integer <code>n</code>.</p>

<pre><code>&gt;&gt;&gt; commify(1)
'1'
&gt;&gt;&gt; commify(123)
'123'
&gt;&gt;&gt; commify(1234)
'1,234'
&gt;&gt;&gt; commify(1234567890)
'1,234,567,890'
&gt;&gt;&gt; commify(123.0)
'123.0'
&gt;&gt;&gt; commify(1234.5)
'1,234.5'
&gt;&gt;&gt; commify(1234.56789)
'1,234.56789'
&gt;&gt;&gt; commify('%.2f' % 1234.5)
'1,234.50'
&gt;&gt;&gt; commify(None)
&gt;&gt;&gt;
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> dateify(datestring)</code><br />
<div style="margin-left:45px"><p>Formats a numified <code>datestring</code> properly.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> nthstr(n)</code><br />
<div style="margin-left:45px"><p>Formats an ordinal.
Doesn't handle negative numbers.</p>

<pre><code>&gt;&gt;&gt; nthstr(1)
'1st'
&gt;&gt;&gt; nthstr(0)
'0th'
&gt;&gt;&gt; [nthstr(x) for x in [2, 3, 4, 5, 10, 11, 12, 13, 14, 15]]
['2nd', '3rd', '4th', '5th', '10th', '11th', '12th', '13th', '14th', '15th']
&gt;&gt;&gt; [nthstr(x) for x in [91, 92, 93, 94, 99, 100, 101, 102]]
['91st', '92nd', '93rd', '94th', '99th', '100th', '101st', '102nd']
&gt;&gt;&gt; [nthstr(x) for x in [111, 112, 113, 114, 115]]
['111th', '112th', '113th', '114th', '115th']
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> cond(predicate, consequence, alternative=None)</code><br />
<div style="margin-left:45px"><p>Function replacement for if-else to use in expressions.</p>

<pre><code>&gt;&gt;&gt; x = 2
&gt;&gt;&gt; cond(x % 2 == 0, "even", "odd")
'even'
&gt;&gt;&gt; cond(x % 2 == 0, "even", "odd") + '_row'
'even_row'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> CaptureStdout(self, func)</code><br />
<div style="margin-left:45px"><p>Captures everything <code>func</code> prints to stdout and returns it instead.</p>

<pre><code>&gt;&gt;&gt; def idiot():
...     print "foo"
&gt;&gt;&gt; capturestdout(idiot)()
'foo\n'
</code></pre>

<p><strong>WARNING:</strong> Not threadsafe!</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> capturestdout(self, func)</code><br />
<div style="margin-left:45px"><p>Captures everything <code>func</code> prints to stdout and returns it instead.</p>

<pre><code>&gt;&gt;&gt; def idiot():
...     print "foo"
&gt;&gt;&gt; capturestdout(idiot)()
'foo\n'
</code></pre>

<p><strong>WARNING:</strong> Not threadsafe!</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> Profile(self, func)</code><br />
<div style="margin-left:45px"><p>Profiles <code>func</code> and returns a tuple containing its output
and a string with human-readable profiling information.</p>

<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; out, inf = profile(time.sleep)(.001)
&gt;&gt;&gt; out
&gt;&gt;&gt; inf[:10].strip()
'took 0.0'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> tryall(context, prefix=None)</code><br />
<div style="margin-left:45px"><p>Tries a series of functions and prints their results. 
<code>context</code> is a dictionary mapping names to values; 
the value will only be tried if it's callable.</p>

<pre><code>&gt;&gt;&gt; tryall(dict(j=lambda: True))
j: True
----------------------------------------
results:
   True: 1
</code></pre>

<p>For example, you might have a file <code>test/stuff.py</code> 
with a series of functions testing various things in it. 
At the bottom, have a line:</p>

<pre><code>if __name__ == "__main__": tryall(globals())
</code></pre>

<p>Then you can run <code>python test/stuff.py</code> and get the results of 
all the tests.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> ThreadedDict(self)</code><br />
<div style="margin-left:45px"><p>Thread local storage.</p>

<pre><code>&gt;&gt;&gt; d = ThreadedDict()
&gt;&gt;&gt; d.x = 1
&gt;&gt;&gt; d.x
1
&gt;&gt;&gt; import threading
&gt;&gt;&gt; def f(): d.x = 2
...
&gt;&gt;&gt; t = threading.Thread(target=f)
&gt;&gt;&gt; t.start()
&gt;&gt;&gt; t.join()
&gt;&gt;&gt; d.x
1
</code></pre></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> clear(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">function</span><code class="function"> clear_all()</code><br />
<div style="margin-left:75px"><p>Clears all ThreadedDict instances.</p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> copy(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> get(self, key, default=None)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> has_key(self, key)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> items(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> iter(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> iteritems(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> iterkeys(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> itervalues(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> keys(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> pop(self, key, *args)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> popitem(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> setdefault(self, key, default=None)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> update(self, *args, **kwargs)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> values(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> autoassign(self, locals)</code><br />
<div style="margin-left:45px"><p>Automatically assigns local variables to <code>self</code>.</p>

<pre><code>&gt;&gt;&gt; self = storage()
&gt;&gt;&gt; autoassign(self, dict(a=1, b=2))
&gt;&gt;&gt; self
&lt;Storage {'a': 1, 'b': 2}&gt;
</code></pre>

<p>Generally used in <code>__init__</code> methods, as in:</p>

<pre><code>def __init__(self, foo, bar, baz=1): autoassign(self, locals())
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> to36(q)</code><br />
<div style="margin-left:45px"><p>Converts an integer to base 36 (a useful scheme for human-sayable IDs).</p>

<pre><code>&gt;&gt;&gt; to36(35)
'z'
&gt;&gt;&gt; to36(119292)
'2k1o'
&gt;&gt;&gt; int(to36(939387374), 36)
939387374
&gt;&gt;&gt; to36(0)
'0'
&gt;&gt;&gt; to36(-393)
Traceback (most recent call last):
    ... 
ValueError: must supply a positive integer
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> safemarkdown(text)</code><br />
<div style="margin-left:45px"><p>Converts text to HTML following the rules of Markdown, but blocking any
outside HTML input, so that only the things supported by Markdown
can be used. Also converts raw URLs to links.</p>

<p>(requires <a href="http://webpy.org/markdown.py">markdown.py</a>)</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> sendmail(from_address, to_address, subject, message, headers=None, **kw)</code><br />
<div style="margin-left:45px"><p>Sends the email message <code>message</code> with mail and envelope headers
for from <code>from_address_</code> to <code>to_address</code> with <code>subject</code>. 
Additional email headers can be specified with the dictionary 
`headers.</p>

<p>Optionally cc, bcc and attachments can be specified as keyword arguments.
Attachments must be an iterable and each attachment can be either a 
filename or a file object or a dictionary with filename, content and 
optionally content_type keys.</p>

<p>If <code>web.config.smtp_server</code> is set, it will send the message
to that SMTP server. Otherwise it will look for 
<code>/usr/sbin/sendmail</code>, the typical location for the sendmail-style
binary. To use sendmail from a different path, set <code>web.config.sendmail_path</code>.</p></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.webapi">web.webapi</a></code><br />
<div style="margin-left:15px"><p>Web API (wrapper around WSGI)
(from web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> header(hdr, value, unique=False)</code><br />
<div style="margin-left:45px"><p>Adds the header <code>hdr: value</code> with the response.</p>

<p>If <code>unique</code> is True and a header with that name already exists,
it doesn't add a new one.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> debug(*args)</code><br />
<div style="margin-left:45px"><p>Prints a prettyprinted version of <code>args</code> to stderr.</p></div></p>
<div style="margin-left:60px">
<p><span class="ts">function</span><code class="function"> write(x)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> input(*requireds, **defaults)</code><br />
<div style="margin-left:45px"><p>Returns a <code>storage</code> object with the GET and POST arguments. 
See <code>storify</code> for how <code>requireds</code> and <code>defaults</code> work.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> data()</code><br />
<div style="margin-left:45px"><p>Returns the data sent with the request.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> setcookie(name, value, expires='', domain=None, secure=False, httponly=False, path=None)</code><br />
<div style="margin-left:45px"><p>Sets a cookie.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> cookies(*requireds, **defaults)</code><br />
<div style="margin-left:45px"><p>Returns a <code>storage</code> object with all the cookies in it.
See <code>storify</code> for how <code>requireds</code> and <code>defaults</code> work.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> HTTPError(self, status, headers={}, data='')</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> OK(self, data='', headers={})</code><br />
<div style="margin-left:45px"><p><code>200 OK</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Created(self, data='Created', headers={})</code><br />
<div style="margin-left:45px"><p><code>201 Created</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Accepted(self, data='Accepted', headers={})</code><br />
<div style="margin-left:45px"><p><code>202 Accepted</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> ok(self, data='', headers={})</code><br />
<div style="margin-left:45px"><p><code>200 OK</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> created(self, data='Created', headers={})</code><br />
<div style="margin-left:45px"><p><code>201 Created</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> accepted(self, data='Accepted', headers={})</code><br />
<div style="margin-left:45px"><p><code>202 Accepted</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Redirect(self, url, status='301 Moved Permanently', absolute=False)</code><br />
<div style="margin-left:45px"><p>A <code>301 Moved Permanently</code> redirect.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Found(self, url, absolute=False)</code><br />
<div style="margin-left:45px"><p>A <code>302 Found</code> redirect.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> SeeOther(self, url, absolute=False)</code><br />
<div style="margin-left:45px"><p>A <code>303 See Other</code> redirect.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> NotModified(self)</code><br />
<div style="margin-left:45px"><p>A <code>304 Not Modified</code> status.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> TempRedirect(self, url, absolute=False)</code><br />
<div style="margin-left:45px"><p>A <code>307 Temporary Redirect</code> redirect.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> redirect(self, url, status='301 Moved Permanently', absolute=False)</code><br />
<div style="margin-left:45px"><p>A <code>301 Moved Permanently</code> redirect.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> found(self, url, absolute=False)</code><br />
<div style="margin-left:45px"><p>A <code>302 Found</code> redirect.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> seeother(self, url, absolute=False)</code><br />
<div style="margin-left:45px"><p>A <code>303 See Other</code> redirect.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> notmodified(self)</code><br />
<div style="margin-left:45px"><p>A <code>304 Not Modified</code> status.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> tempredirect(self, url, absolute=False)</code><br />
<div style="margin-left:45px"><p>A <code>307 Temporary Redirect</code> redirect.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> BadRequest(self)</code><br />
<div style="margin-left:45px"><p><code>400 Bad Request</code> error.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Unauthorized(self, data='Unauthorized', headers={})</code><br />
<div style="margin-left:45px"><p><code>401 Unauthorized</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Forbidden(self, data='Forbidden', headers={})</code><br />
<div style="margin-left:45px"><p><code>403 Forbidden</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> NotFound(message=None)</code><br />
<div style="margin-left:45px"><p>Returns HTTPError with '404 Not Found' error from the active application.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> NoMethod(self, cls=None)</code><br />
<div style="margin-left:45px"><p>A <code>405 Method Not Allowed</code> error.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> NotAcceptable(self, data='Not Acceptable', headers={})</code><br />
<div style="margin-left:45px"><p><code>406 Not Acceptable</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Conflict(self, data='Conflict', headers={})</code><br />
<div style="margin-left:45px"><p><code>409 Conflict</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> Gone(self)</code><br />
<div style="margin-left:45px"><p><code>410 Gone</code> error.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> PreconditionFailed(self, data='Precondition Failed', headers={})</code><br />
<div style="margin-left:45px"><p><code>412 Precondition Failed</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> badrequest(self)</code><br />
<div style="margin-left:45px"><p><code>400 Bad Request</code> error.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> unauthorized(self, data='Unauthorized', headers={})</code><br />
<div style="margin-left:45px"><p><code>401 Unauthorized</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> forbidden(self, data='Forbidden', headers={})</code><br />
<div style="margin-left:45px"><p><code>403 Forbidden</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> notfound(message=None)</code><br />
<div style="margin-left:45px"><p>Returns HTTPError with '404 Not Found' error from the active application.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> nomethod(self, cls=None)</code><br />
<div style="margin-left:45px"><p>A <code>405 Method Not Allowed</code> error.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> notacceptable(self, data='Not Acceptable', headers={})</code><br />
<div style="margin-left:45px"><p><code>406 Not Acceptable</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> conflict(self, data='Conflict', headers={})</code><br />
<div style="margin-left:45px"><p><code>409 Conflict</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> gone(self)</code><br />
<div style="margin-left:45px"><p><code>410 Gone</code> error.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">type</span><code class="type"> preconditionfailed(self, data='Precondition Failed', headers={})</code><br />
<div style="margin-left:45px"><p><code>412 Precondition Failed</code> status</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> InternalError(message=None)</code><br />
<div style="margin-left:45px"><p>Returns HTTPError with '500 internal error' error from the active application.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> internalerror(message=None)</code><br />
<div style="margin-left:45px"><p>Returns HTTPError with '500 internal error' error from the active application.</p></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.webopenid">web.webopenid</a></code><br />
<div style="margin-left:15px"><p>openid.py: an openid library for web.py</p>

<p>Notes:</p>

<ul>
<li><p>This will create a file called .openid<em>secret</em>key in the 
current directory with your secret key in it. If someone 
has access to this file they can log in as any user. And 
if the app can't find this file for any reason (e.g. you 
moved the app somewhere else) then each currently logged 
in user will get logged out.</p></li>
<li><p>State must be maintained through the entire auth process 
-- this means that if you have multiple web.py processes 
serving one set of URLs or if you restart your app often 
then log ins will fail. You have to replace sessions and 
store for things to work.</p></li>
<li><p>We set cookies starting with "openid_".</p></li>
</ul></div></p>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> form(openid_loc)</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">class</span><code class="class"> host(self)</code><br />
<div style="margin-left:45px"><p></p></div></p>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> GET(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
<div style="margin-left:60px">
<p><span class="ts">method</span><code class="method"> POST(self)</code><br />
<div style="margin-left:75px"><p></p></div></p>
</div>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> logout()</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> status()</code><br />
<div style="margin-left:45px"><p></p></div></p>
</div>
<p><span class="ts">module</span><code class="module"> <a name="web.wsgi">web.wsgi</a></code><br />
<div style="margin-left:15px"><p>WSGI Utilities
(from web.py)</p></div></p>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> listget(lst, ind, default=None)</code><br />
<div style="margin-left:45px"><p>Returns <code>lst[ind]</code> if it exists, <code>default</code> otherwise.</p>

<pre><code>&gt;&gt;&gt; listget(['a'], 0)
'a'
&gt;&gt;&gt; listget(['a'], 1)
&gt;&gt;&gt; listget(['a'], 1, 'b')
'b'
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> runfcgi(func, addr=('localhost', 8000))</code><br />
<div style="margin-left:45px"><p>Runs a WSGI function as a FastCGI server.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> runscgi(func, addr=('localhost', 4000))</code><br />
<div style="margin-left:45px"><p>Runs a WSGI function as an SCGI server.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> runwsgi(func)</code><br />
<div style="margin-left:45px"><p>Runs a WSGI-compatible <code>func</code> using FCGI, SCGI, or a simple web server,
as appropriate based on context and <code>sys.argv</code>.</p></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> validaddr(string_)</code><br />
<div style="margin-left:45px"><p>Returns either (ip<em>address, port) or "/path/to/socket" from string</em></p>

<pre><code>&gt;&gt;&gt; validaddr('/path/to/socket')
'/path/to/socket'
&gt;&gt;&gt; validaddr('8000')
('0.0.0.0', 8000)
&gt;&gt;&gt; validaddr('127.0.0.1')
('127.0.0.1', 8080)
&gt;&gt;&gt; validaddr('127.0.0.1:8000')
('127.0.0.1', 8000)
&gt;&gt;&gt; validaddr('fff')
Traceback (most recent call last):
    ...
ValueError: fff is not a valid IP address/port
</code></pre></div></p>
</div>
<div style="margin-left:30px">
<p><span class="ts">function</span><code class="function"> validip(ip, defaultaddr='0.0.0.0', defaultport=8080)</code><br />
<div style="margin-left:45px"><p>Returns <code>(ip_address, port)</code> from string <code>ip_addr_port</code></p></div></p>
</div>
</div>

---
layout: default
title: Auto Application
---

# Auto Application

Autre langages : [english](/docs/0.3/apps/auto) | ...

L'auto application agit comme la [basic application](/docs/0.3/apps/basic/fr), seulement il ne nécessite pas un mapping d'url pour être créé. Le mapping est dérivé des noms de classe (utilisant les métaclasses). Dans sa forme la plus basique :

## Exemple

     app = web.auto_application() 

     class hello(app.page): 
         def GET(self): 
             return "hello, world!"
     
     if __name__ == '__main__':
         app.run() # goto http://hostname:8080/hello



Vous pouvez également modifier le chemin par défaut (qui est le nom de la classe) en définissant une variable de classe "path". Voir ci-dessous:

## Exemple:

    app = web.auto_application() 
    
    class hello(app.page): 
        path = "/foobar"
        def GET(self): 
            return "hello, world!" 
    
    if __name__ == '__main__':
        app.run() # goto http://hostname:8080/foobar
---
layout: default
title: Auto Application
---

# Auto Application

Other languages : [français](/docs/0.3/apps/auto/fr) | ...

The auto application acts like the [basic application](/docs/0.3/apps/basic), only it doesn't require a URL mapping to be created.  The mapping is derived from the class names (using metaclasses). In it's most basic form:

## Example code 

     app = web.auto_application() 

     class hello(app.page): 
         def GET(self): 
             return "hello, world!"
     
     if __name__ == '__main__':
         app.run() # goto http://hostname:8080/hello


You can also override the default path (which is the name of the class) by setting a class variable "path".  See below:


## More Example code 

    app = web.auto_application() 
    
    class hello(app.page): 
        path = "/foobar"
        def GET(self): 
            return "hello, world!" 
    
    if __name__ == '__main__':
        app.run() # goto http://hostname:8080/foobar
---
layout: default
title: Basic Application
---

# Basic Application

Autres langages : [français](/../basic) | ...


La basic application définit un appariement des urls à des mappings de classe. Dans l'exemple ci-dessous, les variables URL définissent un appariement d'une expression régulière à un nom de classe.

Quand un utilisateur a accès à une ressource,  la liste des expressions régulières d'url est parcourue. Si une URL correspondant à la regex, la classe est instanciée, et la méthode 'GET' ou 'POST' est appelée selon la méthode http. Les données retournées depuis GET ou POST sont affichées dans le navigateur.


Si l'URL demandée ne correspond à aucune des expressions régulières, une erreur 404 est renvoyée.

## Exemple

    import web
            
    urls = (
        '/(.*)', 'hello'
    )
    app = web.application(urls, globals())
    
    class hello:        
        def GET(self, name):
            if not name: 
                name = 'World'
            return 'Hello, ' + name + '!'
    
    if __name__ == "__main__":
        app.run()
---
layout: default
title: Basic Application
---

# Basic Application

Other languages : [français](/docs/0.3/apps/basic/fr) | ...

The basic application defines a pairing of urls to class mappings.  In the example below, the urls variable defines a pairing of a regular expression to a class name. 

When a user access a resource, runs through the list of url regular expressions.  If a url matches the regex, the class is instantiated, and the method 'GET' or 'POST' is called based on the http method. Data returned from the GET or POST is displayed in the browser.

If the requested url doesn't match any regex, a 404 is returned.


## Example

    import web
            
    urls = (
        '/(.*)', 'hello'
    )
    app = web.application(urls, globals())
    
    class hello:        
        def GET(self, name):
            if not name: 
                name = 'World'
            return 'Hello, ' + name + '!'
    
    if __name__ == "__main__":
        app.run()
---
layout: default
title: webpy Applications
---

# webpy Applications

Other languages : [français](/docs/0.3/apps/fr) | ...

webpy applications encompass the urls and handlers that map to them. They fall into several categories:

* [Basic app](/docs/0.3/apps/basic). Define urls and classes to handle them.
* [Auto app](/docs/0.3/apps/auto). Urls are determined automatically based on classes.
* [Subdir app](/docs/0.3/apps/subdir). Run multiple apps on a single domain based on url.
* [Subdomain app](/docs/0.3/apps/subdomain). Run multiple apps based on subdomains.
---
layout: default
title: Subdir application
---

# Subdir application

A subdir application lets you run various mount points on the same hostname, but switched based on directory mount point.


This example assumes you have applications already working and called "app" defined in wiki.py, blog.py and auth.py. 


## Example code

    import wiki 
    import blog 
    import auth 

    mapping = ( 
        "/wiki", wiki.app, 
        "/blog", blog.app, 
        "/auth", auth.app) 

    app = web.subdir_application(mapping)

    if __name__ == '__main__:
        app.run()

Now, going to /wiki/ will send the trailing / to the wiki.app, and its return data will be displayed as normal.
---
layout: default
title: Subdomain application
---

# Subdomain application

Subdomain applications delegate requests based on host. This makes virtual hosting very easy. This works like a [subdir application](/docs/0.3/apps/subdir), only switches to the corresponding application based on host name instead of sub directory.

## Example

     import mainsite 
     import wiki
     import usersite

     mapping = ( 
         "(www\.)?example.com", mainsite.app, 
         "wiki.example.com", wiki.app,
         ".*\.example.com", usersite.app 
     ) 

     app = web.subdomain_application(mapping)

     if __name__ == '__main__':
         app.run()
---
layout: default
title: Applications webpy
---

# Applications webpy

Autres langages : [english](/../apps) | ...

Les Applications webpy apparient les urls et les traitements qui sont mappés vers elles. Elles se répartissent en plusieurs catégories:


* [Basic app](/docs/0.3/apps/basic/fr). Défini les urls et les classes pour les traiter.
* [Auto app](/docs/0.3/apps/auto/fr). Les urls sont déterminées automatiquement en se basant sur les classes.
* [Subdir app](/docs/0.3/apps/subdir). Run multiple apps on a single domain based on url. (traduction demandée)
* [Subdomain app](/docs/0.3/apps/subdomain). Run multiple apps based on subdomains. (traduction demandée)
---
layout: default
title: Application processors
---

# Application processors

Autres langues : [english](/../app_processors) | ...

les Application processors permettent au programmeur d'executer du code commun avant que chaque requête soit traitée. Ceci est utile pour les schémas d'authentification ou pour organiser l'état des utilisateurs à chaque requête. Des processors multiples peuvent être ajoutés par application, et ils seront executés dans l'ordre ou ils ont été ajoutés. Le plus basique processor ressemble à ça:


    def proc(handle):
        # faire tout ce dont vous avez besoin ici
        web.ctx.user = web.cookies(user=None).user
        # renvoi le traitement executé
        return handle()
    
    app = web.application(urls, globals())
    # Ajouter le processor
    app.add_processor(proc)

Le "handle" de l'application processor se réfère au code qui sera envoyé à l'URL correspondante (ou chaque processor successif). Cela vous permet d'utiliser "try" et "except", de cette façon:

        def proc(handle):
            try:
                ret = handle()
            except:
                log_error('Uh oh')
            return ret


Voici un exemple de base sur la façon dont un système d'authentification est créé en utilisant les applications processors. Ce n'est pas sécurisé pour une utilisation réelle; Cela ne vise qu'à démontrer comment les application processors pouvent vérifier quelque chose avant que chaque URL ne soit traitée.


## Exemple
    """ Application processors dans web.py """
    import web
    
    urls = (
        '/', 'Index',
        '/login', 'Login',
        '/logout', 'Logout',
    )
    
    class Index:
    
        def GET(self):
            return '<html>Hello %s <a href="/logout">Logout</a></html>' \
                % web.ctx.username
    
    
    class Login:
        
        def GET(self):
            return """
            <html>
            <form action="" method="post">
                <input type="text" name="username">
                <input type="submit" value="Login">
            </form>
            </html>
            """
    
        def POST(self):
            # only set cookie if user login succeeds
            name = web.input(username=None).username
            if name:
                web.setcookie('username', name)
            raise web.seeother('/')
    
    
    class Logout:
        
        def GET(self):
            web.setcookie('username', '', expires=-1)
            raise web.seeother('/login')
        
    
    
    app = web.application(urls, globals())
    
    # Authentification Processor
    def auth_app_processor(handle):
        path = web.ctx.path
        web.ctx.username = name = web.cookies(username=None).username
        if not name and path != '/login':
            raise web.seeother('/login')
        return handle()
    
    app.add_processor(auth_app_processor)
    
    
    if __name__ == '__main__':
        app.run()
---
layout: default
title: Application processors
---

# Application processors

Other languages : [français](/app_processors/fr) | ...

Application processors allow the programmer to execute common code before each request is processed.  This is helpful for authentication schemes or for setting up user state on each request.  Multiple processors can be added per application, and they will be executed in the order which they are added.  The most basic processor looks like this:

    def proc(handle):
        # do whatever you need to here
        web.ctx.user = web.cookies(user=None).user
        # return the executed handle
        return handle()
    
    app = web.application(urls, globals()
    # Add the processor
    app.add_processor(proc)

The "handle" of the app processor refers to the code that will be dispatched by the matching URL (and any subsequent processors).  This allows us to use try and except, like this:

        def proc(handle):
            try:
                ret = handle()
            except:
                log_error('Uh oh')
            return ret


Here's a basic example of how an authentication scheme is created using app processors.  This is not secure for actual use; it is only meant to demonstrate how app processors can check something before each url is processed.

## Example
    """ Application processors in web.py """
    import web
    
    urls = (
        '/', 'Index',
        '/login', 'Login',
        '/logout', 'Logout',
    )
    
    class Index:
    
        def GET(self):
            return '<html>Hello %s <a href="/logout">Logout</a></html>' \
                % web.ctx.username
    
    
    class Login:
        
        def GET(self):
            return """
            <html>
            <form action="" method="post">
                <input type="text" name="username">
                <input type="submit" value="Login">
            </form>
            </html>
            """
    
        def POST(self):
            # only set cookie if user login succeeds
            name = web.input(username=None).username
            if name:
                web.setcookie('username', name)
            raise web.seeother('/')
    
    
    class Logout:
        
        def GET(self):
            web.setcookie('username', '', expires=-1)
            raise web.seeother('/login')
        
    
    
    app = web.application(urls, globals())
    
    # Auth Processor
    def auth_app_processor(handle):
        path = web.ctx.path
        web.ctx.username = name = web.cookies(username=None).username
        if not name and path != '/login':
            raise web.seeother('/login')
        return handle()
    
    app.add_processor(auth_app_processor)
    
    
    if __name__ == '__main__':
        app.run()
---
layout: default
title: Librairie formulaires
---

# Librairie formulaires

Autres langues : [English](/form) | ...

# Sommaire

* <a href="#introduction">Introduction</a>
* <a href="#carac">Caracteristiques des entrées formulaires</a>
* <a href="#listes">Listes déroulantes</a>
* <a href="#parti">Particularités des formulaires</a>
* <a href="#exemple">Exemple</a>

<a name="introduction"></a>
## Introduction

Le module de formulaire de web.py permet de générer des formulaires HTML, de récuperer les entrées des utilisateurs, et les valider avant de les traiter ou les ajouter à une base de donnée.

Le module de formulaire définit 2 classes primaires: la classe Form et la classe Input. 

Les formulaires sont instanciés avec une ou plusieurs entrées, et des validateurs optionnels. Les entrées sont instanciées avec une variable nom, ainsi que des arguments optionnels et des validateurs. 

La classe Input est sous-classée dans les entrées html suivantes (type HTML dans les parenthèses):


* Textbox     - Champ de saisie de texte d'une ligne (input type="text")
* Password   - Champ de saisie de texte d'une ligne qui cache ce qui est entré (input type="password")
* Textarea   - Champ de saisie de texte multiligne (textarea)
* Dropdown - Selection d'un seul élément dans une liste déroulante (select and options)
* Radio         - Boutons radio pour un seul choix (input type="radio")
* Checkbox  - Cases à cocher à plusieurs choix (input type="checkbox")
* Button        - Soumettre le formulaire (button)

Un simple formulaire de connexion pourrait ressembler à ceci:

    login = form.Form(
        form.Textbox('username'),
        form.Password('password'),
        form.Button('Login'),
    )

Ceci définit un simple formulaire. Une fois défini, vous devrez l'appeler à nouveau pour obtenir une instance, et alors vous pourrez appeler la méthode de rendu sur elle, de cette façon:

    f = login()
    print f.render()

Ce qui affichera le code HTML suivant:

    <table>
        <tr><th><label for="username">username</label></th><td><input type="text" id="username" name="username"/><div class="post" style="display: none;"></div></td></tr>
        <tr><th><label for="password">password</label></th><td><input type="password" id="password" name="password"/><div class="post" style="display: none;"></div></td></tr>
        <tr><th><label for="Login"></label></th><td><button id="Login" name="Login">Login</button><div class="post" style="display: none;"></div></td></tr>
    </table>

Ce qui donnera:

<table>
    <tr><th><label for="username">username</label></th><td><input type="text" id="username" name="username"/><div class="post" style="display: none;"></div></td></tr>
    <tr><th><label for="password">password</label></th><td><input type="password" id="password" name="password"/><div class="post" style="display: none;"></div></td></tr>
    <tr><th><label for="Login"></label></th><td><button id="Login" name="Login">Login</button><div class="post" style="display: none;"></div></td></tr>
</table>

<a name="carac"></a>
## Caracteristiques des entrées formulaires
Les entrées formulaires offrent quelques attributs additionnels. Par exemple :


    form.textbox("firstname",
        form.notnull, # Place les validateurs en premier, suivi par des attributs facultatifs
        class_="textEntry", # Donne un nom de classe à la zone de texte - à noter le caractère de soulignement (underscore)
        pre="pre", # Directement devant la zone de texte
        post="post", # Directement après la zone de texte
        description="please enter your name", # Décrit le champ, par défaut le nom du formulaire
        value="bob", # Valeur par défaut
        id="nameid", # Spécifier l'ID
    )

En plus des attributs ci-dessus, tous les attributs HTML peuvent être entré de la même manière. Par exemple:
    
    myform2 = form.Form(
        form.textbox('phonenumber',
            size="12",
            maxlength="12"        )
    )

<a name="listes"></a>
##Listes déroulantes  (Dropdown) 

Les entrées des listes déroulantes permettent une description et une valeur uniques de chaque élément dans la liste déroulante. Pour ce faire, créez la liste déroulante avec les tuples comme ceci:
    
    form.Dropdown('mydrop', [('value1', 'description1'), ('value2', 'description2')])

<a name="introduction"></a>
## Particularités des formulaires
En plus des champs de saisie individuels, form.py permet une complète validation de formulaire qui autorise la comparaison des champs. Les validations sont passées sous forme de liste dans une variable 'validators'. Par exemple :

    signup = form.Form(
        form.Textbox('username'),
        form.Password('password'),
        form.Password('password_again'),
        validators = [form.Validator("Passwords didn't match.", lambda i: i.password == i.password_again)]
    )

Une fois les données du formulaire postées, elles peuvent facilement être mises dans une base de données (si la structure de base de données a des noms compatibles avec votre formulaire webpy). Par exemple:

    def POST(self):
        f = myform()
        if f.validates():
            web.insert('data_table', **f.d)
        # NE FAITES PAS: web.insert('data_table', **web.input()) Car des données malicieuses peuvent être envoyées
        else:
            render.foo(f)

<a name="exemple"></a>
## Exemple

    import web
    from web import form

    render = web.template.render('templates/')

    urls = ('/', 'index')
    app = web.application(urls, globals())

    myform = form.Form( 
        form.Textbox("boe"), 
        form.Textbox("bax", 
            form.notnull,
            form.regexp('\d+', 'Must be a digit'),
            form.Validator('Must be more than 5', lambda x:int(x)>5)),
        form.Textarea('moe'),
        form.Checkbox('curly'), 
        form.Dropdown('french', ['mustard', 'fries', 'wine'])) 

    class index: 
        def GET(self): 
            form = myform()
            # make sure you create a copy of the form by calling it (line above)
            # Otherwise changes will appear globally
            return render.formtest(form)

        def POST(self): 
            form = myform() 
            if not form.validates(): 
                return render.formtest(form)
            else:
                # form.d.boe and form['boe'].value are equivalent ways of
                # extracting the validated arguments from the form.
                return "Grrreat success! boe: %s, bax: %s" % (form.d.boe, form['bax'].value)

    if __name__=="__main__":
        web.internalerror = web.debugerror
        app.run()

Ansi que l'exemple formtest.html (à placer dans le sous-repertoire *templates*): 

    $def with (form)

    <form name="main" method="post"> 
    $if not form.valid: <p class="error">Try again, AmeriCAN:</p>
    $:form.render()
    <input type="submit" />    </form>
---
layout: default
title: web.py 0.3 documentation
---

# web.py 0.3 documentation

Other languages : [français](/docs/0.3.fr) | ...

## Install
* [Install](/install). Install web.py, configure LightTPD, Apache, Nginx ...(CGI, FastCgi, ...)

## Tutorial

* [Quick tutorial](/tutorial3.en). Getting started with your first application.

## Example Code

* [Cookbook](/cookbook). How to perform basic and common tasks.
* [Code samples](/src). Example code of how to write some basic applications.

## Component Documentation
* [Applications](/docs/0.3/apps). How to map urls to python code paths.
    * [Basic app](/docs/0.3/apps/basic). Map regexes to classes.
    * [Auto app](/docs/0.3/apps/auto). Have webpy keep track of the urls based on class name.
    * [Subdir app](/docs/0.3/apps/subdir). Host multiple apps based on the sub-directory.
    * [Subdomain app](/docs/0.3/apps/subdomain). Host multiple apps based on the subdomain.
* [Templates](/docs/0.3/templetor). Templetor, the web.py templating system
* [Forms](/form). Dealing with user input
* [Application processors](/docs/0.3/app_processors). Run code before each request.
* [Sessions](/docs/0.3/sessions). Store persistent data per user across requests. 
* Database
* Testing

## Upgrade to Current Version

* [Upgrade to 0.3 versions of web.py](/docs/0.3/upgrade)


## API Documentation

* [API documentation](/docs/0.3/api)

## Recommended Setup

* [setup](/recommended_setup). Recommended software for production servers.
---
layout: default
title: Les sessions web.py
---

# Les sessions web.py

Autres langages : [english](/../sessions) | ...


Les sessions sont un moyen de stocker des informations entre les requêtes, faisant ainsi du http un protocole avec état. Elles fonctionnent en envoyant à l'utilisateur un cookie, qui mappe vers un objet de stockage de session sur le serveur. Lorsque l'utilisateur fait une requête vers une page, le client renvoie le cookie avec la requête, web.py charge la session basée sur sa clef, et le code peut demander et stocker des informations dedans.

Les sessions sont pratiques car elles permettent à un programmeur de stocker l'état des utilisateurs dans des objets natifs Python.

## Types de stockage

Les sessions de web.py permettent différents procédés de stockage des données sessions. Ces méthodes comprennent:

* DiskStore: Les données sessions sont sérialisées dans un repertoire désigné. Lors de l'instanciation, le premier et le seul argument est le dossier dans lequel les informations de session doivent être stockées sur le disque.

* DBStore: Les données sessions sont sérialisées et sotckées dans une base de donnée. Cela peut être très utile si vous souhaitez stocker les données sessions sur un système séparé. Pendant la création, DBStore prend deux arguments: une instance web.py de base de donnée, et le nom de la table (string). La table qui stocke la session doit avoir la structure suivante:


        session_id CHAR(128) UNIQUE NOT NULL,
        atime DATETIME NOT NULL default current_timestamp,
        data TEXT

* ShelfStore: Les données sont stockées en utilisant le module [shelve](http://docs.python.org/library/shelve.html) de python.


Les méthodes de stockage ont des performances variées et des ajustement d'installation, donc les options vous permettent de choisir ce qui convient le mieux pour votre appplication.

## Exemple
Le code suivant montre comment utiliser une session de base DiskStore.

    import web
    
    
    urls = (
        '/', 'Index',
        '/login', 'Login',
        '/logout', 'Logout',
    )
    
    web.config.debug = False
    app = web.application(urls, locals())
    session = web.session.Session(app, web.session.DiskStore('sessions'))      
    
    class Index:
        def GET(self):
            if session.get('logged_in', False):
                return '<h1>You are logged in</h1><a href="/logout">Logout</a>'
            return '<h1>You are not logged in.</h1><a href="/login">Login now</a>'
    
    class Login:
        def GET(self):
            session.logged_in = True
            raise web.seeother('/')
    
    class Logout:
        def GET(self):
            session.logged_in = False
            raise web.seeother('/')
    
    
    if __name__ == '__main__':
        app.run()
---
layout: default
title: web.py Sessions
---

# web.py Sessions

Other languages : [français](/sessions/fr) | ...

Sessions are a way to store information between requests, thereby making http stateful.  They work by sending the user a cookie, which maps to a session storage object on the server.  When the user requests a page, the client sends the cookie back with the request, web.py loads the session based on the key, and code can request and store information in it.

Sessions are convenient because they allow a programmer to store user state in native Python objects.

## Storage types
web.py sessions allow for multiple ways to store the session data.  These methods include:

* DiskStore. Session data is pickled in a designated directory. When instantiating, the first and only argument is the folder where the session information should be stored on disk.
* DBStore. Session data is pickled and stored in a database.  This can be useful if you want to store session data on a separate system. When creating, the DBStore takes 2 arguments: a web.py database instance, and the table name (string). The table which stores the session must have the following schema:

        session_id CHAR(128) UNIQUE NOT NULL,
        atime DATETIME NOT NULL default current_timestamp,
        data TEXT

* ShelfStore. Data is stored using the python shelve module. When creating, the ShelfStore takes the filename that should be used to store the data.

The storage methods have various performance and setup tradeoffs, so the options allow you to choose what's best for your application.


## Example
The following code shows how to use a basic DiskStore session.

    import web
    
    
    urls = (
        '/', 'Index',
        '/login', 'Login',
        '/logout', 'Logout',
    )
    
    web.config.debug = False
    app = web.application(urls, locals())
    session = web.session.Session(app, web.session.DiskStore('sessions'))      
    
    class Index:
        def GET(self):
            if session.get('logged_in', False):
                return '<h1>You are logged in</h1><a href="/logout">Logout</a>'
            return '<h1>You are not logged in.</h1><a href="/login">Login now</a>'
    
    class Login:
        def GET(self):
            session.logged_in = True
            raise web.seeother('/')
    
    class Logout:
        def GET(self):
            session.logged_in = False
            raise web.seeother('/')
    
    
    if __name__ == '__main__':
        app.run()


## Sessions and Reloading/Debug Mode
Is your session data disappearing for seemingly no reason? This can happen when using the web.py app reloader (local debug mode), which will not persist the session object between reloads. Here's a nifty hack to get around this.

    # Hack to make session play nice with the reloader (in debug mode)
    if web.config.get('_session') is None:
        session = web.session.Session(app, db.SessionDBStore())
        web.config._session = session
    else:
        session = web.config._session

---
layout: default
title: Templator: le système de gabarits de web.py
---

# Templator: le système de gabarits de web.py

Autre langues : [English](/docs/0.3/templetor) | ...

## Sommaire

* <a href="#introduction">Introduction</a>
* <a href="#using">Utiliser un modèle de gabarit</a>
* <a href="#syntax">Syntaxe</a>
	* <a href="#expressionsubstitution">Substitution d'expression</a>
	* <a href="#attribut">Attribution</a>
	* <a href="#filtrering">Filtrage</a>
	* <a href="#newlinesuppression">Suppression d'un retour à la ligne</a>
	* <a href="#escaping">Caractère d'échappement '$'</a>
	* <a href="#comments">Commentaires</a>
	* <a href="#controlstructure">Structures de contrôle</a>
* <a href="#otherstatements">Autres déclarations</a>
	* <a href="#def">$def : définir une nouvelle fonction de gabarit</a>
	* <a href="#code">$code : écrire du code python dans le gabarit</a>
	* <a href="#var">$var : définir des propriétés additionnelles dans les résultats du gabarit</a>
* <a href="#builtins">Objets internes et variables globales</a>
* <a href="#security">Sécurité</a>
* <a href="#upgrading">Mise à jour depuis le gabarit web.py 0.2</a>


<a name="introduction"></a>
# Introduction

Le langage de gabarit de web.py, appelé 'Templator', est conçu pour apporter la puissance de python aux modèles de gabarits.
Au lieu d'inventer une nouvelle syntaxe pour les gabarits, il réutilise la syntaxe de python.
Si vous connaissez le langage de programmation python, vous serez à l'aise. 


Templator limite intentionnellement l'accès aux variables dans un gabarit. Un utilisateur a accès aux variables passées dans le modèle de gabarit ainsi qu'à certaines fonctions Python intégrées. Cela permet aux utilisateurs maladroits d'écrire des gabarits, sans vous soucier de causer des dommage au système en cours d'exécution. Vous pouvez, bien sûr, augmenter les variables globales disponibles, c'est ce que nous verrons plus tard.

Voici un gabarit tout simple:

    $def with (name)
    Hello $name!

La première ligne indique que le gabarit est défini avec un argument appelé 'name'.
`$name` dans la seconde ligne sera remplacé par la valeur de name lorsque le template sera rendu.

<a name="using"></a>
# Utiliser un modèle de gabarit

La façon la plus imple d'utiliser le rendu de gabarits est celle-ci :

    render = web.template.render('templates')
    print render.hello('world')
   
La fonction 'render' prend comme argument le repertoire 'templates'. 'render.hello(..)' appelle le gabarit 'hello.html' avec les arguments donnés. En fait, il cherche les fichiers correspondants 'hello.*' dans le repertoire 'template' et sélectionne le premier fichier correspondant.


Vous pouvez également créer des modèles à partir d'un fichier en utilisant 'frender'.

    hello = web.template.frender('templates/hello.html')
    print hello('world')
    
Ou encore à partir d'une chaîne de caractères:

    template = "$def with (name)\nHello $name"
    hello = web.template.Template(template)
    print hello('world')

<a name="syntax"></a>
# Syntaxe

<a name="expressionsubstitution"></a>
## Substitution d'expression

Le caractère spécial '$' est utilisé pour spécifier des expressions python. Les expressions peuvent être jointent dans '()' ou '{}' pour un regroupement explicite.

    Look, a $string. 
    Hark, an ${arbitrary + expression}. 
    Gawk, a $dictionary[key].function('argument'). 
    Cool, a $(limit)ing.

<a name="attribut"></a>
## Attribution

Vous aurez parfois besoin de définir de nouvelles variables et de réattribuer certaines d'entre elles.
    
    $ bug = get_bug(id)
    <h1>$bug.title</h1>
    <div>
        $bug.description
    <div>
     
Notez l'espace après '$' dans l'attribution. Il est requis pour différencier l'attribution à la substitution d'expression.

<a name="filtrering"></a>
## Filtrage 

Par defaut, Templator utilise le filtre 'web.websafe' pour encoder le HTML.

    >>> render.hello("1 < 2")
    "Hello 1 &lt; 2"

Pour désactiver le filtre, utilisez ':' après '$'. Par exemple:

    Ce qui suit ne sera pas remplacé par une chaîne HTML ("&" par "&amp;" par exemple).
    $:form.render()

<a name="newlinesuppression"></a>
## Suppression d'un retour à la ligne

Un retour à la ligne peut-être supprimé en ajoutant l'anti-slash '\' à la fin de la ligne.

    Si vou ajoutez un anti-slash \ 
    à la fin de la ligne \ 
    (comme ceci) \ 
    alors il n'y aura pas de retour à la ligne.
    
<a name="escaping"></a>
## Caractère d'échappement '$'

Utilisez `$$` pour avoir `$` (signe dollars) à l'affichage.

    Can you lend me $$50?
    
<a name="comments"></a>
## Commentaires

'$#' est utilisé comme indicateur de commentaires. Tout ce qui commence par '$#' jusqu'à la fin de la ligne sera ignoré.

    $# Ceci est un commentaire
    Hello $name.title()! $# Affiche le nom comme titre

<a name="controlstructure"></a>
## Structures de contrôles

Le système de gabarit accepte les instructions `for`, `while`, `if`, `elif` et `else`.
Tout comme en Python, le corps de la déclaration est indenté.

    $for i in range(10): 
        I like $i

    $for i in range(10): I like $i
        
    $while a:
        hello $a.pop()

    $if times > max: 
        Stop! In the name of love. 
    $else: 
        Keep on, you can do it.

La boucle fixe un certain nombre de variables disponibles dans la boucle:

    loop.index: iteration de la boucle (1-indexé)
    loop.index0: iteration de la boucle (0-indexé)
    loop.first: Vrai si c'est la première itération
    loop.last: Vrai si c'est la dernière itération
    loop.odd: Vrai si une itération impaire
    loop.even: Vrai si une itération paire
    loop.parity: "impair" ou "paire" selon ce qui est vrai
    loop.parent: la boucle ci-dessus est une boucle imbriquée
    
Parfois, celles-ci peuvent être très pratique.

    <table>
    $for c in ["a", "b", "c", "d"]:
        <tr class="$loop.parity">
            <td>$loop.index</td>
            <td>$c</td>
        </tr>
    </table>
    
<a name="otherstatements"></a>
## Autres déclarations

<a name="def"></a>
### $def

Vous pouvez définir une nouvelle fonction de gabarit en utilisant `$def`. les arguments-clés sont aussi supportés.

    $def say_hello(name='world'):
        Hello $name!
    
    $say_hello('web.py')
    $say_hello()

Autre exemple
        
    $def tr(values):
        <tr>
        $for v in values:
            <td>$v</td>
        </tr>

    $def table(rows):
        <table>
        $for row in rows:
            $:row
        </table>
    
    $ data = [['a', 'b', 'c'], [1, 2, 3], [2, 4, 6], [3, 6, 9] ]
    $:table([tr(d) for d in data])
    
<a name="code"></a>
### $code

Du code python arbitraire peut être écrit en utilisant le bloc '$code'.

    $code:
        x = "you can write any python code here"
        y = x.title()
        z = len(x + y)
        
        def limit(s, width=10):
            """limits a string to the given width"""
            if len(s) >= width:
                return s[:width] + "..."
            else:
                return s
                
    Puis nous revenons dans le code du gabarit.
    Les variables définies dans le bloc '$code' peuvent être utilisées ici.
    Par exemple, $limit(x)
  
<a name="var"></a>  
### $var

Le bloc '$var' peut être utilisé pour définir des propriétés additionnelles dans les résultats du gabarit.

    $def with (title, body)
    
    $var title: $title
    $var content_type: text/html
    
    <div id="body">
    $body
    </div>
    
Les résultat du modèle ci-dessus peuvent être utilisés comme suit:

    >>> out = render.page('hello', 'hello world')
    >>> out.title
    u'hello'
    >>> out.content_type
    u'text/html'
    >>> str(out)
    '\n\n<div>\nhello world\n</div>\n'

<a name="builtins"></a>
# Objets internes et variables globales

Comme toutes fonctions python, le gabarit peut également accèder aux objets internes avec ses arguments et ses variables locales.
Quelques fonctions internes communes telles que 'range', 'max', 'min', etc... et les valeurs booléennes 'True' et 'False' sont accessibles à tous les gabarits.

Outre les fonctions intégrées, les globales spécifique d'application peuvent être spécifiées pour les rendre accessibles à tous les gabarits. [NOTE TRADUCTEUR : A préciser]

Les variables globales peuvent être spécifiées comme arguments à `web.template.render`.

    import web
    import markdown
    
    globals = {'markdown': markdown.markdown}
    render = web.template.render('templates', globals=globals)

Les objets internes qui sont exposés dans les gabarits peuvent aussi être contrôlées. [NOTE TRADUCTEUR: la traduction de Builtins et Globals est à vérifier]

    # disable all builtins
    render = web.template.render('templates', builtins={})

<a name="security"></a>
# Securité

L'un des objectifs de conception de Templetor est de permettre à des utilisateurs non épprouvés d'écrire des gabarits.

Pour rendre l'exécution du gabarit sûre, ce qui suit n'est pas autorisé dans les templates.

* Les déclarations telles que `import`, `exec` etc.
* Accéder aux attributs qui commencent par `_`
* Des fonctions internes telles que `open`, `getattr`, `setattr` etc.

`SecurityException` est déclenchée si votre modèle utilise l'une de celles-ci.

<a name="upgrading"></a>
# Mise à jour depuis le gabarit web.py 0.2

La nouvelle implémentation est totalement compatible avec la mise en œuvre plus haut. Cependant, certains cas pourraient ne pas fonctionner pour les raisons suivantes:

* Le rendu du gabarit est toujours stocké comme un objet `TemplateResult`, toutefois, le convertir en 'unicode' ou 'str' donne le résultat sous forme de chaîne unicode.

* La réassignation d'une valeur globale ne fonctionnera pas. Ce qui suit ne fonctionnera pas si x est une globale.
    
        $ x = x + 1
    
Ce qui suit est toujours supporté, mais peu recommandé.

* Utiliser `\$` pour l'échappement. Utilisez plutôt '$$'.
* Modifier `web.template.Template.globals`. Passez plutôt les globales à `web.template.render` en argument à la place.
---
layout: default
title: Templetor - The web.py templating system
---

# Templetor: The web.py templating system

Other languages : [français](/docs/0.3/templetor.fr) | ...

## Summary

* <a href="#introduction">Introduction</a>
* <a href="#using">Using the template system</a>
* <a href="#syntax">Syntax</a>
	* <a href="#expressionsubstitution">Expression Substitution</a>
	* <a href="#assignments">Assignments</a>
	* <a href="#filtering">Filtering</a>
	* <a href="#newlinesuppression">Newline suppression</a>
	* <a href="#escaping">Escaping '$'</a>
	* <a href="#comments">Comments</a>
	* <a href="#controlstructure">Control Structures</a>
* <a href="#otherstatements">Other Statements</a>
	* <a href="#def">$def : define a new template function using $def</a>
	* <a href="#code">$code : arbitrary python code can be written</a>
	* <a href="#var">$var : can be used to define additional properties</a>
* <a href="#builtins">Builtins and globals</a>
* <a href="#security">Security</a>
* <a href="#upgrading">Upgrading from web.py 0.2 templates</a>


<a name="introduction"></a>
# Introduction

The web.py template language, called `Templetor` is designed to bring the power of Python to templates.
Instead of inventing new syntax for templates, it re-uses python syntax. 
If you know the Python programming language, you will be at home.

Templetor intentionally limits variable access within a template. A user has access to the variables passed into the template and some builtin python functions.  This allows untrusted users to write templates, and not worry about them causing harm to the running system. You can, of course, increase the global variables available, but more on this later.

Here is a simple template:

    $def with (name)
    Hello $name!

The first line says that the template is defined with one argument called `name`.
`$name` in the second line will be replaced with the value of name when the template is rendered.


<a name="using"></a>
# Using the template system

The most common way of rendering templates is this:

    render = web.template.render('templates')
    print render.hello('world')
   
The `render` function takes the template root as argument. `render.hello(..)` calls the template `hello.html` with the given arguments.
In fact, it looks for the files matching `hello.*` in the template root and picks the first matching file.

However you can also create template from a file using `frender`.

    hello = web.template.frender('templates/hello.html')
    print hello('world')
    
And if you have the template as a string:

    template = "$def with (name)\nHello $name"
    hello = web.template.Template(template)
    print hello('world')

<a name="syntax"></a>
# Syntax

<a name="expressionsubstitution"></a>
## Expression Substitution

Special character `$` is used to specify python expressions. Expression can be enclosed in `()` or `{}` for explicit grouping.

    Look, a $string. 
    Hark, an ${arbitrary + expression}. 
    Gawk, a $dictionary[key].function('argument'). 
    Cool, a $(limit)ing.

<a name="assignments"></a>
## Assignments

Sometimes you may want to define new variables and re-assign some variables.
    
    $ bug = get_bug(id)
    <h1>$bug.title</h1>
    <div>
        $bug.description
    <div>

Notice the space after `$` in the assignment. It is required to differentiate assignment from expression substitution.

<a name="filtering"></a>
## Filtering 

By default, Templetor uses `web.websafe` filter to do HTML-encoding.

    >>> render.hello("1 < 2")
    "Hello 1 &lt; 2"

To turnoff filter use `:` after `$`. For example:

    The following will not be html escaped.
    $:form.render()

<a name="newlinesuppression"></a>   
## Newline suppression

Newline can be suppressed by adding `\` character at the end of line. 

    If you put a backslash \ 
    at the end of a line \ 
    (like these) \ 
    then there will be no newline.
    
<a name="escaping"></a> 
## Escaping $

Use `$$` to get `$` in the output.

    Can you lend me $$50?
    
<a name="comments"></a> 
## Comments

`$#` is used as comment indicator. Anything starting with $# till end of the line is ignored.

    $# this is a comment
    Hello $name.title()! $# display the name in title case

<a name="controlstructure"></a> 
## Control Structures

The template system supports `for`, `while`, `if`, `elif` and `else`.
Just like in python, body of the statement is indented.

    $for i in range(10): 
        I like $i

    $for i in range(10): I like $i
        
    $while a:
        hello $a.pop()

    $if times > max: 
        Stop! In the name of love. 
    $else: 
        Keep on, you can do it.

The for loop sets a number of variables available within the loop:

    loop.index: the iteration of the loop (1-indexed)
    loop.index0: the iteration of the loop (0-indexed)
    loop.first: True if first iteration
    loop.last: True if last iteration
    loop.odd: True if an odd iteration
    loop.even: True if an even iteration
    loop.parity: "odd" or "even" depending on which is true
    loop.parent: the loop above this in nested loops
    
Sometimes these can be very handy.

    <table>
    $for c in ["a", "b", "c", "d"]:
        <tr class="$loop.parity">
            <td>$loop.index</td>
            <td>$c</td>
        </tr>
    </table>
    
<a name="otherstatements"></a> 
## Other Statements

<a name="def"></a>
### def

You can define a new template function using `$def`. Keyword arguments are also supported.

    $def say_hello(name='world'):
        Hello $name!
    
    $say_hello('web.py')
    $say_hello()

Another example:
        
    $def tr(values):
        <tr>
        $for v in values:
            <td>$v</td>
        </tr>

    $def table(rows):
        <table>
        $for row in rows:
            $:row
        </table>
    
    $ data = [['a', 'b', 'c'], [1, 2, 3], [2, 4, 6], [3, 6, 9] ]
    $:table([tr(d) for d in data])
    
<a name="code"></a>
### code

Arbitrary python code can be written using the `code` block.

    $code:
        x = "you can write any python code here"
        y = x.title()
        z = len(x + y)
        
        def limit(s, width=10):
            """limits a string to the given width"""
            if len(s) >= width:
                return s[:width] + "..."
            else:
                return s
                
    And we are back to template.
    The variables defined in the code block can be used here.
    For example, $limit(x)
    
<a name="var"></a>
### var

The `var` block can be used to define additional properties in the template result.

    $def with (title, body)
    
    $var title: $title
    $var content_type: text/html
    
    <div id="body">
    $body
    </div>
    
The result of the above template can be used as follows:

    >>> out = render.page('hello', 'hello world')
    >>> out.title
    u'hello'
    >>> out.content_type
    u'text/html'
    >>> str(out)
    '\n\n<div>\nhello world\n</div>\n'

<a name="builtins"></a>
# builtins and globals

Just like any Python function, template can also access builtins along with its arguments and local variables.
Some common builtin functions like `range`, `min`, `max` etc. and boolean values `True` and `False` are made available to all the templates.
Apart from the builtins, application specific globals can be specified to make them accessible in all the templates.

Globals can be specified as an argument to `web.template.render`.

    import web
    import markdown
    
    globals = {'markdown': markdown.markdown}
    render = web.template.render('templates', globals=globals)

Builtins that are exposed in the templates can be controlled too.

    # disable all builtins
    render = web.template.render('templates', builtins={})

<a name="security"></a>
# Security

One of the design goals of Templetor is to allow untrusted users to write templates.

To make the template execution safe, the following are not allowed in the templates.

* Unsafe statements like `import`, `exec` etc.
* Accessing attributes starting with `_`
* Unsafe builtins like `open`, `getattr`, `setattr` etc.

`SecurityException` is raised if your template uses any of these.

<a name="upgrading"></a>
# Upgrading from web.py 0.2 templates

The new implementation is mostly compatible with the earlier implementation. However some cases might not work because of the following reasons.

* Template output is always storage like `TemplateResult` object, however converting it to `unicode` or `str` gives the result as unicode/string.
* Reassigning a global value will not work. The following will not work if x is a global.
    
        $ x = x + 1
    
The following are still supported but not preferred.

* Using `\$` for escaping dollar. Use `$$` instead.
* Modifying `web.template.Template.globals`. pass globals to `web.template.render` as argument instead.

---
layout: default
title: Templetor web.py 模板系统
---

# Templetor: web.py 模板系统

<a name="introduction"></a>
# Introduction

<style>
pre {
    background-color:#F0F0F0;
    border:1px solid #CCCBBA;
       padding: 10px 10px 10px 20px;
}
code {
    background: inherit;
    color: inherit;
}
.warning {
    border: 1px solid #FFAAAA;
    padding: 10px;
    background-color: #FFF0F0;
}
</style>


web.py 的模板语言叫做 `Templetor`，它能负责将 python 的强大功能传递给模板系统。
在模板中没有重新设计语法，它是类 python 的。 
如果你会 python，你可以顺手拈来。

这是一个模板示例:

    $def with (name)
    Hello $name!

第一行表示模板定义了一个变量 `name`。
第二行中的 `$name` 将会用 `name` 的值来替换。

<div class="warning">
如果是从 web.py 0.2 升级请看这里 <a href="#upgrading">升级</a> 部分。
</div>

<a name="using"></a>
# 使用模板系统

通用渲染模板的方法：

    render = web.template.render('templates')
    return render.hello('world')
   
`render` 方法从模板根目录查找模板文件，`render.hello(..)`表示渲染 hello.html 模板。实际上，系统会在根目录去查找叫 `hello`的所有文件，直到找到匹配的。(事实上他只支持 .html 和 .xml 两种)

除了上面的使用方式，你也可以直接用文件的方式来处理模板 `frender`：

    hello = web.template.frender('templates/hello.html')
    render hello('world')
    
直接使用字符串方式：

    template = "$def with (name)\nHello $name"
    hello = web.template.Template(template)
    return hello('world')

<a name="syntax"></a>
# 语法

## 表达式用法

特殊字符 `$` 被用于特殊的 python 表达式。表达式能够被用于一些确定的组合当中 `()` 和 `{}`:

    Look, a $string. 
    Hark, an ${arbitrary + expression}. 
    Gawk, a $dictionary[key].function('argument'). 
    Cool, a $(limit)ing.

## 赋值

有时你可能需要定义一个新变量或给一些变量重新赋值，如下：
    
    $ bug = get_bug(id)
    <h1>$bug.title</h1>
    <div>
        $bug.description
    <div>

注意 `$`在赋值变量名称之前要有一个空格，这有区别于常规的赋值用法。

## 过滤

模板默认会使用 `web.websafe` 过滤 html 内容(encodeing 处理)。

    >>> render.hello("1 < 2")
    "Hello 1 &lt; 2"

不需要过滤可以在 `$` 之后 使用 `:`。示例：

    该 Html 内容不会被义
    $:form.render()
    
## 新起一行用法

在行末添加 `\` 代表显示层该内容不会被真实处理成一行。

    If you put a backslash \ 
    at the end of a line \ 
    (like these) \ 
    then there will be no newline.
    
## 转义 `$`

使用 `$$` 可以在输出的时候显示字符 `$`.

    Can you lend me $$50?
    
## 注释

`$#` 是注释指示符。任何以 `$#` 开始的某行内容都被当做注释。

    $# this is a comment
    Hello $name.title()! $# display the name in title case

## 控制结构

模板系统支持 `for`, `while`, `if`, `elif` 和 `else`。像 python 一样，这里是需要缩进的。

    $for i in range(10): 
        I like $i

    $for i in range(10): I like $i
        
    $while a:
        hello $a.pop()

    $if times > max: 
        Stop! In the name of love. 
    $else: 
        Keep on, you can do it.

`for` 循环内的成员变量只在循环内发生可用：

    loop.index: the iteration of the loop (1-indexed)
    loop.index0: the iteration of the loop (0-indexed)
    loop.first: True if first iteration
    loop.last: True if last iteration
    loop.odd: True if an odd iteration
    loop.even: True if an even iteration
    loop.parity: "odd" or "even" depending on which is true
    loop.parent: the loop above this in nested loops
    
有时候，他们使用起来很方便：

    <table>
    $for c in ["a", "b", "c", "d"]:
        <tr class="$loop.parity">
            <td>$loop.index</td>
            <td>$c</td>
        </tr>
    </table>
    
## 其他

### 使用 `def`

可以使用 `$def` 定义一个新的模板函数，支持使用参数。

    $def say_hello(name='world'):
        Hello $name!
    
    $say_hello('web.py')
    $say_hello()

其他示例：
        
    $def tr(values):
        <tr>
        $for v in values:
            <td>$v</td>
        </tr>

    $def table(rows):
        <table>
        $for row in rows:
            $:row
        </table>
    
    $ data = [['a', 'b', 'c'], [1, 2, 3], [2, 4, 6], [3, 6, 9] ]
    $:table([tr(d) for d in data])
    
### 代码

可以在 `code` 块书写任何 python 代码：
    $code:
        x = "you can write any python code here"
        y = x.title()
        z = len(x + y)
        
        def limit(s, width=10):
            """limits a string to the given width"""
            if len(s) >= width:
                return s[:width] + "..."
            else:
                return s
                
    And we are back to template.
    The variables defined in the code block can be used here.
    For example, $limit(x)
    
### 使用 `var`

`var` 块可以用来定义模板结果的额外属性：

    $def with (title, body)
    
    $var title: $title
    $var content_type: text/html
    
    <div id="body">
    $body
    </div>
    
以上模板内容的输出结果如下：

    >>> out = render.page('hello', 'hello world')
    >>> out.title
    u'hello'
    >>> out.content_type
    u'text/html'
    >>> str(out)
    '\n\n<div>\nhello world\n</div>\n'

<a name="builtins"></a>
# 内置 和 全局

像 python 的任何函数一样，模板系统同样可以使用内置以及局部参数。很多内置的公共方法像 `range`，`min`，`max`等，以及布尔值 `True` 和 `False`，在模板中都是可用的。部分内置和全局对象也可以使用在模板中。

全局对象可以使用参数方式传给模板，使用 `web.template.render`：

    import web
    import markdown
    
    globals = {'markdown': markdown.markdown}
    render = web.template.render('templates', globals=globals)

内置方法是否可以在模板中也是可以被控制的：

    # 禁用所有内置方法
    render = web.template.render('templates', builtins={})

<a name="security"></a>
# 安全

模板的设计想法之一是允许非高级用户来写模板，如果要使模板更安全，可在模板中禁用以下方法：

* 不安全部分像 `import`，`exec` 等；
* 允许属性开始部分使用 `_`；
* 不安全的内置方法 `open`, `getattr`, `setattr` 等。

如果模板中使用以上提及的会引发异常 `SecurityException`。

<a name="upgrading"></a>
# 从 web.py 0.2 升级

新版本大部分兼容早期版本，但仍有部分使用方法会无法运行，看看以下原因：

* Template output is always storage like `TemplateResult` object, however converting it to `unicode` or `str` gives the result as unicode/string.
* 重定义全局变量将无法正常运行，如果 x 是全局变量下面的写法是无法运行的。
    
        $ x = x + 1
    
以下写法仍被支持，但不被推荐。

* 如果你原来用 `\$` 反转美元字符串， 推荐用 `$$` 替换；
* 如果你有时会修改 `web.template.Template.globals`，建议通过向 `web.template.render` 传变量方式来替换。

---
layout: default
title: TODO - A faire
---

# TODO - A faire

#Traduction française

Ici sera réunie la liste des travaux à réaliser et ceux en cours de réalisation, conçernant la traduction française de web.py.

1. Lorsque vous commençez une traduction, pensez à le noter sur cette page, dans la rubrique 'en cours',  afin qu'un autre traducteur ne fasse pas le même travail au même moment.

1. N'oubliez pas de mettre à jour les liens se rapportant à la page traduite.

1. Les chemins des pages traduites devront ressembler à l'exemple ci-dessous et respecter la hierarchie du schéma anglais:
	*cookbook/helloworld* --> *cookbook/helloworld/fr*

-------------------------------------------------

# En cours

* [Utiliser session avec reloader](/cookbook/session_with_reloader). - en cours

# A faire

## Documentation de web.py 0.3


### Exemples de code
* [Code samples](/src). - traduction demandée

### Documentation des composants
* [Subdir app](/docs/0.3/apps/subdir). - traduction demandée
* [Subdomain app](/docs/0.3/apps/subdomain). - traduction demandée

### Mise à jour vers la version actuelle 
* [Upgrade to 0.3 versions of web.py](/docs/0.3/upgrade) - traduction demandée

	### API Documentation
* [API documentation](/docs/0.3/api) - traduction demandée


## Cookbook

###Avancé
* [Comment utiliser web.background](/cookbook/background). - traduction demandée
* [Run-time language switch](/cookbook/runtime-language-switch). - traduction demandée

###Sessions et état des utilisateurs:
* [Utiliser session dans un gabarit](/cookbook/session_in_template). - traduction demandée
* [Travailler avec les cookies](/cookbook/cookies). - traduction demandée
* [Authentification des utilisateurs](/cookbook/userauth). - traduction demandée
* [Authentification des utilisateurs avec base de données Postgresql](/cookbook/userauthpgsql). - traduction demandée
* [Session avec des sous-apps](/cookbook/sessions_with_subapp). - traduction demandée 

###Utils:
* [Envoi de Mail](/cookbook/sendmail). - traduction demandée
* [Envoi de Mail en utilisant Gmail](/cookbook/sendmail_using_gmail).  - traduction demandée
* [Webservice en utilisant soaplib + WSDL](/cookbook/webservice). - traduction demandée

###Modèles de mise en forme, gabarits de mise en page:
* [Utiliser des gabarits sur le site](/cookbook/layout_template). - traduction demandée
* [Alterner un style](/cookbook/alternating_style). - traduction demandée
* [Importer des fonctions dans les gabarits](/cookbook/template_import). - traduction demandée
* [i18n support dans les fichiers gabarits](/cookbook/i18n_support_in_template_file ). - traduction demandée
* [Utiliser le moteur de gabarit Mako dans webpy](/cookbook/template_mako). - traduction demandée
* [Utiliser le moteur de gabarit Cheetah dans webpy](/cookbook/template_cheetah). - traduction demandée
* [Utiliser le moteur de gabarit  Jinja2 dans webpy](/cookbook/template_jinja). - traduction demandée
* [Comment utiliser les gabarits sur Google App Engine](/cookbook/templates_on_gae). - traduction demandée

###Essais:
* [Tester avec Paste et Nose](/cookbook/testing_with_paste_and_nose). - traduction demandée
* [RESTful doctesting using an application's request method](/cookbook/restful_doctesting_using_request). - traduction demandée

###Entrées utilisateurs:
* [Uploader un fichier](/cookbook/fileupload). - traduction demandée
* [Stocker un fichier uploadé](/cookbook/storeupload). - traduction demandée
* [Comment limiter la taille des fichiers uploadés](/cookbook/limiting_upload_size). - traduction demandée
* [Accéder aux entrées utilisateurs par le biais de web.input](/cookbook/input). - traduction demandée
* [Comment utiliser les formulaires](/cookbook/forms). - traduction demandée
* [Rendu individuel des champs de formulaires](/cookbook/form_fields). - traduction demandée

###Base de données:
* [Multiples bases de données](/cookbook/multidbs). - traduction demandée
* [Select: Récupérer les entrées d'une base de données](/cookbook/select). - traduction demandée
* [Update: Mettre à jour les entrées d'une base de données](/cookbook/update).  - traduction demandée
* [Delete: Supprimer les entrées d'une base de données](/cookbook/delete). - traduction demandée
* [Insert: Ajouter des entrées à une base de donnée](/cookbook/insert).  - traduction demandée
* [Query: Base de données - Requêtes avancées](/cookbook/query). - traduction demandée
* [Query: How to use database transactions](/cookbook/transactions). - traduction demandée
* [Comment utiliser sqlalchemy](/cookbook/sqlalchemy). - traduction demandée
* [Intégrer SQLite UDF (user-defined-functions) à la couche de base de données webpy](/cookbook/sqlite-udf). - traduction demandée
* [Utiliser un dictionnaire comme clause where](/cookbook/where_dict). - traduction demandée

###Déploiement:
* [Déploiement Fastcgi au travers lighttpd](/cookbook/fastcgi-lighttpd). - traduction demandée
* [Déploiement Fastcgi au travers Apache](/cookbook/fastcgi-apache).  - traduction demandée
* [Déploiement CGI au travers Apache](/cookbook/cgi-apache). - traduction demandée
* [Déploiement mod_wsgi au travers Apache](/cookbook/mod_wsgi-apache ).  - traduction demandée
* [Déploiement mod_wsgi au travers Nginx](/cookbook/mod_wsgi-nginx ).  - traduction demandée
* [Déploiement Fastcgi au travers Nginx](/cookbook/fastcgi-nginx). - traduction demandée
---
layout: default
title: web.py 0.3 tutorial
---

# web.py 0.3 tutorial

Autre langages : [english](/tutorial3.en) | [chinese](/tutorial3.zh-cn) | [japan](/tutorial2.ja) | ...

# Sommaire


* <a href="#introduction">Prérequis</a>
* <a href="#manipurl">Manipuler les URLs</a>
* <a href="#gereurl">Gérer les URLs</a>
* <a href="#getpost">GET et POST : la différence</a>
* <a href="#index">Page index - ma première classe</a>
* <a href="#lance">Lancer le serveur</a>
* <a href="#template">Modèles, gabarits</a>
* <a href="#formulaires">Formulaires</a>
* <a href="#bd">Base de données</a>
* <a href="#affbd">Afficher le contenu d'une base de données</a>
* <a href="#ecrbd">Ecrire dans une base de données</a>
* <a href="#debug">Debugger</a>
* <a href="#apres">Et Après ?</a>

<a name="introduction"></a>
# Prérequis



Vous connaissez Python et vous désirez construire un site web. Webpy vous permettra de le faire facilement.

Si vous décidez de suivre l'ensemble de ce tutorial, vous aurez besoin d'installer Python, [web.py] (/install/fr) , flup, psycopg2 et Postgres (ou une base de donnée equivalente et les pilotes python). Pour plus de détails, veuillez consulter [webpy.org](http://webpy.org/)

Si vous possédez déjà un projet web.py existant, jetez un oeil à la page de [mise à jour](http://webpy.org/docs/0.3/upgrade) pour plus d'informations sur la migration.


# Commençons


<a name="manipurl"></a>
## Manipuler les URLs

La partie la plus importante de n'importe quel site web est la structure des URLs. Les URLs ne sont pas que des liens que vos visiteurs voient et envoient par mails à leurs amis, elles fournissent aussi un modèle mental sur la façon avec laquel un site web fonctionne. Sur des sites populaires tels que del.icio.us, les URLs font partie même de l'interface utilisateur. Web.py rend la création d'URLs facile.

Pour commencer avec votre application web.py, ouvrez un nouveau fichier texte (que nous appelerons "code.py") et tapez:

     import web

Cela importera le module web.py.

Maintenant, Nous devons donner à web.py notre structure URL. Commençons avec quelque chose de simple:

     urls = (
            '/', 'index'
            )

La première partie est une expression régulière que l'on applique à une chaîne de caractère (l'URL), telle que /, /help/faq, /item/(\d+), etc.. (Note: \d+ n'admettra qu'une séquence de chiffre). Les parenthèses signifient qu'il faut capturer la séquence pour s'en servir plus tard. La seconde partie est le nom d'une Classe vers laquelle la requête sera envoyée, comme 'index', 'view', 'welcome.hello' (qui recherchera la Classe hello du module welcome.), ou get_\1.
/1 est remplacé par la première capture de l'expression régulière; toutes les captures restantes seront passées à votre fonction. [Note traducteur : A préciser]

Cette ligne signifie que nous souhaitons l'URL / (Note: la page d'accueil) qui doit être traitée par la classe nommée 'index'.

<a name="gereurl"></a>
## Gérer les URLs

Maintenant, nous avons besoin de créer une application spécifiant les URLs.

     app = web.application(urls, globals())

Cela explique à web.py qu'il faut créer une application avec les URLs qui sont listées ci-dessus, en appelant les Classes dans l'espace de noms global de ce fichier.

<a name="getpost"></a>
## GET et POST: la différence

Alors que la plupart des gens ne le remarquent pas en naviguant simplement, votre navigateur utilise un protocole connu appelé HTTP pour communiquer avec le World Wide Web. Les détails ne sont pas importants, mais l'idée de base est que les visiteurs de sites web demandent aux serveurs de sites web de remplir certaines fonctions (telles que GET ou POST) sur les URLs (comme / ou /foo?f=1).

GET est celle que nous connaissons tous, celle qui sert à demander le texte d'une page web. Lorsque vous tapez 'harvard.edu' dans votre navigateur, cela demande littéralement au serveur web de Harvard de fournir /. La seconde fonction très célèbre, POST, est souvent utilisée lorsque vous utilisez certains types de formulaires, comme une demande d'achat d'un produit. Vous utilisez POST chaque fois que vous soumettez une demande (comme le débit de votre carte de crédit et le traitement d'une commande). Cela est essentiel, parce que GET URLs peut être transmis et indexé par les moteurs de recherche, que vous voulez certainement pour la plupart de vos pages, mais ne désirez certainement pas pour des choses comme le traitement des ordres (imaginez si Google essaye de tout acheter sur votre site!)


<a name="index"></a>
## Page index - ma première classe

Dans notre code web.py, nous faisons la distinction entre les deux clairement. Maintenant, il est nécessaire d'écrire la Classe 'index'.

     class index:
        def GET(self):
           return "Hello, world!"

Cette fonction GET sera maintenant appelée par web.py chaque fois qu'il y aura une requête GET pour /.

Très bien, maintenant nous avons juste besoin d'en finir avec une ligne finale disant à web.py de commencer à fournir des pages web:

     if __name__ == "__main__": app.run()

Cela explique à web.py qu'il faut lancer l'application que nous avons créé ci-dessus.

Maintenant notez que, bien que j'ai beaucoup parlé ici, nous avons seulement cinq ou six lignes de code tout au plus. C'est tout ce dont nous avons besoin pour créer une application web.py complète. 

<a name="lance"></a>
## Lancer le serveur

Si vous allez dans votre terminal et que vous tapez les lignes de commande suivantes :

     $ python code.py

Vous verrez s'afficher : http://0.0.0.0:8080/

Vous avez maintenant votre application web.py qui tourne comme un vrai serveur web sur votre ordinateur!

En visitant cette URL, vous devriez voir "Hello, world!" dans votre navigateur. (Vous pouvez ajouter une adresse IP/Port après la partie "code.py" pour contrôler où web.py lancera le serveur. Vous pouvez aussi lui dire de faire fonctionner un serveur fastcgi ou scgi.)

[Note traducteur : A PRECISER]

Note: Vous pouvez spécifier le numéro de port à utiliser dans la ligne de commande, si vous ne souhaitez pas utiliser le port par défaut :

     $ python code.py 1234



<a name="template"></a>
# Modèles, gabarits

Ecrire du HTML à l'intérieur de python peut être lourd et pesant. C'est bien plus amusant d'écrire du Python à l'intérieur du HTML. Par bonheur, web.py le fait très facilement.

Note: Les anciennes versions de web.py utilisent le système de gabarit de [Cheetah] (http://www.cheetahtemplate.org/). Vous êtes, evidemment, libres d'utiliser celui-ci ou n'importe quel autre logiciel de template avec web.py, mais il n'est plus officiellement supporté.

Créons un nouveau répertoire pour nos gabarits (nous l'appellerons templates). A l'intérieur, créons un nouveau fichier dont l'extension sera HTML (appelons-le index.html). Dans ce fichier, vous pouvez juste écrire du HTML classique:

     <em>Hello</em>, world!

Ou utiliser le langage de template de web.py ( [Templator](http://webpy.org/docs/0.3/templetor.fr) ) pour ajouter du code dans votre HTML:

     $def with (name)

        $if name:
           I just wanted to say <em>hello</em> to $name.
        $else:
           <em>Hello</em>, world!

Comme vous pouvez le voir, les gabarits ressemblent beaucoup à des fichiers Python, excepté la déclaration 'def' tout en haut (qui explique avec quoi le modèle est appelé) ainsi que les $s placés devant chaque code. 
Actuellement, template.py exige que la déclaration $def soit la première ligne du gabarit. Notez également que web.py encode automatiquement les variables utilisées ici, de sorte que si, pour une raison un nom est défini dans une valeur contenant du HTML, il sera proprement encodé et apparaitra comme un texte plein. 
Si vous souhaitez désactiver cette fonction, écrivez $:name à la place de $name.

Maintenant, retournons à notre "code.py". Sous la première ligne ajoutez:

     render = web.template.render('templates/')

Cela indique à web.py qu'il faut rechercher le gabarit dans le repertoire 'templates'. Maintenant modifiez le contenu de la fonction GET dans index en:

     name = 'Bob'    
     return render.index(name)

(Ici, 'index' est le nom du gabarit et 'name' est un argument qui lui est transmis)

Visitez votre site, il devrait vous afficher "I just wanted to say hello to Bob."

Mais imaginons que nous souhaitions que les gens entrent leur propre nom. Dans ce cas, remplacez les deux lignes que nous avons ajouté par:

     i = web.input(name=None)
     return render.index(i.name)

En visitant / il devrait vous afficher "Hello, world!". Mais en visitant /?name=Joe il vous affichera "I just wanted to say hello to Joe."
Naturellement, en voyant ceci, on constate que l'URL n'est pas très claire. Pour l'améliorer, modifiez votre ligne URL en haut en:

     '/(.*)', 'index'

Et modifiez la définition de la fonction GET de la classe index en:

     def GET(self, name):
        return render.index(name)

puis effaçez la ligne qui définit le nom. Maintenant, visitez /joe et il devrait vous afficher hello to Joe.

Si vous désirez en apprendre davantage sur les gabarits de web.py, visitez la page [Templetor](http://webpy.org/templetor)

<a name="formulaires"></a>
# Formulaires

Le module de formulaire de web.py permet de générer des formulaires HTML, de récuperer les entrées des utilisateurs, et les valider avant de les traiter ou les ajouter à une base de donnée.
Si vous souhaitez en apprendre plus sur l'utilisation du module de formulaires de web.py, consultez la [Documentation](http://webpy.org/docs/0.3.fr) ou la traduction française du module [Formulaires](http://webpy.org/docs/0.3/form.fr)

<a name="bd"></a>
# Base de données

Note: Avant de pouvoir utiliser une base de données, soyez certains d'avoir la librairie de la base de données appropriée déjà installée. Pour la base de donnée MySQL, utilisez MySQLdb et pour Postgres, utilisez psycopg2.

Premièrement, vous devez créer un objet database.

     db = web.database(dbn='postgres', user='username', pw='password', db='dbname')

(Adaptez ici -- particulièrement pour `username`, `password`, and `dbname` -- vos paramètres de connexion. les utilisateurs de MySQL devront modifier la définition `dbn` en `mysql`.)

C'est tout ce dont vous avez besoin -- web.py gèrera automatiquement la connexion et la déconnexion à la base de données.

<a name="affbd"></a>
## Afficher le contenu d'une base de données

Utilisez votre interface d'administration de la base de données, et créez une simple table dans la base de données:

     CREATE TABLE todo (
        id serial primary key,
        title text,
        created timestamp default now(),
        done boolean default 'f'    
        );

Ainsi qu'une ligne initiale:

     INSERT INTO todo (title) VALUES ('Learn web.py');

Revenez à "code.py" et modifiez la fonction 'GET' de la Classe 'index' de la façon suivante en remplaçant la fonction entièrement:

     def GET(self):
        todos = db.select('todo')
        return render.index(todos)

puis remodifiez le gestionnaire d'URLs pour qu'il ne prenne en compte que /:

     '/', 'index'

Editez et remplaçez le contenu entier du gabarit `index.html` de cette façon:

     $def with (todos)
        <ul>
           $for todo in todos:
              <li id="t$todo.id">$todo.title</li>
        </ul>

En visitant à nouveau votre site, vous devriez voir: "Learn web.py". 

Félicitations ! Vous venez de créer une application complète qui lit une base de données. 

<a name="ecrbd"></a>
## Ecrire dans une base données

Maintenant, nous allons écrire dans la base de données.

A la fin du gabarit `index.html`, ajoutez:

     <form method="post" action="add">
        <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
     </form>

puis modifiez la liste de vos URLs pour qu'elle ressemble à:

     '/', 'index',
     '/add', 'add'

(Vous devez être très prudents avec les virgules. Si vous en oubliez, Python joint les chaînes ensembles, et verra `/index/addadd` à la place de votre liste d'URLs!)

Maintenant, ajoutons une nouvelle Classe:

     class add:
        def POST(self):
           i = web.input()
           n = db.insert('todo', title = i.title)
           raise web.seeother('/')

(Avez-vous noté que nous utilisons la fonction `POST` pour celle-ci?)

`web.input` vous donne accès à toutes les variables de l'utilisateur soumises via un formulaire.

Note: Afin d'accéder aux données à partir de plusieurs éléments identiquement nommé, dans un format de liste (Une série de cases à cocher qui ont toutes l'attribut name="name"), utilisez:

     post_data=web.input(name=[])

`db.insert` insère les valeurs dans la table `todo` de la base de données et renvoie l'ID de la ligne créée.  
`seeother` redirige les utilisateurs vers cette URL.

Quelques notes additionnelles: 

`db.update` fonctionne comme `db.insert` excepté qu'au lieu de renvoyer l'ID, il doit recevoir en argument, après le nom de la table, soit l'ID soit une clause `WHERE` permettant d'identifier la ligne à modifier.

    
    db.update('todo', where="id = 10", title = "web.py pour les nuls")


`web.input`, `db.query`, et d'autres fonctions dans web.py renvoient des Objets de Stockage (Storage objects), qui sont comme des dictionnaires mis à part que vous pouvez écrire `d.foo` en plus de `d['foo']`. Cela rend le code plus clair.

<a name="debug"></a>
# Debugger

web.py possède aussi des outils de debugging pour nous aider. Quand nous le faisons tourner avec le server web intégré, il commence l'application en mode debuggage. Dans ce mode, toutes les modifications du code et des gabarits sont automatiquement rechargées et les messages d'erreur contiennent de précieuses informations.

Le debuggage n'est pas actif lorsque l'application tourne comme un vrai serveur. Si vous souhaitez désactiver ce mode, vous pouvez le faire en ajoutant la ligne suivante avant de créer votre application/gabarit:

     web.config.debug = False

C'est la fin du tutorial maintenant. Jetez un oeil à la [Documentation](http://webpy.org/docs/0.3.fr) pour voir ce que vous pouvez utiliser avec web.py.

Vous pourrez trouver pleins de détails de tout ceci ainsi que de toutes les fonctions web.py dans la [Documentation](http://webpy.org/docs/0.3.fr).

<a name="apres"></a>
## Et après ?

* [Plus de documentation](/docs/0.3.fr) 
* [Formulaires](/docs/0.3/form.fr) 
* [Templator: le modèle de gabarit de web.py](/docs/0.3/templetor.fr)
* [Cookbook](/cookbook/fr)
* [Exemples de codes](/src)
---
layout: default
title: Tutorial web.py 0.3
---

# Tutorial

Bahasa Lain : [Inggris](/docs/0.3/tutorial) | [China 简体中文](/docs/0.3/tutorial.zh-cn) | [Perancis](/docs/0.3/tutorial.fr) | ...

## Ringkasan

* [Memulai](#starting)
* [Penanganan URL](#urlhandling)
* [GET dan POST: perbedaannya](#getpost)
* [Memulai server](#start)
* [Menggunakan template](#templating)
* [Form](#forms)
* [Menggunakan database](#databasing)
* [Selama pengembangan](#developing)
* [Berikutnya?](#whatnext)

## Memulai

Jadi Anda mengerti Python dan ingin membuat sebuah website. web.py 
menyediakan kode untuk membuatnya mudah. 

Apabila Anda ingin mengikuti keseluruhan tutorial, Anda perlu 
menginstall Python, web.py, flup, psycopg2 dan PostgreSQL (atau 
database yang ekuivalen dan driver untuk Python). Lihatlah halaman <a 
href="/install">install</a> untuk detilnya. 

Mari kita mulai.

<a name="urlhandling"> </a>
## Penanganan URL

Bagian paling penting dari setiap website adalah struktur URL yang 
digunakan. URL yang Anda gunakan bukan saja merupakan sesuatu yang 
pengunjung Anda lihat dan email ke teman-temannya, namun juga 
merupakan model mental dari bagaimana website Anda bekerja. Pada 
website populer seperti [del.icio.us](http://del.icio.us/), URL bahkan 
merupakan bagian dari user interface. web.py memudahkan kita untuk 
membuat URL yang bagus. 

Untuk memulai aplikasi web.py Anda, buatlah file teks baru (mari kita 
beri nama `code.py`) dan ketikkan:

    import web

Ini akan mengimport modul web.py. 

Sekarang, kita perlu beri tahu web.py tentang struktur URL kita. Mari 
kita mulai dengan yang sederhana:

    urls = (
      '/', 'index'
    )

Bagian pertama merupakan [regular expressions](http://osteele.com/tools/rework/) yang cocok dengan sebuah 
URL, seperti `/`, `/help/faq`, `/item(\d+)` dan sebagainya (contoh: 
`\d+` akan cocok dengan deretan digit). Tanda kurung akan cocok dengan 
bagian dari data untuk dipergunakan nantinya. Bagian kedua merupakan 
nama class di mana request akan dikirim, seperti `index`, `view`, 
`welcomes.hello` (yang akan merujuk pada class `hello` dari modul 
`welcomes`),atau `get_\1`. `\1` akan digantikan dengan tangkapan 
pertama dari regular expression yang digunakan; tangkapan lainnya akan 
dilewatkan ke fungsi yang Anda buat. 

Baris ini menyatakan bahwa kita ingin agar URL `/` (contoh: halaman 
depan sebuah website) akan ditangani oleh class dengan nama `index`. 

<a name="getpost"> </a>
## GET dan POST: perbedaannya

Sekarang kita ingin menulis class `index`. Walau sebagian besar 
pengunjung tidak memperhatikan pada saat browsing, browser Anda 
mempergunakan bahasa yang dikenal sebagai HTTP untuk berkomunikasi 
dengan World Wide Web. Detilnya memang tidak penting, tapi pada 
dasarnya, pengunjung web meminta kepada web server untuk melakukan 
fungsi tertentu (seperti `GET` atau `POST`) pada URL (seperti `/` atau 
`/foo?f=1`). 

`GET`, yang kita kenal, akan meminta teks dari halaman web. Pada saat 
Anda mengetikkan `harvard.edu` di web browser Anda, browser tersebut 
akan meminta kepada web server Harvard untuk `GET /`. Yang kita kenal 
juga, `POST`, umum digunakan pada saat mengirimkan form-form tertentu, 
seperti pada saat berbelanja online. Anda menggunakan `POST` pada saat 
aksi dari pengiriman sebuah request akan _melakukan sesuatu_ (seperti 
charge kartu kredit atau memroses sebuah order). Perhatikanlah, karena 
URL `GET` dapat diindeks oleh search engine, yang mana umumnya Anda  
inginkan untuk sebagian besar halaman Anda, tapi _tidak_ Anda inginkan 
untuk hal-hal seperti memroses order (bayangkan jika Google mencoba 
untuk membeli segalanya di website Anda). 

Di dalam kode web.py kita, kita bedakan dengan jelas antara keduanya:

    class index:
        def GET(self):
            return "Hello, world!"

Fungsi `GET` akan dipanggil oleh web.py setiap saat seseorang membuat 
request `GET` untuk `/`. 

Sekarang kita perlu membuat sebuah aplikasi dengan menyatakan URL yang 
kita miliki dan meminta kepada web.py untuk memulai melayani halaman 
web:

    if __name__ == "__main__": 
        app = web.application(urls, globals())
        app.run()        

Pertama, kita meminta kepada web.py untuk membuat sebuah aplikasi 
dengan URL yang kita daftarkan di atas, dengan mencari class-class 
dari namespace global file ini. Dan, akhirnya, kita meminta web.py 
untuk menjalankan server untuk aplikasi yang kita buat sebelumnya. 

Perhatikanlah bahwa walaupun saya telah banyak berbicara, kita 
sebenarnya hanya memiliki lima baris kode. Itulah yang Anda perlukan 
untuk membuat sebuah aplikasi web.py yang lengkap. 

Untuk lebih mudahnya, berikut adalah kode lengkapnya:

    import web
    
    urls = (
        '/', 'index'
    )
    
    class index:
        def GET(self):
            return "Hello, world!"
    
    if __name__ == "__main__":
        app = web.application(urls, globals())
        app.run()

<a name="start"> </a>
## Memulai server

Apabila Anda ke command line dan mengetikkan:

    $ python code.py
    http://0.0.0.0:8080/

Maka aplikasi web.py Anda akan menjalankan sebuah web server 
sesungguhnya di komputer Anda. Kunjungilah URL tersebut dan seharusnya 
Anda akan melihat tulisan: "Hello, world!" (Anda dapat menambahkan 
alamat IP/port setelah "code.py" untuk mengontrol di mana web.py akan 
menjalankan server. Anda juga dapat memintanya untuk menjalankan 
server `fastcgi` atau `scgi`.)

**Catatan**: Anda dapat menentukan port yang ingin digunakan di command 
line seperti ini, jika Anda tidak dapat atau tidak ingin menggunakan 
nilai default:

    $ python code.py 1234


<a name="templating"> </a>
## Menggunakan template

Menulis HTML di dalam Python bisa menjadi merepotkan; lebih nyaman 
untuk menulis Python di dalam HTML. Untungnya, web.py membuatnya cukup 
mudah. 

Mari buat direktori untuk menyimpan template kita (kita berikan nama 
`templates`). Di dalamnya, buatlah file baru dengan nama diakhiri 
dengan HTML (kita berikan nama `index.html`). Sekarang, di dalam file 
tersebut, Anda dapat menulis HTML seperti biasanya:

    <em>Hello</em>, world!

Atau, Anda bisa gunakan bahasa template milik web.py untuk menambahkan 
kode ke dalam HTML Anda:

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

Seperti yang bisa Anda lihat, template sangat mirip dengan file Python 
kecuali dengan adanya statemen `def with` di awal file (menyatakan apa 
yang dilewatkan ke template) dan `$` yang ada di awal setiap kode. 
Saat ini, template.py mengharuskan statement `def with` merupakan 
baris pertama file. Perhatikanlah juga bahwa web.py secara otomatis 
akan mengescape setiap variabel yang digunakan di sini, sehingga 
apabila `name` diberikan nilai yang mengandung kode HTML tertentu, 
secara otomatis akan diescape dan tampil sebagai teks biasa. Apabila 
Anda ingin menonaktifkan fitur ini, gantilah `$name` dengan `$:name`. 

Sekarang, mari kembali ke `code.py`. Di bawah baris pertama, tambahkan:

    render = web.template.render('templates/')

Ini akan meminta web.py untuk mencari template ke dalam direktori 
`templates`. Kemudian, gantilah `index.GET` menjadi:

    name = 'Bob'    
    return render.index(name)

('index' adalah nama template dan 'name' merupakan argumen yang 
dilewatkan kepadanya)

Kunjungilah website Anda, yang harusnya akan menyapa hello kepada Bob. 

Tapi, katakanlah kita ingin agar pengunjung dapat memasukkan namanya 
sendiri. Gantilah dua baris yang kita tambahkan di atas dengan:

    i = web.input(name=None)
    return render.index(i.name)

Kunjungilah `/` dan harusnya, hello kepada dunia akan ditampilkan. 
Kunjungilah `/?name=Joe` dan harusnya, hello kepada Joe akan 
ditampilkan. 

Tentu saja, memiliki `?` tersebut di URL tidaklah cantik. Mari ganti 
definisi URL di bagian atas kode menjadi:

    '/(.*)', 'index'

Dan ganti definisi `index.GET` menjadi:

    def GET(self, name):
        return render.index(name)

Dan hapuslah baris yang mengatur name. Sekarang, kunjungilah `/Joe` 
dan harusnya, hello kepada Joe akan ditampilkan. 

Apabila Anda ingin belajar lebih lanjut tentang template, kunjungilah 
<a href="/docs/0.3/templetor">halaman templetor</a>.

<a name="forms"> </a>
## Form

Modul form dari web.py memungkinkan pembuatan form HTML, mendapatkan 
input dari user, dan melakukan validasi sebelum input diproses atau 
ditambahkan ke dalam database. Apabila Anda ingin belajar lebih lanjut 
tentang modul form web.py, bacalah [Dokumentasi](/docs/0.3) or 
kunjungilah link langsung ke [Pustaka Form](/form).

<a name="databasing"> </a>
## Menggunakan database

**Catatan:** Sebelum Anda dapat mulai menggunakan database, 
pastikanlah pustaka untuk mengakses database telah terinstall. Untuk 
database MySQL, gunakanlah 
[MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) 
dan untuk database PostgreSQL, gunakanlah [psycopg2](http://initd.org/pub/software/psycopg/).

Pertama, Anda perlu membuat objek database.

    db = web.database(dbn='postgres', user='username', pw='password', db='dbname')

(Sesuaikanlah -- terutama `username`, `password`, dan `dbname` -- 
dengan setup Anda. Pengguna MySQL juga perlu mengubah definisi `dbn` 
ke `mysql`.)

Ini adalah semua yang perlu Anda lakukan -- web.py secara otomatis 
akan menangani koneksi dan diskoneksi dari database. 

Pada interface admin dari engine database yang Anda gunakan, buatlah sebuah 
tabel sederhana di dalam database Anda:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

Dan tambahkan sebuah baris:

    INSERT INTO todo (title) VALUES ('Learn web.py');

Kembalilah mengedit `code.py` dan gantilah `index.GET` menjadi nilai 
berikut, menimpa seluruh isi fungsi sebelumnya: 

    def GET(self):
        todos = db.select('todo')
        return render.index(todos)

Dan gantilah handler URL untuk hanya menerima `/` seperti berikut:

    '/', 'index',

Edit dan gantilah keseluruhan isi `index.html` sehingga menjadi 
berikut:

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

Kunjungilah kembali website Anda dan Anda harusnya akan melihat sebuah 
item todo: "Learn web.py". Selamat! Anda telah membuat sebuah aplikasi 
lengkap yang membaca dari database. Sekarang, mari kita membuatnya 
dapat juga menulis ke database. 

Pada bagian akhir dari `index.html`, tambahkanlah:

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

Dan gantilah definisi URL menjadi:

    '/', 'index',
    '/add', 'add'

(Hati-hatilah dengan koma-koma yang ada. Apabila Anda tidak 
menuliskannya, Python akan menggabungkan semuanya sehingga menjadi 
`'/index/addadd'` dan bukannya daftar URL Anda!)

Sekarang, tambahkanlah class lain:

    class add:
        def POST(self):
            i = web.input()
            n = db.insert('todo', title=i.title)
            raise web.seeother('/')

(Perhatikanlah bagaimana kita menggunakan `POST` untuk ini?)

`web.input` memungkinkan kita untuk mengakses setiap variabel yang 
dikirim oleh user lewat sebuah form. 

**Catatan:** Untuk dapat mengakses data dari berbagai item yang 
bernama sama, dalam format list (contoh: berbagai checkbox yang 
semuanya memiliki atribut name="name"), pergunakanlah:

    post_data=web.input(name=[])

`db.insert` akan menambahkan nilai ke dalam tabel database `todo` dan 
mengembalikan nilai ID dari baris baru. `seeother` akan melakukan 
redireksi ke suatu URL. 

`web.input`, `db.query` dan fungsi lainnya di web.py mengembalikan 
"objek Storage", yang mirip dengan dictionary, namun Anda bisa 
melakukan `d.foo` selain `d['foo']`. Ini akan menjadikan kode lebih 
bersih. 

Untuk detil lebih lanjut, termasuk untuk semua fungsi web.py, bacalah 
[dokumentasi](/docs/0.3).

<a name="developing"> </a>
## Selama pengembangan

web.py juga memiliki beberapa alat bantu untuk membantu kita melakukan 
debugging. Pada saat berjalan dengan web server bawaan, web.py akan 
menjalankan aplikasi pada modus debug. Dalam modus tersebut, setiap 
perubahan pada kode dan template secara otomatis akan dibaca ulang dan 
pesan-pesan kesalahan akan mengandung lebih banyak informasi berguna. 

Modus debug ini tidak diaktifkan pada saat aplikasi berjalan pada web 
server sesungguhnya. Apabila Anda ingin menonaktifkan modus debug, 
Anda dapat menambahkan kode berikut sebelum membuat aplikasi/template:

    web.config.debug = False

<a name="whatnext"> </a>
## Berikutnya?

Sampai di sini dulu tutorial kita. Kunjungilah [buku resep](/cookbook/) 
dan [contoh kode](/src/) untuk contoh-contoh keren yang dapat Anda 
lakukan dengan web.py. Dan, jangan lupakan juga [referensi 
api](/docs/0.3/api).

---
layout: default
title: Tutorial
---

# Tutorial

Other languages : [chinese 简体中文 ](/docs/0.3/tutorial.zh-cn) | [français](/docs/0.3/tutorial.fr) | [Bahasa Indonesia](/docs/0.3/tutorial.id) | ...

## Summary

* [Starting](#starting)
* [URL Handling](#urlhandling)
* [GET and POST: the difference](#getpost)
* [Start the server](#start)
* [Templating](#templating)
* [Forms](#forms)
* [Databasing](#databasing)
* [Developing](#developing)
* [What next?](#whatnext)

## Starting

So you know Python and want to make a website. web.py provides the code to make that easy.

If you want to do the whole tutorial, you'll need to have installed Python, web.py, flup, psycopg2, and Postgres (or equivalent database and Python driver). (See <a href="/install">install</a> for details.)

Let's get started.

<a name="urlhandling"> </a>
## URL Handling

The most important part of any website is its URL structure. Your URLs aren't just the thing that your visitors see and email to their friends, they also provide a mental model of how your website works. On popular sites like [del.icio.us](http://del.icio.us/), the URLs are even part of the user interface. web.py makes it easy to make great URLs.

To get started with your web.py application, open up a new text file (let's call it `code.py`) and type:

    import web

This imports the web.py module.

Now we need to tell web.py our URL structure. Let's start out with something simple:

    urls = (
      '/', 'index'
    )

The first part is a [regular expressions](http://osteele.com/tools/rework/) that matches a URL, like `/`, `/help/faq`, `/item/(\d+)`, etc. (i.e. `\d+` would match a sequence of digits). The parentheses say to capture that piece of the matched data for use later on. The second part is the name of a class to send the request to, like `index`, `view`, `welcomes.hello` (which gets the `hello` class of the `welcomes` module), or `get_\1`. `\1` is replaced by the first capture of your regular expression; any remaining captures get passed to your function.

This line says we want the URL `/` (i.e. the front page) to be handled by the class named `index`.

<a name="getpost"> </a>
## GET and POST: the difference

Now we need to write the `index` class. While most people don't notice it just browsing around, your browser uses a language known as HTTP for communicating with the World Wide Web. The details aren't important, but the basic idea is that Web visitors ask web servers to perform certain functions (like `GET` or `POST`) on URLs (like `/` or `/foo?f=1`). 

`GET` is the one we're all familiar with, the one used to request the text of a web page. When you type `harvard.edu` into your web browser, it literally asks the Harvard web server to `GET /`.  The second-most famous, `POST`, is often used when submitting certain kinds of forms, like a request to purchase something. You use `POST` whenever the act of submitting a request _does something_ (like charge your credit card and process an order). This is key, because `GET` URLs can be passed around and indexed by search engines, which you definitely want for most of your pages but definitely _don't_ want for things like processing orders (imagine if Google tried to buy everything on your site!).

In our web.py code, we make the distinction between the two clear:

    class index:
        def GET(self):
            return "Hello, world!"

This `GET` function will now get called by web.py anytime someone makes a `GET` request for `/`.

Now we need to create an application specifying the urls and a way to tell  web.py to start serving web pages:

    if __name__ == "__main__": 
        app = web.application(urls, globals())
        app.run()        

First we tell web.py to create an application with the URLs we listed above, looking up the classes in the global namespace of this file.
And finally we make sure that web.py serves the application we created above.

Now notice that although I've been talking a lot here, we only really have five or so lines of code. That's all you need to make a complete web.py application.

For easier access, here's how your code should look like:

    import web
    
    urls = (
        '/', 'index'
    )
    
    class index:
        def GET(self):
            return "Hello, world!"
    
    if __name__ == "__main__":
        app = web.application(urls, globals())
        app.run()

<a name="start"> </a>
## Start the server

 If you go to your command line and type:

    $ python code.py
    http://0.0.0.0:8080/

You now have your web.py application running a real web server on your computer. Visit that URL and you should see "Hello, world!" (You can add an IP address/port after the "code.py" bit to control where web.py launches the server. You can also tell it to run a `fastcgi` or `scgi` server.)

**Note:** You can specify the port number to use on the command line like this
if you can't or don't want to use the default:

    $ python code.py 1234


<a name="templating"> </a>
## Templating

Writing HTML from inside Python can get cumbersome; it's much more fun to write Python from inside HTML. Luckily, web.py makes that pretty easy.

Let's make a new directory for our templates (we'll call it `templates`). Inside, make a new file whose name ends with HTML (we'll call it `index.html`). Now, inside, you can just write normal HTML:

    <em>Hello</em>, world!

Or you can use web.py's templating language to add code to your HTML:

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

As you can see, the templates look a lot like Python files except for the `def with` statement at the top (saying what the template gets called with) and the `$`s placed in front of any code.  Currently, template.py requires the `$def` statement to be the first line of the file.  Also, note that web.py automatically escapes any variables used here, so that if for some reason `name` is set to a value containing some HTML, it will get properly escaped and appear as plain text. If you want to turn this off, write `$:name` instead of `$name`.

Now go back to `code.py`. Under the first line, add:

    render = web.template.render('templates/')

This tells web.py to look for templates in your templates directory. Then change `index.GET` to:

    name = 'Bob'    
    return render.index(name)

('index' is the name of the template and 'name' is the argument passed to it)

Visit your site and it should say hello to Bob. 

But let's say we want to let people enter their own name in. Replace the two lines we added above with:

    i = web.input(name=None)
    return render.index(i.name)

Visit `/` and it should say hello to the world. Visit `/?name=Joe` and it should say hello to Joe.

Of course, having that `?` in the URL is kind of ugly. Instead, change your URL line at the top to:

    '/(.*)', 'index'

and change the definition of `index.GET` to:

    def GET(self, name):
        return render.index(name)

and delete the line setting name. Now visit `/Joe` and it should say hello to Joe.

If you wish to learn more about web.py templates, visit the <a href="/docs/0.3/templetor">templetor page</a>.

<a name="forms"> </a>
## Forms

The form module of web.py allows the ability to generate html forms, get user input, and validate it before processing it or adding it to a database.
If you want to learn more about using the module forms web.py, see the [Documentation](/docs/0.3) or direct link to [Form Library](/form)

<a name="databasing"> </a>
## Databasing

**Note:** Before you can start using a database, make sure you have the appropriate database library installed.  For MySQL databases, use [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) and for Postgres use [psycopg2](http://initd.org/pub/software/psycopg/).

First you need to create a database object.

    db = web.database(dbn='postgres', user='username', pw='password', db='dbname')

(Adjust these -- especially `username`, `password`, and `dbname` -- for your setup. MySQL users will also want to change `dbn` definition to `mysql`.)

That's all you need to do -- web.py will automatically handle connecting and disconnecting from the database.

Using your database engines admin interface, create a simple table in your database:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

And an initial row:

    INSERT INTO todo (title) VALUES ('Learn web.py');

Return to editing `code.py` and change `index.GET` to the following, replacing the entire function:

    def GET(self):
        todos = db.select('todo')
        return render.index(todos)

and change back the URL handler to take just `/` as in:

    '/', 'index',

Edit and replace the entire contents of `index.html` so that it reads:

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

Visit your site again and you should see your one todo item: "Learn web.py". Congratulations! You've made a full application that reads from the database. Now let's let it write to the database as well.

At the end of `index.html`, add:

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

And change your URLs list to read:

    '/', 'index',
    '/add', 'add'

(You've got to be very careful about those commas.  If you omit them, Python adds the strings together and sees `'/index/addadd'` instead of your list of URLs!)

Now add another class:

    class add:
        def POST(self):
            i = web.input()
            n = db.insert('todo', title=i.title)
            raise web.seeother('/')

(Notice how we're using `POST` for this?)

`web.input` gives you access to any variables the user submitted through a form. 

Note: In order to access data from multiple identically-named items, in a list format (e.g.: a series of check-boxes all with the attribute name="name") use:

    post_data=web.input(name=[])

`db.insert` inserts values into the database table `todo` and gives you back the ID of the new row. `seeother` redirects users to that URL.

Some quick additional notes: `db.update` works just like `db.insert` except instead of returning the ID it takes it (or a string `WHERE` clause) after the table name.

`web.input`, `db.query`, and other functions in web.py return "Storage objects", which are just like dictionaries except you can do `d.foo` in addition to `d['foo']`. This really cleans up some code.

You can find the full details on these and all the web.py functions in [the documentation](/docs/0.3).

<a name="developing"> </a>
## Developing

web.py also has a few tools to help us with debugging. When running with the built-in webserver, it starts the application in debug mode. In debug mode any changes to code and templates are automatically reloaded and error messages will have more helpful information.

The debug is not enabled when the application is run in a real webserver. If you want to disable the debug mode, you can do so by adding the following line before creating your application/templates.

    web.config.debug = False

<a name="whatnext"> </a>
## What Next ?

This ends the tutorial for now. Take a look at the [cookbook](/cookbook/) and the [code examples](/src/)  for lots more cool stuff you can do with web.py.
Also don't forget about the [api reference](/docs/0.3/api)


---
layout: default
title: web.py 0.3 新手指南
---

# web.py 0.3 新手指南

* [开始](#starting)
* [URL处理](#urlhandling)
* [GET和POST的区别](#getpost)
* [启动服务](#start)
* [模板](#templating)
* [表单](#forms)
* [数据库](#databasing)
* [开发](#developing)
* [下一步做什么?](#whatnext)

## 开始

你知道Python同时你希望制作一个网站。 那么web.py正好提供了一种简单的方法。

如果你希望读完整个指南， 你需要安装Python, web.py, flup, psycopg2, 和Postgres (或者等价的数据库和Python驱动)。 详细，可以查看 [webpy.org](http://webpy.org/).

如果你已经有了一个web.py项目，请看看[升级](/docs/0.3/upgrade) 页面的相关信息。

准备开始。

<a name="urlhandling"> </a>
## URL 处理

任何网站最重要的部分就是它的URL结构。你的URL并不仅仅只是访问者所能看到并且能发给朋友的。它还规定了你网站运行的心智模型。在一些类似[del.icio.us](http://del.icio.us/)的流行网站 , URL甚至是UI的一部分。 web.py使这类强大的URL成为可能。

在开始你的web.py程序之前,打开一个文本文件（文件名为code.py）输入:

    import web

这条语句会导入web.py模块。

现在我们需要把我们的URL结构告诉web.py。让我从下面这个简单的例子开始:

    urls = (
      '/', 'index'
    )

第一部分是匹配URL的[正则表达式](http://osteele.com/tools/rework/)，像`/`、`/help/faq`、`/item/(\d+)`等(`\d+`将匹配数字)。圆括号表示捕捉对应的数据以便后面使用。第二部分是接受请求的类名称，像`index`、`view`、`welcomes.hello` (`welcomes`模块的`hello`类)，或者`get_\1`。`\1` 会被正则表达式捕捉到的内容替换，剩下来捕捉的的内容将被传递到你的函数中去。

这行表示我们要URL`/`(首页)被一个叫`index`的类处理。

现在我们需要创建一个列举这些url的application。

    app = web.application(urls, globals())

这会告诉web.py去创建一个基于我们刚提交的URL列表的application。这个application会在这个文件的全局命名空间中查找对应类。

<a name="getpost"> </a>
## GET和POST: 区别

现在我们需要来写`index`类。虽然大多数人只会看看，并不会注意你的浏览器在使用用于与万维网通信的HTTP语言。具体的细节并不重要，但是要理解web访问者请求web服务器去根据URL(像`/`、`/foo?f=1`)执行一个合适的函数（像`GET`、`POST`）的基本思想。

`GET`是我们都熟悉的。它用于请求网页文本。当你在浏览器输入`harvard.edu`，它会直接访问Harvard的web服务器，去`GET /`。 第二个最有名的是`POST`，它经常被用在提交form，比如请求买什么东西。每当提交一个去做什么事情(像使用信用卡处理一笔交易)的请求时，你可以使用`POST`。这是关键，因为`GET`的URL可以被搜索引擎索引，并通过搜索引擎访问。虽然大部分页面你希望被索引，但是少数类似订单处理的页面你是不希望被索引的 (想象一下Google尝试去购买你网站上的所有东西)。

在我们web.py的代码中，我们将这两个方法明确区分:

    class index:
        def GET(self):
            return "Hello, world!"

当有人用`GET`请求`/`时，这个`GET`函数随时会被web.py调用。

好了，限制我们只需要最后一句就写完了。这行会告诉web.py开始提供web页面:

    if __name__ == "__main__": app.run()

这会告诉web.py为我们启动上面我们写的应用。


现在注意，即使我已经在这里说了很多，但我们真正有5行这些代码。这就是你需要编写的一个完整的web.py应用。
为了更方便的使用，你的完整代码应该像下面这样:

    import web
    
    urls = (
        '/', 'index'
    )
    
    class index:
        def GET(self):
            return "Hello, world!"
    
    if __name__ == "__main__":
        app = web.application(urls, globals())
        app.run()

		

<a name="start"> </a>
## 启动服务

 如果你在命令行下面，请输入::
    $ python code.py
    http://0.0.0.0:8080/

现在你的web.py应用正运行在你电脑上的一个真正的web服务器上。 访问那个URL，然后你应该看到"Hello, world!" (你可以通过把IP地址/端口加在"code.py"的后面，来控制web.py在哪里启动服务器。你也可以让它运行在`fastcgi`或`scgi`服务器上)。

**注意:** 如果你不能或者不想使用默认端口，你可以使用这样的命令来指定端口号:

    $ python code.py 1234

	

<a name="templating"> </a>
## 模板

在 Python 中写 HTML 不是聪明的选择，相反在 HTML 中写 Python 则有趣的多。幸运的是，`web.py` 让这件事情做得简单而又漂亮。

**注意：** 老版本的 `web.py` 使用 [Cheetah 模板系统](http://www.cheetahtemplate.org/)，你可以也欢迎使用其他模板系统，但它可能不会被长久支持。

给模板新建一个目录（命名为 `templates`），在该目录下新建一个以 `.html` 结尾的文件，内容如下：

    <em>Hello</em>, world!

你也可以在模板中使用 `web.py` 模板支持代码：

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

如上，该模板看起来就像 python 文件一样，除了顶部的 `def with` (表示从模板将从这后面取值)和总是位于代码段之前的`$`。当前，`template.py` 首先请求模板文件的首行 `$def` 。当然，你要注意 `web.py` 将会转义任何任何用到的变量，所以当你将 `name` 的值设为是一段 HTML 时，它会被转义显示成纯文本。如果要关闭该选项，可以写成 `$:name` 来代替 `$name`。

回看再看 `code.py`。在第一行之下添加：

    render = web.template.render('templates/')

这会告诉web.py到你的模板目录中去查找模板。然后把 `index.GET`改成:
告诉 `web.py` 在你的模板目录下查找模板文件。修改 `index.GET` ：

    name = 'Bob'    
    return render.index(name)

（'index' 是模板的名字，'name' 是传入模板的一个参数）

访问站点它将显示 hello Bob。

但是如果我们想让用户自行输入他的名字，么办？如下：

    i = web.input(name=None)
    return render.index(i.name)

访问 `/` 将显示 hello world，访问 `/?name=Joe` 将显示 hello Joe。

URL 的后面的 `?` 看起来不好看？修改下 URL 配置：

    '/(.*)', 'index'

然后修改下 `index.GET`：

    def GET(self, name):
        return render.index(name)

现在访问 `/Joe` 看看，它会显示 hello Joe。

如果学习更多关于 web.py 的模板处理，请访问 [web.py 模板](/docs/0.3/templetor).

<a name="forms"> </a>
## 表单

web.py的form模块能够帮助你生成HTML表单；获取用户的输入，并在处理或添加到数据库之前对其进行内容的验证。
如果你要学习更多关于form模块的使用，请查看[帮助文档](/docs/0.3)或者[Form](/form)类库的链接


<a name="databasing"> </a>
## 数据库操作

**注意:** 在你开始使用数据库之前，确保你已经安装了合适的数据库访问库。比如对于MySQL数据库，使用 [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) ，对于Postgres数据库使用[psycopg2](http://initd.org/pub/software/psycopg/)。

首先你需要创建一个数据库对象。

    db = web.database(dbn='postgres', user='username', pw='password', db='dbname')

(根据需要修改这里 -- 尤其是`username` 、 `password` 、 `dbname` -- 。 MySQL用户还需要把 `dbn` 定义改为 `mysql`。)

这就是所有你需要做的 -- web.py将会自动处理与数据库的连接和断开。

使用的的数据库引擎管理工具，在你的库中创建一个简单的表:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

然后初始化行:

    INSERT INTO todo (title) VALUES ('Learn web.py');

我们回来继续编辑 `code.py` ，把 `index.GET` 改成下面的样子，替换整个函数:

    def GET(self):
        todos = db.select('todo')
        return render.index(todos)

然后把URL列表改回来，只保留 `/`:

    '/', 'index',

像这样编辑并替换 `index.html` 的全部内容:

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

再访问你的网站，然后你可以看到你的todo item: "Learn web.py"。恭喜你！你已经完整地写好了一个可以从数据库读取数据的程序。现在让我们同样再写一个可以把数据写入数据库的程序。

在 `index.html`尾部添加:

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

然后把你的URL列表改为:

    '/', 'index',
    '/add', 'add'

(你必须要非常小心那些逗号。如果你省略他们，Python会把所有字符串连接起来,变成 `'/index/addadd'`)

现在添加另一个类:

    class add:
        def POST(self):
            i = web.input()
            n = db.insert('todo', title=i.title)
    	    raise web.seeother('/')

(注意现在我们正在使用 `POST`)

`web.input` 可以让你访问用户通过form提交的任何数据。

注意: 如果要访问多个相同名字的字段，请使用list的格式(比如:一串name="name"的多选框):

    post_data=web.input(name=[])

`db.insert` 把数据插入数据表 `todo` ，然后把新的行号返回给你。 `seeother` 把用户重定向到指定的URL。

一些快速补充说明: `db.update` 与 `db.insert` 差不多，除了它返回的行号是直接从sql语句里面提取的(`WHERE ID=2`)。

`web.input`、 `db.query`已经其他web.py中的函数返回"Storage objects"，这些东西就像字典，你除了可以 `d['foo']`之外，你还可以 `d.foo`。这可以让代码更加干净。

你可以在[the documentation](/docs/0.3)找到这方面具体的细节以及所有web.py的函数说明。

<a name="developing"> </a>
## 开发

web.py 还有一些帮助我们debug的工具。当它在内建的服务器中运行时，它会一debug模式启动程序。在debug模式中，任何代码、模板的修改，都会让服务器重新加载它们，然后还会输出有用的错误消息。

只有在生产环境中debug模式是关闭的。如果你想禁用debug模式，你可以在创建程序/模板前添加像这样的行。

    web.config.debug = False

我们的指南就到这里了。如果要做更多很酷的东西，你可以先查看一下文档。

<a name="whatnext"> </a>
## 下一步是什么?

* [更多文档](/docs/0.3)
* [Cookbook](/cookbook)
* [code samples](/src)
---
layout: default
title: How to upgrade from earlier versions of web.py to 0.3
---

# How to upgrade from earlier versions of web.py to 0.3

Web.py 0.3 has some backward-incompatible changes. 

* <a href="#return">prints are replaced by return statements</a>
* <a href="#app">new application framework</a>
* <a href="#db">new database system</a>
* <a href="#exceptions">http errors are exceptions</a>
* <a href="#others">other incompatible changes</a>

<a name="return"></a>
## prints are replaced by return statements

In earlier versions of web.py the GET and POST methods used to print the data to be send to the client. Now instead of printing the data, the data must be returned from that function. This makes post-processing of returned data possible.

If your old code is like this:

    class hello:
        def GET(self):
            print "Hello, world!"

It should become:

    class hello:
        def GET(self):
            return "Hello, world!"

`yield` statements can also be used to return an iterator.

    class hello:
        def GET(self):
            for i in range(5):
                yield "hello " + str(i)

## new application framework

New application framework has been introduced in web.py 0.3 and due to that there is a slight change in the way the program's main section is written.

If your old code has:

    urls = ("/", "index")
    ....

    if __name__ == "__main__":
        web.run(urls, globals())

It should become:

    urls = ("/", "index")
    app = web.application(urls, globals())

    ....

    if __name__ == "__main__":
        app.run()

<a name="db"></a>
## new database system

The database module of web.py has been improved to make it more modular.

If you have code like this:

    web.config.db_parameters = dict(dbn='postgres', db='test', user='joe', password='secret')
    def foo():
        web.insert('test', name='foo')

It should become:

    db = web.database(dbn='postgres', db='test', user='joe', password='secret')
    def foo():
        db.insert('test', name='foo')

Same applies to other database functions like `select`, `update`, `delete` and `query`.

If you are using transactions, they should be changed too.

    def foo():
        web.transact()
        web.insert('t1', name='foo')
        web.insert('t2', name='bar')
        web.commit()

should become:

    def foo():
        t = db.transaction()
        db.insert('t1', name='foo')
        db.insert('t2', name='bar')
        t.commit()

If you are using python 2.5 or later, transactions can be used with `with` statement.

    def foo():
        with db.transaction():
		    db.insert('t1', name='foo')
		    db.insert('t2', name='bar')
            
<a name="exceptions"></a>
## http errors are exceptions

In 0.3, all http errors have been changed to exceptions.

If you have code like this:

    def GET(self):
        ....
        if not page:
            web.notfound()
        else:
            ....

It should become:

    def GET(self):
        ....
        if not page:
            raise web.notfound()
        else:
	    ....

<a name="others"></a>
## Other incompatible changes

In web.py 0.3, `web.input()` returns values in unicode. This may create trouble sometimes.

To force `web.input` to return strings instead of unicode values, use:

    web.input(_unicode=False)
---
layout: default
title: Documentation de web.py 0.3
---

# Documentation de web.py 0.3

Autre langages : [english](/docs/0.3) | ...

## Installation
* [Installation](/install/fr). Installer web.py, configurer LightTPD, Apache, Nginx ...(CGI, FastCgi, ...)

## Tutorial

* [Tutorial rapide](/tutorial3.fr). Commençez  votre première application.

## Exemples de code

* [Cookbook](/cookbook/fr). Comment effectuer des tâches basiques et communes. 
* [Code samples](/src). Example code of how to write some basic applications. (traduction demandée)

## Documentation des composants
* [Applications](/docs/0.3/apps/fr). Comment mapper des urls à du code python.
    * [Basic app](/docs/0.3/apps/basic/fr). Mapper des expressions régulières à des classes.
    * [Auto app](/docs/0.3/apps/auto/fr). Webpy suit les urls basées sur le nom des classes.
    * [Subdir app](/docs/0.3/apps/subdir). Host multiple apps based on the sub-directory. - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
    * [Subdomain app](/docs/0.3/apps/subdomain). Host multiple apps based on the subdomain. - traduction demandée, voir [Todo](/docs/0.3.fr/todo)
* [Modèles, gabarits](/docs/0.3/templetor.fr). Templetor, le système de gabarits de web.py.
* [Formulaires](/docs/0.3/form.fr). Gérer les entrées des utilisateurs.
* [Application processors](/docs/0.3/app_processors/fr). Executer du code avant chaque requête.
* [Sessions](/docs/0.3/sessions/fr). Stocker des données persistantes des utilisateurs au travers les requêtes.
* Database
* Testing

## Mise à jour vers la version actuelle

* [Upgrade to 0.3 versions of web.py](/docs/0.3/upgrade)  - traduction demandée, voir [Todo](/docs/0.3.fr/todo)


## API Documentation 

* [API documentation](/docs/0.3/api) - traduction demandée, voir [Todo](/docs/0.3.fr/todo)

## Configuration recommandée

* [Configuration](/recommended_setup/fr). Logiciels recommandés pour les serveurs en production.

## Todo

* [Todo](/docs/0.3.fr/todo). Liste des travaux en cours ou à faire, conçernant la traduction française.
---
layout: default
title: TODO - A faire
---

# TODO - A faire

#Traduction française

Ici sera réunie la liste des travaux à réaliser et ceux en cours de réalisation, conçernant la traduction française de web.py.

1. Lorsque vous commençez une traduction, pensez à le noter sur cette page, dans la rubrique 'en cours',  afin qu'un autre traducteur ne fasse pas le même travail au même moment.

1. N'oubliez pas de mettre à jour les liens se rapportant à la page traduite.

1. Les chemins des pages traduites devront ressembler à l'exemple ci-dessous et respecter la hierarchie du schéma anglais:
	*cookbook/helloworld* --> *cookbook/helloworld/fr*

-------------------------------------------------

# En cours




---

# A faire

## Documentation de web.py 0.3


### Exemples de code

* [Code samples](/src). - traduction demandée

### Documentation des composants


* [Subdir app](/docs/0.3/apps/subdir). - traduction demandée
* [Subdomain app](/docs/0.3/apps/subdomain). - traduction demandée

### Mise à jour vers la version actuelle 

* [Upgrade to 0.3 versions of web.py](/docs/0.3/upgrade) - traduction demandée

### API Documentation

* [API documentation](/docs/0.3/api) -  traduction demandée


## Cookbook


###Avancé

* [Select: Récupérer les entrées d'une base de données](/cookbook/select). - traduction demandée
* [Update: Mettre à jour les entrées d'une base de données](/cookbook/update).  - traduction demandée
* [Delete: Supprimer les entrées d'une base de données](/cookbook/delete). - traduction demandée
* [Insert: Ajouter des entrées à une base de donnée](/cookbook/insert).  - traduction demandée
* [Query: Base de données - Requêtes avancées](/cookbook/query). - traduction demandée
* [Comment utiliser web.background](/cookbook/background). - traduction demandée
* [Run-time language switch](/cookbook/runtime-language-switch). - traduction demandée

###Sessions et état des utilisateurs:


* [Authentification des utilisateurs avec base de données Postgresql](/cookbook/userauthpgsql). - traduction demandée


###Utils:

* [Envoi de Mail](/cookbook/sendmail). - traduction demandée
* [Webservice en utilisant soaplib + WSDL](/cookbook/webservice). - traduction demandée

###Modèles de mise en forme, gabarits de mise en page:


* [Alterner un style](/cookbook/alternating_style). - traduction demandée
* [Importer des fonctions dans les gabarits](/cookbook/template_import). - traduction demandée
* [i18n support dans les fichiers gabarits](/cookbook/i18n_support_in_template_file ). - traduction demandée
* [Utiliser le moteur de gabarit Mako dans webpy](/cookbook/template_mako). - traduction demandée
* [Utiliser le moteur de gabarit Cheetah dans webpy](/cookbook/template_cheetah). - traduction demandée
* [Utiliser le moteur de gabarit  Jinja2 dans webpy](/cookbook/template_jinja). - traduction demandée
* [Comment utiliser les gabarits sur Google App Engine](/cookbook/templates_on_gae). - traduction demandée

###Essais:

* [Tester avec Paste et Nose](/cookbook/testing_with_paste_and_nose). - traduction demandée
* [RESTful doctesting using an application's request method](/cookbook/restful_doctesting_using_request). - traduction demandée

###Entrées utilisateurs:


* [Rendu individuel des champs de formulaires](/cookbook/form_fields). - traduction demandée

###Base de données:

* [Multiples bases de données](/cookbook/multidbs). - traduction demandée

* [Query: How to use database transactions](/cookbook/transactions). - traduction demandée
* [Comment utiliser sqlalchemy](/cookbook/sqlalchemy). - traduction demandée
* [Intégrer SQLite UDF (user-defined-functions) à la couche de base de données webpy](/cookbook/sqlite-udf). - traduction demandée
* [Utiliser un dictionnaire comme clause where](/cookbook/where_dict). - traduction demandée

###Déploiement:

* [Déploiement Fastcgi au travers Apache](/cookbook/fastcgi-apache).  - traduction demandée
* [Déploiement CGI au travers Apache](/cookbook/cgi-apache). - traduction demandée
* [Déploiement mod_wsgi au travers Apache](/cookbook/mod_wsgi-apache ).  - traduction demandée
* [Déploiement mod_wsgi au travers Nginx](/cookbook/mod_wsgi-nginx ).  - traduction demandée
* [Déploiement Fastcgi au travers Nginx](/cookbook/fastcgi-nginx). - traduction demandée
---
layout: default
title: Documentation
---

# Documentation

* [web.py 0.3 documentation](/docs/0.3)
* [web.py 0.2 documentation](/docs/0.2)
---
layout: default
title: webpy docs that need fixing, and how!
---

# webpy docs that need fixing, and how!

This is a list of work needed for the documentation cleanup.  Please add pages, separated by horizontal rules (three asterisks in markdown).

We need both reporters (tell us what's wrong!) and fixers (write code, make content consistent, etc).

When adding work to be done, please place it in a section devoted to the page and/or parent page, and a link to that page. For example:

***
#Cookbook: [Cookbook](/cookbook)
* database select example code is incorrect

***

When finishing working on something, delete it from the list. If a code block refers to old (version 0.2 for example) code, please add it to a separate url.  Also, add new content at new url (and delete old link when done) For instance:

1. /foo is out of date with version 0.2 code
1. move /foo to /foo/0.2
1. put new code at /foo/0.3
1. delete content at /foo, and update any urls that link to it


***
#Code samples: [Code samples](/src)
* Move url to /samples

## Samples
* simple-wiki: 0.2, external
* simple-wiki num 2: 0.2, external
* simple delicious: 0.2
* alternate tutorial SQLite & SQLObject: 0.2
* templating with genshi: should be part of larger 'templating' section


## tips & tricks

* Possibly move entirely to cookbook?

vhost, metaclass and multiple apps should have separate section, but this setup isn't the way to do things in 0.3

* simple sessions: no longer with flup, better docs elsewhere
* template tricks: with template code
* vhost: no longer needed with subdomain apps
* metaclass: also no longer need (auto app)
* test web app: need separate testing section
* serving images: 0.2, should use mimetypes module?
* multiple apps: not needed


## Real web apps

* Leave them external, but annotate which version of webpy they use.

***
---
layout: default
title: test
---

# test


---
layout: default
title: Získání web.py
---

# Získání web.py

## Získání poslední stabilní verze

Nejsnazší cesta k instalaci web.py je použít [easy_install](http://peak.telecommunity.com/DevCenter/EasyInstall):

    $ easy_install web.py

Pokud nemáte `easy_install`, zkuste stáhnout zdrojáky:

    $ wget http://webpy.org/static/web.py-0.32.tar.gz
    $ tar xvzf web.py-0.32.tar.gz
    $ cd webpy
    $ sudo python setup.py install

Když nechcete instalovat web.py pro celý systém (nebo když chcete zabalit web.py s vaší aplikací):

    $ cd your-app-dir
    $ wget http://webpy.org/static/web.py-0.32.tar.gz
    $ tar xvzf web.py-0.32.tar.gz
    $ ln -s webpy/web .

V Ubuntu Linuxu nebo Debianu, můžete instalovat web.py přes `apt-get`. Pak ale možná nezískáte poslední verzi, protože cyklus vydání Debianu/Ubuntu je jiný než u web.py.

    $ sudo apt-get install python-webpy

## Získání poslední vývojové verze

    $ git clone git://github.com/webpy/webpy.git
---
layout: default
title: Téléchargement
---

# Téléchargement

Autre langages : [english](/download) | ...

## Obtenir la dernière version stable

La façon la plus simple d'installer web.py est d'utiliser [easy_install](http://peak.telecommunity.com/DevCenter/EasyInstall)[:](http://www.dofollownet.com/)

    $ easy_install web.py

Si vous n'avez pas 'easy_install', essayez de télécharger les sources.

    $ wget http://webpy.org/static/web.py-0.33.tar.gz
    $ tar xvzf web.py-0.33.tar.gz
    $ cd web.py-0.33
    $ sudo python setup.py install

Si vous ne voulez pas installer web.py pour tout le système (ou si vous désirez grouper web.py avec votre application):

    $ cd your-app-dir
    $ wget http://webpy.org/static/web.py-0.33.tar.gz
    $ tar xvzf web.py-0.33.tar.gz
    $ ln -s web.py-0.33/web .
   
Si vous êtes sous Linux Ubuntu ou Debian, vous pouvez installer web.py en utilisant la commande 'apt-get'. Mias vous n'aurez pas la dernière version car  les cycles de versions de debian/ubuntu (releases) diffèrent de ceux de web.py.

    $ sudo apt-get install python-webpy

Si vous utilisez Fedora, RHEL ou CentOS (ainsi que les dépôts [EPEL](https://fedoraproject.org/wiki/EPEL) ), vous pouvez installer web.py avec 'yum' or 'up2date':

    $ yum install python-webpy
    $ up2date -i python-webpy

## Téléchargez la dernière version de développement

    $ git clone git://github.com/webpy/webpy.git
---
layout: default
title: Download
---

# Download

Other languages : [français](/download/fr) | ...
## Get the latest stable version

The easiest way to install web.py is using [easy_install](http://peak.telecommunity.com/DevCenter/EasyInstall):

    $ easy_install web.py

If you don't have `easy_install`, try downloading the sources.

    $ wget http://webpy.org/static/web.py-0.37.tar.gz
    $ tar xvzf web.py-0.37.tar.gz
    $ cd web.py-0.37
    $ sudo python setup.py install

If you don't want to install web.py system-wide (or if you want to bundle web.py with your application):

    $ cd your-app-dir
    $ wget http://webpy.org/static/web.py-0.37.tar.gz
    $ tar xvzf web.py-0.37.tar.gz
    $ ln -s web.py-0.37/web .
   
If you are on Ubuntu Linux or Debian, you can install web.py using `apt-get` [ packaging service](http://en.wikipedia.org/wiki/Advanced_Packaging_Tool). But you may not get the latest as debian/ubuntu release cycles are different from web.py.

    $ sudo apt-get install python-webpy

If you're running Fedora, RHEL or CentOS (and using the [EPEL](https://fedoraproject.org/wiki/EPEL) repository), you can install web.py using `yum` or `up2date`:

    $ yum install python-webpy
    $ up2date -i python-webpy

## Get the latest development version

    $ git clone git://github.com/webpy/webpy.git

---
layout: default
title: dreamhost
---

# dreamhost

There is currently a page on the Dreamhost wiki <a href="http://wiki.dreamhost.com/index.php/Web.py">for web.py</a>.   The instructions there will work, just give plenty of time for FastCGI to be enabled.  Dreamhost's panel application says 10 minutes but it may take much longer.

For a <a href="http://svn.natalian.org/projects/todo/.htaccess">.htaccess</a> that works.

Dreamhost imposes a limit of 100MB of virtual memory on your apps. See the <a href="http://groups.google.com/group/webpy/browse_thread/thread/635e005516f8be90/7945b3f8b032aa2e#7945b3f8b032aa2e">post by Deepak Sarda to the mailing list</a> for more information.
---
layout: default
title: ČKD
---

# ČKD

99. **Jak použiji šablony template.py?**

    Pro základní dokumentaci a nějaké ukázky kódu, se podívej na [template.py dokumentaci](/templetor).

    Chcete-li zobrazit stránku z web.py aplikace, stačí

            homepage = template.Template(open("homepage.tmpl").read())
            print homepage()

    
99. **Proč jsou adresy URL pouze jeden dlouhý seznam?**

    Pokud by byly ve slovníku, nebylo by je možné řadit. Pokud by byly v seznamu n-tic (tuple), bylo by s nima mnohem více psaní.

99. **How do I serve static files such as JavaScripts or images like PNG and JPG with the web.py server?**

    Create a directory (also known as a folder) called `static` in the location of the script that runs the web.py server. Then place the static files you wish to server in the `static` folder. For example, the URL `http://localhost/static/logo.png` will send the image `./static/logo.png` to the client.

99. **Kam se mohu obrátit pro další pomoc?**

    Google Groups má [skupinu web.py](http://groups.google.com/group/webpy) která je docela užitečná.

99. **Jak můžu změnit výchozí "not found" stránku?**

    Můžete napsat svůj vlastní notfound handler a připojit ho k  web.webapi.notfound

            def my_notfound(): 
                print "MUJ VLASTNI NOT FOUND" 
            web.webapi.notfound = my_notfound 

99. **How can i get auto completion in python after loading the webpy module?**

    In IPython, after importing webpy auto completion may no longer work. You can still use 'python' with auto completion feature. Try it out directly. Fire up 'python':

            import readline, rlcompleter; readline.parse_and_bind("tab: complete")

    and tab it! :-)

    To make in sort that this will be run default when you fire up 'python'. Make a file called '~/.pythonstartup.py' and put the import line in it. Then set the 'PYTHONSTARTUP' environment variable to point to that file.

    With my bash, i do it like following; edit ~/.bashrc and add:

            export PYTHONSTARTUP=~/.pythonstartup.py

99. **Why can't I access the database?**

    If you're trying to access the database from a non-web-serving thread (e.g. you created a new thread or you never started serving web pages) then you need to run `web.load()`. Sorry, this will be fixed in web.py 0.3.

99. **Mohu vícekrát iterovat IterBetter?**

    Ne. Nejdřív převeď IterBetter na seznam pomocí `ib = list(ib)`.

99. **Jak vytisknu debug do konsole?**

	web.debug("Budu vytištěn do konsole a ne do těla stránky")

99. **Narazil jsem na chybu ve web.py. Kam ji můžu nahlásit?**

	Jdi na [webpy launchpad](https://launchpad.net/webpy), přihlaš se (nebo se zaregistruj) a klikni na "report a bug".
---
layout: default
title: Preguntas frecuentes
---

# Preguntas frecuentes

La existencia de una pregunta en esta lista usualmente significa que hay una mala idea que será arreglada pronto.

## ¿Porque son las URLs una sola lista larga?

Si fueran un diccionario, no serian ordenadas. Si fuera una lista de tuplas, habria que tipear un monton mas.

## ¿Cual es el método usado para elegir el número de versión de web.py?

El primer dígito se incrementa si web.py completa el soporte de una capa del proceso de construcción de aplicaciones web. Asi que va a ser 0 por un tiempo.

Luego viene un punto decimal.

El siguiente dígito se incrementa si un feature importante se agrega a web.py (por ejemplo forms, templates, etc.).

El siguiente dígito se incrementa si se agrega algun feature a web.py.

El siguiente dígito se incrementa si se corrige un bug.
---
layout: default
title: FAQ
---

# FAQ

Autres langages : [español](/faq/es) | [russian ???????](/faq/ru) |[ Japan 日本語](/faq/ja) | [chinese 简体中文](/faq/zh-cn) | [english](/faq) | ...


Des exemples de code pour de nombreuses questions communes peuvent être trouvées dans la section [cookbook](/cookbook/fr).
    
99. **Pourquoi les urls ne sont qu'une longue liste?**

    Si elles étaient de type dictionnaire, elles ne seraient pas classées. Si c'etait une liste tuples, ce serait plus long à taper.

99. **Comment puis-je servir des fichiers statiques comme les JavaScripts ou des images de type PNG ou JPG avec le serveur web.py?**

    Créez un repertoire ( ou dossier) appelé 'static' au même emplacement que le script qui fait tourner le server web.py (par défaut code.py). Puis placez les fichiers statiques (scripts javascripts, css, images) que vous voulez servir dans ce dossier 'static'. Par exemple, l'URL 'http://localhost/static/logo.png' enverra l'image './static/logo.png' au client.

99. **Où puis-je trouver de l'aide supplémentaire??**

    Les Groupes Google proposent le [groupe web.py ](http://groups.google.com/group/webpy) qui est très utile.

99. **Comment afficher un débugage dans la console**

	web.debug("Je serai affiché dans la console et NON dans le corps de la page web.")

99. **Je suis tombé sur un bug dans web.py. Ou puis-je l'annonçer?**

	Allez sur le site [webpy launchpad](https://launchpad.net/webpy), connectez-vous (ou enregistrez-vous) et cliquez sur "report a bug".

99. **Qu'est-ce que ce fameux 'ctx' que je vois dans les exemples ?**

	'ctx' est une classe qui permet d'utiliser des variables contextuelles dans votre code, comme par exemple, la page  référante, le navigateur du client... voir [web.ctx](/cookbook/ctx/fr)
---
layout: default
title: faq
---

# faq

99. **template.pyを使いたいのですがどうすれば良いですか?**

    基本的なドキュメントやサンプルコードについては [template.py ドキュメント](/templetor) を参照してください。

    web.py app内部からテンプレートファイル (homepage.tmpl) を使用して表示するには以下のように記述します。

          # Version 0.2x
          homepage = template.Template(open("homepage.tmpl").read())
          print homepage()

          # web.py 0.3
          homepage = web.template.Template(open("homepage.tmpl").read())
          return homepage()

    
99. **なぜ urls は単に1つの長いリストなのですか?**

    もし辞書なら使用されないし、それがタプルであってもタイピング数が多いからです。

99. **どのようにして、静的ファイル JavaScriptsや画像(PNGやJPEG)をweb.pyサーバに配置すればいいですか?**

    web.pyサーバを実行するスクリプトファイル(チュートリアルでは code.py を指す)のディレクトリに、新しく静的ファイル用のディレクトリ static を作成してください。 
    次に、作成したディレクトリに静的ファイル logo.png を配置してください。

    たとえば、画像のURLが http://localhost:8080/static/logo.png ならば ./static/logo.png がクライアントに送られます。 

99. **どこで私は、補足支援できますか?**

    Googleグループに [web.py group](http://groups.google.com/group/webpy)があるので、そちらでお願いします。

99. **デフォルトのページがない場合 "not found"と表示されますが、どのようにしてそれを変更できますか?**


    web.webapi.notfound を変更することで独自のページを作成することができます。

            # 0.2x
            def my_notfound(): 
                print "MY OWN NOT FOUND" 
            web.webapi.notfound = my_notfound 

            # 0.3
            -

99. **webpyをロードした後、どうすれば自動補完できますか?**

    IPythonでは、webpyをインポートします。
    自動補完が動作しない場合は、'python' の自動補完を試してみてください。( readline ):

            import readline, rlcompleter; readline.parse_and_bind("tab: complete")

    タブで補完されます。

    'Python' を実行した時、デフォルトで何か処理を行いたい場合は、'~/.pythonstartup.py' ファイルに記述します。そのファイルに前述した import文を記述し、環境変数に 'PYTHONSTARTUP' を追加します。

    私はbashで以下のようにしています。~/.bashrcを編集し、以下の行を足します。

            export PYTHONSTARTUP=~/.pythonstartup.py

99. **データベースにアクセスできません、どうしてですか?**

    Web-servingスレッド以外のスレッドからデータベースにアクセスする場合（例えば、新しいスレッドを作ったとか、Webページのserveを開始しなかった場合とか）には、`web.load()`を実行する必要があります。web.py 0.3では修正される予定です。ごめんなさい。

99. **IterBetterは複数回イテレートできますか？**

    できません。`ib = list(ib)`でIterBetterをリストに変換してください。

99. **どのようにデバッグ文をコンソールに出力しますか？**

    web.debug("デバッグ文")

99. **もしwebpyの不具合(バグ)を見つけた場合どこで報告すればいいのですか？**

    [ここ(webpy launchpad site)](https://launchpad.net/webpy) からバグ報告することができます。ログインが必要な場合は登録を行ってからバグ報告をしてください。
---
layout: default
title: FAQ
---

# FAQ

Other languages : [español](/faq.es) | [russian русский](/faq.ru) | [japan 日本語](/faq.ja) | [chinese 简体中文](/faq.zh-cn) | [français](/faq.fr) | [Česko](/faq.cs)

Example code for many common questions can be found in the [cookbook section](/cookbook).
    
99. **Why are the urls just one long list?**

    If they were a dictionary, they wouldn't be ordered. If it was a list of tuples, then it'd be a lot more typing.

99. **How do I serve static files such as JavaScripts or images like PNG and JPG with the web.py server?**

    Create a directory (also known as a folder) called `static` in the location of the script that runs the web.py server. Then place the static files you wish to server in the `static` folder. For example, the URL `http://localhost/static/logo.png` will send the image `./static/logo.png` to the client.

99. **Where can I go for additional help?**

    Google Groups has a [web.py group](http://groups.google.com/group/webpy) that is quite helpful.

99. **How do I debug print to the console?**

	web.debug("I will get printed to the console and not the body of the webpage")

99. **I stumbled over a bug in web.py. Where can I file it?**

	Go to the [webpy launchpad site](https://launchpad.net/webpy), login (or register if you have to) and click on "report a bug".

99. **What's this magic `ctx` I see in examples?**

	[ctx cookbook recipe](/cookbook/ctx) []()
---
layout: default
title: faq/ru
---

# faq/ru

# web.py ЧАВО

Наличие в этом списке какого-либо вопроса означает что нечто не так, и должно быть пофикшено достатночно скоро.

## Почему urls это просто длинный список?
Если сделать из него dict, он перестанет быть сортированым. Можно конечно сделать список кортежей, но кажется набирать это на много тяжелее и дольше.

# Пока никто не спросил
## Какова схема нумерации версий web.py

Первая цифра увеличится если web.py полностью покроет весь слой разработки веб-приложений. Так что это пока 0.

После этого - точка.

Следующая цифра изменяется в случае добавления новой важной фичи, например поддержка построения форм, темплейты и тп.

Следующая цифра изменяется если добавилась просто новая фича.

Следующая цифра изменяется на каждый произведенный багфикс.

`Комментарии, вопросы, предложения - Английский: webpy@aaronsw.com. Русский: bobuk@justos.org.`
---
layout: default
title: FAQ
---

# FAQ

99. **如何使用template.py模板?**

    基本的文档内容与一些代码片段，请查看 [template.py doc](/templetor)

    通过web.py应用显示页面，使用如下

            homepage = template.Template(open("homepage.tmpl").read())
            print homepage()

    
99. **为什么urls是一个长长的数组？**

    如果是一个dictionary，那么就不会被排序好。 如果是一个tuples数组, 那需要更加多的文字输入。

99. **如何来通过web.py服务器来处理静态文件比如JavaScripts 或像PNG、JPG这些图片？**

    在运行web.py服务代码的目录下创建一个文件夹命名为 `static`。 然后将你需要的静态文件放到这个 `static` 文件夹下。 比如，   请求URL `http://localhost/static/logo.png` 将会把图片 `./static/logo.png` 传递给客户端。

99. **哪里可以找到更多帮助？**

    Google Groups 上的 [web.py group](http://groups.google.com/group/webpy) 会很有用。

99. **如何来更改默认的 "not found" 页面？**

    你可以改写你自己的notfound函数并将它赋值给 web.webapi.notfound

            def my_notfound(): 
                print "MY OWN NOT FOUND" 
            web.notfound = my_notfound 

99. **将webpy模块导入后，在python中如何才能够自动补全？**

    在IPython中， 导入webpy之后自动补全功能可能会不可用。 你还是可以使用 'python' 的自动补全功能。请尝试输入如下：

            import readline, rlcompleter; readline.parse_and_bind("tab: complete")

    使用tab吧！:-)

    为了能在python运行时可以默认提供该补全功能。 创建文件命名为 '~/.pythonstartup.py' 并将以上import代码放入其中。 然后设置  'PYTHONSTARTUP' 环境变量指向该文件。

    在bash中，如下所示；编辑 ~/.bashrc 并添加：

            export PYTHONSTARTUP=~/.pythonstartup.py

99. **为什么不能访问数据库？**

    If you're trying to access the database from a non-web-serving thread (e.g. you created a new thread or you never started serving web pages) then you need to run `web.load()`. Sorry, this will be fixed in web.py 0.3.

99. **能否多次遍历IterBetter？**

    不可以。 通过 `ib = list(ib)` 将IterBetter转变为数组。

99. **如何输出debug信息到console？**

	web.debug("I will get printed to the console and not the body of the webpage")

99. **我凑巧遇到web.py的一个bug。我需要提交到何处？**

	请到 [webpy launchpad site](https://launchpad.net/webpy), 登录(如果没有帐号请注册) 并点击 "report a bug"。
---
layout: default
title: Librairie Formulaires
---

# Librairie Formulaires

# Sommaire

* <a href="#introduction">Introduction</a>
* <a href="#carac">Caracteristiques des entrées formulaires</a>
* <a href="#listes">Listes déroulantes</a>
* <a href="#parti">Particularités des formulaires</a>
* <a href="#exemple">Exemple</a>

<a name="introduction"></a>
## Introduction

Le module de formulaire de web.py permet de générer des formulaires HTML, de récuperer les entrées des utilisateurs, et les valider avant de les traiter ou les ajouter à une base de donnée.

Le module de formulaire définit 2 classes primaires: la classe Form et la classe Input. 

Les formulaires sont instanciés avec une ou plusieurs entrées, et des validateurs optionnels. Les entrées sont instanciées avec une variable nom, ainsi que des arguments optionnels et des validateurs. 

La classe Input est sous-classée dans les entrées html suivantes (type HTML dans les parenthèses):


* Textbox     - Champ de saisie de texte d'une ligne (input type="text")
* Password   - Champ de saisie de texte d'une ligne qui cache ce qui est entré (input type="password")
* Textarea   - Champ de saisie de texte multiligne (textarea)
* Dropdown - Selection d'un seul élément dans une liste déroulante (select and options)
* Radio         - Boutons radio pour un seul choix (input type="radio")
* Checkbox  - Cases à cocher à plusieurs choix (input type="checkbox")
* Button        - Soumettre le formulaire (button)

Un simple formulaire de connexion pourrait ressembler à ceci:

    login = form.Form(
        form.Textbox('username'),
        form.Password('password'),
        form.Button('Login'),
    )

Ceci définit un simple formulaire. Une fois défini, vous devrez l'appeler à nouveau pour obtenir une instance, et alors vous pourrez appeler la méthode de rendu sur elle, de cette façon:

    f = login()
    print f.render()

Ce qui affichera le code HTML suivant:

    <table>
        <tr><th><label for="username">username</label></th><td><input type="text" id="username" name="username"/><div class="post" style="display: none;"></div></td></tr>
        <tr><th><label for="password">password</label></th><td><input type="password" id="password" name="password"/><div class="post" style="display: none;"></div></td></tr>
        <tr><th><label for="Login"></label></th><td><button id="Login" name="Login">Login</button><div class="post" style="display: none;"></div></td></tr>
    </table>

Ce qui donnera:

<table>
    <tr><th><label for="username">username</label></th><td><input type="text" id="username" name="username"/><div class="post" style="display: none;"></div></td></tr>
    <tr><th><label for="password">password</label></th><td><input type="password" id="password" name="password"/><div class="post" style="display: none;"></div></td></tr>
    <tr><th><label for="Login"></label></th><td><button id="Login" name="Login">Login</button><div class="post" style="display: none;"></div></td></tr>
</table>

<a name="carac"></a>
## Caracteristiques des entrées formulaires
Les entrées formulaires offrent quelques attributs additionnels. Par exemple :


    form.textbox("firstname",
        form.notnull, # Place les validateurs en premier, suivi par des attributs facultatifs
        class_="textEntry", # Donne un nom de classe à la zone de texte - à noter le caractère de soulignement (underscore)
        pre="pre", # Directement devant la zone de texte
        post="post", # Directement après la zone de texte
        description="please enter your name", # Décrit le champ, par défaut le nom du formulaire
        value="bob", # Valeur par défaut
        id="nameid", # Spécifier l'ID
    )

En plus des attributs ci-dessus, tous les attributs HTML peuvent être entré de la même manière. Par exemple:
    
    myform2 = form.Form(
        form.textbox('phonenumber',
            size="12",
            maxlength="12"        )
    )

<a name="listes"></a>
##Listes déroulantes  (Dropdown) 

Les entrées des listes déroulantes permettent une description et une valeur uniques de chaque élément dans la liste déroulante. Pour ce faire, créez la liste déroulante avec les tuples comme ceci:
    
    form.Dropdown('mydrop', [('value1', 'description1'), ('value2', 'description2')])

<a name="introduction"></a>
## Particularités des formulaires
En plus des champs de saisie individuels, form.py permet une complète validation de formulaire qui autorise la comparaison des champs. Les validations sont passées sous forme de liste dans une variable 'validators'. Par exemple :

    signup = form.Form(
        form.Textbox('username'),
        form.Password('password'),
        form.Password('password_again'),
        validators = [form.Validator("Passwords didn't match.", lambda i: i.password == i.password_again)]
    )

Une fois les données du formulaire postées, elles peuvent facilement être mises dans une base de données (si la structure de base de données a des noms compatibles avec votre formulaire webpy). Par exemple:

    def POST(self):
        f = myform()
        if f.validates():
            web.insert('data_table', **f.d)
        # NE FAITES PAS: web.insert('data_table', **web.input()) Car des données malicieuses peuvent être envoyées
        else:
            render.foo(f)

<a name="exemple"></a>
## Exemple

    import web
    from web import form

    render = web.template.render('templates/')

    urls = ('/', 'index')
    app = web.application(urls, globals())

    myform = form.Form( 
        form.Textbox("boe"), 
        form.Textbox("bax", 
            form.notnull,
            form.regexp('\d+', 'Must be a digit'),
            form.Validator('Must be more than 5', lambda x:int(x)>5)),
        form.Textarea('moe'),
        form.Checkbox('curly'), 
        form.Dropdown('french', ['mustard', 'fries', 'wine'])) 

    class index: 
        def GET(self): 
            form = myform()
            # make sure you create a copy of the form by calling it (line above)
            # Otherwise changes will appear globally
            return render.formtest(form)

        def POST(self): 
            form = myform() 
            if not form.validates(): 
                return render.formtest(form)
            else:
                # form.d.boe and form['boe'].value are equivalent ways of
                # extracting the validated arguments from the form.
                return "Grrreat success! boe: %s, bax: %s" % (form.d.boe, form['bax'].value)

    if __name__=="__main__":
        web.internalerror = web.debugerror
        app.run()

Ansi que l'exemple formtest.html (à placer dans le sous-repertoire *templates*): 

    $def with (form)

    <form name="main" method="post"> 
    $if not form.valid: <p class="error">Try again, AmeriCAN:</p>
    $:form.render()
    <input type="submit" />    </form>
---
layout: default
title: Form Library
---

# Form Library

Other languages : [français](/docs/0.3/form.fr) | ...

# Summary

* <a href="#introduction">Introduction</a>
* <a href="#inputfeatures">Input Features</a>
* <a href="#dropdown">Dropdown</a>
* <a href="#formfeatures">Form Features</a>
* <a href="#example">Example</a>

<a name="introduction"></a>
## Introduction


The form module of web.py allows the ability to generate html forms, get user input, and validate it before processing it or adding it to a database.

The form module defines 2 primary classes: the Form class, and the Input class.  Forms are instantiated with one or more inputs, and optional validators.  Inputs are instantiated with a name variable, and optional arguments and validators. The Input class is subclassed into the following html inputs (html type in parens):

* Textbox - free form single line input (input type="text")
* Password - free form single line that hides input (input type="password")
* Textarea - free form multi line input (textarea)
* Dropdown - mutually exclusive input for lists (select and options)
* Radio - mutually exclusive input for a few options (input type="radio")
* Checkbox - binary input (input type="checkbox")
* Button - submit the form (button)

A basic login form would look like this:

    login = form.Form(
        form.Textbox('username'),
        form.Password('password'),
        form.Button('Login'),
    )

This defines a basic form. Once defined, you should call it again to get an copied instance, and then you can call the render method on it, like so:

    f = login()
    print f.render()

This outputs the following HTML:

    <table>
        <tr><th><label for="username">username</label></th><td><input type="text" id="username" name="username"/><div class="post" style="display: none;"></div></td></tr>
        <tr><th><label for="password">password</label></th><td><input type="password" id="password" name="password"/><div class="post" style="display: none;"></div></td></tr>
        <tr><th><label for="Login"></label></th><td><button id="Login" name="Login">Login</button><div class="post" style="display: none;"></div></td></tr>
    </table>

Which looks like:

<table>
    <tr><th><label for="username">username</label></th><td><input type="text" id="username" name="username"/><div class="post" style="display: none;"></div></td></tr>
    <tr><th><label for="password">password</label></th><td><input type="password" id="password" name="password"/><div class="post" style="display: none;"></div></td></tr>
    <tr><th><label for="Login"></label></th><td><button id="Login" name="Login">Login</button><div class="post" style="display: none;"></div></td></tr>
</table>

<a name="inputfeatures"></a>
## Input Features
The form inputs support several additional attributes.  For example:

    form.textbox("firstname",
        form.notnull, #put validators first followed by optional attributes
        class_="textEntry", #gives a class name to the text box -- note the underscore
        pre="pre", #directly before the text box
        post="post", #directly after the text box
        description="please enter your name", #describes field, defaults to form name ("firstname")
        value="bob", #default value
        id="nameid", #specify the id
    )

In addition to the attributes above, any html attributes can be entered in the same manner.  For example:
    
    myform2 = form.Form(
        form.textbox('phonenumber',
            size="12",
            maxlength="12"        )
    )

<a name="dropdown"></a>
##Dropdown

Dropdown inputs allow a unique description and value for each item in the dropdown list.  To do this, create the dropdown list with tuples like this:
    
    form.Dropdown('mydrop', [('value1', 'description1'), ('value2', 'description2')])

<a name="formfeatures"></a>
## Form Features
In addition individual input validators, form.py supports entire form validation which allows comparisons of fields.  The validators get passed as a list as the variable 'validators'.  For example:

    signup = form.Form(
        form.Textbox('username'),
        form.Password('password'),
        form.Password('password_again'),
        validators = [form.Validator("Passwords didn't match.", lambda i: i.password == i.password_again)]
    )

Once the form data has been posted, it can easily be put into a database (if the database scheme has names consistent with your webpy form).  For example:

    def POST(self):
        f = myform()
        if f.validates():
            web.insert('data_table', **f.d)
        #don't do web.insert('data_table', **web.input()) because malicious data could be submitted too
        else:
            render.foo(f)

<a name="example"></a>
## Example

    import web
    from web import form

    render = web.template.render('templates/')

    urls = ('/', 'index')
    app = web.application(urls, globals())

    myform = form.Form( 
        form.Textbox("boe"), 
        form.Textbox("bax", 
            form.notnull,
            form.regexp('\d+', 'Must be a digit'),
            form.Validator('Must be more than 5', lambda x:int(x)>5)),
        form.Textarea('moe'),
        form.Checkbox('curly'), 
        form.Dropdown('french', ['mustard', 'fries', 'wine'])) 

    class index: 
        def GET(self): 
            form = myform()
            # make sure you create a copy of the form by calling it (line above)
            # Otherwise changes will appear globally
            return render.formtest(form)

        def POST(self): 
            form = myform() 
            if not form.validates(): 
                return render.formtest(form)
            else:
                # form.d.boe and form['boe'].value are equivalent ways of
                # extracting the validated arguments from the form.
                return "Grrreat success! boe: %s, bax: %s" % (form.d.boe, form['bax'].value)

    if __name__=="__main__":
        web.internalerror = web.debugerror
        app.run()

And sample formtest.html (place this in the *templates* subdirectory): 

    $def with (form)

    <form name="main" method="post"> 
    $if not form.valid: <p class="error">Try again, AmeriCAN:</p>
    $:form.render()
    <input type="submit" />    </form>
---
layout: default
title: godaddy.com
---

# godaddy.com

I signed up for the Deluxe Linux account. I don't know anything about the Windows account. Presumably, the virtual and dedicated Linux accounts are also possible.

Godaddy has support for Python and MySQL (albeit an older version).

1) Extract flup and copy the "flup" folder to a folder called "flup" in your root directory.<br/>2) Extact Cheetah and copy the contents of "src" to a folder called "Cheetah" in your root directory.<br/>3) I configured everything to work with CGI, according to the tutorial.  I was unable to get FastCGI working, although godaddy claims to support FastCGI for RoR applications.<br/>4) The version of MySQL is 4.0.*, so the "todo" table in the tutorial will need to be massaged. It looks like this:
<p>CREATE TABLE `todo` (<br/>  `id` bigint(20) unsigned NOT NULL auto_increment primary key,<br/>  `title` text,<br/>  `created` timestamp NOT NULL,<br/>  `done` tinyint(1) default '0',<br/>  PRIMARY KEY  (`id`),<br/>  UNIQUE KEY `id` (`id`)<br/>)
</p>(Setting DEFAULT CURRENT_TIMESTAMP didn't seem to work for me, athough I'm new to MySQL, and impatient.)<br/>5) Log into your Account Manager to get the exact address for the MySQL database. It will be something like mysql##.secureserver.com. The exact value of ## will differ. I had to implicitly specify the host database address in the connection parameters (host=mysql##.secureserver.com); the local socket didn't work.<br/>6) Don't forget to chmod +x your Python scripts. There is no SSH access, only FTP.

Otherwise, things are working fine for me, so far.  

Getting Cheetah to work the way I wish it would is another matter...

Updated: July 24, 2006


---
layout: default
title: GrokThis
---

# GrokThis

[http://grokthis.net](http://grokthis.net)

It seems their [traditional](http://www.grokthis.net/Hosting/traditional.html), [advanced](http://www.grokthis.net/Hosting/advanced.html), and [VPS](http://www.grokthis.net/Hosting/vps.html) plans all support web.py
---
layout: default
title: hosts
---

# hosts

How to's on getting web.py on the following hosts:

* [TextDrive](/TextDrive)
* [Symonds.net](/Symonds.net)
* [dreamhost](/dreamhost)
* [apinc.org](http://apinc.org/)
* [godaddy.com](/godaddy.com)
* [GrokThis](/GrokThis)
* [kimsufi](/kimsufi)
* [DevelopmentIsland](/DevelopmentIsland)
* [eSecureData](http://www.esecuredata.com)
---
layout: default
title: ideas
---

# ideas

Here are ideas for web.py projects to take on if you have some free time, say, this summer.

## web.py infrastructure

<a name="enhancing-templating"></a>
### enhancing templating

The current templating system, and even Adam Atlas's rewrite, doesn't perfectly conform to the spec. For example, it doesn't support arbitrary Python code execution within a template. This project would be to take the templating system the final mile and fix the remaining bugs and unimplemented features.

<a name="engine-agnostic-templating"></a>
### Engine-agnostic templating

Python has many templating engines, each emphasizing different features and approaches. Web.py currently supports Cheetah and Templator (its built-in engine). It would be nice to be able to be able to use the same model (a 'render' object which responds to template names, outputs the content-type, etc) with other engines (like Genshi, Clearsilver, Kid and others). Turbogears has some code doing similar stuff that can be canibalized.

<a name="javascript-form-support"></a>
### javascript form support

It's annoying to have to fill out a form.py form, only to get it back to find that it's been incorrectly filled out. This project would be to add metadata to web.py validators to allow them to be implemented in JavaScript (for `notnull` and `regexp`, this should be trivial) and then update the forms so that they work like [this qweb example][q] -- giving the user immediate feedback when they've failed a requirement.

  [q]: http://notabug.com/qweb/bbbbb

<a name="user-accounts"></a>
### user accounts

web.py has long been lacking a user account system. The goal would be to build something simple and flexible enough that it could be plugged into all sorts of database backends and UI front ends, but still handle the details of HMACs and OpenID and stuff like that. If you're interested in this project, work with the mailing list to come up with a clear spec before you get started.

<a name="built-in-session-middleware"></a>
### Built-in session middleware

Sessions are a useful abstraction for web applications. Flup comes with some simple session middleware, but it doesn't back to databases (which is very useful if your deployment scenario relies on multiple web servers using the same DB server). It would be nice if web.py would come with a built-in, file or DB -backed session facility.

### other

Is there a set of functionality you find yourself implementing over and over that you think would be good for web.py? Let us know; perhaps it would make a good project.

## web.py tools

<a name="screen-scraping-data-processing"></a>
### screen scraping / data processing

Lots of exciting web sites (e.g. [Chicago Crime][cc]) are built by scraping existing public data sources and reformulating them in a new way. This project would be to work on various public works screen scraping and data processing tasks to feed data to a new such public works site.

  [cc]: http://chicagocrime.org/

<a name="collaborative-filtering"></a>
### collaborative filtering

Many database-backed web sites display various sorts of items -- news stories, users, photos -- and provide users with various techniques for finding them. Most of the traditional techniques (searching, filtering, following links) are pretty easy to implement in web.py. But one key one that's missing is support for collaborative filtering. This project would be to take existing collaborative filtering algorithms and implementations (e.g. [consensus][c]), possibly improving them or replacing them if necessary, and fitting them into a framework where they can be used on large-scale web.py sites. That means developing tools to move stuff from the database into the recommendation system, store the recommendations, update the recommendations regularly, etc.

  [c]: http://exogen.case.edu/projects/consensus/

<a name="stats-package"></a>
### stats package

Every hit to the server contains within it a wealth of information -- user IP, cookies, browser information, referrers -- but for most people, all this data is largely thrown a way. For the most part, people still use the same log analysis tools developed in the early 1990s. What about a system that used the power of modern databases to let you explore this log information in a meaningful way? Click on a particular URL and see how its traffic has changed over time, how it compares with other URLs on the site, what referrers have linked to it and what those referrers say about it. Click on a particular IP and see its entire path through the site, watching where it came from and where it got stuck. And so on. I've got _lots_ of ideas for this if you're interested in building it.

## web apps

<a name="startupideas-org"></a>
### startupideas.org

A bunch of people come up with fairly good ideas for new web apps to build. A bunch of people are fairly good at building them. But, as far as I can tell, these groups aren't very good at talking to each other. This would be a simple web.py site where people could submit their new website ideas, other people could vote and comment on them, and developers could sign up to implement them. It's all about bringing people together. To build websites.

<a name="teh-communicator"></a>
### teh communicator

IRC is nice for asking questions because you can get answers in real-time. But it's bad because it requires special client software, has pretty useless archives, and if no one answers your question in real-time then it doesn't get answered. "teh communicator" (just a code name) is a project to develop a new website that uses AJAX push to give you the realtime feel of IRC on a website (using web.py's `untwisted` module) but stores conversations in a database so that they're nicely archived, threaded, and you can keep track of which ones have already been answered.

<a name="wiki-debate"></a>
### WikiDebate

Wikipedia is great when you want to know the facts of a subject, but often you don't want the facts, you want the arguments. The goal of the WikiDebate project would be to develop a new site that was more of a cross between a threaded discussion and Wikipedia. Instead of simply having an edit war over which are the real facts, the site would capture the structure of real arguments on the subject, with the back-and-forth of claim and refutation. Ideally, pointless online arguments could be moved into this system and real progress could be made, instead of hashing the same points out over and over again.

<a name="webpy-org"></a>
### webpy.org

When people fish for a Python web framework, the first thing they encounter is the framework's website. They check how good (and easy to use) the documentation is, how easy it is to report bugs and interact with the developers, and those who aren't very technical just check how warm and fuzzy the website makes them feel. Web.py's website is not doing very well on the warm-and fuzzyness effort, it's distributed between a static page (decent design, but sparse), a wiki (on a commercial service, developed using web.py itself but looking pretty generic), a Trac site (which needs lots of love if it is to be at all useful) and a mailing list. The challenge is to both do a better job at marketing _and_ getting real value out of the effort (by making it easier for people collaborate of developing and supporting web.py).

## web.py community

<a name="pyweek-for-webpy"></a>
### PyWeek for web.py

[PyWeek](http://www.pyweek.org/) is a contest challenging entrants to design, build, and complete a game starting from scratch in only one week.  Web.py could start with a similar model and rule set and invite interested parties to take a simple idea for a web app (possibly connected to startupideas.org?) and turn it into a functioning application in a specified amount of time.  Judgment and prizes aren't the point, we want to inspire folks with some free time to pick up the tools and just start using them.
---
layout: default
title: Serving Images
---

# Serving Images

## Basic Directory Set-up

First let your urls extend beyond images:

    import web
    
    urls = (
    '/images/(.*)', 'images' #this is where the image folder is located....
    )

## Basic Image Class
Now create the class that will handle them:

    import os
    class images:
        def GET(self,name):
            ext = name.split(".")[-1] # Gather extension
            
            cType = {
                "png":"images/png",
                "jpg":"images/jpeg",
                "gif":"images/gif",
                "ico":"images/x-icon"            }

            if name in os.listdir('images'):  # Security
                web.header("Content-Type", cType[ext]) # Set the Header
                return open('images/%s'%name,"rb").read() # Notice 'rb' for reading images
            else:
                raise web.notfound()

---
layout: default
title: A propos de Web.py
---

# A propos de Web.py

Autre langages : [english](/) | ...


**web.py** est un framework pour python qui est aussi simple qu'il est puissant. Web.py est dans le domaine publique; vous pouvez l'utiliser à toutes fins sans aucunes restrictions.

##Une application complète web.py

    import web
            
    urls = (
        '/(.*)', 'hello'
    )
    app = web.application(urls, globals())
    
    class hello:        
        def GET(self, name):
            if not name: 
                name = 'World'
            return 'Hello, ' + name + '!'
    
    if __name__ == "__main__":
        app.run()


## Pour commençer

web.py 0.33 a été réalisé le 2009-10-28: [web.py-0.33.tar.gz][16]

   [16]: /static/web.py-0.33.tar.gz

Pour avoir toujours la dernière version de web.py, exécutez:
    
    git clone git://github.com/webpy/webpy.git
    ln -s `pwd`/webpy/web .

ou bien téléchargez la dernière version en [zip](http://github.com/webpy/webpy/zipball/master) ou [tarball](http://github.com/webpy/webpy/tarball/master).

Mise à jour depuis une version plus ancienne? Assurez-vous de [lire le guide de mise à jour][17].

   [17]: http://webpy.org/docs/0.3/upgrade

## Qui utilise web.py ?

web.py a été publié alors que Aaron Swartz travaillait sur [reddit.com][20], où le site l'utilisait pour grandir et devenir l'un des 1000 premiers sites selon Alexa et servait des millions de pages vues tous les jours. "C'est le framework anti-framework. web.py ne vous gagne en aucune manière," expliquait le fondateur Steve Huffman. (Le site a été réécrit en utilisant d'autres outils, après avoir été acquis par Condé Nast.)

   [20]: http://reddit.com/

[Frinki](http://frinki.com), Un réseau social de type Facebook en espagnol.

[Make History](http://makehistory.national911memorial.org), un projet du 9/11 Memorial Museum, qui est conçu avec Web.py en tête de Google App Engine. Le 11 septembre 2009, il reçevait près de 200.000 visiteurs. "C'est la première fois que je travaille avec web.py et essentiellement en Python," note son développeur. "web.py est génial."

[local.ch](http://www.local.ch), Le répertoire téléphonique en ligne officiel de Suisse - utilise web.py en service d'arrière plan pour suivre les contenus expirés - code en open-source sur [urldammit](http://github.com/harryf/urldammit/tree/master)

[sitecanary.com](https://sitecanary.com/) un site pour être alerté quand votre site web est hors-service.

[watchdog.net](http://watchdog.net/), un site de service politique, construit en web.py.

[archivd.com](http://www.archivd.com), une application web pour des recherches collaboratives et de l'archivage, réalisé avec web.py

[colr.org](http://www.colr.org), un site de ponctions de couleurs, réalisé avec web.py.


[Chiefmall](http://www.chiefmall.com/), un outil de recherche d'entrepeneurs, qui a été réalisé avec web.py.

[grouplite.com](http://www.grouplite.com) utilise web.py.

[Yandex][21], Un fournisseur d'acces internet Russe dont la page d'accueil seule reçoit 70 millions de visites par jour, utilise web.py pour certains projets.
   [21]: http://yandex.ru

[LShift][22] a utilisé web.py pour construire des sites web pour [Expro][23] et [publisher Dorling Kindersley][24]. "web.py nous permet de faire ce que nous faisons de mieux," rapportent-ils. "il réalise les applications web avec brio, sans nous obliger à faire des compromis sur la flexibilité et l'originalité."

   [22]: http://www.lshift.net/
   [23]: http://exproretail.com/
   [24]: http://travel.dk.com/

[micropledge][m], une application Web qui recueille des fonds pour des idées de logiciels, et qui est construite avec web.py. "Nous avons apprécié sont intégration avec son approche minimale," raconte le développeur Ben Hoyt.

   [m]: http://micropledge.com/

Le [bivalidateur](http://xhtml-css.com/) vérifie votre HTML et la validation CSS.

[jottit.com](http://jottit.com) est construit avec web.py.  Jottit permet d'obtenir un site web aussi facilement que le remplissage d'un champ de saisie. 

[Tasko][t] élaboré avec web.py. Tasko est un gestionnaire de tâches en ligne qui utilise un format de fichier de texte brut pour stocker toutes les informations.

   [t]: http://taskodone.com/

[Damiga][d] est bâtit avec web.py. Damiga est un endroit où vous pouvez anonymement et librement dire au monde ce que vous ressentez à propos d'autres personnes: amis, célébrités, même des personnages de fiction. C'est aussi un endroit où vous pouvez voir ce que le monde pense de vous. 

   [d]: http://damiga.com/

[Fotosaur.us][f], une incroyable application de marque-pages d'images, réalisée avec web.py.

   [f]: http://fotosaur.us


[URIs.us][u] est un service pour créer des urls courtes. Déployé sur Google App Engine

   [u]: http://uris.us 


[xykra] [x] est un wiki minimaliste (160 lignes de Python) qui utilise [Markdown](http://daringfireball.net/projects/markdown/).

   [x]: http://xykra.org

[Edgarest] [y] est réalisé avec Web.py. Edgarest fournit un accès rapide et une recherche intuitive de SEC Filings (publication de documents boursiers)

   [y]: http://edgarest.com


[Wklej.to] [z] est une application nopaste/Pastebin( application web qui permet aux utilisateurs de télécharger des morceaux de textes) avec une api ouverte et libre, et naturellement des modules Desktop et des clients.

   [z]: http://wklej.to

[Biomed Search] [zzz] recherche plus de un million d'images biomédicales dans des tailles bien visibles.

   [zzz]: http://www.biomed-search.com

"[web.py a inspiré le] framework web que nous utilisons tel que FriendFeed [et] l'application framework livrée avec App Engine..."  
 - [Brett Taylor](http://bret.appspot.com/entry/experimenting-google-app-engine), co-fondateur de FriendFeed et leader technique original de Google App Engine

"Dans l'écosystème des frameworks web, quelque chose doit occuper le créneau du "petit, léger et rapide". web.py est celui-là."  
- Lloyd Dalton, [colr.org](http://colr.org)

"Nous avons terminé la réécriture de notre serveur il y a quelques jours avec web.py et c'était tout ce que nous souhaitions."  
- Sam Hsiung, [YouOS][25]

   [25]: http://www.youos.com/

"Django vous permet d'écrire des applications web en Django. TurboGears vous permet d'écrire des applications web en TurboGears. Web.py vous permet d'écrire des applications web en Python."  
- Adam Atlas

"très élégant et concis (sans oublier que c'est écrit par Aaron Swartz, dont les compétences en codage sont impressionnantes), et ça ne m'a pas fait perdre de temps."   
- Jonas Galvez, Aupeo [#][26]

   [26]: http://www.artima.com/forums/flat.jsp?forum=106&thread=146149

"Le premier framework ... sur lequel je peux bidouiller du code et voir quelque chose fonctionner sans même être obligé de comprendre la logique de celui-ci. Un plaisir à intégrer."   
- Delaunay Antoine built [a photo gallery][28] and [an agenda][34] with it

   [28]: http://github.com/antoine/ibrouteur/
   [34]: http://metagenda.org

"Guido [van Rossum, Créateur de Python], vous constaterez probablement que web.py convient le mieux à votre style. ...Si vous ne l'aimez pas, je ne peux imaginer lequel des autres douzaines d'autres framework sortis vous *pourriez* aimer."   
- Phillip J. Eby, créateur du Python Web Server Gateway Interface (WSGI) [#lien][30]

   [30]: http://www.artima.com/forums/flat.jsp?forum=106&thread=146149&start=30&msRange=15

"... l'exemple [Cheetah] que j'ai vu sur web.py à l'air "bon". (web.py itself OTOH gets an "F", for undocumented code with too much magic behavior. upvars(), bah.)"  [ Note traducteur : A préciser]
- Guido van Rossum, Créateur de Python [#Lien][31]

   [31]: http://www.artima.com/weblogs/viewpost.jsp?thread=146503

"il suffit de dire je crois, que Aaron se dirige dans la bonne direction."   
- Harry Fuecks: [un simple wiki avec web.py][32]

   [32]: http://www.sitepoint.com/blogs/2006/01/06/a-simple-wiki-with-webpy/

"un moment très fascinant pour moi. Le même sentiment que j'ai eu lorsque j'ai écrit pour la première fois un script PHP. il est certain que ça me permettra d'apprendre python de façon amusante. Bon travail Aaron !"   
- Kamal [Un simple blog en webpy, apprendre python de façon amusante][33]

   [33]: http://www.k4ml.com/node/165

### Documentation web.py :

* [installation](/install)
    * [english](/install)
    * [mac os x](/install_macosx)
    * [español](/install/es)
    * [日本語](/install/ja)
    * [简体中文](/install/zh-cn)
    * [Italiano](/install/it)
    * [français](/install/fr)


* [tutoriaux pour la version 0.3 (dernière en date)](/tutorial3)
    * [english](/tutorial3.en)
    * [简体中文](/tutorial3.zh-cn)
    * [p?????? 0.2](http://webpy.infogami.com/tutorial2.ru)
    * [????](http://www.dup2.org/files/web.py%200.2%20tutorial.html)
    * [template.py tutorial](/templetor)
    * [form.py (short) tutorial](/form)
    * [日本語](/tutorial2.ja)
    * [e???????](http://webpy.org/tutorial2.el)
    * [français](/tutorial3.fr)

* [tutoriaux (anciennes versions)](/tutorial):
    * [english](http://webpy.org/tutorial)
    * [español](/tutorial/es)
    * português: [1](http://www.writely.com/View.aspx?docid=bbcm927cd2fmj) [2](http://www.writely.com/View.aspx?docid=bbcnjdbhbfh6n) [3](http://www.writely.com/View.aspx?docid=bccxp4cgw36p3)
    * [français](http://sunfox.org/tutoriel-web-py-fr/)
    * [p??????](http://bobuk.infogami.com/webpytrans)
    * [日本語](http://kinneko.googlepages.com/webpy_tutorial_ja)


* [Documentation](/docs/0.3.fr)


* FAQ:
    * [english](http://webpy.org/faq)
    * [español](/faq/es)
    * [???????](/faq/ru)
    * [???](http://kinneko.googlepages.com/webpy_faq)
    * [日本語](/faq/ja)
    * [简体中文](/faq/zh-cn)
    * [français](/faq/fr)

* cookbook:
      * [日本語](/cookbook/ja)
      * [english](/cookbook)
      * [简体中文](/cookbook/zh-cn)
      * [français](/cookbook/fr)

* [exemples de code](/src)

* [friendly hosts](/hosts)

* [related projects](/related)

* [tricks](/tricks)


### Communauté web.py

* [**mail list**](http://groups.google.com/group/webpy/ "web.py google group"): home of the web.py discussion

* [**irc channel**](irc://irc.freenode.net/webpy "#webpy on irc.freenode.net"): home of the web.py talk

* [powered by web.py buttons](http://luke.jottit.com/webpy_logo)

### Developpement web.py 

* [git repository](http://github.com/webpy/webpy)

* [launchpad site](http://launchpad.net/webpy)
---
layout: default
title: Welcome to web.py!
---

**web.py** is a web framework for Python that is as simple as it is powerful. web.py is in the public domain; you can use it for whatever purpose with absolutely no restrictions.

<div style="float: right; margin: 1em">
<pre>
import web
        
urls = (
    '/(.*)', 'hello'
)
app = web.application(urls, globals())

class hello:        
    def GET(self, name):
        if not name: 
            name = 'World'
        return 'Hello, ' + name + '!'

if __name__ == "__main__":
    app.run()
</pre>
<em>A complete web.py application.</em>
</div>

## Get Started

web.py 0.37 is the latest released version of web.py. You can install it by running:

    sudo easy_install web.py

Or to get the latest development version from git:
    
    git clone git://github.com/webpy/webpy.git
    ln -s `pwd`/webpy/web .

## Who uses web.py?

web.py was originally published while Aaron Swartz worked at [reddit.com][20], where the site used it as it grew to become one of the top 1000 sites according to Alexa and served millions of daily page views. "It's the anti-framework framework. web.py doesn't get in your way," explained founder Steve Huffman. (The site was rewritten using other tools after being acquired by Condé Nast.)

   [20]: http://reddit.com/

* [Frinki](http://frinki.com), a new social network in Spanish.

* [Yandex][21], the leading Russian search engine (their homepage alone receives 70 million daily page views).

   [21]: http://yandex.ru

* [Make History](http://makehistory.national911memorial.org), a project of the 9/11 Memorial Museum, is powered by web.py on top of Google App Engine. On September 11, 2009, it received nearly 200,000 visitors. "It's my first time working with web.py and basically with Python," noted its developer. "web.py was awesome."

* [Oyster.com](http://www.oyster.com/), a website that reviews and photographs hotels, uses web.py for the entire site. They note that "web.py gives us the control we need for a large-scale website". As of Jan 2013, Oyster.com renders about 230,000 pages per day.

* [local.ch](http://www.local.ch), the official online Telephone Directory for Switzerland - using web.py in a backend service for tracking expired content - code open-sourced as [urldammit](http://github.com/harryf/urldammit/tree/master).

* [archivd.com](http://www.archivd.com), a web application for collaborative research and archiving, is built on web.py.

* [Chiefmall](http://www.chiefmall.com/), a contractor search tool, was built with web.py.

* [pudung.com](http://pudung.com), Online Store based in Jakarta, Indonesia, is using [onlinestore-multi](https://github.com/nopri/onlinestore-multi) (Simple Online Store application built using Python, web.py, jQuery and MySQL).

"[web.py inspired the] web framework we use at FriendFeed [and] the webapp framework that ships with App Engine..."  
<span class="cite">&nbsp;&nbsp;&mdash;&nbsp; [Brett Taylor](http://bret.appspot.com/entry/experimenting-google-app-engine), co-founder of FriendFeed and original tech lead on Google App Engine</span>

"Django lets you write web apps in Django. TurboGears lets you write web apps in TurboGears. Web.py lets you write web apps in Python."  
<span class="cite">&nbsp;&nbsp;&mdash;&nbsp; Adam Atlas</span>

"Guido [van Rossum, creator of Python], you'll probably find that web.py best suits your style. ... If you don't like it, I can't imagine which of the other dozens of frameworks out there you *would* like."   
<span class="cite">&nbsp;&nbsp;&mdash;&nbsp; Phillip J. Eby, creator of the Python Web Server Gateway Interface (WSGI) [#][30]</span>

   [30]: http://www.artima.com/forums/flat.jsp?forum=106&thread=146149&start=30&msRange=15

---
layout: default
title: Insert: Adding a new entry to a database
---

# Insert: Adding a new entry to a database

###Problem: You want to add data to a database

###Solution: 

With version 0.3, databases are defined like this:

    db = web.database(dbn='postgres', db='mydata', user='dbuser', pw='')

Once the database is defined as such, performing insert can be performed like this:
    
    # Insert an entry into table 'mytable'
    sequence_id = db.insert('mytable', firstname="Bob",lastname="Smith",joindate=web.SQLLiteral("NOW()"))

The insert statement takes the following keyword arguments:
 
tablename
seqname   
_test  
\**values
 


##tablename
The name of the table in your database to which you would like to add data to.

##seqname
An optional argument, the default value is None. Set `seqname` to the ID if it's not the default, or to `False`.

##_test
The _test variable lets you see the SQL produced by the statement:

    results = db.select('mytable', offset=10, _test=True) 
    ><sql: 'SELECT * FROM mytable OFFSET 10'>

##\**values
A set of named arguments that represent the fields in your table. If values are not given, the database may create default values or issue a warning.
---
layout: default
title: install/es
---

# install/es

## Instalación

Para instalar web.py, descargar de:
    
    http://webpy.org/web.py

en el directorio donde se encuentra sus aplicaciones. También puedes hacer accesible las aplicaciones al directorio de Python site-packages. Para ver donde se encuentra, ejecute:

    python -c "import sys; print[x for x in sys.path if x.endswith('site-packages')][-1]"
## Producción

El servidor web que inicias cuando ejecutas un programa en web.py, es algo muy agradable y placentero, pero si deseas sitios más populares, es interesante tener montado algo un poco más serio.

### FastCGI

Lighttpd con soporte FastCGI lo más recomendable para montar web.py en un sitio en producción. Sitios como [reddit.com][3] soportan millones de peticiones y está funcionando con Lighttpd + FastCGI.

   [3]: http://reddit.com/

Al inicio de su code.py añade:

    #!/usr/bin/env python

Y ejecute chmod +x code.py


#### lighttpd

Su configuración lighttpd puede ser parecida a:

     server.modules = ("mod_fastcgi", "mod_rewrite")
     server.document-root = "/path/to/root/"     fastcgi.server = ( "/code.py" =>     (( "socket" => "/tmp/fastcgi.socket",
        "bin-path" => "/path/to/root/code.py",
        "max-procs" => 1
     ))
     )
    
     url.rewrite-once = (
       "^/favicon.ico$" => "/static/favicon.ico",
       "^/static/(.*)$" => "/static/$1",
       "^/(.*)$" => "/code.py/$1",
     )
    

#### Apache

Si deseas utilizar FastCGI con Apache en lugar de otra opción, tienes que instalar mod_fastcgi y usar .htaccess así: 

    <Files code.py>    SetHandler fastcgi-script
    </Files>
Desafortunadamente, con Apache no pasa como con lighttpd, y tenemos que decirle de forma explícita que interactuamos con el servidor FastCGI, así que tenemos que añadir este código para decirle a web.py que usamos el servidor FastCGI:

    web.runwsgi = web.runfcgi


### mod_python
---
layout: default
title: Installation
---

# Installation

Autre langages : [español](/install/es) | [Japan](/install/ja) | [chinese](/install/zh-cn) | [italiano](/install/it) | [english](/install) 

## Sommaire

* <a href="#installation">Installation</a>
	* <a href="#macosx">.. sur MacOS X</a>
* <a href="#dev">Développement</a>
* <a href="#prod">Production</a>
	* <a href="#lighttpd">LightTPD</a>
		* <a href="#lighttpdfastcgi">...avec FastCGI</a>
	* <a href="#apache">Apache</a>
		* <a href="#apachecgi">...avec CGI</a>
		* <a href="#apachecgihtaccess">.. avec CGI en utilisant .htaccess</a>
		* <a href="#apachefastcgi">.. avec FastCGI</a>
		* <a href="#apachescgi">.. avec SCGI</a>
		* <a href="#apachemodpython">.. avec mod_python</a>
		* <a href="#apachemodwsgi">.. avec mod_wsgi</a>
		* <a href="#apachemodrewrite">.. avec mod_rewrite</a>


<a name="installation"></a>
## Installation
Pour installer web.py, commencez par télécharger l'archive:
    
[web.py-0.33.tar.gz] (/static/web.py-0.33.tar.gz)

Décompressez l'archive et copier le dossier _web_ dans le dossier de votre application. Ou, pour rendre web.py accessible par toutes les applications, exécutez:
    
    python setup.py install

Note: sur certains systèmes Unix (ou Linux), il vous faudra vous connecter en tant que root (commande su) ou exécuter:

    sudo python setup.py install

Une autre option est d'utiliser [Easy Install](http://peak.telecommunity.com/DevCenter/EasyInstall). Une fois Easy Install correctement paramétré, exécutez:


    easy_install web.py

<a name="macosx"></a>
### ... Sur MacOS X

La procédure d'installation sur MacOS X n'a pas encore été traduite. Vous pouvez cependant visionner la version anglaise pour la version 0.1 : [Install MacOS X](/install_macosx) 


<a name="dev"></a>
## Développement:

webpy intègre son propre serveur web.  Apprenez comment écrire une application en suivant le [tutoriel](/tutorial3.fr).  Quand votre application est écrite, insérez votre code dans `code.py` et démarrez le serveur avec la commande:

     python code.py

Ouvrez votre navigateur et allez à l'adresse [http://localhost:8080/](http://localhost:8080/) pour visualiser la page. Pour spécifier un port différent, utilisez simplement `python code.py 1234`.

<a name="prod"></a>
## Production

Le serveur web intégré à web.py est bien pratique en phase de développement, mais pour un site en production, il vaut mieux prévoir quelque chose de plus sérieux. web.py fonctionne avec n'importe quel serveur http compatible avec  [WSGI](http://www.python.org/dev/peps/pep-0333/). 

WSGI est une API permettant la communication entre serveur web et applications, similaire à Java's Servlet Interface. Pour faire fonctionner web.py avec CGI, FastCGI ou SCGI, il vous faudra installer [flup](http://trac.saddi.com/flup) ([téléchargez ici](http://www.saddi.com/software/flup/dist/)), qui permet d'interfacer WSGI avec ces différentes API.

Pour utiliser une de ces variantes de CGI, ajoutez au début de votre `code.py` la ligne suivante :

    #!/usr/bin/env python

N'oubliez pas de le rendre exécutable: `chmod +x code.py`.

<a name="lighttpd"></a>
### LightTPD

<a name="lighttpdfastcgi"></a>
#### .. avec FastCGI

FastCGI associé à lighttpd est la manière recommandée d'utiliser web.py en production. [reddit.com][3] gère des millions de visites de cette façon.

   [3]: http://reddit.com/

Votre configuration lighttpd doit ressemble à ceci:
    
     server.modules = ("mod_fastcgi", "mod_rewrite")
     server.document-root = "/path/to/root/"     
     fastcgi.server = ( "/code.py" =>     
     (( "socket" => "/tmp/fastcgi.socket",
        "bin-path" => "/path/to/root/code.py",
        "max-procs" => 1
     ))
     )
    
     url.rewrite-once = (
       "^/favicon.ico$" => "/static/favicon.ico",
       "^/static/(.*)$" => "/static/$1",
       "^/(.*)$" => "/code.py/$1"
     )
    
Avec certaines versions de lighttpd, il est important de s'assurer que la propriété "check-local" du paramètre fastcgi.server est bien positionné à "false", surtout si votre `code.py` est situé en dehors de la racine.

Si vous recevez un message d'erreur indiquant qu'il n'est pas possible d'importer _flup_, installez-le en ligne de commande en utilisant la commande "easy_install flup".

Depuis la revision 145, il est nécessaire de définir une variable  "bin-environment" dans la configuration de fastcgi si votre code utilise des redirections.  Par exemple, si votre code redirige vers  http://domain.com/ et que vous voyez l'URL http://domain.com/code.py/ dans la barre de navigation, vous devrez modifier la configuration de fastcgi.server de la manière suivante:
     
    fastcgi.server = ( "/code.py" =>
    ((
       "socket" => "/tmp/fastcgi.socket",
       "bin-path" => "/path/to/root/code.py",
       "max-procs" => 1,
       "bin-environment" => (
         "REAL_SCRIPT_NAME" => ""
       ),
       "check-local" => "disable"
    ))
    )
    
<a name="apache"></a>
### Apache

<a name="apachecgi"></a>
#### .. avec CGI


Ajoutez les lignes suivante à `httpd.conf` ou `apache2.conf`.

    Alias /foo/static/ /path/to/static
    ScriptAlias /foo/ /path/to/code.py

<a name="apachecgihtaccess"></a>
#### .. avec CGI en utilisant .htaccess

CGI est facile à configurer mais ce n'est pas la meilleure des solutions pour les sites à très fort trafic.

Ajoutez les lignes suivantes à votre fichier `.htaccess`:

    Options +ExecCGI
    AddHandler cgi-script .py

Ouvrez votre navigateur et aller à l'URL `http://example.com/code.py/`. N'oubliez pas le slash final, sinon vous aurez droit à une 'page non trouvée'. Pour que ça fonctionne sans avoir à indiquer `code.py` dans l'URL, il faut activer le 'mod_rewrite' dans votre fichier '.htaccess' (voir en fin de document).

Note: la manière dont `web.py` est implémenté provoque une erreur du module `cgitb` à cause de la capture du `stdout`. Voici une façon de contourner le problème:
    
    import cgitb; cgitb.enable()
    import sys
    
    # ... import web etc here...
    
    def cgidebugerror():
        """                                                                         
        """        _wrappedstdout = sys.stdout
    
        sys.stdout = web._oldstdout
        cgitb.handler()
    
        sys.stdout = _wrappedstdout
    
    web.internalerror = cgidebugerror

<a name="apachefastcgi"></a>
#### .. avec FastCGI

FastCGI est facile à configurer et est aussi performant que 'mod_python'.

Ajoutez les lignes suivantes à votre fichier `.htaccess`:
    
    <Files code.py>      SetHandler fastcgi-script
    </Files>

Malheureusement, et contrairement à lighttpd, Apache ne donne aucune indication demandant à votre script web.py de fonctionner comme un serveur FastCGI, il faut donc l'indiquer à web.py de façon explicite, en ajoutant le code suivant dans votre script `code.py`, juste avant la ligne 
`if __name__ == "__main__":` :
    
    web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
    
<a name="apachescgi"></a>
#### .. avec SCGI

Téléchargez et installez le [module mod_scgi](http://www.mems-exchange.org/software/files/mod_scgi/)

modifier le fichier 'httpd.conf':

    LoadModule scgi_module Modules/mod_scgi.so
    SCGIMount / 127.0.0.1:8080

redémarrez le serveur Apache et lancer votre 'code.py' avec la commande suivante:

    python code.py 127.0.0.1:8080 scgi

lancez votre navigateur et visitez l'adresse suivante 127.0.0.1
C'est aussi simple que ça...enfin, si ça marche du premier coup ;-) 

<a name="apachemodpython"></a>
#### .. avec mod_python

mod_python est aussi performant que FastCGI, mais il n'est pas aussi évident à configurer. Suivez le guide:

Pour Python 2.5, procédez comme suit:

    cd /usr/lib/python2.5/wsgiref
    # or in windows: cd /python2.5/lib/wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # or fetch the file from that address using your browser

Pour Python <2.5, procéder plutôt ceci:

    cd /usr/lib/python2.4/site-packages
    # or in windows: cd /python2.4/lib/site-packages
    svn co svn://svn.eby-sarna.com/svnroot/wsgiref/wsgiref
    cd wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # or fetch the file from that address using your browser  


renommez votre script `code.py` en quelque chose comme `codep.py` et ajoutez le code suivant:
    
    main = web.wsgifunc(web.webpyfunc(urls, globals()))

Dans votre fichier `.htaccess`, ajoutez:
    
    
    AddHandler python-program .py
    PythonHandler wsgiref.modpython_gateway::handler
    PythonOption wsgi.application codep::main
    

Vous aurez surement aussi besoin d'ajouter une `RewriteRule` pour rediriger  `/` vers `/codep.py/`

<a name="apachemodwsgi"></a>
#### .. avec mod_wsgi

mod\_wsgi est un nouveau module Apache  [plus performant que mod_python](http://code.google.com/p/modwsgi/wiki/PerformanceEstimates) pour l'hébergement d'applications WSGI, et très facile à mettre en place.

A la fin de votre script `code.py`, ajoutez la ligne suivante:

    application = web.wsgifunc(web.webpyfunc(urls, globals()))

mod\_wsgi offre [plusieurs façons différentes](http://code.google.com/p/modwsgi/wiki/ConfigurationDirectives) de spécifier l'URL pointant vers une application WSGI, mais une manière simple peut être d'ajouter le code suivant dans votre fichier '.htaccess':

    <Files code.py>
        SetHandler wsgi-script
        Options ExecCGI FollowSymLinks
    </Files>

Si vous recevez un message d'erreur du style "ImportError: No module named web" dans le fichier error.log d'Apache, vous pouvez essayer de spécifier un chemin absolu dans votre script 'code.py' avant l'instruction 'import web':

    import sys, os
    abspath = os.path.dirname(__file__)
    sys.path.append(abspath)
    os.chdir(abspath)
    import web

Plus d'information dans la section "Application Working Directory"  sur [Common problems with WSGI application](http://code.google.com/p/modwsgi/wiki/ApplicationIssues).

Encore une fois, votre application devrait-être accessible à l'URL suivante: `http://example.com/code.py/` (sans oublier le slash final!!!).

<a name="apachemodrewrite"></a>
#### mod_rewrite pour Apache

Si vous voulez que webpy soit accessible par l'URL 'http://example.com' au lieu de  'http://example.com/code.py/' ajoutez les directives suivantes dans votre fichier `.htaccess`:

    <IfModule mod_rewrite.c>      
      RewriteEngine on
      RewriteBase /
      RewriteCond %{REQUEST_URI} !^/icons
      RewriteCond %{REQUEST_URI} !^/favicon.ico$
      RewriteCond %{REQUEST_URI} !^(/.*)+code.py/
      RewriteRule ^(.*)$ code.py/$1 [PT]
    </IfModule>

Si le script `code.py` est situé dans le sous-répertoire `myapp/`, changez la directive  `RewriteBase /` en `RewriteBase /myapp/`. 

Si vous avez d'autres fichiers statiques à exclure de la règle de réécriture  (fichiers CSS ou des images), indiquez-les également ici, en dupliquant et adaptant la ligne `RewriteCond %{REQUEST_URI} !^/icons.` ,par exemple, autant de fois que nécessaire.

Pour plus d'information sur le module mod_rewrite et l'utilisation du fichier `.htaccess`, je vous conseille l'excellent article [URL Rewriting pour les nuls] (http://seo.feuxi.com/URL-Rewriting-pour-les-nuls.html).

---
layout: default
title: Installazione
---

# Installazione

Prima di installare web.py dobbiamo scaricare i sorgenti:
    
    http://webpy.org/static/web.py-0.33.tar.gz

estraiamolo e copiamo la cartella "_web_" in una directory dove risiede la nostra applicazione.
Se invece vogliamo rendere web.py accessibile a tutte le applicazioni, dobbiamo installarlo in modo che sia reperibile nella cartella dei moduli di python.
Facciamo questo danto il seguente comando:
    
    python setup.py install

Nota: su alcuni sistemi unix-like bisogna, prima di dare il precedente comando, acquisire i privilegi di root (amministratore di sistema), o usare il comando sudo, come segue:

    sudo python setup.py install

guarda il [setup raccomandato](/recommended_setup) -in inglese-.

Un'altra opzione è quella di usare[Easy Install](http://peak.telecommunity.com/DevCenter/EasyInstall). Una volta che [Easy Install](http://peak.telecommunity.com/DevCenter/EasyInstall) è stato settato correttamente, usare il seguente comando per installare automaticamente web.py:


    easy_install web.py

## Sviluppo

Web.py è fornito con un webserver integrato. Impara a creare una applicazione con web.py seguento il [tutorial](http://webpy.org/tutorial2) -inglese-.  Una volta che avrai scritto la tua applicazione, supponendo che il file si chiami "code.py", avvialo con il seguente comando:

     python code.py

Apri il tuo browser e vai alla pagina [http://localhost:8080/](http://localhost:8080/) per vedere la tua applicazione funzionante! Se non vuoi usare la porta 8080, ma invece un'altra, fai seguire al precedente comando il numero della porta voluta: `python code.py 1234`.

##  Produzione

Il webserver fornito con web.py è utile in fase di sviluppo, ma per siti popolari che richiedono maggiori prestazioni avrai bisogno di qualcosa di più serio e performante. Web.py implementa [WSGI](http://www.python.org/dev/peps/pep-0333/) e viene eseguito su qualunque webserver che supporti questo standard. WSGI è una API standard di comunicazione tra il webserver e l'applicazione, analogamente alla Interfaccia Servlet di Java. Per eseguire web.py con CGI, FastCGI o SCGI avrai bisogno di installare anche [flup](http://trac.saddi.com/flup) ([download here](http://www.saddi.com/software/flup/dist/)), che fornisce una interfaccia WSGI per queste API.

Per tutte le varianti CGI (CGI, FastCGI, SCGI), aggiungi all'inizio del sorgente della tua applicazione (nell'esempio precedente "code.py"):

    #!/usr/bin/env python

ed esegui `chmod +x code.py` per renderlo eseguibile.

### LightTPD

#### ... con FastCGI

FastCGI con lighttpd è la soluzione raccomandata di usare web.py in fase di produzione. [reddit.com][3] gestisce milioni di richieste con questa configurazione!

   [3]: http://reddit.com/

La tua configurazione per LightTPD può essere simile a questa:
    
     server.modules = ("mod_fastcgi", "mod_rewrite")
     server.document-root = "/path/to/root/"     
     fastcgi.server = ( "/code.py" =>     
     (( "socket" => "/tmp/fastcgi.socket",
        "bin-path" => "/path/to/root/code.py",
        "max-procs" => 1
     ))
     )
    
     url.rewrite-once = (
       "^/favicon.ico$" => "/static/favicon.ico",
       "^/static/(.*)$" => "/static/$1",
       "^/(.*)$" => "/code.py/$1"
     )
    

Con alcune versioni di LightTPD, è importante assicurarsi che la proprietà "check-local" di fastcgi.server sia settata a "false". Specialmente se il tuo programma (code.py) si trova fuori dalla document root del webserver.

Se ricevi qualche errore circa l'impossibilità di importare flut, installalo inserendo "easy_install flup" nell terminale (necessiti di installare easy_install, prima).

Dalla revisione 145 (della versione 0.31), è necessario settare una variabile d'ambiente nella configurazione fastcgi se la tua applicazione fà uso di redirect (redirezioni).
Se il tuo codice re-indirizza a http://dominio.com/ e nella tua barra degli indirizzi vedi http://dominio.com/code.py/ (supponendo che code.py sia la tua applicazione) avrai bisogno di settare la variabile d'ambiente.
Questo comporta una variazione della tua configurazione del webserver ala voce fastcgi.server, qualcosa come:
     
    fastcgi.server = ( "/code.py" =>
    ((
       "socket" => "/tmp/fastcgi.socket",
       "bin-path" => "/path/to/root/code.py",
       "max-procs" => 1,
       "bin-environment" => (
         "REAL_SCRIPT_NAME" => ""
       ),
       "check-local" => "disable"
    ))
    )
    
### Apache

#### .. con CGI

Aggiungi le seguenti righe al tuo file `httpd.conf` o `apache2.conf`.

    Alias /foo/static/ /path/to/static
    ScriptAlias /foo/ /path/to/code.py


#### .. con CGI usando il file .htaccess

CGI è facile da configurare, ma non è adeguato per i siti che richiedono elevate prestazioni.
Per usare web.py con CGI aggiungi le seguenti righe al tuo `.htaccess`:

    Options +ExecCGI
    AddHandler cgi-script .py

e scrivi nella barrra degli indirizzi del tuo browser `http://example.com/code.py/`. Non dimenticare lo slash (barra) finale, altrimenti vedrai visualizzato un messaggio `not found` (non trovato) (poichè la lista delle url che hai definito non combacia con niente). Per rendere funzionante l'applicazione senza il bisogno di inserire nell'indirizzo `code.py` devi aver abilitato il modulo mod_rewrite e aggiungere nella configurazione le appropriate regole.

Nota: Il modo in cui `web.py` è implementato non lavora con il modulo `cgitb` poichè cattura lo `stdout`.
    
    import cgitb; cgitb.enable()
    import sys
    
    # ... import web etc qui...
    
    def cgidebugerror():
        """                                                                         
        """        _wrappedstdout = sys.stdout
    
        sys.stdout = web._oldstdout
        cgitb.handler()
    
        sys.stdout = _wrappedstdout
    
    web.internalerror = cgidebugerror

#### .. con FastCGI

FastCGI è facile da configurare e agisce come mod_python.
Aggiungi quanto segue al tuo `.htaccess`:
    
    <Files code.py>      SetHandler fastcgi-script
    </Files>

Sfortunatamente, diversamente da lighttpd, Apache non accenna al fatto che vuole che il codice della tua applicazione agisca come un server FastCGI quindi a web.py devi dirlo esplicitamente. Puoi farlo aggiungendo al tuo `code.py` prima della riga in cui scrivi `if __name__ == "__main__":`
    
    web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
    
e indirizza il tuo browser a `http://example.com/code.py/`. Non dimenticare lo slash (barra) finale, altrimenti vedrai visualizzato un messaggio `not found` (non trovato) (poichè la lista delle url che hai definito non combacia con niente). Per rendere funzionante l'applicazione senza il bisogno di inserire nell'indirizzo `code.py` devi aver abilitato il modulo mod_rewrite e aggiungere nella configurazione le appropriate regole.

[Walter ha altri consigli](http://lemurware.blogspot.com/2006/05/webpy-apache-configuration-and-you.html)[e](http://www.dofollownet.com/).

#### .. con SCGI
https://www.mems-exchange.org/software/scgi/
scarica i sorgenti di `mod_scgi` da qui: http://www.mems-exchange.org/software/files/mod_scgi/
Per gli utenti apache su Windows: 
edita il tuo httpd.conf come segue:

    LoadModule scgi_module Modules/mod_scgi.so
    SCGIMount / 127.0.0.1:8080

riavvia il webserver apache e poi avvia la tua applicazione code.py con il seguente comando:

    python code.py 127.0.0.1:8080 scgi

e apri il tuo browser, visita 127.0.0.1
E' tutto a posto! 

#### .. con mod_python

mod_python funziona come FastCGI, ma non è semplice da configurare.

Per python2.5 segui questi comandi:

    cd /usr/lib/python2.5/wsgiref
    # o in windows: cd /python2.5/lib/wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # o richiedi il file dal tuo browser

Per python < 2.5 (precedente a 2.5) fai questo:

    cd /usr/lib/python2.4/site-packages
    # o in windows: cd /python2.4/lib/site-packages
    svn co svn://svn.eby-sarna.com/svnroot/wsgiref/wsgiref
    cd wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # o richiedi il file dal tuo browser 


Rinomina il tuo `code.py` a qualcosa come `codep.py` e aggiungi:
    
    main = web.wsgifunc(web.webpyfunc(urls, globals()))

Nel tuo `.htaccess`, aggiungi:
    
    
    AddHandler python-program .py
    PythonHandler wsgiref.modpython_gateway::handler
    PythonOption wsgi.application codep::main
    

Probabilmente tu vorrai aggiungere una `RewriteRule` che punta `/` a `/codep.py/`

Sii sicuro di visitare `/codep.py/` con lo slash `/` extra alla fine. Altrimenti vedrai un messaggio di errore come `A server error occurred. Please contact the administrator.`

#### .. con mod_wsgi

mod\_wsgi è un nuovo modulo Apache che [tipicamente supera le peformance di mod_python](http://code.google.com/p/modwsgi/wiki/PerformanceEstimates)per hostare applicazioni WSGI, ed è veramente semplice da settare.

Alla fine del tuo `code.py`, aggiungi:

    application = web.wsgifunc(web.webpyfunc(urls, globals()))

mod\_wsgi offre [molti modi](http://code.google.com/p/modwsgi/wiki/ConfigurationDirectives) per esporre una applicazione WSGI nella gerarchia delle url di apache, ma una semplice via può essere quella di aggiungere le seguenti righe al tuo file .htaccess:

    <Files code.py>
        SetHandler wsgi-script
        Options ExecCGI FollowSymLinks
    </Files>

Se ottieni un errore di tipo "ImportError: No module named web" nel tuo error.log di apache, potrai provare a settare il percorso assoluto in code.py prima di importare web (moduli web.py):

    import sys, os
    abspath = os.path.dirname(__file__)
    sys.path.append(abspath)
    os.chdir(abspath)
    import web

Inoltre, potresti voler leggere la sezione "Application Working Directory" da [Common problems with WSGI application](http://code.google.com/p/modwsgi/wiki/ApplicationIssues)[s] (http://www.destination-casino.com/modules/news/article.php?storyid=13) -in inglese-.

Dovrebbe essere poi accessibile a `http://example.com/code.py/` come al solito.

#### Regole di mod_rewrite per Apache

Se vuoi rendere accessibile la tua applicazione web.py all'indirizzo 'http://example.com' anzichè 'http://example.com/code.py/' aggiungi le seguenti regole al file `.htaccess`:

    <IfModule mod_rewrite.c>      
      RewriteEngine on
      RewriteBase /
      RewriteCond %{REQUEST_URI} !^/icons
      RewriteCond %{REQUEST_URI} !^/favicon.ico$
      RewriteCond %{REQUEST_URI} !^(/.*)+code.py/
      RewriteRule ^(.*)$ code.py/$1 [PT]
    </IfModule>

Se il file `code.py` è nella sottodirectory `myapp/`, modifica la RewriteBase  rendendola similie a `RewriteBase /myapp/`. Se hai file statici come i file CSS ed immagini da rendere disponibili, duplica la regola per ogni percorso tu voglia rendere disponibile. Per maggiori informazioni circa l'utilizzo delle rewrite rule di apache fai riferimento alle pagini ufficiali del modulo mod_rewrite presente sul sito ufficiale del progetto apache.
---
layout: default
title: インストールガイド
---

# インストールガイド

web.pyをダウンロードします。
    
    http://webpy.org/static/web.py-0.33.tar.gz

ダウンロードファイルを展開し、あなたのアプリケーションがあるディレクトリに展開したフォルダ`webpy`の直下にある `web` フォルダをコピーしてください。
もしくは以下のコマンドを実行し、すべてのアプリケーションからのアクセスを可能にします。
    
    python setup.py install

ノート: Ubuntuなどrootを許可していない unix/linux などでは以下のコマンドで実行する必要があるかもしれません。

    sudo python setup.py install

[推奨セットアップ](/recommended_setup)を参照してください。

[Easy Install](http://peak.telecommunity.com/DevCenter/EasyInstall)を使えばワンステップでインストールすることが可能です。


    easy_install web.py

## 開発

webpy には内蔵のウェブサーバが付属されています。
まず、[チュートリアル](http://webpy.org/tutorial2)にしたがってアプリケーションを学んでください。
チュートリアルで作成したソースコードを`code.py`と名前をつけたファイルに保存してください。以下のコマンドを実行することで、ウェブサーバーが起動します。

     python code.py

ブラウザを起動し、 [http://localhost:8080/](http://localhost:8080/) のページを開いてください。別のポートを指定するには `python code.py 1234` のようにします。

## 本番(公開)稼動

開発時やサンプルプログラムを実行するだけなら内蔵のウェブサーバでかまいませんが、
外部へ公開するには力不足です。本番稼動に向けたWebサーバー構築の方法を示します。

web.py は[WSGI](http://www.python.org/dev/peps/pep-0333/)を実装していますので、互換性のあるもので実行することが可能です。

WSGIとは、ウェブサーバとアプリケーション(JavaのServletインターフェースと非常に似ています)の間で共通のAPIです。
CGI/FastCGI/SCGIを備えたweb.pyを実行するためには、[flup](http://trac.saddi.com/flup)([ここからダウンロード](http://www.saddi.com/software/flup/dist/))をインストールする必要があります。インストールすることで、web.pyにWSGIインターフェースのAPIを提供することができます。

CGI実行を行う場合はファイル`code.py`の先頭に以下を追記してください。

    #!/usr/bin/env python

また、ファイルに実行権限を付加してください。 `chmod +x code.py`

### LightTPD

#### .. with FastCGI

web.pyでは、lighttpd + FastCGI方式が推奨されています。[reddit.com][3] はこの方式で何百万ものアクセスに応答しています。

   [3]: http://reddit.com/

lighttpdの設定は以下のようになります。
    
     server.modules = ("mod_fastcgi", "mod_rewrite")
     server.document-root = "/path/to/root/"     
     fastcgi.server = ( "/code.py" =>     
     (( "socket" => "/tmp/fastcgi.socket",
        "bin-path" => "/path/to/root/code.py",
        "max-procs" => 1
     ))
     )
    
     url.rewrite-once = (
       "^/favicon.ico$" => "/static/favicon.ico",
       "^/static/(.*)$" => "/static/$1",
       "^/(.*)$" => "/code.py/$1"
     )
    
lighttpdのいくつかのバージョンでは、fastcgi.serverの"check-local"の値が"false"に設定しておく必要があります。特に配置したcode.pyがドキュメントルート外に配している場合が特に注意が必要です。

もし、flupがインストールがインストールできない場合は、"easy_install flup" を実行することでインストールすることができるかもしれません。

Since revision 145, it is necessary to set a bin-environment variable on the fastcgi configuration if your code uses redirects.  If when your code redirects to http://domain.com/ and in the url bar you see http://domain.com/code.py/, you'll need to set the environment variable.  This will cause your fastcgi.server configuration above to look something like this:
     
    fastcgi.server = ( "/code.py" =>
    ((
       "socket" => "/tmp/fastcgi.socket",
       "bin-path" => "/path/to/root/code.py",
       "max-procs" => 1,
       "bin-environment" => (
         "REAL_SCRIPT_NAME" => ""
       ),
       "check-local" => "disable"
    ))
    )
    

### Apache

#### .. with CGI

`httpd.conf`もしくは`apache2.conf`に以下を追記してください。

    Alias /foo/static/ /path/to/static
    ScriptAlias /foo/ /path/to/code.py


#### .. with CGI using .htaccess

CGIは以下を`.htaccess`に追記するだけですので構築するのは簡単ですが、高性能なウェブサイトには向いていません。

    Options +ExecCGI
    AddHandler cgi-script .py

and point your browser to `http://example.com/code.py/`. Don't forget the trailing slash, otherwise you'll see a `not found` message (because the `urls` list you defined do not match anything). To make things work without having to enter `code.py`, enable mod_rewrite rules (see below).

Note: The way `web.py` is implemented breaks the `cgitb` module because it captures `stdout`. I worked around the issue by using this:
    
    import cgitb; cgitb.enable()
    import sys
    
    # ... import web etc here...
    
    def cgidebugerror():
        """                                                                         
        """        _wrappedstdout = sys.stdout
    
        sys.stdout = web._oldstdout
        cgitb.handler()
    
        sys.stdout = _wrappedstdout
    
    web.internalerror = cgidebugerror

#### .. with FastCGI

FastCGIを構築するのは簡単で、mod_pythonと同じ動作をします。

`.htaccessに以下を追記してください。`
    
    <Files code.py>      SetHandler fastcgi-script
    </Files>

残念ですが、lighttpdと異なり、apacheでは、明示的にFastCGIであることをweb.pyに教えなければなりません。`code.py`の`if __name__ == "__main__":`の後に以下を追記する必要があります。
    
    web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
    
and point your browser to `http://example.com/code.py/`. Don't forget the trailing slash, otherwise you'll see a `not found` message (because the `urls` list you defined do not match anything). To make things work without having to enter `code.py`, enable mod_rewrite rules (see below).

[Walterからの追加のアドバイスはこちら](http://lemurware.blogspot.com/2006/05/webpy-apache-configuration-and-you.html).


#### .. with SCGI
https://www.mems-exchange.org/software/scgi/
download `mod_scgi` source here: http://www.mems-exchange.org/software/files/mod_scgi/
windows apache user: 
edit your httpd.conf:

    LoadModule scgi_module Modules/mod_scgi.so
    SCGIMount / 127.0.0.1:8080

apacheの再起動とcode.pyを以下のコマンドで起動してください。

    python code.py 127.0.0.1:8080 scgi

起動後、ブラウザで 127.0.0.1を開いて確認してください。

#### .. with mod_python

mod_pythonは、FastCGIと同様に動作しますが、構築するのは簡単ではありません。

Python 2.5を使用している場合:

    cd /usr/lib/python2.5/wsgiref
    # or in windows: cd /python2.5/lib/wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # or fetch the file from that address using your browser

Python 2.5以前のバージョンを使用している場合:

    cd /usr/lib/python2.4/site-packages
    # or in windows: cd /python2.4/lib/site-packages
    svn co svn://svn.eby-sarna.com/svnroot/wsgiref/wsgiref
    cd wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # or fetch the file from that address using your browser  


`code.py`のファイル名を`codep.py`に変更してください。
    
    main = web.wsgifunc(web.webpyfunc(urls, globals()))

.htaccessに以下を追記してください。
    
    
    AddHandler python-program .py
    PythonHandler wsgiref.modpython_gateway::handler
    PythonOption wsgi.application codep::main
    

さらに`RewriteRule`を追加することで、`/` を `/codep.py/` に向けることができます。

`/codep.py/` の末尾 `/`(スラッシュ)を忘れると、`エラー画面(Please contact the administrator.)`が表示されます。

#### .. with mod_wsgi

mod_wsgiは、特色として[mod_pythonより性能](http://code.google.com/p/modwsgi/wiki/PerformanceEstimates)が優れており、構築が非常に簡単な新しいApacheモジュールです。

At the end of your `code.py`, add:

    application = web.wsgifunc(web.webpyfunc(urls, globals()))

mod\_wsgi offers [many possible ways](http://code.google.com/p/modwsgi/wiki/ConfigurationDirectives) to expose a WSGI application in Apache's URL hierarchy, but one simple way would be to add the following to your .htaccess:

    <Files code.py>
        SetHandler wsgi-script
        Options ExecCGI FollowSymLinks
    </Files>

If you get an "ImportError: No module named web" in your apache error.log file, you could try setting the absolute path in code.py before importing web:

    import sys, os
    abspath = os.path.dirname(__file__)
    sys.path.append(abspath)
    os.chdir(abspath)
    import web

Also, you might want to read the "Application Working Directory" section from [Common problems with WSGI applications](http://code.google.com/p/modwsgi/wiki/ApplicationIssues).

It should then be accessible at `http://example.com/code.py/` as usual.

#### mod_rewrite Rules for Apache

If you want webpy to be accessible at 'http://example.com' instead of 'http://example.com/code.py/' add the following rules to the `.htaccess` file:

    <IfModule mod_rewrite.c>      
      RewriteEngine on
      RewriteBase /
      RewriteCond %{REQUEST_URI} !^/icons
      RewriteCond %{REQUEST_URI} !^/favicon.ico$
      RewriteCond %{REQUEST_URI} !^(/.*)+code.py/
      RewriteRule ^(.*)$ code.py/$1 [PT]
    </IfModule>

If the `code.py` is in the subfolder `myapp/`, adjust the RewriteBase to `RewriteBase /myapp/`. If you have static files like CSS files and images to pass through, duplicate the line with the icons for each path you want to allow.
---
layout: default
title: Install guide
---

# Install guide

Other languages : [español](/install.es) | [Japan 日本語 ](/install.ja) | [chinese 简体中文 ](/install.zh-cn) | [italiano](/install.it) | [français](/install.fr) | [Serbo-Croatian](http://science.webhostinggeeks.com/webpy-vodic-za-instalaciju)

## Summary

* <a href="#install">Install</a>
	* <a href="#macosx">.. on MacOS X</a>
* <a href="#dev">Development</a>
* <a href="#prod">Production</a>
	* <a href="#lighttpd">LightTPD</a>
		* <a href="#lighttpdfastcgi">.. with FastCGI</a>
	* <a href="#apache">Apache</a>
		* <a href="#apachecgi">.. with CGI</a>
		* <a href="#apachecgihtaccess"> .. with CGI using .htaccess</a>
		* <a href="#apachefastcgi">.. with FastCGI</a>
		* <a href="#apachescgi">.. with SCGI</a>
		* <a href="#apachemodpython">.. with mod_python</a>
		* <a href="#apachemodwsgi">.. with mod_wsgi</a>
		* <a href="#apachemodrewrite">.. with mod_rewrite</a>


<a name="install"></a>
## Install


To install web.py, download:
    
    http://webpy.org/static/web.py-0.37.tar.gz

or the get the latest dev version:

    https://github.com/webpy/webpy/tarball/master

extract it and copy the _web_ folder into a directory where your application is. Or, to make it accessible to all applications, run:
    
    python setup.py install

Note: on some unix like systems you may need to switch to root or run:

    sudo python setup.py install

see [recommended setup](/recommended_setup).

Another option is to use [Easy Install](http://peak.telecommunity.com/DevCenter/EasyInstall). Once Easy Install is properly setup:


    sudo easy_install web.py
    
Or [PIP](http://packages.python.org/distribute/)

    sudo pip install web.py

<a name="macosx"></a>
### MacOS X

To install web.py on  [mac os x](/install_macosx). Web.py 0.1 only...

<a name="dev"></a>
## Development

web.py comes with a built-in webserver.  Learn how to write an application by following the [tutorial](http://webpy.org/tutorial).  When you have an application written, put your code into `code.py` and start the server like this:

     python code.py

Open your browser and go to [http://localhost:8080/](http://localhost:8080/) to view the page. To specify another port, use `python code.py 1234`.

<a name="prod"></a>
## Production

The web server that gets started when you run a web.py program is nice, but for popular sites you're going to want something a little more serious. web.py implements [WSGI](http://www.python.org/dev/peps/pep-0333/) and runs with everything that is compatible to it. WSGI is a common API between web servers and applications, analogous to Java's Servlet Interface. To run web.py with CGI, FastCGI or SCGI you will need to install [flup](http://trac.saddi.com/flup) ([download here](http://www.saddi.com/software/flup/dist/)), which provides WSGI interfaces for those APIs. 

For all the CGI variants, add this to the top of your `code.py`:

    #!/usr/bin/env python

And run `chmod +x code.py` to make it executable.

<a name="lighttpd"></a>
### LightTPD

<a name="lighttpdfastcgi"></a>
#### .. with FastCGI

FastCGI with lighttpd is the recommended way of using web.py in production. [reddit.com][3] handles millions of hits this way.

   [3]: http://reddit.com/
   
Your lighttpd config can be something like:
    
     server.modules = ("mod_fastcgi", "mod_rewrite")
     server.document-root = "/path/to/root/"     
     fastcgi.server = ( "/code.py" =>     
     (( "socket" => "/tmp/fastcgi.socket",
        "bin-path" => "/path/to/root/code.py",
        "max-procs" => 1
     ))
     )
    
     url.rewrite-once = (
       "^/favicon.ico$" => "/static/favicon.ico",
       "^/static/(.*)$" => "/static/$1",
       "^/(.*)$" => "/code.py/$1"
     )
    
With some versions of lighttpd, it is important to ensure the "check-local" property of the fastcgi.server entry is set to "false", especially if your `code.py` is located outside of the document root.

If you get error messages about not being able to import flup, install it by typing "easy_install flup" at the command line.

Since revision 145, it is necessary to set a bin-environment variable on the fastcgi configuration if your code uses redirects.  If when your code redirects to http://domain.com/ and in the url bar you see http://domain.com/code.py/, you'll need to set the environment variable. This will cause your fastcgi.server configuration above to look something like this:
     
    fastcgi.server = ( "/code.py" =>
    ((
       "socket" => "/tmp/fastcgi.socket",
       "bin-path" => "/path/to/root/code.py",
       "max-procs" => 1,
       "bin-environment" => (
         "REAL_SCRIPT_NAME" => ""
       ),
       "check-local" => "disable"
    ))
    )
    
<a name="apache"></a>
### Apache

<a name="apachecgi"></a>
#### .. with CGI


Add the following to `httpd.conf` or `apache2.conf`.

    Alias /foo/static/ /path/to/static
    ScriptAlias /foo/ /path/to/code.py

<a name="apachecgihtaccess"></a>
#### .. with CGI using .htaccess

CGI is easy to configure, but is not suitable for high-performance websites.
Add this to your `.htaccess`:

    Options +ExecCGI
    AddHandler cgi-script .py

and point your browser to `http://example.com/code.py/`. Don't forget the trailing slash, otherwise you'll see a `not found` message (because the `urls` list you defined do not match anything). To make things work without having to enter `code.py`, enable mod_rewrite rules (see below).

Note: The way `web.py` is implemented breaks the `cgitb` module because it captures `stdout`. I worked around the issue by using this:
    
    import cgitb; cgitb.enable()
    import sys
    
    # ... import web etc here...
    
    def cgidebugerror():
        """
        """        
        _wrappedstdout = sys.stdout
    
        sys.stdout = web._oldstdout
        cgitb.handler()
    
        sys.stdout = _wrappedstdout
    
    web.internalerror = cgidebugerror


<a name="apachefastcgi"></a>
#### .. with FastCGI

FastCGI is easy to configure and performs as well as mod_python.

Add this to your `.htaccess`:
    
    <Files code.py>      
    SetHandler fastcgi-script
    </Files>

Unfortunately, unlike lighttpd, Apache gives no hint that it wants your web.py script to act as a FastCGI server so you have to tell web.py explicitly. Add this to `code.py` before your `if __name__ == "__main__":` line:
    
    web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
    
and point your browser to `http://example.com/code.py/`. Don't forget the trailing slash, otherwise you'll see a `not found` message (because the `urls` list you defined do not match anything). To make things work without having to enter `code.py`, enable mod_rewrite rules (see below).

[Walter has some additional advice](http://lemurware.blogspot.com/2006/05/webpy-apache-configuration-and-you.html).


<a name="apachescgi"></a>
#### .. with SCGI
https://www.mems-exchange.org/software/scgi/
download `mod_scgi` source here: http://www.mems-exchange.org/software/files/mod_scgi/
windows apache user: 
edit your httpd.conf:

    LoadModule scgi_module Modules/mod_scgi.so
    SCGIMount / 127.0.0.1:8080

restart apache and then start your code.py in the command below:

    python code.py 127.0.0.1:8080 scgi

and open you browser,visit 127.0.0.1
It's ok! 


<a name="apachemodpython"></a>
#### .. with mod_python

mod_python performs as well as FastCGI, but is not as straight-forward to configure.

For Python 2.5 do this:

    cd /usr/lib/python2.5/wsgiref
    # or in windows: cd /python2.5/lib/wsgiref
    wget -O modpython_gateway.py http://svn.aminus.net/misc/modpython_gateway.py
    # or fetch the file from that address using your browser

For Python <2.5 do this:

    cd /usr/lib/python2.4/site-packages
    # or in windows: cd /python2.4/lib/site-packages
    svn co svn://svn.eby-sarna.com/svnroot/wsgiref/wsgiref
    cd wsgiref
    wget -O modpython_gateway.py http://svn.aminus.net/misc/modpython_gateway.py
    # or fetch the file from that address using your browser  


Rename your `code.py` to something like `codep.py` and add:
    
    app = web.application(urls, globals())
    main = app.wsgifunc()

In your `.htaccess`, add:
    
    
    AddHandler python-program .py
    PythonHandler wsgiref.modpython_gateway::handler
    PythonOption wsgi.application codep::main
    

You also probably want to add a `RewriteRule` pointing `/` to `/codep.py/`

Be sure to visit `/codep.py/` with the extra `/` on the end. Otherwise, you'll see an error message like `A server error occurred. Please contact the administrator.`

<a name="apachemodwsgi"></a>
#### .. with mod_wsgi

mod\_wsgi is a new Apache module which [typically outperforms mod_python](http://code.google.com/p/modwsgi/wiki/PerformanceEstimates) for hosting WSGI applications, and is very easy to set up. <div style="text-indent:-90000px;">[Watch Live Sports Online](http://www.sportspiks.com)[Watch tv episodes online](http://purehunting.blogspot.com)[Watch movies Online](http://www.overheadmovies.com)[Watch Resident Evil Afterlife (2010) Online](http://www.overheadmovies.com/action/resident-evil-afterlife-2010)</div>

At the end of your `code.py`, add:

    app = web.application(urls, globals(), autoreload=False)
    application = app.wsgifunc()

mod\_wsgi offers [many possible ways](http://code.google.com/p/modwsgi/wiki/ConfigurationDirectives) to expose a WSGI application in Apache's URL hierarchy, but one simple way would be to add the following to your .htaccess:

    <Files code.py>
        SetHandler wsgi-script
        Options ExecCGI FollowSymLinks
    </Files>

If you get an "ImportError: No module named web" in your apache error.log file, you could try setting the absolute path in code.py before importing web:

    import sys, os
    abspath = os.path.dirname(__file__)
    sys.path.append(abspath)
    os.chdir(abspath)
    import web

Also, you might want to read the "Application Working Directory" section from [Common problems with WSGI application](http://code.google.com/p/modwsgi/wiki/ApplicationIssues).

It should then be accessible at `http://example.com/code.py/` as usual.



<a name="apachemodrewrite"></a>
#### mod_rewrite Rules for Apache

If you want web.py to be accessible at 'http://example.com' instead of 'http://example.com/code.py/' add the following rules to the `.htaccess` file:

    <IfModule mod_rewrite.c>      
      RewriteEngine on
      RewriteBase /
      RewriteCond %{REQUEST_URI} !^/icons
      RewriteCond %{REQUEST_URI} !^/favicon.ico$
      RewriteCond %{REQUEST_URI} !^(/.*)+code.py/
      RewriteRule ^(.*)$ code.py/$1 [PT]
    </IfModule>

If the `code.py` is in the subfolder `myapp/`, adjust the RewriteBase to `RewriteBase /myapp/`. If you have static files like CSS files and images to pass through, duplicate the line with the icons for each path you want to allow.

---
layout: default
title: 安装
---

# 安装

## Summary

* <a href="#install">安装</a>
* <a href="#dev">开发</a>
* <a href="#prod">产品</a>
	* <a href="#lighttpd">LightTPD</a>
		* <a href="#lighttpdfastcgi">.. 使用 FastCGI</a>
	* <a href="#apache">Apache</a>
		* <a href="#apachecgi">.. 使用 CGI</a>
		* <a href="#apachecgihtaccess"> .. 使用 CGI using .htaccess</a>
		* <a href="#apachefastcgi">.. 使用 FastCGI</a>
		* <a href="#apachescgi">.. 使用 SCGI</a>
		* <a href="#apachemodpython">.. 使用 mod_python</a>
		* <a href="#apachemodwsgi">.. 使用 mod_wsgi</a>
		* <a href="#apachemodrewrite">.. 使用 mod_rewrite</a>

<a name="install"></a>
## 安装

安装web.py, 请先下载：
    
    http://webpy.org/static/web.py-0.37.tar.gz

或者获取最新的开发版：

    https://github.com/webpy/webpy/tarball/master

解压并拷贝 _web_ 文件夹到你的应用程序目录下。 或者，为了让所有的应用程序都可以使用，运行：
    
    python setup.py install

注意: 在某些类unix系统上你可能需要切换到root用户或者运行：

    sudo python setup.py install

查看 [推荐设置](/recommended_setup).

另外一个选择是使用[Easy Install](http://peak.telecommunity.com/DevCenter/EasyInstall). Easy Install 使用如下：


    easy_install web.py

或者 [PIP](http://packages.python.org/distribute/)

    sudo pip install web.py

<a name="dev"></a>
## 开发

web.py 内置了web服务器。可以按照 [tutorial](http://webpy.org/tutorial2) 学习如何写一个Web应用。 写完后，将你的代码放到 `code.py` 并如下面的方法来启动服务器：

     python code.py

打开你的浏览器输入 [http://localhost:8080/](http://localhost:8080/) 查看页面。 若要制定另外的端口，使用 `python code.py 1234`。

<a name="prod"></a>
## 产品

现在所运行 web.py 程序的web服务器是挺不错的， 但绝大多数网站还是需要更加专业一些的web服务器。web.py 实现了 [WSGI](http://www.python.org/dev/peps/pep-0333/) 并能在任何兼容它的服务器上运行。 WSGI 是一个web服务器与应用程序之间的通用API, 就如Java 的 Servlet 接口。 你需要安装 [flup](http://trac.saddi.com/flup) ([download here](http://www.saddi.com/software/flup/dist/)) 使web.py 支持with CGI， FastCGI 或 SCGI， flup提供了这些API的WSGI接口。

对于所有的CGI变量， 添加以下到你的 `code.py`:

    #!/usr/bin/env python

并运行 `chmod +x code.py` 添加可执行属性。

<a name="lighttpd"></a>
### LightTPD

<a name="lighttpdfastcgi"></a>
#### .. 使用 FastCGI

在产品中通过FastCGI结合lighttpd是web.py使用的一种推荐方法。 [reddit.com][3] 通过该方法来处理百万次的点击。

   [3]: http://reddit.com/

lighttpd config设置参考如下：
    
     server.modules = ("mod_fastcgi", "mod_rewrite")
     server.document-root = "/path/to/root/"     
     fastcgi.server = ( "/code.py" =>     
     (( "socket" => "/tmp/fastcgi.socket",
        "bin-path" => "/path/to/root/code.py",
        "max-procs" => 1
     ))
     )
    
     url.rewrite-once = (
       "^/favicon.ico$" => "/static/favicon.ico",
       "^/static/(.*)$" => "/static/$1",
       "^/(.*)$" => "/code.py/$1"
     )
    
在某些版本的lighttpd中， 需要保证fastcgi.server选项下的"check-local"属性设置为"false", 特别是当你的 `code.py` 不在文档根目录下。

如果你得到错误显示不能够导入flup， 请在命令行下输入 "easy_install flup" 来安装。

从修订版本 145开始， 如果你的代码使用了重定向，还需要在fastcgi选项下设置bin-environment变量。 如果你的代码重定向到http://domain.com/ 而在url栏中你会看到 http://domain.com/code.py/， 你可以通过设置这个环境变量来阻止。 这样你的fastcgi.server设置将会如下：
     
    fastcgi.server = ( "/code.py" =>
    ((
       "socket" => "/tmp/fastcgi.socket",
       "bin-path" => "/path/to/root/code.py",
       "max-procs" => 1,
       "bin-environment" => (
         "REAL_SCRIPT_NAME" => ""
       ),
       "check-local" => "disable"
    ))
    )
    

<a name="apache"></a>
### Apache

<a name="apachecgi"></a>
#### .. 使用 CGI


添加以下到 `httpd.conf` 或 `apache2.conf`。

    Alias /foo/static/ /path/to/static
    ScriptAlias /foo/ /path/to/code.py


<a name="apachecgihtaccess"></a>
#### .. 使用 CGI .htaccess

CGI很容易配置， 但不适合高性能网站。
添加以下到你的 `.htaccess`：

    Options +ExecCGI
    AddHandler cgi-script .py

将你的浏览器指向 `http://example.com/code.py/`。 不要忘记最后的斜杠，否则你将会看到 `not found` 消息 (因为在 `urls` 列表中你输入的没有被匹配到). 为了让其运行的时候不需要添加 `code.py`， 启用mod_rewrite 法则 (查看如下)。

注意: `web.py` 的实现破坏了 `cgitb` 模块，因为它截取了 `stdout`。 可以通过以下的方法来解决该问题：
    
    import cgitb; cgitb.enable()
    import sys
    
    # ... import web etc here...
    
    def cgidebugerror():
        """                                                                         
        """        _wrappedstdout = sys.stdout
    
        sys.stdout = web._oldstdout
        cgitb.handler()
    
        sys.stdout = _wrappedstdout
    
    web.internalerror = cgidebugerror

<a name="apachefastcgi"></a>
#### .. 使用 FastCGI

FastCGI很容易配置，运行方式如同mod_python。

添加以下到 `.htaccess`：
    
    <Files code.py>      SetHandler fastcgi-script
    </Files>

不幸的是, 不像lighttpd, Apache不能够暗示你的web.py脚本以FastCGI 服务器的形式工作，因此你需要明确的告诉web.py。 添加以下到 `code.py`的  `if __name__ == "__main__":` 行前：
    
    web.wsgi.runwsgi = lambda func, addr=None: web.wsgi.runfcgi(func, addr)
    
将你的浏览器指向 `http://example.com/code.py/`。 不要忘记最后的斜杠，否则你将会看到 `not found` 消息 (因为在 `urls` 列表中你输入的没有被匹配到). 为了让其运行的时候不需要添加 `code.py`， 启用mod_rewrite 法则 (查看如下)。

[Walter 还有一些额外建议](http://lemurware.blogspot.com/2006/05/webpy-apache-configuration-and-you.html).

<a name="apachescgi"></a>
#### .. 使用 SCGI
https://www.mems-exchange.org/software/scgi/
从 http://www.mems-exchange.org/software/files/mod_scgi/ 下载 `mod_scgi` 代码
windows apache 用户： 
编辑 httpd.conf：

    LoadModule scgi_module Modules/mod_scgi.so
    SCGIMount / 127.0.0.1:8080

重启apache，并在命令行中如下方式启动code.py：

    python code.py 127.0.0.1:8080 scgi

打开你的浏览器，访问127.0.0.1
It's ok! 

<a name="apachemodpython"></a>
#### .. 使用 mod_python

mod_python 运行方式如同FastCGI， 但不是那么方便配置。

对于 Python 2.5 按照如下：

    cd /usr/lib/python2.5/wsgiref
    # or in windows: cd /python2.5/lib/wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # or fetch the file from that address using your browser

对于 Python <2.5 按照如下：

    cd /usr/lib/python2.4/site-packages
    # or in windows: cd /python2.4/lib/site-packages
    svn co svn://svn.eby-sarna.com/svnroot/wsgiref/wsgiref
    cd wsgiref
    wget -O modpython_gateway.py http://projects.amor.org/misc/browser/modpython_gateway.py?format=raw
    # or fetch the file from that address using your browser  


重命名 `code.py` 为 `codep.py` 或别的名字， 添加：
    
    app = web.application(urls, globals())
    main = app.wsgifunc()

在 `.htaccess` 中， 添加：
    
    
    AddHandler python-program .py
    PythonHandler wsgiref.modpython_gateway::handler
    PythonOption wsgi.application codep::main
    

你应该希望添加  `RewriteRule` 将 `/` 指向 `/codep.py/`

确保访问 `/codep.py/` 的时候有添加最后的 `/`。  否则，你将会看到一条错误信息，比如 `A server error occurred. Please contact the administrator.`

<a name="apachemodwsgi"></a>
#### .. 使用 mod_wsgi

mod\_wsgi 是一个新的Apache模块 [通常优于mod_python](http://code.google.com/p/modwsgi/wiki/PerformanceEstimates) 用于架设WSGI应用，它非常容易配置。

在 `code.py` 的最后添加：

    app = web.application(urls, globals(), autoreload=False)
    application = app.wsgifunc()

mod\_wsgi 提供 [许多可行方法](http://code.google.com/p/modwsgi/wiki/ConfigurationDirectives) 来实现WSGI应用, 但一种简单的方法是添加以下到 .htaccess：

    <Files code.py>
        SetHandler wsgi-script
        Options ExecCGI FollowSymLinks
    </Files>

如果在apache的 error.log 文件中出现 "ImportError: No module named web"， 在导入web之前，你可能需要在code.py中尝试设置绝对路径：

    import sys, os
    abspath = os.path.dirname(__file__)
    sys.path.append(abspath)
    os.chdir(abspath)
    import web

同时， 你可能需要查看 [WSGI应用的常见问题](http://code.google.com/p/modwsgi/wiki/ApplicationIssues)的 "Application Working Directory" 部分。

最终应该可以访问 `http://example.com/code.py/`。

<a name="apachemodrewrite"></a>
#### mod_rewrite 法则，Apache

如果希望 web.py 能够通过 'http://example.com' 访问，代替使用 'http://example.com/code.py/'， 添加以下法则到 `.htaccess` 文件：

    <IfModule mod_rewrite.c>      
      RewriteEngine on
      RewriteBase /
      RewriteCond %{REQUEST_URI} !^/icons
      RewriteCond %{REQUEST_URI} !^/favicon.ico$
      RewriteCond %{REQUEST_URI} !^(/.*)+code.py/
      RewriteRule ^(.*)$ code.py/$1 [PT]
    </IfModule>

如果 `code.py` 在子目录 `myapp/`中， 调整 RewriteBase 为 `RewriteBase /myapp/`。 如果还有一些静态文件如CSS文件和图片文件, 复制这些并改成你需要的地址。

---
layout: default
title: Installation
---

# Installation

`web.py` supports Python 2.4 – 2.6 and has no immediate prerequisites.

1.  [Stable Version](#stable)
    1.  [From Source](#source)
        1.  [System-wide](#system)
        1.  [Local](#local)
    1.  [Via Distribution](#distribution)
        1.  [Debian-based](#debian)
        1.  [Red Hat-based](#red-hat)
1.  [Development Version](#development)
1.  [Verify Install](#verify)

<h2 id=stable>Stable Version</h2>

The easiest way to install `web.py` is using
<code>[easy_install](http://peak.telecommunity.com/DevCenter/EasyInstall)</code>.  
<em><small><strong>Note</strong> that you will install the version specified in the [Python Package Index](http://pypi.python.org/pypi/web.py).</small></em>

<pre><code><kbd>easy_install web.py</kbd>
<kbd></kbd></code></pre>

<h3 id=source>From Source</h3>

<pre><code><kbd>wget http://webpy.org/static/web.py-0.33.tar.gz</kbd>
<kbd>tar xvzf web.py-0.33.tar.gz</kbd>
<kbd></kbd></code></pre>

<h4 id=system>System-wide</h4>

<pre><code><kbd>cd web.py-0.33</kbd>
<kbd>sudo python setup.py install</kbd>
<kbd></kbd></code></pre>

<h4 id=local>Local</h4>

If you need to bundle `web.py` with your application extract the source to a `vendor` folder and create a symlink, normally within your package's root.

<pre><code><kbd>ln -s vendor/web.py-0.33/web web</kbd>
<kbd></kbd></code></pre>

<h3 id=distribution>Via GNU/Linux Distribution</h3>

<h4 id=debian>Debian <small>or Ubuntu</small></h4>

If you are on a Debian-based system you can install `web.py` using `apt-get`.  
<em><small><strong>Note</strong> that you may not get the latest version as the Ubuntu/Debian release cycles are different from `web.py`. See <a href=http://packages.debian.org/search?searchon=names&keywords=python-webpy>Debian</a> and <a href=https://launchpad.net/ubuntu/+source/webpy>Ubuntu</a> package profiles for more information.</small></em>

<pre><code><kbd>sudo apt-get install python-webpy</kbd>
<kbd></kbd></code></pre>

<h4 id=red-hat>Red Hat <small>or Fedora, RHEL, CentOS</small></h4>

If you are on a Red Hat-based system you can install `web.py` using `yum` or `up2date`.  
<em><small><strong>Note</strong> that CentOS requires the [<abbr title="Extra Packages for Enterprise Linux">EPEL</abbr>](https://fedoraproject.org/wiki/EPEL) repository.</small></em>

<pre><code><kbd class=su>yum install python-webpy</kbd>
<kbd class=su></kbd></code></pre>
<pre><code><kbd class=su>up2date -i python-webpy</kbd>
<kbd class=su></kbd></code></pre>

<h2 id=development>Development Branch</h2>

To follow the bleeding edge clone the master branch.

<pre><code><kbd>git clone git://github.com/webpy/webpy.git</kbd>
<kbd></kbd></code></pre>

<h2 id=verify>Verify Install</h2>

<pre><code><kbd>python -c "import web; web.application(('/', lambda: 'success')).run()"</kbd>
<samp>http://0.0.0.0:8080/</samp></code></pre>

Point a browser to your host at port `8080` and expect a response of `success`.
---
layout: default
title: install macos x
---

# install macos x

Install Webpy 0.1 via darwinports.  

Adapted from [macdevlog](http://macdevlog.com/webpy01-install.html)

0. Install [macports](http://macports.org/downloads/DarwinPorts-1.3.1-10.4.dmg).

1. update macports.
    
        sudo port selfupdate

2. Get python.  
    
        sudo port install python24

3. Install postgreSQL

        sudo port install postgresql81

4. Get web.py
    
        curl -O "http://webpy.org/web.py"
5. Install Cheetah 

        curl -O "http://jaist.dl.sourceforge.net/sourceforge/cheetahtemplate/Cheetah-1.0.tar.gz"        gunzip Cheetah-1.0.tar.gz
        tar -xvf Cheetah-1.0.tar
        rm Cheetah-1.0.tar
        cd Cheetah-1.0
        sudo python ./setup.py install
        cd ..
        sudo rm -Rf Cheetah-1.0

6. Install pyscopg

    The version in darwinports is the older 1.x code branch.  Since we've installed Postgres in to a non-standard location, we have to nugde the setup.cfg file just a little bit.

        curl -O "http://initd.org/pub/software/psycopg/psycopg2-latest.tar.gz"        tar -xzvf psycopg2-latest.tar.gz
        rm psycopg2-latest.tar.gz
        cd psycopg2-2.0.4
        echo library_dirs=/opt/local/lib/postgresql81 >> setup.cfg
        echo include_dirs=/opt/local/include/postgresql81 >> setup.cfg
        sudo python setup.py install
        cd ..
        sudo rm -Rf psycopg2-2.0.4
    
8. Download [pgadmin](http://www.pgadmin.org/download/macosx.php) (optional)

9. Setup postgresql

    To create a postgre user and group, we are going to use netinfo.  According to reports, Mas OS X 10.5 Leopard will be stripped of netinfo.  These commands are likely to be Tiger only.
    
    First, find an unused userID and groupID.  typically anything in the 200s or 300s will be unused on most Mac OS X non-server systems.  Let's assumes uid 206 and gid 207
    If you need to check which uid and gid are in use, the following netinfo commands can be used:
    
        nireport / /users name uid
        nireport / /groups name gid
    
    Make the users and groups:
    
        sudo niutil -create / /groups/postgres
        sudo niutil -createprop / /groups/postgres gid 207
        sudo niutil -create / /users/postgres
        sudo niutil -createprop / /users/postgres uid 206
        sudo niutil -createprop / /users/postgres gid 207
        sudo niutil -destroyprop / /users/postgres passwd changeme
    
    Now, we need a data store.  We can use the Users/Shared directory for this.
    
        mkdir /Users/Shared/PostgreSQL
        sudo mkdir /Users/Shared/PostgreSQL/data
        sudo chown postgres /Users/Shared/PostgreSQL/data
        sudo chgrp postgres /Users/Shared/PostgreSQL/data
        sudo -u postgres /opt/local/lib/postgresql81/bin/initdb -D /Users/Shared/PostgreSQL/data
    
    The initdb comnmand will take a moment, but output the status and notify you of success at the end.
        
10. Starting and stopping postgreSQL
    
    The -b will launch the process in the backgroud.
    
        sudo -b -u postgres /opt/local/lib/postgresql81/bin/postmaster -D /Users/Shared/PostgreSQL/data >/Users/Shared/PostgreSQL/logfile 2>&1
    
    This is how you stop a postgres process.
    
        sudo -u postgres /opt/local/lib/postgresql81/bin/pg_ctl -D /Users/Shared/PostgreSQL/data stop

11. Preparing PostgreSQL

    Create a user and a test db.  Our user is called webpy and the name of the database is webpydb.  
    
        sudo -u postgres /opt/local/lib/postgresql81/bin/createuser --no-superuser --createdb --no-createrole webpy
        sudo -u postgres /opt/local/lib/postgresql81/bin/createdb  --username=webpy webpydb
        sudo -u postgres /opt/local/lib/postgresql81/bin/createlang  plpgsql webpydb
        sudo -u postgres /opt/local/lib/postgresql81/bin/psql -c "create group webpydb"        sudo -u postgres /opt/local/lib/postgresql81/bin/psql -c "alter group webpydb add user webpy"        
    
    If these commands are successful, you should see 'CREATE ROLE', 'CREATE DATABASE', 'CREATE LANGUAGE', 'CREATE ROLE', and 'ALTER ROLE' printed out for the respective commands.  
        
12. Hardening PostgreSQL

    During most of these steps, we shell into root.  Be careful or your could break something.

        cd /Users/Shared/PostgreSQL/
        sudo sh
        cd data

    Backup the pg_hba.conf file and then remove the 1 line that starts with local and the 2 lines that start with host.  These default values are way to insecure.
    
        mv pg_hba.conf pg_hba.conf.bak
        sed -e '/^local/ d' -e '/^host / d' pg_hba.conf.bak > pg_hba.conf
    
    Make the conf file secure.  These are based off of the [Apple recommended settings](http://developer.apple.com/internet/opensource/postgres.html).  Feel free to customize if you know what you are doing.
    
        echo 'local   all         all                               md5' >> pg_hba.conf
        echo 'host    all         postgres    127.0.0.1/32          md5' >> pg_hba.conf
        echo 'host    samegroup   all         127.0.0.1/32          md5' >> pg_hba.conf
        echo 'host    all         postgres    ::1/128               md5' >> pg_hba.conf
        echo 'host    samegroup   all         ::1/128               md5' >> pg_hba.conf
        chown postgres pg_hba.conf
        exit
    
    Done with root.  All that remains is to assign passwords to the username.  Have you have ever had that dream where you go to school or work but have forgotten your pants?.  Skipping this step is kind of like that part of the dream where the cute girl is laughing and pointing at your open port.  Make sure the command outputs 'ALTER ROLE' to verify success.

        sudo -u postgres /opt/local/lib/postgresql81/bin/psql -c "alter user postgres with password 'changeme1'"        sudo -u postgres /opt/local/lib/postgresql81/bin/psql -c "alter user webpy with password 'changeme2'"            
    Time to reload and restart pgSQL

        sudo -u postgres /opt/local/lib/postgresql81/bin/pg_ctl -D /Users/Shared/PostgreSQL/data reload

---
            
You can follow the [webpy tutorial](http://webpy.org/tutorial) as long as you make the following change:    
    
    web.db_parameters = dict(dbn='postgres', user='webpy', pw='changeme2', db='webpydb')

Also, you can use the following command to send database SELECT and INSERT querys:

    /opt/local/lib/postgresql81/bin/psql webpy webpy SOME_QUERY

These folowing  two items are for production deployment.  You won't not need them if you are just taking a quick look at web.py.  If you do want to play with around with a simple server setup, the following commands will get you started.

    sudo port install lighttpd
    curl -O http://www.saddi.com/software/flup/dist/flup-r2028.tar.gz
        
    
References:

* [PostgreSQL 8.1.4 Documentation](http://www.postgresql.org/docs/8.1/interactive/)
* [PostgreSQL on Mac OS X](http://developer.apple.com/internet/opensource/postgres.html)
* [PostgreSQL for Mac OS X](http://www.macdevcenter.com/pub/a/mac/2002/06/07/postgresql.html?page=1)



[macports]: http://macports.org/
---
layout: default
title: 
---

I'm using web.py on a kimsufi host. The main advantage is the price and the flat rate for the bandwidth. The less is the memory available (256mb) but lighttpd works really well with web.py.


* http://www.kimsufi.com/
---
layout: default
title: MetaClassAutoURLS
---

# MetaClassAutoURLS

web.py maps URLs regexes to classes via a list like so:

    class Default(object):
        ''' Action for / '''        def GET(self):
            pass

    class Login(object):
        ''' Action for /login '''        def GET(self):
            pass

        def POST(self):
            pass

    urls = ["/", "Default", "/login", "Login"]

One of the disadvantages of this approach is that for large applications, the urls list can get very long and tedious to maintain.  Things get worse during long refactorings/reorgnanizations because it's easy to typo a class or module name or just forget to update the urls list.  After spending a couple hours debugging just this problem and then smacking myself on the forehead for missing such a simple mistake, I thought to myself, _There's got to be a way to automate this!_  After some research, I found that metaclasses can do exactly what I want:

    urls = [ ]

    class ActionMetaClass(type):
        def __init__(klass, name, bases, attrs):
            urls.append(attrs["url"])
            urls.append("%s.%s" % (klass.__module__, name))

    class Default(object):
        __metaclass__ = ActionMetaClass
        url = "/"
        def GET(self):
            pass

    class Login(object):
        __metaclass__ = ActionMetaClass
        url = "/login"
        def GET(self):
            pass

        def POST(self):
            pass

Of course, this is a simple example that leaves a lot to be desired (handling attrs lacking a url key, for instance), but it should get you on your way.

* * *

**AaronSw writes:** That's a clever idea. One improvement might be to have the classes inherit from a class with the metaclass set, so you don't have that unsightly `__metaclass__` every time.

**xunil writes:** Yeah, I went w/ this approach in the end since I found that I wanted each action class to inherit some common functionality anyway.  You can [view the source](http://www.theanykey.com/svn/) for [my incomplete site](http://dev.theanykey.com) which uses a metaclass and decorators.

* * *

May be it's better to do it with decorators?

**xunil writes:** I originally tried to use decorators to do this since I was already familiar w/ them, but unless I'm missing something, decorators don't work on classes eg.

    @action("/")
    class Default:
        def GET(self):
            pass

That won't work.  [The PEP for decorators](http://www.python.org/dev/peps/pep-0318/) describes it, but apparently it was never incorporated into the language (perhaps b/c metaclasses are available and do the same thing).

* * *

I couldn't figure out how to get this to work with URL classes in separate files, so I did something a little different, based on [this Python Cookbook recipe](http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/436873):

    import os, web
    
    urls = [ ]
    
    for aaa in os.listdir(os.getcwd()):
        module_name, ext = os.path.splitext(aaa)
        if module_name.startswith('cgi_') and ext == '.py':
            module = __import__(module_name)
            urls.append(module.url[0])
            urls.append(module_name + "." + module.url[1])
    
    if __name__ == "__main__":
        web.run(urls)

And then e.g. cgi_hello.py (in the same directory) would be:

    import web
    url = ('/(.*)', 'hello')
    
    class hello:
        def GET(self, name):
            i = web.input(times=1)
            if not name: name = 'world'            for c in xrange(int(i.times)): print 'Hello,', name+'!'
Is this a terrible way to do it?

* * *

**xunil writes:** This is not altogether a bad idea, but it again decouples the URL information from the class, making it a module-level tuple or list.  You could combine your importing logic w/ my metaclass idea, actually, and achieve the same thing as me eg.

    import os, web
    
    for aaa in os.listdir(os.getcwd()):
        module_name, ext = os.path.splitext(aaa)
        if module_name.startswith('cgi_') and ext == '.py':
            module = __import__(module_name)
    
    if __name__ == "__main__":
        import metaclass
        web.run(metaclass.urls)

metaclass.py:

    urls = [ ]

    class ActionMetaClass(type):
        def __init__(klass, name, bases, attrs):
            urls.append(attrs["url"])
            urls.append("%s.%s" % (klass.__module__, name))

cgi_hello.py:

    import web
    from metaclass import ActionMetaClass
    
    class hello:
        __metaclass__ = ActionMetaClass
        url = '/(.*)'
        def GET(self, name):
            i = web.input(times=1)
            if not name: name = 'world'            for c in xrange(int(i.times)): print 'Hello,', name+'!'
* * *
---
layout: default
title: Minimalism
---

# Minimalism

A minimalist site template for webpy.org.
---
layout: default
title: Django style multiple apps with web.py
---

# Django style multiple apps with web.py

Here is a hack to support decoupling urls for multiple applications using web.py


suppose we have two applications `blog` and `wiki` and we want to put them in same project.

This is the main driver.

    """run.py"""    import blog
    import wiki
    import delegate

    mapping = (
        ("/blog", blog.urls, blog),
        ("/wiki", wiki.urls, wiki)
    )

    if __name__ == "__main__":
        delegate.run(mapping)


The wiki application:

    """wiki.py"""
    urls = (
        "/", "welcome",
        "/hello", "hello"    )

    class welcome:
        def GET(self):
            print "welcome wiki"
    class hello:
        def GET(self):
            print "hello wiki"
The blog application:

    """blog.py"""
    urls = (
        "/", "welcome",
        "/hello", "hello"    )

    class welcome:
        def GET(self):
            print "welcome blog"
    class hello:
        def GET(self):
            print "hello blog"        

And this is the hack for supporting multiple application abstration.


    """delegate.py"""    import web
    import types

    def delegate_apps(mapping):
        """Delegates appropriate app based on prefix.
        `mapping` should be tuple of (prefix, urls, fvars).
        """        def f():
            for prefix, urls, fvars in mapping:
                if type(fvars) == types.ModuleType:
                    fvars = fvars.__dict__

                if web.ctx.path.startswith(prefix):
                    path = web.ctx.path[len(prefix):]

                    # it will be better if web.request.handle takes path also as argument.
                    # return web.request.handle(mapping, fvars, path)
                    
                    web.ctx.path = path
                    return web.request.handle(urls, fvars)
            else:
                return web.notfound()

        return f

    def run(mapping):
        """Starts web.py server with the specified mapping.
        `mapping` should be tuple of (prefix, urls, fvars).
        """        handler = delegate_apps(mapping)
        web.run(handler, {})

---
layout: default
title: Page List
---

# Page List

{{PageList()}}
---
layout: default
title: Philosophy
---

# The web.py Philosophy

The web.py slogan is: "Think about the ideal way to write a web app. Write the code to make it happen."

This is literally how I developed web.py. I wrote a web application in Python just imagining how I wanted the API to be. It started with <code>import web</code>, of course, and then had a place to define URLs, simple functions for GET and POST, a thing to deal with input variables and so on. Once the code looked right to me, I did whatever it took to make it execute _without changing the application code_ -- the result was web.py.

In response to someone complaining about web.py having "yet another template language", [I wrote a bit more about my philosophy](http://groups.google.com/group/webpy/msg/f266701d97e7ceb1):

> You don't have to use it -- each part of web.py is completely separate 
> from the others. But you're right, it is "yet another template 
> language". And I'm not going to apologize for it. 
> 
> The goal of web.py is to build the ideal way to make web apps. If 
> reinventing old things with only small differences were necessary to 
> achieve this goal, I would defend reinventing them. The difference 
> between the ideal way and the almost-ideal way is, as Mark Twain 
> suggested, the difference between the lightning and the lightning bug. 
> 
> But these aren't just small differences. Instead of exposing Python 
> objects, web.py allows you to build HTTP responses. Instead of trying 
> to make the database look like an object, web.py makes the database 
> easier to use. And instead of coming up with yet another way to write 
> HTML, the web.py template system tries to bring Python into HTML. Not 
> many other people are really trying to do that. 
> 
> You can disagree that these ways are better and say why. But simply 
> criticizing them for being different is a waste of time. Yes, they are 
> different. That's the whole point.

---
layout: default
title: quick vhosting hack
---

# quick vhosting hack

Here is a 10 minute hack with lots of room for improvement but I think its
pretty useful. I made this to allow the serving of multiple
sites from a single webpy app.

I created this because I would like to run a few small sites but my cheap
account at my hosting provider:

 * Only allows 40MB to be used by persistent processes. 
 * Only allows *one* persistent process.
 * Multiple instances of webpy would require multiple ports to be proxied with apache's mod_proxy
   and this configuration can only be done by the server admin.

So, I just made a quick decorator for `web.handler`.

###Stuff to Note:

This expects to be working behind a proxy but that can easily be corrected.

More work could be done on `web.render` and the page class names so
the code you create for sites in this setup can be more easily made into
standalone sites later on.

The /static directory is currently still shared between all sites.


###The Code

     #
     ## URL MAPPING
     #
     urls_1 = (
         '/','index_1',
     )
     
     urls_2 =(
         '/','index_2',
     )
     
     urls_3=(
         '/','index_3',
     )

     #vhost mapping: {domain:url_mapping}

     vhosts={'test.org':urls_1,
             'www.test.org':urls_2,
             'another-url.org':urls_3
             }

     #
     ## VHOSTING DECORATOR
     #
     def vhostrr(vhosts=vhosts):
         def decorator(func): 
             def proxyfunc(*args, **kw):
                 if 'HTTP_X_FORWARDED_HOST' in web.ctx.environ:
                     rd=web.ctx.environ['HTTP_X_FORWARDED_HOST']
                     mapping=None
                     for d in vhosts.keys():
                         if d==rd:
                             mapping=vhosts[d]
                     if mapping==None:
                         print 'Error, Not configured for vhost: '+rd
                         return
                 else:
                     print 'Direct access not allowed. Use proxy.'
                     return
                 return func(mapping=mapping, *args, **kw)
             return proxyfunc
         return decorator
          
     ########################################################################
     # Site 1:
     ########################################################################
     class index_1:
         def GET(self):
             web.render('../templates_1/main.html')
     
     ########################################################################
     # Site 2:
     ########################################################################
     class index_2:
         def GET(self):
             web.render('../templates_2/main.html')
     
     ########################################################################
     # Site 3:
     ########################################################################
     class index_3:
         def GET(self):
             web.render('../templates_3/main.html')

     #
     ## RUN APPLICATION
     #
     
     if __name__ == "__main__":
     
         import sys
         sys.argv.append('2345') #Set the port I want. A better way to do this?
         
         #instead of:
         #web.run(urls, web.reloader, session_mw)
         
         #apply the vhostrr "decorator" remotely
         web.run(vhostrr()(web.handle), web.reloader)

---
layout: default
title: Recent Changes
---

# Recent Changes


{{RecentChanges()}}
---
layout: default
title: Configuration recommandée
---

# Configuration recommandée

Autre langages : [english](/recommended_setup) | ...

### Sommaire

* <a href="#webserver">Serveurs web</a>
* <a href="#database">Bases de données</a>
* <a href="#pool">Pool de connexions</a>
* <a href="#template">Modèles, gabarits</a>
* <a href="#userinput">Entrées utilisateurs</a>


Web.py recommande les logiciels suivants pour les serveurs de production:

<a name="webserver"></a>
##Serveurs web:

Webpy dispose d'un serveur web interne, mais il devrait être utilisé pour le développement seulement. Pour le déploiement, un serveur plus robuste est recommandé, comme l'un de ceux-ci:

*  [lighttpd](http://www.lighttpd.net/download/) [BSD] [(doc)](http://trac.lighttpd.net/trac/wiki/#ReferenceDocumentation) via [flup's fastcgi](http://trac.saddi.com/flup) [BSD] ('easy_install flup')
*  [Apache](http://www.apache.org/) [Apache] via [(mod_wsgi)](http://code.google.com/p/modwsgi/) [Apache]

<a name="database"></a>
##Bases de données:

Webpy ne nécessite pas de base de données pour fonctionner. Il supporte néanmoins les bases suivantes:


*  [postgresql](http://www.postgresql.org/download/) [BSD] [(doc)](http://www.postgresql.org/docs/) avec [psycopg2](http://initd.org/pub/software/psycopg/) [BSD] [(doc)](http://www.initd.org/tracker/psycopg/wiki/PsycopgTwo) comme client python. ('easy_install psycopg2')
*  [mysql](http://dev.mysql.com/downloads/mysql/5.0.html) [GPL] [(doc)](http://www.mysql.org/doc/) avec [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) [CNRI] [(doc)](http://mysql-python.sourceforge.net/MySQLdb.html) comme client python ('easy_install MySQL-python')
*  [sqlite](http://www.sqlite.org/) [Public domain] [(doc)](http://www.sqlite.org/docs.html) avec [pysqlite](http://code.google.com/p/pysqlite/) comme client python ('easy_install pysqlite').

<a name="pool"></a>
##Pool de connexions:

Pour les sites à haut traffic, le pool de connexion autorise Webpy à conserver de multiples connexions aux bases de données ouvertes, afin d'accélérer l'accès aux bases. Cette option est facultative, mais disponible comme échelon tactique.

*  [DBUtils](http://www.w4py.org/downloads/DBUtils/) [CNRI] [(doc)](http://www.webwareforpython.org/DBUtils/Docs/UsersGuide.html) ('easy_install DBUtils')

<a name="template"></a>
##Modèles, gabarits:

Webpy possède son propre système de gabarit qui permet aux utilisateurs d'autoriser l'écriture de gabarits aux utilisateurs moins épprouvés, et d'utiliser une syntaxe proche de celle du python dans les templates.

*  template.py [built-in] [(doc)](/docs/0.3/templetor.fr)

<a name="userinput"></a>
##Entrées utilisateurs:

Markdown permet aux utilisateurs de Webpy d'écrire du texte qui est convertit en HTML dans la page. Ce n'est pas indispensable, mais c'est la meilleure façon de générer du HTML à partir des entrées utilisateur.

*  [python-markdown](http://sourceforge.net/project/showfiles.php?group_id=153041) [BSD] [(doc)](http://www.freewisdom.org/projects/python-markdown/)
---
layout: default
title: 推奨環境
---

# 推奨環境

web.pyは以下のソフトウェアを推奨しています。:

##ウェブサーバー:
*  [lighttpd](http://www.lighttpd.net/download/) [BSD] [(doc)](http://trac.lighttpd.net/trac/wiki/#ReferenceDocumentation)

##データベース:
*  [postgresql](http://www.postgresql.org/download/) [BSD] [(doc)](http://www.postgresql.org/docs/) with [psycopg2](http://initd.org/pub/software/psycopg/) [BSD] [(doc)](http://www.initd.org/tracker/psycopg/wiki/PsycopgTwo) as the python client. (`easy_install psycopg2`)
  
*  [mysql](http://dev.mysql.com/downloads/mysql/5.0.html) [GPL] [(doc)](http://www.mysql.org/doc/) with [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) [CNRI] [(doc)](http://sourceforge.net/docman/?group_id=22307) as the python client (`easy_install MySQL-python`)

##CGI/FastCGI/SCGI:
*  [flup](http://trac.saddi.com/flup) [BSD] (`easy_install flup`)

##コネクションプール:
*  [DBUtils](http://www.w4py.org/downloads/DBUtils/) [CNRI] [(doc)](http://www.webwareforpython.org/DBUtils/Docs/UsersGuide.html) (`easy_install DBUtils`)

##テンプレートエンジン:
*  template.py [built-in] [(doc)](templetor)
*  [Cheetah](http://dl.sourceforge.net/cheetahtemplate/Cheetah-1.0.tar.gz) 1.0 [BSD] [(doc)](http://www.cheetahtemplate.org/learn.html)
##User Input:
*  [python-markdown](http://sourceforge.net/project/showfiles.php?group_id=153041) [BSD] [(doc)](http://www.freewisdom.org/projects/python-markdown/)
---
layout: default
title: Recommended Setup
---

# Recommended Setup

Other languages : [français](/recommended_setup/fr) | ...

### Summary

* <a href="#webserver">Web Server</a>
* <a href="#database">Databases</a>
* <a href="#pool">Connection Pooling</a>
* <a href="#template">Templates</a>
* <a href="#userinput">User Input</a>

web.py recommends the following software for production servers:

<a name="webserver"></a>
##Web Server:

Webpy has an internal web server, but it should be used for development only. For deployment, a more robust server should be used, such as one of these:

*  [lighttpd](http://www.lighttpd.net/download/) [BSD] [(doc)](http://trac.lighttpd.net/trac/wiki/#ReferenceDocumentation) through [flup's fastcgi](http://trac.saddi.com/flup) [BSD] (`easy_install flup`)
*  [Apache](http://www.apache.org/) [Apache] through [(mod_wsgi)](http://code.google.com/p/modwsgi/) [Apache]

<a name="database"></a>
##Databases:

Webpy does not require a database to run. It does, however, support using the following databases:

*  [postgresql](http://www.postgresql.org/download/) [BSD] [(doc)](http://www.postgresql.org/docs/) with [psycopg2](http://initd.org/pub/software/psycopg/) [BSD] [(doc)](http://www.initd.org/tracker/psycopg/wiki/PsycopgTwo) as the python client. (`easy_install psycopg2`)
*  [mysql](http://dev.mysql.com/downloads/mysql/5.0.html) [GPL] [(doc)](http://www.mysql.org/doc/) with [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) [CNRI] [(doc)](http://mysql-python.sourceforge.net/MySQLdb.html) as the python client (`easy_install MySQL-python`)
*  [sqlite](http://www.sqlite.org/) [Public domain] [(doc)](http://www.sqlite.org/docs.html) with [pysqlite](http://code.google.com/p/pysqlite/) as python client (`easy_install pysqlite`).

<a name="pool"></a>
##Connection Pooling:

For high traffic sites, connection pooling allows Webpy to keep multiple database connections open, typically allowing faster access from the database. This is optional, but available as a scaling tactic.

*  [DBUtils](http://www.w4py.org/downloads/DBUtils/) [CNRI] [(doc)](http://www.webwareforpython.org/DBUtils/Docs/UsersGuide.html) (`easy_install DBUtils`)

<a name="template"></a>
##Templates:

Webpy has its own template system which allows users to let untrusted users write templates using this, and use python-like syntax within templates.

*  template.py [built-in] [(doc)](/docs/0.3/templetor)

<a name="userinput"></a>
##User Input:

Markdown allows Webpy users to write text which gets converted to HTML on page display.  It isn't necessary, but is the recommended way to generate formatted HTML from user input.


*  [python-markdown](http://sourceforge.net/project/showfiles.php?group_id=153041) [BSD] [(doc)](http://www.freewisdom.org/projects/python-markdown/)
---
layout: default
title: API Reference
---

# API Reference


+ <a href="/reference/web.ctx.get">web.ctx.get()</a>
+ <a href="/reference/web.cookies">web.cookies()</a>
+ <a href="/reference/web.header">web.header()</a>
+ <a href="/reference/input">web.input()</a>
+ <a href="/reference/web.insert">web.insert()</a>
+ <a href="/reference/web.output">web.output()</a>
+ <a href="/reference/web.query">web.query()</a>
+ <a href="/reference/web.redirect">web.redirect()</a>
+ <a href="/reference/select">web.select()</a>
+ <a href="/reference/web.setcookies">web.setcookies()</a>
+ <a href="/reference/render">web.template.render()</a>
+ <a href="/reference/web.update">web.update()</a>
+ <a href="/reference/web.webapi.notfound">web.webapi.notfound</a>


---
layout: default
title: web.input()
---

# web.input()

`web.input` gives you access to any variables the user submitted through a form. 

<b>returns:</b> Storage object


## Checkboxes
In order to access data from multiple identically named items in a list format (e.g.: a series of checkboxes all with the attribute name="name") use:

## basic usage

        class add:
            def POST(self):
                i = web.input()
                n = web.insert('todo', title=i.title)
    	        web.seeother('/')

(Notice how we're using `POST` for this?)


## images
example by dmpayton. allows you to insert an image into a mysql blob column

    class upload: 
        def POST(self): 
            image = web.input(img={})['img'] 
            web.insert('image', mime=image.type, data=image.value, 
    name=image.filename) 

    class view: 
        def GET(self, id): 
            image = fn.oneResult(web.select('image', where="image_id='%d'" % id, limit=1)) 
            web.header('Content-type', image['mime']) 
            print image['data'].tostring() 





---
layout: default
title: web.select()
---

# web.select()

`select(tables, vars=None, what='*', where=None, order=None, group=None, limit=None, offset=None, _test=False):`

Selects `what` from `tables` with clauses `where`, `order`, 
     `group`, `limit`, and `offset`. Uses vars to interpolate. 
     Otherwise, each clause can be a SQLQuery.
    

## parameters

`tables
a table as a str()

`vars


## examples
### script
    refs = web.select('refs', None, '*', "references_id = " + str(resume.references_id))
    this selects '*' from the 'refs' table where references_id = the given resume.references_id

### command line 
    >>> select('foo', _test=True)
    <sql: 'SELECT * FROM foo'>
    >>> select(['foo', 'bar'], where="foo.bar_id = bar.id", limit=5, _test=True)
    <sql: 'SELECT * FROM foo, bar WHERE foo.bar_id = bar.id LIMIT 5'>


page started by huntercross - last edited by huntercross
---
layout: default
title: web.cookies()
---

# web.cookies()

returns a storage object filled with the cookies available to the current domain.  If you have set a cookie using web.setcookie() but have not specified the domain that you are using for web.cookies(), then it will not show up in this list.

        
        web.setcookie('hc', '1', 3600, 'huntercross.com')
        
        print web.cookies()


---
layout: default
title: web.ctx.get()
---

# web.ctx.get()

Returns the HTTP username passed in the request headers, or 'None' if none.

    return web.ctx.get('environ',{}).get('REMOTE_USER', None)
---
layout: default
title: web.header()
---

# web.header()

used to pass a proper header to the web browser before print statements, so that those print statements are interpreted by the web browser as html.  

## standard html example

    web.header('Content-Type','text/html; charset=utf-8', unique=True) 

## image example

     web.header('Content-type', 'image/jpeg') 

---
layout: default
title: web.insert()
---

# web.insert()

used to insert into the given database.

## example

    web.insert('image', image_data=image)


## example
---
layout: default
title: web.output()
---

# web.output()

used to send text to the web browser, following a web.header() usage.  Allows you to bypass the templates and directly print to the web browser.

hc - i think this is the same as print

example

   web.output("You need to call this with a suitable XML-RPC client!<br/>") 
---
layout: default
title: web.query()
---

# web.query()

used to send a SQL statement to the database.


        # store everything in the sql statement
        clean_query = str(
            'UPDATE ' + clean_update + 
            ' SET ' + clean_column + " = '" + clean_value.encode(output_charset) + 
            "' WHERE " + clean_where
        )
        # execute
        web.query(clean_query)
---
layout: default
title: web.redirect()
---

# web.redirect()

used to redirect to a different url


uses two arguments, url accepts a url,
status defaults to '301 Moved Permanently'

    web.redirect(url, status)
---
layout: default
title: web.select
---

# web.select

in db.py

`select(tables, vars=None, what='*', where=None, order=None, group=None, limit=None, offset=None, _test=False):`
   : Selects `what` from `tables` with clauses `where`, `order`, 
     `group`, `limit`, and `offset`. Uses vars to interpolate. 
     Otherwise, each clause can be a SQLQuery.
     
## examples
### script
    refs = web.select('refs', None, '*', "references_id = " + str(resume.references_id))
    this selects '*' from the 'refs' table where references_id = the given resume.references_id

### command line 
    >>> select('foo', _test=True)
    <sql: 'SELECT * FROM foo'>
    >>> select(['foo', 'bar'], where="foo.bar_id = bar.id", limit=5, _test=True)
    <sql: 'SELECT * FROM foo, bar WHERE foo.bar_id = bar.id LIMIT 5'>


page started by huntercross - last edited by huntercross
---
layout: default
title: web.setcookies()
---

# web.setcookies()

Allows you to set a cookie. Useful for carrying around non-private data       

accepts the following arguments:
name, value, expiration time, domain

in the following example you can see that the name of the cookie is 'hc', the value is '1', the expiry is in seconds, so 3600 seconds == 1 hour, then domain is 'huntercross.com'


## example 

        web.setcookie('hc', '1', 3600, 'huntercross.com')
        
        print web.cookies()


---
layout: default
title: web.update()
---

# web.update()

used to make updates to a single database row.   Specify the database and a clause.

`update(tables, where, vars=None, _test=False, **values)`
   : Update `tables` with clause `where` (interpolated using `vars`)
     and setting `values`.
## other example

        web.update('resume', where='resume_id = $current', resume_availability = 'available')


## docs example
         >>> joe = 'Joseph'
         >>> update('foo', where='name = $joe', name='bob', age=5,
         ...   vars=locals(), _test=True)
         <sql: "UPDATE foo SET age = 5, name = 'bob' WHERE name = 'Joseph'">


---
layout: default
title: related
---

# related

## ports

* [Colubrid](http://wsgiarea.pocoo.org/colubrid/)
* [PHP](http://code.google.com/p/wephp/)
* [Lua](http://dev.alt.textdrive.com/browser/LW/Web.lua)
---
layout: default
title: Roadmap
---

# Roadmap

[[discussion](http://groups.google.com/group/webpy/browse_thread/thread/b8505370cef1c37c/9e65f5d621c47913)]

Next release of web.py will be version 0.3. As the number suggests it   
will be major release. There will be some changes to API, which   
breaks the backward compatability. But I promise, it is not going to   
change very much. 

Major changes will be 

     * return instead of print 
     * moving away from globals 
     * better db api 

Apart from these, the existing subversion repository is be migrated   
to bazaar. 
 From now on, the official repository will be 

     http://webpy.org/bzr/webpy.dev 

Please let me know if you have any suggestions, objections or feature   
requests. 
Some of these changes(application stuff and return instead of print)   
are already checked in, I request you to play with it and let me know   
if there are any bugs. 

Here is how the new API is going to look like. 

## Hello world 

`print` will be replaced with `return`. 

     import web 

     urls = ( 
         '/(.*)', 'hello' 
     ) 

     # more about this later 
     app = web.application(urls, globals()) 

     class hello: 
         def GET(self, name): 
             if not name: name = 'world' 
             return 'Hello,' + name + '!' 

     if __name__ == "__main__": 
         app.run() 

## database 

db configuration will not be global any more. Multiple databases can   
be used at the same time and no `web.load()` magic required to make   
database work. 

     import web 

     db = web.database(dbn='postgres', db='todo', user='you', pw='') 

     db.select('todo') 
     db.select('todo', where='id=$id', vars={'id': 2}) 
     db.query('SELECT * FROM todo') 

## application 
Application is a new way of mapping urls to classes, coming in 0.3. 
There will be many different kinds of supported applications. 

### web.application 
Application to delegate requests based on path. 

     urls = ( 
         "/hello", "hello", 
         "/magic/.*", "magic") 

     app = web.application(urls, globals()) 

### web.auto_application 
Application similar to web.application but urls are constructed   
automatiacally using metaclasses. 

     app = web.auto_application() 

     class hello(app.page): 
         def GET(self): 
             return "hello, world!" 

### web.subdir_application 
Application to delegate requests based on subdir. 
This allows reuse of code easily by taking some existing app and   
mounting it at a directory. 

     import wiki 
     import blog 
     import auth 

     mapping = ( 
         "/wiki", wiki.app, 
         "/blog", blog.app, 
         "/auth", auth.app) 

     app = web.subdir_application(mapping) 

### web.subdomain_application 
Application to delegate requests based on host. 
This makes virtual hosting very easy. 

     import mainsite 
     import usersite 

     mapping = ( 
         "(www\.)?example.com", mainsite.app, 
         ".*\.example.com", usersite.app 
     ) 

     app = web.subdomain_application(mapping) 

## testing 

Testing becomes very easy with applications. Both doctest and   
unittest can be used to test web applications. 

doctest: 

     urls = ("/hello", "hello") 
     app = web.application(urls, globals()) 

     class hello: 
         """Hello world example. 

             >>> response = app.request("/hello") 
             >>> response.data 
             'hello, world!' 
             >>> response.status 
             '200 OK' 
             >>> response.headers['Content-Type'] 
             'text/plain' 
         """ 
         def GET(self): 
             web.header('Content-Type', 'text/plain') 
             return "hello, world!" 

unittest: 

     import unittest 
     from helloworld import app 

     class HelloWorldTest(unittest.TestCase): 
         def testHelloWorld(self): 
             response = app.request('GET', '/')
             self.assertEquals(response.data, 'hello, world!')
             self.assertEquals(response.headers['Content-Type'], 'text/plain')
             self.assertEquals(response.status, '200 OK')

     if __name__ == "__main__": 
         unittest.main() 

## templates 

* no whitespace magic 
* better error reporting 
* should allow template reuse 
* Probably use Adam Atlas's implementation 

## Contrib 

* New module, `web.contrib` with contributed utilities, which are not   
part of the web.py core. For example, good auth module (port from   
django?) and OpenID support.
---
layout: default
title: Sandbox
---

# Sandbox

Place for experimenting!

**Hello, world!**
---
layout: default
title: How to send mail using gmail
---

# How to send mail using gmail

Problem: How to send mail using gmail.

Solution:

Often it is tedious to setup and maintain a mail server. If you have a
gmail accout, you can use gmail as SMTP server to send mail. To do
that we need to specify username and password of gmail account in
`web.config`.

    web.config.smtp_server = 'smtp.gmail.com'
    web.config.smtp_port = 587
    web.config.smtp_username = 'cookbook@gmail.com'
    web.config.smtp_password = 'secret'
    web.config.smtp_starttls = True

Once this configuration is set, `web.sendmail` can be used to send
mail using the gmail account. Gmail signs all these mails.

    web.sendmail('cookbook@gmail.com', 'user@example.com', 'subject', 'message')

Read [GMail: Configuring other mail clients][1] for more details.

[1]: http://mail.google.com/support/bin/answer.py?hl=en&answer=13287
---
layout: default
title: CookieHandler for Sessions
---

# CookieHandler for Sessions

# Specification

see [project blog post](http://planet-soc.com/node/2158)

bazaar branch at http://bazaar.launchpad.net/~karol.tarcak/webpy/webpy.sessions.cookie

## How to generate a RSA key file

    import web
    web.session.generate_key('some_rsa_file', 1024)


## Summary


## Implementation details

CookieHandler is a derivate of Handler.

### Public methods
 * store() -
 * retrieve() -
 * remove() -
 * clean() - it will do nothing, it's not possible to implement

### Requirements


[Sessions specs](/sessions)
---
layout: default
title: DBHandler for Sessions
---

# DBHandler for Sessions

# Specification

## Summary
The DBHandler will provide Handler-interface to db storage.
It will store pickled data, session id & client's IP address in db. Also retreiving & removing requested data by id will be implemented. On request the DBHandler will perform a generall clean up -> delete old session rows.

## Implementation details

DBHandler is a derivate of Handler.

### Public methods
 * store() - it will store the session data (& pickle them before that); if the argument _old\_id is set, it will look for an already storaged session data and if they are present overwrite them or else store as new; if there is already stored data (SELECT), it will do an UPDATE on the table, otherwise it will just call INSERT
 * retreive() - it will retreive storaged data unpickled in a Storage object ( id, ip, time, data), if there aren't any for given id, it will return empty Storage object; it will do a SELECT on the storage db-table
 * remove() - it will remove storaged data for given id; it will not do a check to see if there is any stored data under given id, it will only call DELETE
 * clean() - it will remove all session data, which been updated longer then before given timeout (DELETE)

### Requirements
DBHandler will need an extra table in the db (where \<name\> == web.config.handler_parameters.db_table):

      CREATE TABLE <name> (
        id CHAR(129) UNIQUE NOT NULL,
        ip CHAR(16) NOT NULL,
        created int NOT NULL,
        touched int NOT NULL,
        data TEXT
      );

[Sessions specs](/sessions)
---
layout: default
title: Session example
---

# Session example

put this in code.py and run _python code.py_

    import time
    
    import web
    
    web.config.db_parameters = {
                                'dbn' : 'postgres',
                                'host' : 'localhost',
                                'user' : 'web',
                                'pw' : 'web',
                                'db' : 'web'
                        }
    
    ##web.config.db_parameters = {
    ##                          'dbn' : 'sqlite',
    ##                          'db' : 'web.db'
    ##                  }
    
    web.config.db_printing = True
    
    urls = (
        '/(.*)', 'index'
    )
    
    class index:
        def GET(self, rest):
                # if you are going to use FileHandler
                #web.config.session_parameters.handler = 'file'
                # set the file prefix
                #web.config.handler_parameters.file_prefix = 'sess'
                # and directory
                #web.config.handler_parameters.file_dir = '/tmp'

                if rest == 'logout':
                        web.ctx.session.start()
                        web.ctx.session.destroy()
                        web.redirect('/')
                        return
    
                print '<html><body>'
                print 'don\'t forget to create sqlite db-file web.db and table session_data'
                print '<br>'
                print '------------------------------------'
                print '<br>'
                print 'client cookies at start: ', web.websafe(web.cookies())
                print '<br>'
                print '------------------------------------'
                print '<br>'
    
                s = web.ctx.session
                print 'starting session ...'
                print '<br>'
                s.start()
                print '------------------------------------'
                print '<br>'
    
                print 'got session: ', web.websafe(s)
                print '<br>'
                print '------------------------------------'
                print '<br>'
    
                try:
                        t = s.time
                except AttributeError:
                        t = False
    
                print 'last hit at: ', web.websafe(t)
                print '<br>'
                print '------------------------------------'
                print '<br>'

                if not t:
                        s['1'] = 0
                        s['2'] = 0
                        s['3'] = 0
    
                if rest in ('1', '2', '3'):
                        print '<b>you\'re on page no. ', rest, '</b>'
                        print '<br>'
                        print '------------------------------------'
                        print '<br>'
                        s[rest] += 1
    
                print 'changing data ...'
                print '<br>'
                s.time = time.strftime('%a, %d %b %Y %H:%M:%S')
    
                print '------------------------------------'
                print '<br>'
                print 'page <a href="/1">1</a>: ', s['1'], ' times'
                print '<br>'
                print 'page <a href="/2">2</a>: ', s['2'], ' times'
                print '<br>'
                print 'page <a href="/3">3</a>: ', s['3'], ' times'
                print '<br>'
                print '------------------------------------'
                print '<br>'
    
                print '<a href="/logout">destroy session</a>'
                print '<br>'

                s.save()
    
                print '<!--'
                print web.ctx
                print '-->'
                print '</body></html>'
    
    web.webapi.internalerror = web.debugerror
    
    if __name__ == '__main__':
        web.run(urls, globals(), web.reloader)
---
layout: default
title: FileHandler for Sessions
---

# FileHandler for Sessions

# Specification

## Summary
The FileHandler will provide Handler-interface to file storage. It will store pickled data, session id & client's IP address in specified directory as files. Also retreiving & removing requested data by id will be implemented. On request the FileHandler will perform a generall clean up -> delete old session files.

## Implementation details

FileHandler is a derivate of Handler. All files will be created in the directory  web.config.handler_parameters.file_dir with prefix web.config.handler_parameters.file_prefix.

### Public methods
 * store() - it will store the session data (& pickle them before that); if the argument _old_id is set, it will look for an already storaged session data, it will create locks on both old & new session files, it will try to retreive time of the old session creation; after the pickle data is stored, the lock will be released; it will call \_acquire_lock(), \_release\_lock() and \_session\_file()
 * retreive() - it will retreive storaged data unpickled in a Storage object ( id, ip, time, data), if there aren't any for given id, it will return empty Storage object; all necessary lock procedures will be used; it will call \_acquire\_lock(), \_release\_lock() and \_session\_file()
 * remove() - it will remove storaged data for given id; all necessary lock procedures will be used, it will simply unlink the session file (ignoring if it's not existing); it will call \_acquire\_lock(), \_release\_lock() and \_session\_file()
 * clean() - it will remove all session data, which been updated longer then before given timeout; all necessary lock procedures will be used (however not blocking); it will call \_acquire\_lock() and \_release\_lock()


### Private methods
 * \_session\_file() - it will return the full name of the session storage file
 * \_lock\_file() - it will return the full name of the session storage lock file; ; it will call \_session\_file()
 * \_acquire\_lock() - it will create a lock file; if the lock file is already present, it will check, that the lock file is not older than 60s, in that case the old lock file will be erased; if blocking is set False, it will not wait; it will call \_lock\_file()
 * \_release\_lock() - it will simply unlink the session lock file (ignoring if it's not existing); it will call \_lock\_file()

### Requirements
FileHandler will need a storage directory (web.config.handler_parameters.file_dir) on the filesystem with write (& read) permission.

[Sessions specs](/sessions)
---
layout: default
title: Google Summer of Code: web.py - Session management
---

# Google Summer of Code: web.py - Session management

[project blog](http://planet-soc.com/blog/77) at [planet-soc.com](http://planet-soc.com/)

## Post GSoC work
 * WSGI
 * online migration between handlers?


## End of GSoC
 * FileHandler
 * CookieHandler - see project blog [first](http://planet-soc.com/node/2158) and [second](http://planet-soc.com/node/2477) post


## OLD Schedule - [DONE](https://bugs.launchpad.net/~karol.tarcak/)
 * May 28 - June 9 (1st & 2nd week): getting familiar with SVN/Bazaar, internals of web.py, flup and jonpy's sessions; creating a DDL for storing sessions
 * June 10 - June 17 (3rd): creating DBHandler class
 * June 18 - July 8 (4th - 6th): creating Session class's identify/verify methods
 * July 9 - mid-term evulation deadline
 * July 10 - August 19 (7th - ...): finishing the Session class
 * August 20 - final evaluation deadline

## Tasks

### Administrative
 * Bazaar/SVN
 * blog

### DBHandler
 * create table DDL
 * write store(), retrieve(), remove()
 * test (& some docs)

### Session
 * write default session id generator(s)
 * write & test session cookie creation, identification, verification
 * write & test session id regeneration (mainly cookies & session identification)
 * write start()
 * write save()
 * write destroy(), cleanup()
 * test & docs

---
layout: default
title: Session
---

# Session

# Usage
[example](/sessions/example)

[simple example, a counter](/sessions/simpleexample)


# Specification
## Summary
The main session object will be created depending on the configuration. However the user/developer will choose it's usage. If needed the user will call start() method and there by inicializing handlers, variables from db-config like variables. The session will be implemented as storage object. Session identification will mostly rely on client cookies (optionally also on client IP address). All data will be stored/retrieved through handler object (DB-, file-, cookie?- based). Save/commit & destroy methods will be created. The user will have the option to set various settings including expiration timeout, handler, session id generator (a default will be provided).

## Design
The session functionality will rely on a two-layer implementation: Session -> Handler. The Session class will provide identification & verification of the client request while the Handler-like classes will guarante data persistence.

## Implementation details

### Session class
The Session class is a derivate of Storage. It will store as a dict anyhow called variable, but through the Storage interface only variables not named as internal private variables.

#### Private variables
 * _handler - reference to user-choosen Handler
 * _id - current session id
 * \_old\_id - used if the session regenerates id
 * _data - internal Storage object for session data

#### Public methods

 * start() - it will start the session, regenerate id, set cookies, retreive data if the session isn't new; it will call \_identity(), \_verify(), \_generate\_id(), \_retreive()
 * get_id() - it will return current session id
 * cleanup() - it will clean expired sessions depending on the provided interface by choosen Handler object (cookie based will do nothing); it will call Handler.clean() with the user preset timeout
 * save() - it will save session data using the _store()
 * destroy() - it will remove the session (cookies & data); it will call _remove()

#### Private methods

 * _generate\_id() - it will _only_ make a hash of ip, time, seed or it will call user supplied generator
 * _identify() - it will identify the session id (through client cookie                s)
 * _verify() - it will verify the session id with retreived data from handler object i.e. check for expiration, IP change (headers change?)
 * _store() - a simple wrapper around Handler.store(); data will be passed **unpickled**
 * _retreive() - a simple wrapper around Handler.retreive(); data will be awaited **unpickled**
 * _remove() - a simple wrapper around Handler.remove()

#### Main session parameters
web.config.session_parameters - Storage object:

 * cookie_name - name of the cookie which will transfer the session id; default value: 'webpy'
 * cookie_domain - cookie domain for the setcookie() when setting session id cookie; default value: None
 * timeout - number of second after a not-updated session will be considered expired; default value: 600
 * max_age - the maximum age a session can reach; default value: 24 * 60 * 60 (1day)
 * id_seed - a seed-string that will be used in the default Session._generator(); default value: 'web.py'
 * regenerate_id - should the session id be regenerated and set again with a cookie on every request?; default value: True
 * generator - a function to generate _random_ session ids, if False, the implicit generator (Session.\_generate\_id()) will be used; default value: False
 * ignore_change_ip - if the pair ( _id_, _ip_) doesn't match the retreived data from Handler objcet, then fail/raise exception/...; default value: False
 * ignore_expiration - should the session expiration be ignored?; default value: False
 * ignore_old_age - should the session be checked for max_age?; default value: True
 * handler - a Handler-like object to provide persistence for Session class; default value: 'db'

### Handler class
An abstract class which defines a interface to store/retreive/remove session data.

#### Public methods
 * store() - it will store the session data (& pickle them before that); if the argument _old\_id_ is set, it will look for an already storaged session data and if they are present overwrite them or else store as new
 * retreive() - it will retreive storaged data *unpickled* in a Storage object ( _id_, _ip_, _time_, _data_), if there aren't any for given _id_, it will return empty Storage object
 * remove() - it will remove storaged data for given _id_
 * clean() - optional function (may not be available for any Handler implementation [CookieHandler]), it will remove all session data, which been updated longer then before given _timeout_

### Handler parameters
web.config.handler_parameters as Storage object will include additional parameters that are necessary for various Handlers
#### DBHandler
 * db_table - table storing session data; default value: 'session_data'
#### FileHandler
 * file_dir - directory used to store session data; default value: '/tmp'
 * file_prefix - prefix to session data files; default value: 'sess'

### *Handler specs
 * [DBHandler](/sessions/dbhandler)
 * [FileHandler](/sessions/filehandler)
 * [CookieHandler](/sessions/cookiehandler) - **DANGEROUS, UNSECURE, EXPERIMENTAL**


## Notes
 * [Google Summer of Code project](/sessions/gsoc)
 * [installation instructions](/sessions/install)
 * [bazaar](http://bazaar-vcs.org/) branch: http://bazaar.launchpad.net/~karol.tarcak/webpy/webpy.sessions.branch
---
layout: default
title: Installation
---

# Installation

## Development branch

1) download & install [bazaar](http://bazaar-vcs.org/) - instructions at [bazaar download page](http://bazaar-vcs.org/Download)

2) run command:

    bzr branch http://bazaar.launchpad.net/~karol.tarcak/webpy/webpy.sessions.branch webpy

to get the CookieHandler (EXPERIMENTAL) branch run

    bzr branch http://bazaar.launchpad.net/~karol.tarcak/webpy/webpy.sessions.cookie webpy_cookie

3) enjoy

## Stable
merged with the trunk; it should be distributen within the next stable project tarball
---
layout: default
title: Prototype
---

# Prototype

-

    # some modules that are expected to be used
    import time
    
    import pickle # the default ASCII "pickling"
    import sha # Python2.5 hashlib
    
    # settings
    web.config.session_parameters = {
        use_flag : False, # will the session be used? if not then the Session object will not be created
        timeout : 600,
        id_seed : 'web.py',
        regenerate_id : True, # boolean, on every request regenerate id and set again cookie
        generator : False, # if False, use default generator

        ignore_change_ip : True, # boolean, if the pair ( id, ip ) doesn't match the db, then fail/raise exception/...
        ignore_expiration : False,

        handler : DBHandler()
    }

    web.config.handler_parameters = { # optional handler settings
        file_dir : '/tmp',
        db_table : 'session_data' # table name
    }


    
    class Session( Storage ):
            '''main session object
                    main instance variables
                            _generator - reference to user-supplied "unique random number generator" or just to default session generator function
                            _handler
                            _id
                            _data - internal Storage object'''
    
            def __init__( self ):
                    pass
    
            # public methods
            def start( self ):
                    '''starts the session, regenerates id, sets cookies
                            calls _identity, _verify, _generator function'''
                    pass
    
            def get_id( self ):
                    '''returns current session id'''
                    pass
    
            def cleanup( self ):
                    '''cleans expired sessions'''
                    pass

            def save( self ):
                    '''save session data'''
                    pass

            def destroy( self ):
                    '''removes session (including cookies)'''
                    pass            

            # private methods
            def _generate_id( self ):
                    '''implicit session id generator
                            "hashes" ip, time, seed, microtime (?), ...'''
                    pass
    
            def _identify( self ):
                    '''identifies session id (through cookies)'''
                    pass
    
            def _verify( self ):
                    '''verifies with retreived data from handler object'''
                    pass
    
            def _store( self ):
                    '''stores session data (wrapper around handler object)'''
                    pass
    
            def _retreive( self ):
                    '''retreive session data (wrapper around handler object)'''
                    pass
    
            def _remove( self ):
                    '''removes session data (wrapper around handler object)'''
                    pass
    # class
    
    class Handler:
            '''abstract handler class'''
            def __init__( self ):
                    pass
    
            def store( self, ip, id, data ):
                    '''takes
                            ip - client ip, probably number
                            id - string
                            data - dictionary'''
                    pass
    
            def retreive( self, id ):
                    '''return ( id, ip, data, time ) or maybe dictionary'''
                    pass
    
            def remove( self, id ):
                    pass
    # class
    
    def DBHandler( Handler ):
            def __init__( self ):
                    pass
    
            def clean( self, timeout ):
                    '''removes all expired sessions'''
                    pass
    # class
    
    def FileHandler( Handler ):
            def __init__( self ):
                    '''takes dir where to create session files'''
                    pass
    # class

---
layout: default
title: Very simple session example
---

# Very simple session example

put this in code.py and run python code.py

    import web

    web.config.db_parameters = {
                                'dbn' : 'postgres',
                                'host' : 'localhost',
                                'user' : 'web',
                                'pw' : 'web',
                                'db' : 'web'
                        }

    urls = (
        '/', 'index'
    )

    class index:
        def GET(self):
            s = web.ctx.session
            s.start()

            try:
                s.click += 1
            except AttributeError:
                s.click = 1

            print 'click: ', s.click
            s.save()

    if __name__ == '__main__':
        web.run(urls, globals(), web.reloader)

---
layout: default
title: Sites that use web..py
---

# Sites that use web..py

web.py was originally published while Aaron Swartz worked at [reddit.com][20], where the site used it as it grew to become one of the top 1000 sites according to Alexa and served millions of daily page views. "It's the anti-framework framework. web.py doesn't get in your way," explained founder Steve Huffman. (The site was rewritten using other tools after being acquired by Condé Nast.)

   [20]: http://reddit.com/

[Frinki](http://frinki.com), a Facebook-like social network in spanish.

[Make History](http://makehistory.national911memorial.org), a project of the 9/11 Memorial Museum, is powered by web.py on top of Google App Engine. On September 11, 2009, it received nearly 200,000 visitors. "It's my first time working with web.py and basically with Python," noted its developer. "web.py was awesome."

[local.ch](http://www.local.ch), the official online Telephone Directory for Switzerland - using web.py in a backend service for tracking expired content - code open-sourced as [urldammit](http://github.com/harryf/urldammit/tree/master)

[sitecanary.com](https://sitecanary.com/) a site for being alerted if your website is down.

[watchdog.net](http://watchdog.net/), a political watchdog site, is built in web.py.


[archivd.com](http://www.archivd.com), a web application for collaborative research and archiving, is built on web.py

[colr.org](http://www.colr.org), a color scheme picking site, is built in web.py.


[Chiefmall](http://www.chiefmall.com/), a contractor search tool, was built with web.py.

[grouplite.com](http://www.grouplite.com) uses web.py.

[Yandex][21], a Russian traffic provider whose homepage alone receives 70 million daily page views, uses web.py for certain projects.

   [21]: http://yandex.ru

[LShift][22] has used web.py to build websites for [Expro][23] and [publisher Dorling Kindersley][24]. "web.py allows us to do what we do best," they report. "It does the webapp thing brilliantly, and without requiring us to compromise on flexibility and originality."

   [22]: http://www.lshift.net/
   [23]: http://exproretail.com/
   [24]: http://travel.dk.com/

[micropledge][m], a web app that collects funding for software ideas, is built in web.py. "We've enjoyed fitting in with its minimalist approach," says developer Ben Hoyt.

   [m]: http://micropledge.com/

The [bivalidator](http://xhtml-css.com/) checks your HTML and CSS validation.

[jottit.com](http://jottit.com) is built with web.py.  Jottit makes getting a website as easy as filling out a textbox. 

[Tasko][t] is built with web.py. Tasko is an online task management tool which  uses a plain text file format to store all the information.

   [t]: http://taskodone.com/

[Damiga][d] is built with web.py. Damiga is a place where you can anonymously and freely tell the world how you feel about other people: friends, celebrities, even fictional characters. It's also a place where you can see how the world feels about you.  

   [d]: http://damiga.com/

[Fotosaur.us][f], an unbelievably rad image bookmarking app, was written with web.py.

   [f]: http://fotosaur.us


[URIs.us][u] is service for creating short urls. Deploying on Google App Engine

   [u]: http://uris.us 


[xykra] [x] is a minimalist (160 Python lines) wiki using [Markdown](http://daringfireball.net/projects/markdown/).

   [x]: http://xykra.org

[Edgarest] [y] is built with web.py.Edgarest provides fast, intuitive search of SEC Filings.

   [y]: http://edgarest.com


[Wklej.to] [z] is a nopaste/Pastebin app with Free and Open api, and of course with desktop plugins and clients.

   [z]: http://wklej.to

[Sysinternals CD] [zz] integrates webpy and postgresql to render an automated website

   [zz]: http://sysinternals.xykra.org

[Biomed Search] [zzz] searches over a million biomedical images images in nicely viewable sizes.

   [zzz]: http://www.biomed-search.com

"[web.py inspired the] web framework we use at FriendFeed [and] the webapp framework that ships with App Engine..."  
 - [Brett Taylor](http://bret.appspot.com/entry/experimenting-google-app-engine), co-founder of FriendFeed and original tech lead on Google App Engine

"In the ecosystem of web frameworks, something needs to occupy the 'small, light and fast' niche. web.py is it."  
- Lloyd Dalton, [colr.org](http://colr.org)

"We completed our server rewrite a few days ago with web.py and it was everything we could have wished for."  
- Sam Hsiung, [YouOS][25]

   [25]: http://www.youos.com/

"Django lets you write web apps in Django. TurboGears lets you write web apps in TurboGears. Web.py lets you write web apps in Python."  
- Adam Atlas

"very nicely written and concise (not to mention it's written by Aaron Swartz, whose coding skills are very trustable), and doesn't get in my way"   
- Jonas Galvez, Aupeo [#][26]

   [26]: http://www.artima.com/forums/flat.jsp?forum=106&thread=146149

"the first framework ... where I could just scribble code and see something working without even having to try to understand the logic of it. A pleasure to integrate."   
- Delaunay Antoine built [a photo gallery][28] and [an agenda][34] with it

   [28]: http://github.com/antoine/ibrouteur/
   [34]: http://metagenda.org

"Guido [van Rossum, creator of Python], you'll probably find that web.py best suits your style. ... If you don't like it, I can't imagine which of the other dozens of frameworks out there you *would* like."   
- Phillip J. Eby, creator of the Python Web Server Gateway Interface (WSGI) [#][30]

   [30]: http://www.artima.com/forums/flat.jsp?forum=106&thread=146149&start=30&msRange=15

"... the [Cheetah] example I saw on web.py looks "right". (web.py itself OTOH gets an "F", for undocumented code with too much magic behavior. upvars(), bah.)"   
- Guido van Rossum, creator of Python [#][31]

   [31]: http://www.artima.com/weblogs/viewpost.jsp?thread=146503

"suffice to say I think Aaron is headed in the right direction."   
- Harry Fuecks: [a simple wiki with web.py][32]

   [32]: http://www.sitepoint.com/blogs/2006/01/06/a-simple-wiki-with-webpy/

"a very fascinating moment for me. The feelings just like the first time I wrote my php script ... it sure have let me learn python in the fun way. Good work aaron !"   
- Kamal [simple blog in webpy, learning python the fun way][33]

   [33]: http://www.k4ml.com/node/165
---
layout: default
title: webpy 0.2 skeleton code
---

# webpy 0.2 skeleton code

Here's the skeleton of a typical web.py app (as of 0.2):

## code.py

    import web
    import view, config
    from view import render

    urls = (
        '/', 'index'    )

    class index:
        def GET(self):
            print render.base(view.listing())

    if __name__ == "__main__":
        web.run(urls, globals(), *config.middleware)

## config.py

    import web
    web.config.db_parameters = dict(dbn='postgres', db='appname', user='username', pw='')
    web.webapi.internalerror = web.debugerror
    middleware = [web.reloader]
    cache = False

## db.py

    import web

    def listing(**k):
        return web.select('items', **k)

## view.py

    import web
    import db
    import config

    render = web.template.render('templates/', cache=config.cache)

    def listing(**k):
        l = db.listing(**k)
        return render.listing(l)
    
    web.template.Template.globals.update(dict(
      datestr = web.datestr,
      render = render
    ))

## sql/tables.sql

    CREATE TABLE items (
        id serial primary key,
        author_id int references users,
        body text,
        created timestamp default (current_timestamp at time zone 'utc')
    );

## templates/base.html

    $def with (page, title=None)
    <html><head>        <title>my site\
    $if title: : $title\
    </title>    </head><body>    <h1><a href="/">my site</a></h1>
    $:page
    
    </body></html>
## templates/listing.html

    $def with (items)

    $for item in items:
        $:render.item(item)

## templates/item.html

    $def with (item)
    
    <p>$item.body</p>    
    <p class="details">created $datestr(item.created)</p>
---
layout: default
title: webpy 0.3 skeleton code
---

# webpy 0.3 skeleton code

Here's the skeleton of a typical 0.3 web.py app:

## code.py

    import web
    import view, config
    from view import render

    urls = (
        '/', 'index'
    )

    class index:
        def GET(self):
            return render.base(view.listing())

    if __name__ == "__main__":
        app = web.application(urls, globals())
        app.internalerror = web.debugerror
        app.run()

## config.py

    import web
    DB = web.database(dbn='postgres', db='appname', user='username', pw='')
    cache = False

## db.py

    import config

    def listing(**k):
        return config.DB.select('items', **k)

## view.py

    import web
    import db
    import config
    
    t_globals = dict(
      datestr=web.datestr,
    )
    render = web.template.render('templates/', cache=config.cache, 
        globals=t_globals)
    render._keywords['globals']['render'] = render

    def listing(**k):
        l = db.listing(**k)
        return render.listing(l)
    
## sql/tables.sql

    CREATE TABLE items (
        id serial primary key,
        author_id int references users,
        body text,
        created timestamp default (current_timestamp at time zone 'utc')
    );

## templates/base.html

    $def with (page, title=None)
    <html><head>
    <title>my site\
    $if title: : $title\
    </title>
    </head><body>
    <h1><a href="/">my site</a></h1>
    $:page   
    </body></html>

## templates/listing.html

    $def with (items)

    $for item in items:
        $:render.item(item)

## templates/item.html

    $def with (item)
    
    <p>$item.body</p>    
    <p class="details">created $datestr(item.created)</p>
---
layout: default
title: skeleton
---

# skeleton

Here's the skeleton of a typical web.py app (as of 0.2):

## code.py

    import web
    import view, config
    from view import render

    urls = (
        '/', 'index'    )

    class index:
        def GET(self):
            print render.base(view.listing())

    if __name__ == "__main__":
        web.run(urls, globals(), *config.middleware)

## config.py

    import web
    web.config.db_parameters = dict(dbn='postgres', db='appname', user='username', pw='')
    web.webapi.internalerror = web.debugerror
    middleware = [web.reloader]
    cache = False

## db.py

    import web

    def listing(**k):
        return web.select('items', **k)

## view.py

    import web
    import db
    import config

    render = web.template.render('templates/', cache=config.cache)

    def listing(**k):
        l = db.listing(**k)
        return render.listing(l)
    
    web.template.Template.globals.update(dict(
      datestr = web.datestr,
      render = render
    ))

## sql/tables.sql

    CREATE TABLE items (
        id serial primary key,
        author_id int references users,
        body text,
        created timestamp default (current_timestamp at time zone 'utc')
    );

## templates/base.html

    $def with (page, title=None)
    <html><head>        <title>my site\
    $if title: : $title\
    </title>    </head><body>    <h1><a href="/">my site</a></h1>
    $:page
    
    </body></html>
## templates/listing.html

    $def with (items)

    $for item in items:
        $:render.item(item)

## templates/item.html

    $def with (item)
    
    <p>$item.body</p>    
    <p class="details">created $datestr(item.created)</p>
---
layout: default
title: Basic Blog in 0.3
---

# Basic Blog in 0.3

A really basic blog. Note there isn't authentication on this, so anyone could create a post, but it shows the basic functionality.

## Files

    /blog.py
    /schema.sql
    /templates:
        /templates/view.html
        /templates/new.html
        /templates/base.html
        /templates/index.html
        /templates/edit.html
    /model.py


###/blog.py


    """ Basic blog using webpy 0.3 """
    import web
    import model
    
    ### Url mappings
    
    urls = (
        '/', 'Index',
        '/view/(\d+)', 'View',
        '/new', 'New',
        '/delete/(\d+)', 'Delete',
        '/edit/(\d+)', 'Edit',
    )
    
    
    ### Templates
    t_globals = {
        'datestr': web.datestr
    }
    render = web.template.render('templates', base='base', globals=t_globals)
    
    
    class Index:
    
        def GET(self):
            """ Show page """
            posts = model.get_posts()
            return render.index(posts)
    
    
    class View:
        
        def GET(self, id):
            """ View single post """
            post = model.get_post(int(id))
            return render.view(post)
    
    
    class New:
    
        form = web.form.Form(
            web.form.Textbox('title', web.form.notnull, 
                size=30,
                description="Post title:"),
            web.form.Textarea('content', web.form.notnull, 
                rows=30, cols=80,
                description="Post content:"),
            web.form.Button('Post entry'),
        )
    
        def GET(self):
            form = self.form()
            return render.new(form)
    
        def POST(self):
            form = self.form()
            if not form.validates():
                return render.new(form)
            model.new_post(form.d.title, form.d.content)
            raise web.seeother('/')
    
    
    class Delete:
        
        def POST(self, id):
            model.del_post(int(id))
            raise web.seeother('/')
    
    
    class Edit:
    
        def GET(self, id):
            post = model.get_post(int(id))
            form = New.form()
            form.fill(post)
            return render.edit(post, form)
    
    
        def POST(self, id):
            form = New.form()
            post = model.get_post(int(id))
            if not form.validates():
                return render.edit(post, form)
            model.update_post(int(id), form.d.title, form.d.content)
            raise web.seeother('/')
    
    
    app = web.application(urls, globals())
    
    if __name__ == '__main__':
        app.run()



###/schema.sql


    
    
    CREATE TABLE entries (
        id INT AUTO_INCREMENT,
        title TEXT,
        content TEXT,
        posted_on DATETIME,
        primary key (id)
    );



###/templates/view.html


    $def with (post)
    
    <h1>$post.title</h1>
    $datestr(post.posted_on)<br/>
    
    $post.content



###/templates/new.html


    $def with (form)
    
    
    <h1>New Blog Post</h1>
    <form action="" method="post">
    $:form.render()
    </form>



###/templates/base.html


    $def with (page)
    
    <html>
    <head>
        <title>My Blog</title>
        <style>
            #menu {
                width: 200px;
                float: right;
            }
        </style>
    </head>
    <body>
    
    <ul id="menu">
        <li><a href="/">Home</a></li>
        <li><a href="/new">New Post</a></li>
    </ul>
    
    $:page
    
    </body>
    </html>



###/templates/index.html


    $def with (posts)
    
    <h1>Blog posts</h1>
    
    <ul>
    $for post in posts:
        <li>
            <a href="/view/$post.id">$post.title</a> 
            from $datestr(post.posted_on) 
            <a href="/edit/$post.id">Edit</a>
        </li>
    </ul>



###/templates/edit.html


    $def with (post, form)
    
    <h1>Edit $form.d.title</h1>
    
    <form action="" method="post">
    $:form.render()
    </form>
    
    
    <h2>Delete post</h2>
    <form action="/delete/$post.id" method="post">
        <input type="submit" value="Delete post"/>
    </form>



###/model.py


    import web, datetime
    
    db = web.database(dbn='mysql', db='blog', user='justin')
    
    def get_posts():
        return db.select('entries', order='id DESC')
    
    def get_post(id):
        try:
            return db.select('entries', where='id=$id', vars=locals())[0]
        except IndexError:
            return None
    
    def new_post(title, text):
        db.insert('entries', title=title, content=text, posted_on=datetime.datetime.utcnow())
    
    def del_post(id):
        db.delete('entries', where="id=$id", vars=locals())
    
    def update_post(id, title, text):
        db.update('entries', where="id=$id", vars=locals(),
            title=title, content=text)
---
layout: default
title: Templating with Genshi
---

# Templating with Genshi

<p> 
 
<h2>code.py</h2> 
<p>Put your &quot;code.py&quot; in root directory.
</p> 
<pre><code># -*- coding: utf-8 -*-
 
import web
from web.contrib import template
 
render = template.render_genshi(['./templates/'])
 
urls = (
    '/', 'index'
)
 
class index:
    def GET(self):
        name = 'John Doe'
        return render.index(name=name)
 
app = web.application(urls, globals())
if __name__ == &quot;__main__&quot;:
    app.run()
</code></pre> 
<h2>index.html</h2> 
<p>Put your &quot;index.html&quot; in &quot;template&quot; directory.
</p> 
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;html xmlns:py=&quot;http://genshi.edgewall.org/&quot;&gt;
&lt;body&gt;
&lt;p&gt;Hello, $name.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h2>refer</h2> 
<ul> 
 <li> 
     <a href="http://groups.google.com/group/genshi/t/4f3fa1beddbd4ffc">genshi on gae 2010 - Genshi | Google Groups</a> 
 </li> 
 
 <li> 
     <a href="http://genshi.edgewall.org/browser/trunk/examples/webpy?rev=332">/trunk/examples/webpy – Genshi</a> 
 </li> 
 
 <li> 
     <a href="http://webpy.org/docs/0.3/api">api docs (web.py)</a> 
 </li> 
</ul> 
 
 
</p>
---
layout: default
title: Code samples
---

# Code samples

## Simple samples:
All samples are in the public domain.  They are intentionally unstyled, and they usually lack features that make them usable.  They are intended to show how common patterns are performed in web.py.


* [Skeleton code](/skeleton/0.3). The very basics required to get started.
* [Todo-list](/src/todo-list/0.3). The simplest database-driven app possible.
* [Blog](/src/blog/0.3). A very simple blog, showing basic CRUD functionality.
* [wiki](/src/wiki/0.3). A very basic wiki engine.
* [zbox_wiki](https://github.com/shuge/zbox_wiki). A lightweight wiki system ([demo](http://wiki.shuge-lab.org/zbox-wiki/about-zboxwiki))



## Deprecated Samples:

These samples no longer works with the current version of web.py, but may still contain good patterns:

* [skeleton code](/skeleton/0.2)
* [simple todo-list engine](/src/todo-list/0.2)
* [simple del.icio.us clone](/src/lecker)

## Real Web Apps:

These are fully functional apps with code that have been built with web.py.  Note that these may be using older versions of web.py than the current release.

* [redditriver.com](http://redditriver.com): a mobile version of reddit.com ([src](http://www.catonmat.net/download/redditriver-dot-com-python-source-code.zip) and [how it was written](http://www.catonmat.net/blog/designing-redditriver-dot-com-website/))
* [webme](http://wm.justos.org/txt.intro): a blogging and podcasting system ([src](http://wm.justos.org/static/download/webme-0.2.0.tar.gz))
* [webr](http://www.antrix.net/stuff/webr): a [flickr](http://flickr.com) powered photo gallery
* [colr.org (v5)](http://www.colr.org/): A site for playing with colors. (see [rewrite](http://www.colr.org/rewrite.html))
* todo: a simple web.py example where you can create, delete and edit-in-place an item (CRUD). ([src](http://svn.natalian.org/projects/todo/))
* [music-share](http://github.com/andreisavu/music-share/tree/master): a simple web app for music sharing (mp3 files). ([src](http://github.com/andreisavu/music-share/tree/master))
* [Google Modules](http://www.googlemodules.com): an iGoogle Gadget directory written in MVC style. ([src](http://github.com/alexksikes/googlemodules))
* [Mailer](http://mailer.ksikes.net): a very simple mass mailer. ([src](http://github.com/alexksikes/mailer))
* [MLSS Admin](http://mlss.ksikes.net): a system to rate, comment and accept candidates for conferences and likes. ([src](http://github.com/alexksikes/MLSS))
* [Wikitrivia](http://www.wikitrivia.net): take randomly generated quizes generated using Wikipedia. ([src](http://github.com/alexksikes/wikitrivia))
* [onlinestore-multi](https://github.com/nopri/onlinestore-multi): simple online store application
* [sqliteboy](https://github.com/nopri/sqliteboy): simple SQLite manager/form application

## Tips and Tricks:

* [tricks with template.py](/template_tricks)
* [quick vhosting hack](/quick_vhosting_hack)
* [using a metaclass to automate setting urls](/MetaClassAutoURLS)
* [test your web application with paste](/testing)
* [Serving Images](/images)
* [Create multiple apps using web.py](/multiple_apps)
* [Templating with Genshi](/src/genshi)

---
layout: default
title: lec.ker - a simple del.icio.us clone
---

# lec.ker - a simple del.icio.us clone

_by Valentin Wüstholz_

### database (MySQL):

    CREATE TABLE  `lecker`.`bookmarks` (
      `id` int(10) unsigned NOT NULL auto_increment,
      `url` text NOT NULL,
      `created` timestamp NOT NULL default CURRENT_TIMESTAMP,
      `tags` text NOT NULL,
      `title` text NOT NULL,
      PRIMARY KEY  (`id`),
      UNIQUE KEY `id` (`id`)
    );

### source code:

    todo-list/
      lecker.py
      templates/
        view.html
        edit.html
        delete.html
        search.html

### `lecker.py`

        import web

        urls = (
            '/', 'view',
            '/add', 'add',
            '/delete', 'delete',
            '/edit/([0-9]*)', 'edit',
            '/search/(\S*)', 'search'        )

        class view:
            def GET(self):
                bookmarks = list(web.select("bookmarks", order="created desc"))
                for b in bookmarks:
                    b.tags = b.tags.split()
                web.render('view.html')

        class add:
            def POST(self):
                i = web.input()
                web.debug(type(i.tags))
                n = web.insert('bookmarks', title=i.title, url=i.url, tags=i.tags)
                web.seeother('./#t'+str(n))

        class delete:
            def GET(self):
                bookmarks = web.select("bookmarks", order="title")
                web.render('delete.html')
            def POST(self):
                i = web.input()
                web.debug(i)
                for item in i:
                    web.delete('bookmarks', 'id = '+item)
                web.seeother('./#')

        class edit:
            def GET(self, id):
                try:
                    bookmark = web.select("bookmarks", where="id = "+id)[0]
                    web.render('edit.html')
                except IndexError:
                    print "This bookmark doesn't exist."            def POST(self, id):
                i = web.input()
                web.update('bookmarks', 'id = '+id, title=i.title, url=i.url, tags=i.tags)
                web.seeother('../')

        class search:
            def GET(self, tag):
                bookmarks = []
                bs = list(web.select("bookmarks", order="created desc"))
                for b in bs:
                    b.tags = b.tags.split()
                    if tag in b.tags:
                        bookmarks.append(b)
                empty = (len(bookmarks) == 0)
                web.render('search.html')
            def POST(self, tag):
                i = web.input()
                tags = i.tags.split()
                bookmarks = []
                bs = list(web.select("bookmarks", order="created desc"))
                for b in bs:
                    b.tags = b.tags.split()
                    if every(lambda t: t in b.tags, tags):
                        bookmarks.append(b)
                empty = (len(bookmarks) == 0)
                web.render('search.html')

        def every(f, lst):
            for x in lst:
                if not f(x):
                    return False
            return True

        web.internalerror = web.debugerror
        web.db_parameters = dict(dbn='mysql', user='root', pw='', db='lecker')
        if __name__ == '__main__': web.run(urls, web.reloader)

### `view.html`

        <p><center><h1>lec.ker</h1></center></p>        
        <p>        <hr/>        </p>        
        <center>        <form name="search" method="post" action="search/#">        <p>        <p>        <input type="text" name="tags" size="50" />        </p>        <input type="submit" value="Search" />        </p>        </form>        </center>        
        <p>        <hr/>        </p>        
        <table border="0" width="100%">        #for bookmark in $bookmarks
             <colgroup>               <col width="50%">               <col width="35%">               <col width="15%">             </colgroup>             <tr>             <form name="del$bookmark.id" method="post" action="delete">             <td>               <a href="$bookmark.url"> $bookmark.title </a>             </td>             <td>             #for tag in $bookmark.tags
                  <a href="/search/$tag"> $tag </a> |
             #end for
             </td>             <td align="right">             <a href="edit/$bookmark.id">(edit)</a>             <input type="hidden" name="$bookmark.id" value="1" />             <a href="#" onclick=document.del${bookmark.id}.submit()>(delete)</a>             </td>             </form>             </tr>        #end for
        </table>        
        <p>        <hr/>        </p>        
        <form name="add" method="post" action="add">        <table border="0" width="100%">        <p>        <tr>          <td>            Title:
          </td>          <td>            <input type="text" name="title" size="100" />          </td>        </tr>        <tr>          <td>            Url:
          </td>          <td>            <input type="text" name="url" size="100" />          </td>        </tr>        <tr>          <td>            Tags:
          </td>          <td>            <input type="text" name="tags" size="100" />          </td>        </tr>        </p>        </table>        <p>        <input type="submit" value="Add" />        </p>        </form>        
        <a href="delete">Delete Bookmarks</a>
### `edit.html`

        <p><center><h1>lec.ker</h1></center></p>        
        <p><h2>Edit Bookmark:</h2></p>        
        <form method="post" action="">        <p>        <p>        Title:<input type="text" name="title" value="$bookmark.title" size="100" />        </p>        Url:<input type="text" name="url" value="$bookmark.url" size="100" />        </p>        Tags:<input type="text" name="tags" value="$bookmark.tags" size="100" />        </p>        <input type="submit" value="Edit" />        </p>        </form>        
        <p>        <hr/>        </p>        
        <a href="../">Back</a>
### `delete.html`

        <p><center><h1>lec.ker</h1></center></p>        
        <form name = "bookmarks" method="post" action="delete">          <p><h2>Delete Bookmarks:</h2></p>        
          <p>           #for bookmark in $bookmarks
                <input type="checkbox" name="$bookmark.id" value="1"> <a href="$bookmark.url"> $bookmark.title </a><br>           #end for
          </p>          <p><input type="submit" value="Delete" />          </p>        </form>        
        <p>        <hr/>        </p>        
        <a href="../">Back</a>
### `search.html`

        <p><center><h1>lec.ker</h1></center></p>        
        <table border="0" width="100%">        #for bookmark in $bookmarks
             <colgroup>               <col width="50%">               <col width="35%">               <col width="15%">             </colgroup>             <tr>             <form name="del$bookmark.id" method="post" action="../delete">             <td>               <a href="$bookmark.url"> $bookmark.title </a>             </td>             <td>             #for tag in $bookmark.tags
                  <a href="../search/$tag"> $tag </a> |
             #end for
             </td>             <td align="right">             <a href="../edit/$bookmark.id">(edit)</a>             <input type="hidden" name="$bookmark.id" value="1" />             <a href="#" onclick=document.del${bookmark.id}.submit()>(delete)</a>             </form>             </td>             </form>             </tr>        #end for
        </table>        #if $empty
             No Bookmarks were found.
        #end if
        </p>        
        <p>        <hr/>        </p>        
        <a href="../">Back</a>
---
layout: default
title: Basic Todo List in 0.2
---

# Basic Todo List in 0.2


**DEPRECATED!** This code won't work in the latest version of web.py.


Uses _web.py_ microframework: `web.py`, `template.py`, `form.py`.

Requires `PostgreSQL`, `lighttpd`, `psycopg2` and `flup`.

Note: This code is beta. This means: 2xplore at your own risk ;)

# Files:


    tidy/
      __init__.py
      app/
        __init__.py
        controller.py
      conf/
        httpd.conf
      db/
        model.sql
      static/
        favicon.ico
        icon.jpg
        style.css
      views/
        base.html
        login.html
        todos.html


## Main: 

__init__.py


    #! /usr/bin/env python
    'tidy: a tiny todo list web engine.'
    __version__ = '0.01beta' 
    __author__  = 'domimob'
    __license__ = 'public domain'
    #
    # Modules import.
    import web, app.controller
    #
    # App definition, via URL to class mapping.
    tidy = (
        '/', 'app.controller.Index',
        '/session', 'app.controller.Session',
        '/todo/add', 'app.controller.ToDo',
        '/todo/del/(\d+)', 'app.controller.ToDo',
        '/style.css', 'app.controller.Style' ,)
    #
    # Database connection definition.
    web.db_parameters = dict (
        dbn='postgres',
        user='domimob',
        pw='passwd', 
        db='tidydb' )
    #
    # App execution.
    if __name__ == '__main__': web.run(tidy)


## Model:

db/model.sql


    -- PostgreSQL database model.
    --
    create table todos (id serial primary key, title text);


## Controller:

app/__init__.py


    # Application modules import.
    #
    import controller


app/controller.py


    'todo-list web engine controller.'
    __version__ = '0.01beta' 
    __author__  = 'domimob' 
    #
    # Modules import.
    import web, template, form
    #
    # Views directory definition.
    view = template.render('views/')
    # 
    # Forms definition.
    loginForm = form.Form(form.Password('password'))
    addForm = form.Form(form.Textbox('new', form.notnull))
    #
    # RESTful class definition.
    class Index:
        'Index page object definition.'
        def GET(self):
            'Render the index page.'
            session = web.cookies()
            if not session:
                form = loginForm()
                print view.base(view.login(form))
            else:
                list = web.select('todos')
                form = addForm()
                print view.base(view.todos(list, form), session)
    #
    class Session:
        'Session object definition.'
        def GET(self):
            'Manage the user logout.'
            web.setcookie('user', '', 'Mon, 01-Jan-2000 00:00:00 GMT') 
            web.redirect('/')
        def POST(self):
            'Manage the user login.'
            login = web.input()
            if login.password == web.db_parameters['pw']:
                web.setcookie('user', web.db_parameters['user'])
            web.redirect('/')
    #
    class ToDo:
        'ToDo object definition.'
        def GET(self, id):
            'Delete a todo item, identified by parameter id.'
            web.delete('todos', int(id))
            web.redirect('/')
        def POST(self):
            'Add a todo item.'
            form = addForm()
            if form.validates():
                todo = web.input()
                web.insert('todos', title=todo.new)
            web.redirect('/')
    #
    class Style:
        'Style object definition.'
        def GET(self):
            'Render the stylesheet.'
            web.header("Content-Type","text/css; charset=utf-8")
            print open('static/style.css').read()


## Views:

views/base.html


    $def with (view, session=None)
    $# Base view definition.
    $#
    <html>
    <head>
        <title>tidy</title>
        <link rel="stylesheet" type="text/css" href="http://domimob.infogami.com/wiki/style.css"/>
    </head> 
    <body> 
        <table class="base">
            <tr><td><img src="static/icon.jpg"/></td></tr>
            $if session:
                <tr><td><h3>$session.user's todo list</h3></tr></td>
            $else:
                <tr><td><h3>a tiny todo list web engine</h3></tr></td>
            <tr><td>$:view</tr></td>
        </table>
    </body>
    </html>


views/todos.html


    $def with (list, form)
    $# Todos view definition.
    $# 
    $for todo in list:
        <a class ="todo" href="todo/del/$todo.id" title="click to delete">$todo.title</a><br/>
    <form method="post" action="todo/add">
        <br/>$:form.render()
    </form>
    <a href="/session">.logout</a>

views/login.html


    $def with (form)
    $# Login view definition.
    $#
    <form method="post" action="session">
        <br/>$:form.render()
    </form>

## Static Files:

static/style.css

    body { text-align: left; font-family: arial; color: #C0C0C0 } 
    table.base { width: 50%; text-align: left; margin: auto } 
    a { text-decoration: none; color: gray } 
    a:hover { text-decoration: overline }
    a.todo { text-decoration: none; font-weight: bolder; color: black } 
    a.todo:hover { text-decoration: line-through }

## Web Server:

conf/httpd.conf


    # LigHTTPd web server configuration.
    #
    # Server configuration.
    server.document-root = "/Users/domimob/lab/tidy/"
    server.modules = ("mod_fastcgi", "mod_rewrite")
    server.port = 8080
    #
    # FastCGI configuration.
    fastcgi.server = ( 
        "__init__.py" => ((
            "bin-path" => server.document-root + "/__init__.py",
            "socket" => "/tmp/fastcgi.socket",
            "max-procs" => 1 )))
    #
    # mod_rewrite configuration.
    url.rewrite-once = (
        "^/favicon.ico$" => "/static/favicon.ico", 
        "^/static/(.*)$" => "/static/$1", 
        "^/(.*)$" => "__init__.py/$1" ,)
---
layout: default
title: Basic Todo List in 0.3
---

# Basic Todo List in 0.3

# Todo list

Very basic todo list in 0.3 webpy. Probably the most trivial database-backed app possible.

## Files

    /schema.sql
    /templates:
        /templates/base.html
        /templates/index.html
    /model.py
    /todo.py


###/schema.sql

    CREATE TABLE todo (
        id INT AUTO_INCREMENT,
        title TEXT,
        primary key (id)
    );


###/templates/base.html

    $def with (page)
    
    <html>
    <head>
        <title>Todo list</title>
    </head>
    <body>
    
    $:page
    
    </body>
    </html>


###/templates/index.html


    $def with (todos, form)
    
    <table>
        <tr>
            <th>What to do ?</th>
            <th></th>
        </tr>
    $for todo in todos:
        <tr>
            <td>$todo.title</td>
            <td>
                <form action="/del/$todo.id" method="post">
                    <input type="submit" value="Delete"/>
                </form>
            </td>
        </tr>    
    </table>  
    
    <form action="" method="post">
    $:form.render()
    </form>


###/model.py


    import web
    
    db = web.database(dbn='mysql', db='todo', user='justin')
    
    def get_todos():
        return db.select('todo', order='id')
    
    def new_todo(text):
        db.insert('todo', title=text)
    
    def del_todo(id):
        db.delete('todo', where="id=$id", vars=locals())



###/todo.py


    """ Basic todo list using webpy 0.3 """
    import web
    import model
    
    ### Url mappings
    
    urls = (
        '/', 'Index',
        '/del/(\d+)', 'Delete'
    )
    
    
    ### Templates
    render = web.template.render('templates', base='base')
    
    
    class Index:
    
        form = web.form.Form(
            web.form.Textbox('title', web.form.notnull, 
                description="I need to:"),
            web.form.Button('Add todo'),
        )
    
        def GET(self):
            """ Show page """
            todos = model.get_todos()
            form = self.form()
            return render.index(todos, form)
    
        def POST(self):
            """ Add new entry """
            form = self.form()
            if not form.validates():
                todos = model.get_todos()
                return render.index(todos, form)
            model.new_todo(form.d.title)
            raise web.seeother('/')
    
    
    
    class Delete:
        
        def POST(self, id):
            """ Delete based on ID """
            id = int(id)
            model.del_todo(id)
            raise web.seeother('/')


    app = web.application(urls, globals())
    
    if __name__ == '__main__':
        app.run()
---
layout: default
title: bfzbzfb
---

# bfzbzfb


---
layout: default
title: Basic wiki in 0.3
---

# Basic wiki in 0.3

Basic wiki in Webpy 0.3.  Demonstrates basic idea behind wiki.  Lacks revisions.

## Files

    /schema.sql
    /wiki.py
    /templates:
        /templates/view.html
        /templates/new.html
        /templates/base.html
        /templates/index.html
        /templates/edit.html
    /model.py


###/schema.sql
    
    CREATE TABLE pages (
        id INT AUTO_INCREMENT,
        url TEXT,
        title TEXT,
        content TEXT,
        primary key (id)
    );
    



###/wiki.py


    """ Basic wiki using webpy 0.3 """
    import web
    import model
    import markdown
    
    ### Url mappings
    
    urls = (
        '/', 'Index',
        '/new', 'New',
        '/edit/(\d+)', 'Edit',
        '/delete/(\d+)', 'Delete',
        '/(.*)', 'Page',
    )
    
    
    ### Templates
    t_globals = {
        'datestr': web.datestr,
        'markdown': markdown.markdown,
    }
    render = web.template.render('templates', base='base', globals=t_globals)
    
    
    class Index:
    
        def GET(self):
            """ Show page """
            pages = model.get_pages()
            return render.index(pages)
    
    
    class Page:
        
        def GET(self, url):
            """ View single page """
            page = model.get_page_by_url(url)
            if not page:
                raise web.seeother('/new?url=%s' % web.websafe(url))
            return render.view(page)
    
    
    class New:
    
        def not_page_exists(url):
            return not bool(model.get_page_by_url(url))
    
        page_exists_validator = web.form.Validator('Page already exists', 
                                    not_page_exists)
    
        form = web.form.Form(
            web.form.Textbox('url', web.form.notnull, page_exists_validator,
                size=30,
                description="Location:"),
            web.form.Textbox('title', web.form.notnull, 
                size=30,
                description="Page title:"),
            web.form.Textarea('content', web.form.notnull, 
                rows=30, cols=80,
                description="Page content:", post="Use markdown syntax"),
            web.form.Button('Create page'),
        )
    
        def GET(self):
            url = web.input(url='').url
            form = self.form()
            form.fill({'url':url})
            return render.new(form)
    
        def POST(self):
            form = self.form()
            if not form.validates():
                return render.new(form)
            model.new_page(form.d.url, form.d.title, form.d.content)
            raise web.seeother('/' + form.d.url)
    
    
    class Delete:
        
        def POST(self, id):
            model.del_page(int(id))
            raise web.seeother('/')
    
    
    class Edit:
    
        form = web.form.Form(
            web.form.Textbox('url', web.form.notnull, 
                size=30,
                description="Location:"),
            web.form.Textbox('title', web.form.notnull, 
                size=30,
                description="Page title:"),
            web.form.Textarea('content', web.form.notnull, 
                rows=30, cols=80,
                description="Page content:", post="Use markdown syntax"),
            web.form.Button('Update page'),
        )
    
        def GET(self, id):
            page = model.get_page_by_id(int(id))
            form = self.form()
            form.fill(page)
            return render.edit(page, form)
    
    
        def POST(self, id):
            form = self.form()
            page = model.get_page_by_id(int(id))
            if not form.validates():
                return render.edit(page, form)
            model.update_page(int(id), form.d.url, form.d.title, form.d.content)
            raise web.seeother('/')
    
    
    app = web.application(urls, globals())
    
    if __name__ == '__main__':
        app.run()



###/templates/view.html


    $def with (page)
    
    $var title: $page.title
    
    <h1>$page.title</h1>
    
    $:markdown(page.content)
    
    
    <a href="/edit/$page.id">Edit</a>



###/templates/new.html


    $def with (form)
    
    
    <h1>New Wiki Page</h1>
    <form action="" method="post">
    $:form.render()
    </form>



###/templates/base.html


    $def with (page)
    
    <html>
    <head>
        $if page.has_key('title'):
            <title>$page.title</title>
        $else:
            <title>My Wiki</title>
        <style>
        </style>
    </head>
    <body>
    
    <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/new">New Page</a></li>
    </ul>
    
    $:page
    
    </body>
    </html>



###/templates/index.html


    $def with (pages)
    
    <h1>Webpy Wiki</h1>
    
    <h2>Pages:</h2>
    
    <ul>
    $for page in pages:
        <li><a href="/$page.url">$page.url</a></li>
    
    </ul>



###/templates/edit.html


    $def with (page, form)
    
    <h1>Edit $form.d.title</h1>
    
    <form action="" method="post">
    $:form.render()
    </form>
    
    
    <h2>Delete page?</h2>
    <form action="/delete/$page.id" method="post">
        <input type="submit" value="Delete page"/>
    </form>



###/model.py


    import web
    
    db = web.database(dbn='mysql', db='wiki', user='justin')
    
    def get_pages():
        return db.select('pages', order='id DESC')
    
    def get_page_by_url(url):
        try:
            return db.select('pages', where='url=$url', vars=locals())[0]
        except IndexError:
            return None
    
    def get_page_by_id(id):
        try:
            return db.select('pages', where='id=$id', vars=locals())[0]
        except IndexError:
            return None
    
    def new_page(url, title, text):
        db.insert('pages', url=url, title=title, content=text)
    
    def del_page(id):
        db.delete('pages', where="id=$id", vars=locals())
    
    def update_page(id, url, title, text):
        db.update('pages', where="id=$id", vars=locals(),
            url=url, title=title, content=text)
- Latest version, 
- implementation details, 
- usage information 
- and a test suite
found at <http://code.google.com/p/repetitionmodel/>
---
layout: default
title: Symonds.net
---

# Symonds.net

I was able to get web.py running without too much trouble on my hosting service [Symonds.net](http://symonds.net/). I created a personal status page with it, which can be viewed [here](http://deepak.jois.name). The source code for the page is also included.

## Getting it up

web.py can be run on Symonds.net using FastCGI.

Note that the Python installation on Symonds.net did not have the following modules installed, so I had to install it inside my local folder.  

* Cheetah
* [flup](http://www.saddi.com/software/flup/)

Follow the instructions on your host:

* change directory into the newly created domain, e.g : `cd deepak`
* `wget http://webpy.org/web.py`
* `wget http://www.saddi.com/software/flup/dist/flup-r1839.tar.gz`
* `tar zxvf flup-r1839.tar.gz`
* `mv flup-r1839/flup/ ./flup`

On your local machine, as superuser :

* Download Cheetah from <http://sourceforge.net/project/showfiles.php?group_id=28961&package_id=20864&release_id=391008> and extract it.
* Extract it using `tar xvzf  Cheetah-2.0rc4.tar.gz`
* Install it using : `cd Cheetah-2.0rc4` and `python setup.py install`
* Copy the folder named `/usr/lib/python<version>/site-packages/Cheetah` to your host in the same folder you downloaded `web.py` : `scp -r /usr/lib/python2.4/site-packages/Cheetah username@hostname:public_html/deepak/`

After that, include the following in the `.htaccess` file inside the folder you downloaded `web.py`:

     Options FollowSymLinks ExecCGI
     
     <Files *py>     SetHandler cgi-script
     Addhandler cgi-script py
     </Files>
You might also want to include some URL redirection directives like :

      RewriteEngine on
      RewriteRule    ^status$ status.py/status

After this, you should be able to view your web.py app like [here](http://deepak.jois.name/status).
---
layout: default
title: template tricks
---

# template tricks

### Testing template rendering

Test the rendering of a template.py template

        def renderTemplate(templatename,*args,**kw):
            '''quick way to test a template.py template'''            
            import template
            if not "." in templatename:
                templatename = templatename + ".tmpl"            
                obj = template.Template(open(templatename).read())
            return obj(*args,**kw)

        print renderTemplate("homepage", now=time.ctime())

If your template takes a dict or a storage, then you can just
set global values and let those get passed in:

        username = "User"        
        lastvisit = "yesterday"        
        print renderTemplate("results", store=web.Storage(globals()))

---

### Using the Prototype Javascript library

If you are using a Javascript library, such as Prototype, that binds $
so that it can provide shorthand Javascript functions like $, $A, $F and $H,
then you'll need to do a few things to make it work:

1. Provide additional keyword args, as shown below, in your template
function declaration, so that when template.py can pass-through
the Prototype dollar-sign syntax. 

        $def with (arg1, arg2, ELT="$", F="$F", H="$H", A="$A")

    Note that since $ is special, we are providing
`$ELT` as a replacement Javascript function name.

1. Leave a space after your usage of `$ELT` et al. so that template.py
will not try to funcall it when it sees the parentheses.   

        var cmd = $F ('command');
	`$ELT ('result').value = originalRequest.responseText;`

    Javascript is fine with the space between the function name and arguments, and if
you forget the space, you'll get this error from template.py:

        'str' object is not callable

1. Alternatively if you're only using the $ functions a few times, you can just add a $; before the $ and the templator will render it correctly:

        myElement = $$('elementID');

---

---
layout: default
title: web.py templating system (codename: templetor)
---

# web.py templating system (codename: templetor)

There are almost as many Python templating systems as there are web 
frameworks (and, indeed, it seems like many templating systems are 
adopting web framework-like features), so it is with some trepidation 
that I work on a new one. Sadly, again I find that my requirements are 
met by nothing else: 

1. The templating system has to _look_ decent. No `<%#foo#%>` crud. 
2. Reuse Python terms and semantics as much as possible. 
3. Expressive enough to do real computation. 
4. Usable for any text language, not just HTML and XML. 

And requirements for the implementation as well: 

4. Sandboxable so that you can let untrusted users write templates. 
5. Simple and fast implementation. 

So here's my entry. 

## Variable substitution 

    Look, a $string. 
    Hark, an ${arbitrary + expression}. 
    Gawk, a $dictionary[key].function('argument'). 
    Cool, a $(limit)ing. 

    Stop, \$money isn't evaluated. 

We use basically the same semantics as (rejected) [PEP 
215](http://www.python.org/peps/pep-0215.html). Variables can go 
anywhere in a document. 

## Newline suppression 

    If you put a backslash \ 
    at the end of a line \ 
    (like these) \ 
    then there will be no newline. 

renders as all one line. 

## Expressions 

    Here are some expressions: 

    $for var in iterator: I like $var! 

    $if times > max: 
        Stop! In the name of love. 
    $else: 
        Keep on, you can do it. 

    That's all, folks. 

All your old Python friends are here: `if`, `while`, `for`, `else`, `break`, `continue`, and `pass` also act as you'd 
expect. (Obviously, you can't have variables named any of these.) The 
Python code starts at the `$` and ends at the `:`. The `$` has to be 
at the beginning of the line, but that's not such a burden because of 
newline suppression (above). 

Also, we're very careful about spacing -- all the lines will render 
with no spaces at the beginning. (Open question: what if you want 
spaces at the beginning?)  Also, a trailing space might break your
code.

There are a couple changes from Python: `for` and `while` now take an 
`else` clause that gets called if the loop is never evaluated. 

(Possible feature to add: Django-style for loop variables.) 

## Comments 

    $# Here's where we hoodwink the folks at home: 

    Please enter in your deets: 

    CC: [       ]  $#this is the important one 
    SSN: $#Social Security Number#$ [       ] 

Comments start with `$#` and go to `#$` or the end of the line, 
whichever is first. 

## Code 

**NOTE: This feature has not been implemented in the current web.py implementation of templetor.**

    Sometimes you just need to break out the Python. 

    $ mapping = { 
    $   'cool': ['nice', 'sweet', 'hot'], 
    $   'suck': ['bad', 'evil', 'awful'] 
    $ } 

    Isn't that $mapping[thought]? 
    That's$ del mapping $ fine with me. 

    $ complicatedfunc() 

    $ for x in bugs: 
        $ if bug.level == 'severe': 
            Ooh, this one is bad. 
            $ continue 
        And there's $x... 

**Body of loops have to be indented with exactly 4 spaces.**

Code begins with a `$` and a space and goes until the next `$` or the 
end of the line, whichever comes first. Nothing ever gets output if 
the first character after the `$` is a space (so `complicatedfunc` 
above doesn't write anything to the screen like it might without the 
space). 

## Python integration 

A template begins with a line like this:

    $def with (name, title, company='BigCo')

which declares that the template takes those arguments. (The `with` 
keyword is special, like `def` or `if`.) 

**Don't forget to put spaces in the definition**

The following *will not work*:

    $def with (name,title,company='BigCo')

Inside Python, the template looks like a function that takes these 
arguments. It returns a storage object with the special property that 
evaluating it as a string returns the value of the body of the 
template. The elements in the storage object are the results of the 
`def`s and the `set`s. 

Perhaps an example will make this clearer. Here's a template, "entry": 

    $def with (post)

    $var title: $post.title 

    <p>$markdown(post.body)</p> 

    <p class="byline">by $post.author</p> 

Here's another; "base": 

    $def with (self)
    <html><head> 
      <title>$self.title</title> 
    </head><body> 
    <h1>$self.title</h1> 

    $:self 
    </body></html> 

Now let's say we compile both from within Python, the first as `entry`, 
the second as `base`. Here's how we might use them: 

    print base( entry( post ) )

`entry` takes the argument post and returns an object whose string 
value is a bit of HTML showing the post with its title in the property 
`title`. `base` takes this object and places the title in the 
appropriate place and displays the page itself in the body of the 
page. The Python code prints out the result. 

_Where did `markdown` come from? It wasn't passed as an argument._ You 
can pass a list of functions and variables to the template compiler to 
be made globally available to templates.
_Why $:self?_ See below

Here's an example:

    import template
    render = template.render('templates/')
    template.Template.globals['len'] = len
    
    print render.base(render.message('Hello, world!'))

The first line imports templetor. The second says that our templates are in the directory `templates/`. The third give all our templates access to the `len` function. The fourth grabs the template `message.html`, passes it the argument `'Hello, world!'`, passes the result of rendering it to [mcitp](http://www.buyitcert.com/mcitp.html) the template `base.html` and prints the result. (If your templates don't end in `.html` or `.xml`, templetor will still find them, but it won't do its automatic HTML-encoding.)

## Turning Off Filter
By default `template.render` will use `web.websafe` filter to do HTML-encoding. To turn it off, put a : after the $ as in:

    $:form.render()

Output from form.render() will be displayed as is.

    $:fooBar    $# fooBar = <span>lorem ipsum</span>

Output from variable in template will be displayed as is.

## Including / nesting templates
If you want to nest one template within another, you nest the `render()` calls, and then include the variable (unfiltered) in the page.
In your handler:
    
    print render.foo(render.bar())

or (to make things a little more clear):

    barhtml = render.bar()
    print render.foo(barhtml)

Then in the template `foo.html`:
    
    $def with (bar)
    html goes here
    $:bar
    more html

This replaces the `$:bar` with the output of the `render.bar()` call (which is why it must be `$:`/unfiltered, so [ccnp](http://www.buyitcert.com/ccnp.html) that you get un-encoded HTML (unless you want something else of course)).  You can pass variables in, in the same way:

    print render.foo(render.bar(baz), qux)

In the template bar (`bar.html`):

    $def with (baz)
    bar stuff goes here + baz

In template foo (`foo.html`):
    
    $def with (bar, qux)
    html goes here
    $:bar
    Value of qux is $qux

## Links
---
layout: default
title: Testing webpy applications
---

# Testing webpy applications

See [Testing with Paste and Nose](/cookbook/testing_with_paste_and_nose)
---
layout: default
title: Using web.py on TextDrive
---

# Using web.py on TextDrive

[TextDrive](http://textdrive.com/) graciously provided me with a free shared hosting account to try to get web.py running on their system. I'm keeping notes on what I did here.

I got assigned `aaronsw.textdriven.com` on the server `cardero.textdrive.com` -- you should replace these in my instructions with whatever your server names are.

## Getting it up

First, [file a support ticket](http://help.textdrive.com/index.php?pg=request) requesting a port to run web.py on. Apparently filing such a ticket [is standard practice](http://help.textdrive.com/index.php?pg=kb.page&id=106) for running web apps on TextDrive. You'll get back a number, which we'll call `8048` (obviously you'll want to replace this with the actual number you get).
Second, SSH to `aaronsw.textdriven.com` and run:

    cd web/public/
    mkdir work
    cd work
    wget http://webpy.org/web.py
    # copy my script to code.py in this directory
    python code.py 8048

Now check `http://aaronsw.textdriven.com:8048/` -- you should see your script working.

Now you can log into your webmin (`https://webmin.cardero.textdrive.com/`), click "Apache Webserver", click "Aliases and Redirects", and scroll down to "Map local to remote URLs". Add a line with / in the first box, check the second radio button, and put `http://aaronsw.textdriven.com:8048/` (don't forget to include the n in textdriven!) in the second box. Click "Save". Then click "Apply Changes" (in the upper right corner).

Now check `http://aaronsw.textdriven.com/` -- you should see your script working again.

## Install Cheetah

Installing Cheetah on TextDrive is quite straight forward. Check [here](http://thetruedelight.blogspot.com/2006/12/how-to-install-cheetah-on-textdrive_19.html) to see the full installation script. 

## Keeping it up

In your SSH window, type Ctrl-C to kill the Python script and run:

    python ~aaronsw/web/public/work/code.py 8048 2>/dev/null &
This will run your web.py app as a daemon, so you can log out and it will stay running.

To make sure that the server starts your script back up when it reboots, go into webmin, click "Scheduled Cron Jobs", click "Create a new scheduled cron job", and add this as the command. Click the radio button next to "Simple schedule..." and select "When system boots" from the drop down menu. Then click "Create".

(Note: My server hasn't rebooted yet, so I haven't gotten a chance to test that this works.)

## Making it fast

For reasons I don't quite understand lighttpd proxying to web.py is faster than running web.py directly. So if you want your server to support more serious loads, you should run a simple lighttpd instance on port 8048 and have it talk to web.py through FastCGI. TextDrive has a [knowledge base article](http://help.textdrive.com/index.php?pg=kb.page&id=252) on setting up lighttpd.
---
layout: default
title: todo
---

# todo

## big projects

* session library 

## medium-sized projects

* Finish implementing templetor.

## small things

* Cause templetor to stop caching templates automatically when web.reloader is on.
* Compile templator templates to Python byte code, so they would be useful for poor man CGI only web app.

_See also:_ [ideas](/ideas) list
---
layout: default
title: tricks
---

# tricks

* [using flup on Windows](http://groups.google.com/group/webpy/msg/722acab404514de4?)
* [using Routes](http://groups.google.com/group/webpy/browse_frm/thread/17b5065fe98cbe14/555152afc25501ff)
* [XMLRPC usage](http://webpy.org/tricks/xmlrpc)
---
layout: default
title: tricks/xmlrpc
---

# tricks/xmlrpc

This is a simple recipe how to use XMLRPC with web.py

I wrote some generic xmlrpc adaptor for web.py and drop it to webxml.py,
you can see this below

    import web
    from SimpleXMLRPCServer import SimpleXMLRPCDispatcher
    dispatcher = SimpleXMLRPCDispatcher(allow_none = False, encoding = "UTF-8")

    def init(urllist):
        global dispatcher
        for it in range(len(urllist)/2):
            #dispatcher.register_function(urllist[it+1], urllist[it])
            dispatcher.register_function(urllist[(it*2)+1], urllist[(it*2)])

    class rpc:
        def GET(self):
            global dispatcher
            methods = dispatcher.system_listMethods()
            web.header('Content-Type', 'text/html')
            print "<body><h1>Error!</h1>"
            print "Method GET is not alowed for XMLRPC requests"
            print "List of available methods:"
            print "<ul>"
            for method in methods:
                sig = dispatcher.system_methodSignature(method)
                help =  dispatcher.system_methodHelp(method)
                print "<li><b>%s</b>: [%s] %s</li>" % (method, sig, help)
            print "</ul>"
            print "Be careful"
            print "</body>"
        def POST(self):
            global dispatcher
            response = dispatcher._marshaled_dispatch(web.webapi.data())
            web.header('Content-length', str(len(response)))
            print response

This library slightly based on xmlrpc Django code, but rewriten from scratch at last stage.
Now look at simple usage pattern

    import web
    import webxml
    
    def multiply(x,y):
        return x*y
    
    xmlrpcurls = (
        'mult', multiply
        # Look! First parameter is a public name, second is a lambda value, not string!
    )
    urls = (
        '/rpc/', 'webxml.rpc'    )

    webxml.init(xmlrpcurls)
    if __name__ == "__main__": web.run(urls, globals())

---
layout: default
title: Φροντιστήριο για το web.py 0.2
---

# Φροντιστήριο για το web.py 0.2

## Ξεκινώντας

Αν γνωρίζετε Python και θέλετε να φτιάξετε ένα σάιτ, το web.py παρέχει τον κώδικα ώστε να το φτιάξετε εύκολα.

Για να παρακολουθήσετε ολόκληρο το φροντιστήριο, θα πρέπει να έχετε εγκατεστημένα τα εξής: Python, web.py, flup, psycopg2 και Postgres (ή κάποια αντίστοιχη βάση δεδομένων και τον οδηγό της). Για οδηγίες, κοιτάχτε [εδώ](http://webpy.org/install).

Αν έχετε ήδη ένα υπάρχον πρότζεκτ γραμμένο σε web.py, ρίχτε μια ματιά στην σελίδα [αναβάθμισης](http://webpy.infogami.com/upgrade_to_point2) για πληροφορίες μεταφοράς.

Ας ξεκινήσουμε.

## Διαχείριση των URL

Το πιο σημαντικό κομμάτι κάθε σάιτ είναι η δομή των URL του. Τα URL σας δεν είναι μόνο αυτά που βλέπουν οι επισκέπτες σας, και τα οποία στέλνουν με μέηλ στους φίλους τους, αλλά επίσης παρέχουν ένα νοητό μοντέλο του πως δουλεύει το σάιτ. Σε δημοφιλή σάιτ όπως το [del.icio.us](http://del.icio.us/|del.icio.us), τα URL είναι κομμάτι του user interface. Το web.py σας βοηθά να φτιάχνετε καλά URL.

Για να ξεκινήσετε την εφαρμογή σας, ανοίξτε ένα νέο αρχείο κειμένου (ας το πούμε `code.py`) και γράψτε:

    import web.py

Έτσι αποκτούμε πρόσβαση στον κώδικα του web.py.

Τώρα, χρειαζόμαστε να πούμε στο web.py την δομή των URL μας. Ας βάλουμε κάτι απλό για αρχή:

    urls = (
      '/', 'index',
      '',  'index'    )

Το πρώτο μέρος είναι μια [κανονική έκφραση](http://osteele.com/tools/rework/) που ταιριάζει ένα URL, όπως τα `/`, `/help/faq`, `/item/(\d+)`, κτλ (σημ: το `\d+` ταιριάζει μια ακολουθία αριθμών). Οι παρενθέσεις σώζουν το κείμενο που ταιριάχτηκε με τα δεδομένα για περαιτέρω χρήση. Το δεύτερο μέρος είναι το όνομα της κλάσης στην οποία στέλνουμε το αίτημα, όπως: `index`, `view`, `welcomes.hello` (η οποία παίρνει την κλάση `hello` από το `welcomes`) ή `get_\1`. Το `\1` αντικαθίσταται από το πρώτο μέρος της κανονικής έκφρασης που σώθηκε νωρίτερα· τα υπόλοιπα κομμάτια της κανονικής έκφρασης που σώθηκαν περνάνε στην συνάρτησή σας.

Η γραμμή μας λέει πως θέλουμε το URL `/` (σημ: η πρώτη σελίδα) να το χειρίζεται η κλάση με όνομα `index`.

Τώρα πρέπει να γράψουμε την κλάση `index`. Παρόλο που οι περισσότεροι άνθρωποι δεν το προσέχουν καθώς κινούνται στο δίκτυο, ο μπράουζερ χρησιμοποιεί μια γλώσσα γνωστή ως HTTP για επικοινωνία με το Παγκόσμιο Ιστό. Οι λεπτομέρειες δεν είναι σημαντικές, αλλά η βασική ιδέα είναι πως οι επισκέπτες του Ιστού ζητάνε από τους σέρβερ να εκτελέσουν καθορισμένες λειτουργίες (όπως `GET` ή `POST`) πάνω σε URL (όπως `/` ή `/foo?f=1`).

Το `GET` είναι αυτό με το οποίο είμαστε όλοι εξοικειωμένοι, αυτό που χρησιμοποιούμε όταν ζητάμε μια ιστοσελίδα. Όταν γράφετε `harvard.edu` στο μπράουζερ, αυτός ουσιαστικά ζητά από τον σέρβερ του Χάρβαρντ να φέρει (`GET`) το `/`. Το δεύτερο πιο γνωστό, το `POST`, συχνά χρησιμοποιείται όταν υποβάλουμε κάποιες φόρμες, όπως μια αίτηση για αγορά. Χρησιμοποιούμε το `POST` όταν η πράξη της υποβολής ενός αιτήματος _κάνει κάτι_ (χρεώνει την πιστωτική μας κάρτα και εκτελεί την παραγγελία). Αυτό είναι ουσιώδες, καθώς τα URL που τα κάνουμε `GET` μπορούμε να τα χρησιμοποιήσουμε εδώ κι εκεί, ακόμη και να τα ταξινομήσουμε σε μια μηχανή αναζήτησης, που είναι αυτό που θέλουμε για τις περισσότερες σελίδες, αλλά οπωσδήποτε όχι για πράγματα όπως η διαχείριση μιας παραγγελίας (σκεφτείτε το Google να προσπαθεί να αγοράσει τα πάντα από το σάιτ σας!).

Στον κώδικά μας με το web.py, κάνουμε αυτή την διάκριση σαφή:

    class index:
      def GET(self):
          print "Hello, world!"

Αυτή η συνάρτηση `GET` θα κληθεί από το web.py κάθε φορά που κάποιος κάνει μια αίτηση `GET` για το `/`.

Ωραία, τώρα χρειάζεται να το τελειώσουμε με μια τελική γραμμή που να λέει στο web.py να αρχίζει να εξυπηρετεί τις σελίδες.

    if __name__ == "__main__": web.run(urls, globals())

Αυτό λέει στο web.py να σερβίρει τα URL που του δώσαμε παραπάνω, ψάχνοντας στις κλάσεις από τον καθολικό χώρο ονομάτων (namespace) του αρχείου.

Τώρα, προσέξτε, πως ενώ μιλάω πολύ, έχουμε γράψει μόνο πέντε γραμμές κώδικα. Μόνο αυτό χρειάζεστε για να φτιάξετε μια πλήρη web application. Αν πάτε στον φλοιό και γράψετε:

    $ python code.py
    Launching server: http://0.0.0.0:8080/

θα έχετε την εφαρμογή σας να τρέχει σ' έναν πραγματικό σέρβερ στον υπολογιστή σας. Επισκεφθείτε το URL και θα δείτε το "Hello, world!" (Μπορείτε να προσθέσετε  μια διεύθυνση IP και μια θύρα μετά το "code.py" για να ρυθμίσετε που θα τρέξει το web.py τον σέρβερ. Μπορείτε επίσης να διαλέξετε να τρέξετε έναν fastcgi σέρβερ ή έναν cgi.)

Σημείωση: Μπορείτε να ορίσετε τον αριθμό θύρας αν δεν σας αρέσει ο προκαθορισμένος:

    $ python code.py 1234


## Κατά την ανάπτυξη

Το web.py έχει μερικά εργαλεία που μας βοηθάνε στο debbuging. Πριν το `if __name__` στην τελευταία γραμμή, προσθέστε:

    web.webapi.internalerror = web.debugerror

Αυτό μας δίνει κάπως πιο βοηθητικά μηνύματα σφαλμάτων. Και στην τελευταία γραμμή προσθέστε `web.reloader` ώστε να είναι έτσι:

    if __name__ == "__main__": web.run(urls, globals(), web.reloader)

Αυτό λέει στο web.py να χρησιμοποιήσει το "ενδιάμεσο" κομμάτι κώδικα web.reloader (το ενδιάμεσο είναι ένα κομμάτι κώδικα, σαν περίβλημα, που προσθέτει κάποιες λειτουργίες στον σέρβερ μας), που φορτώνει τα αρχεία μας όταν τα αλλάζουμε, ώστε να βλέπουμε τις αλλαγές στον μπράουζερ απευθείας. (Για σημαντικές αλλαγές όμως, χρειάζεται να ξαναξεκινάμε τον σέρβερ). Μάλλον θα θέλετε να το βγάλετε όταν κάνετε το σάιτ σας δημόσιο, αλλά είναι σπουδαίο κατά την ανάπτυξη. Υπάρχει επίσης ο `web.profiler`, που εκτυπώνει πληροφορίες για το πόση ώρα έκανε κάθε συνάρτηση κατά την εκτέλεση, στο τέλος της σελίδας, ώστε να κάνετε τον κώδικά σας πιο γρήγορο.

## Πρότυπα

Το να γράφουμε HTML μέσα από την Python είναι επίπονο· έχει περισσότερο γούστο να γράφουμε Python μέσα σε HTML. Ευτυχώς, το web.py το καθιστά εύκολο αυτό.

Σημείωση: Παλαιότερες εκδόσεις του web.py χρησιμοποιούσαν τα [Πρότυπα Cheetah](http://www.cheetahtemplate.org/). Είναι, βεβαίως, στην ευχέρειά σας να χρησιμοποιήσετε αυτό ή οποιοδήποτε άλλο πρόγραμμα με το web.py, αλλά δεν υποστηρίζετε πλέον επίσημα.

Ας φτιάξουμε έναν νέο κατάλογο για τα πρότυπά μας (θα τον λέμε `templates`). Εκεί μέσα, θα φτιάξουμε ένα αρχείο που το όνομά του τελειώνει σε HTML (ας πούμε index.html). Τώρα, μέσα στο αρχείο αυτό, μπορούμε να γράψουμε απλή HTML:

    <em>Hello</em>, world!

Ή, μπορούμε να χρησιμοποιήσουμε την γλώσσα προτύπου του web.py για να προσθέσουμε κώδικα στην HTML:

    $def with (name)

    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

Σημείωση: για τώρα, απαιτούνται τέσσερα ακριβώς κενά.

Όπως βλέπετε, το πρότυπο μοιάζει αρκετά με αρχείο Python, εκτός της δήλωσης `def with` στην κορυφή (που λέει με τι καλείται το πρότυπο) και τα δολλάρια που προστίθενται στην αρχή κάθε γραμμής κώδικα. Για την ώρα, το template.py απαιτεί η δήλωσω `$def` να είναι στην πρώτη γραμμή του αρχείου. Επίσης, προσέξτε πως το web.py αυτόματα κρύβει κάθε μεταβλητή που χρησιμοποιείται, ούτως ώστε αν για κάποιο λόγο το `name` περιέχει HTML, αυτό θα εμφανιζόταν κανονικά ως κείμενο. Αν δεν θέλετε αυτή την λειτουργία, γράψτε `$:name` αντί για `$name`.

Τώρα, πίσω στο `code.py`. Υπό την πρώτη γραμμή, προσθέστε:

    render = web.template.render('templates/')

Αυτό λέει στο web.py να ψάξει για πρότυπα στον κατάλογο `templates`. Μετά, αλλάξτε το `index.GET` σε:

    name = 'Bob'
    print render.index(name)

('index' είναι το όνομα του προτύπου και 'name' το όρισμα που του περνάμε).

Πηγαίντε στο σάιτ σας και τώρα πρέπει να λέει γεια τον Μπομπ.

Συμβουλή ανάπτυξης: Προσθέστε `cache=False` στο τέλος της κλήσης του `render` ώστε το web.py να φορτώνει αυτόματα όποιες αλλαγές έχετε κάνει στην σελίδα.

Αλλά, ας υποθέσουμε πώς θέλουμε οι άνθρωποι να βάζουν το δικό τους όνομα. Αντικαταστήστε τις δύο παραπάνω γραμμές με τις παρακάτω:

    i = web.input(name=None)
    print render.index(i.name)

Πηγαίντε στο `/` και πρέπει να χαιρετάει τον κόσμο. Πηγαίντε στο `/?name=Joe` και θα χαιρετάει τον Τζο.

Βέβαια, έχοντας το `?` στο URL είναι κάθως απωθητικό. Γι' αυτό αλλάξετε τα URL στην κορυφή με:

    '/(.*)', 'index'

και αλλάξτε τον ορισμό του `index.GET` σε:

    def GET(self, name):
        print render.index(name)

και διαγράψτε την γραμμή που ορίζει το όνομα. Τώρα πηγαίντε στο `/Joe` και θα χαιρετάει τον Τζο.

Αν θέλετε να μάθετε περισσότερα για τα πρότυπα στο web.py, επισκεφτείτε την σελίδα [templetor](http://webpy.org/templetor).

## Βάσεις

...
---
layout: default
title: Tutorial
---

# Tutorial


---
layout: default
title: web.py tutorial
---

# web.py tutorial

* [english](http://webpy.org/docs/0.3/tutorial)
* português: [1](http://www.writely.com/View.aspx?docid=bbcm927cd2fmj) [2](http://www.writely.com/View.aspx?docid=bbcm927cd2fmj) [3](http://www.writely.com/View.aspx?docid=bbcm927cd2fmj)
* [français](http://sunfox.org/tutoriel-web-py-fr/)
* [pусский](http://bobuk.infogami.com/webpytrans)
* [日本語](http://kinneko.googlepages.com/webpy_tutorial_ja)
---
layout: default
title: web.py 0.2 tutorial
---

# web.py 0.2 tutorial

## Starting

Du kennst also Python und willst eine Webseite erstellen. web.py gibt dir die Möglichkeit, das leicht zu bewerkstelligen.

Wenn du das ganze Tutorial durcharbeiten willst, wirst du python, web.py, flup, psycopg2 und postgres brauchen. Weitere Details dazu auf [webpy.org](http://webpy.org/).

Wenn du bereits ein web.py Projekt hast, schau am besten auf die [upgrade](http://webpy.infogami.com/upgrade_to_point2) Seite (in Englisch) für Informationen zur Migration. 

Legen wir mal los...

## URL Handling

Der wichtigste Bestandteil einer Website ist die URL Struktur. Die URLs sind nicht nur das, was deine Besucher sehen und an ihre Freunde mailen, sie dienen auch als mentales Model, das zeigt, wie die Webseite funktioniert. Bei bekannten Webseiten wie etwa [del.icio.us](http://del.icio.us) sind die URLs sogar ein Teil des Benutzerinterfaces. web.py macht es leicht, gute URLs zu erstellen.

Um mit deinem web.py-Programm anzufangen, öffne eine neue Textdatei (nenn sie `code.py`) und tippe:

    import web

Dadurch wird das web.py-Modul importiert.

Nun müssen wir web.py unsere URL Struktur bekanntmachen, wir beginnen mit etwas Einfachem:

    urls = (
      '/', 'index'    )

Der erste Teil ist ein [regulärer Ausdruck](http://osteele.com/tools/rework/) dem die URL entsprechen muss, beispielsweise ``/``, ``/help/faq``, ``/item/(\d+)``, etc. (Das ``\d+`` entspricht einer Ziffernfolge. Die runden Klammern bewirken, dass das "gefundene" für später aufgehoben wird. )

Der zweite Teil ist der Name der Klasse an welche die Anfrage geschickt wird, beispielsweise `index`, `view`, `welcomes.hello` (gibt die Anfrage an die Klasse `hello` des Moduls `welcomes`), oder `get_\1`. `\1` wird durch den ersten Treffer (geklammerten Teil) des regulären Ausdrucks ersetzt, alle verbleibenden Funde werden an die Funktion weitergeleitet.

Diese Zeile sagt das wir die URL `/` (die Startseite) mit der Klasse namens `index` bearbeiten wollen.

Nun müssen wir die `index`-Klasse schreiben. Die meisten Leute bemerken es beim Surfen nicht, aber der Browser verwendet eine Sprache, die als HTTP bekannt ist, zur Kommunikation mit dem WWW. Die Details dazu sind nicht wichtig, aber die eigentliche Idee ist, dass die Besucher den Webserver auffordern, bestimmte Funktionen (wie eta `GET` oder `POST`) an URLs (wie `/` oder `/foo?f=1`) auszuführen.

`GET` ist die bekannteste Funktion. Sie wird verwendet, um den Text oder Inhalt einer Webseite anzufordern. Wenn du in deinem Browser `harvard.edu` eintippst, dann forderst du im wahrsten Sinne des Wortes den Harvard Webserver auf "to `GET /`". Am zweit bekanntesten ist `POST`. POST wird oft verwendet, wenn man ein Formular abschickt, wie zum Beispiel eine Anfrage etwas zu kaufen. Du benutzt `POST` immer dann, wenn das Abschicken der Anfrage etwas bewirkt (wenn du die Kreditkarte belastest oder eine Bestellung aufgibst). Das ist sehr wichtig, denn `GET` URLs können herum gereicht werden und von Suchmaschinen indexiert werden. Das ist zwar etwas, was du für einen Großteil deiner Seite willst, aber bestimmt _nicht_ für Dinge wie Bestellungen aufgeben. (Stell dir vor, Google würde versuchen alles auf deiner Seite zu kaufen).


In unserem web.py-Quellcode können wir diese zwei Funktionen unterscheiden:

    class index:
        def GET(self):
            print "Hello, world!"

Die `GET`-Funktion wird nun aufgerufen, wenn jemand eine `GET` Anfrage an `/` schickt.

Gut, nun müssen wir nur noch eine Zeile hinzufügen, um web.py zu sagen, dass es Webseiten zur Verfügung stellen soll.

    if __name__ == "__main__": web.run(urls, globals())

Das sagt web.py, dass es die URLs, die wir oben definiert haben bereitstellen soll, indem es die Klassen aufruft, die wir in der Datei global definiert haben.

Nun, obwohl du bereits viel gelesen hast, haben wir eigentlich nur etwa fünf Zeilen geschrieben. Das ist eigentlich auch alles, was du für eine komplette web.py-Applikation brauchst.

Wenn du nun in deine Kommandozeile gehst und folgendes tippst:

    $ python code.py
    Launching server: http://0.0.0.0:8080/

Dann wird deine web.py-Applikation einen Webserver auf deinem Computer laufen lassen. Besuche nun die URL und du solltest ein "Hello, world!" sehen. (Du kannst eine IP Addresse/Port nach dem "code.py" hinzufügen um zu kontrollieren, wo genau web.py den Server startet. Du kannst ihm ebenso sagen ob er ein `fastcgi` oder `scgi` server starten soll.)

**Hinweis:** Du kannst den Port beim Aufruf von 'code.py' angeben, wenn du den Standardwert 8080 nicht benutzen willst oder kannst:

    $ python code.py 1234


## Developing

Web.py hat ebenso ein paar Tools, die uns beim Debugging helfen. Füge in der letzten Zeile vor `if __name__` folgendes hinzu:

    web.webapi.internalerror = web.debugerror

Das wird dir hilfreiche Fehlermeldungen liefern. Außerdem musst du in der letzten Zeile `web.reloader` hinzufügen, damit es wie folgt aussieht: 

    if __name__ == "__main__": web.run(urls, globals(), web.reloader)

Das sagt web.py, dass es web.reloader verwenden soll. web.reloader ist eine "middleware" (eine Funktion, die bestimmte Funktionalitäten zu dem Webserver hinzufügt). Diese lädt die Dateien jedesmal neu, nachdem du diese verändert hast. Dadurch sieht du die Änderungen sofort im Browser, ohne den Server neu zu starten. (Bei größeren Änderungen kann es trotzdem sein, dass du den Server neustarten musst). Wahrscheinlich wirst du das wieder herausnehmen wollen wenn du deine Seite Online stellst, aber zum Entwickeln ist es großartig. Außerdem gibt es noch den `web.profiler`, der zeigt dir am Ende jeder Webseite Informationen darüber, wie lange jede Funktion gebraucht hat, sodass du dein Programm schneller machen kannst. 
    
## Templating

HTML von Python aus zu schreiben kann sehr lästig werden; es macht viel mehr spaß, Python innerhalb von HTML zu schreiben. Glücklicherweise macht web.py das ziemlich einfach.

**Hinweis:** Ältere Versionen von web.py haben [Cheetah templates](http://www.cheetahtemplate.org/) verwendet. Du kannst das natürlich immer noch verwenden. Ebenso kann jede andere Software zusammen mit web.py verwendet werden. Aber Cheetah wird nicht mehr offiziell unterstützt.

Nun, lasst uns ein neues Verzeichnis für unsere templates erstellen (wir nennen es `templates`). Darin erstellen wir eine neue Datei die auf HTML endet (wir nennen sie `index.html`). Darin kannst du nun normales HTML schreiben:

    <em>Hello</em>, world!

Oder du kannst web.py's _templating_-Sprache verwenden und Code zu HTML hinzufügen:

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

**Achtung: Zur Zeit sind vier Leerzeichen erforderlich für die Einrückung.**

Wie du sehen kannst, sieht das Python-Dateien ähnlich, abgesehen von der `def with`-Anweisung am Anfang (das sagt dem Template womit es aufgerufen wird) und den `$`, die vor Codestücken platziert werden. Zur Zeit ist es erforderlich, dass das `$def`-Statement in der ersten Zeile der Datei steht. Sollte `name` z.B. `<b>test</b>` enthalten so wird auch `<b>test</b>` angezeigt, wenn man will das der HTML Code wirklich interpretiert wird, so muss man `$:name` anstatt `$name` schreiben.

Nun, zurück zur `code.py`. Unter der ersten Zeile fügen wir hinzu:

    render = web.template.render('templates/')

Damit sucht web.py nach Templates in deinem Template-Verzeichnis. Nun ändere `index.GET` zu:

    name = 'Bob'    
    print render.index(name)

(`index` ist der Name des Templates und `name` ist das Argument welches an dieses weitergeleitet wird). 

Besuche deine Seite. Sie sollte nun "hello to Bob" ausgeben.

**Entwicklungstipp:** Füge `cache=False` an das Ende deines `render`-Aufrufs. Damit wird web.py jedesmal das Template neu laden wenn du die Seite aufrufst.

Nun ändere die URL-Zeile zu:

    '/(.*)', 'index'

und ändere die Definition von `index.GET` zu:

    def GET(self, name):

und lösche die Zeile mit `name = 'Bob'`. Besuche `/` und es sollte "hello to the world" zu sehen sein. Besuche `/Joe` und es sollte "hello to Joe" erscheinen.

Wenn du mehr über web.py templates wissen willst, besuche die [templetor page](/templetor).

## Databasing

**Hinweis:** Bevor du eine Datenbank benutzen kannst, vergewissere dich das du die entsprechenden Datenbank Bibliotheken installiert hast. Für MySql Datenbanken kannst du [MySQLdb](http://sourceforge.net/project/shofiles.php?group_id=22307) verwenden und für Postgres verwende [psycopg2](http://initd.org/pub/software/psycopg/).

Über der `web.run` Zeile füge folgendes hinzu:

    web.config.db_parameters = dict(dbn='postgres', user='username', pw='password', db='dbname')

(Passe die Parameter entsprechend an, vor allem `username`, `password`, und `dbname`. MySQL User sollten `dbn` zu `mysql` ändern.)
Die Zeile könnte für Sqlite Benutzer in etwa wie folgt aussehen:

	web.config.db_parameters = dict(dbn='sqlite', db='data.db')

Erstelle eine einfache Tabellen in deiner Datenbank:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

Und füge eine Zeile ein:

    INSERT INTO todo (title) VALUES ('Learn web.py');

In `code.py` ändere `index.GET` zu:

    def GET(self):
        todos = web.select('todo')
        print render.index(todos)

und ändere den URL-Handler wieder zurück zu `/`.

Ändere `index.html` damit es wie folgt aussieht: 

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

Besuche deine Seite erneut und du wirst dein erstes Todo-Item sehen: "Learn web.py". Gratuliere, du hast ein voll funktionsfähiges Programm, das aus einer Datenbank liest. Nun wollen wir es auch noch in die Datenbank schreiben lassen.

Füge folgendes am Ende von `index.html` hinzu:

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

Und ändere deine URLs, damit es so aussieht:

    '/', 'index',
    '/add', 'add'

(Passe mit den Kommas auf. Wenn du sie vergisst, fügt Python die Strings zusammen und sieht `'/index/addadd'`, was nicht das ist, das du haben willst!)

Füge in `code.py` folgende Klasse hinzu: 

    class add:
        def POST(self):
            i = web.input()
            n = web.insert('todo', title=i.title)
    	    web.seeother('/')

(Bemerkt? Wir benutzen hier `POST`)

`web.input` gibt dir Zugriff auf jede Variable die der User durch ein Formular abgeschickt hat. Wenn du Daten von Items mit dem selben Namen verarbeiten willst (wie in etwa bei einer Serie von Checkboxen mit name="name" benutze:

    post_data=web.input(name=[])

`web.insert` fügt eine Zeile zur Datenbanktabelle `todo` hinzu und gibt die ID der neuen Zeile zurück. `seeother` leitet den User weiter zu dieser URL.

Kurz: `web.transact()` startet eine Transaktion. `web.commit()` übergibt diese. `web.rollback()` macht die Transaktion nichtig. `web.update` funktioniert in etwa so wie `web.insert` außer dass es anstatt eine ID zurückzugeben eine nach dem Tabellennamen benötigt (oder eine `WHERE` Klausel). 

`web.input`, `web.query` und einige andere Funktionen in web.py liefern "Storage objects" zurück, sie funktionieren genau wie Dictionaries, außer das du `d.foo` zusätzlich zu `d['foo']` verwenden kannst. Das macht vieles einfach lesbar.

Du kannst die ganzen Details dazu und allen anderen web.py-Funktionen in der [Dokumentation](http://new.webpy.org/docs) nachlesen.

Das Tutorial endet hier, schau dir die Dokumentation an, um zu sehen was man noch so cooles mit web.py machen kann.

---
layout: default
title: Φροντιστήριο για το web.py 0.2
---

# Φροντιστήριο για το web.py 0.2

## Ξεκινώντας

Αν γνωρίζετε Python και θέλετε να φτιάξετε ένα σάιτ, το web.py παρέχει τον κώδικα ώστε να το φτιάξετε εύκολα.

Για να παρακολουθήσετε ολόκληρο το φροντιστήριο, θα πρέπει να έχετε εγκατεστημένα τα εξής: Python, web.py, flup, psycopg2 και Postgres (ή κάποια αντίστοιχη βάση δεδομένων και τον οδηγό της). Για οδηγίες, κοιτάχτε [εδώ](http://webpy.org/install).

Αν έχετε ήδη ένα υπάρχον πρότζεκτ γραμμένο σε web.py, ρίχτε μια ματιά στην σελίδα [αναβάθμισης](http://webpy.infogami.com/upgrade_to_point2) για πληροφορίες μεταφοράς.

Ας ξεκινήσουμε.

## Διαχείριση των URL

Το πιο σημαντικό κομμάτι κάθε σάιτ είναι η δομή των URL του. Τα URL σας δεν είναι μόνο αυτά που βλέπουν οι επισκέπτες σας, και τα οποία στέλνουν με μέηλ στους φίλους τους, αλλά επίσης παρέχουν ένα νοητό μοντέλο του πως δουλεύει το σάιτ. Σε δημοφιλή σάιτ όπως το [del.icio.us](http://del.icio.us/|del.icio.us), τα URL είναι κομμάτι του user interface. Το web.py σας βοηθά να φτιάχνετε καλά URL.

Για να ξεκινήσετε την εφαρμογή σας, ανοίξτε ένα νέο αρχείο κειμένου (ας το πούμε `code.py`) και γράψτε:

    import web.py

Έτσι αποκτούμε πρόσβαση στον κώδικα του web.py.

Τώρα, χρειαζόμαστε να πούμε στο web.py την δομή των URL μας. Ας βάλουμε κάτι απλό για αρχή:

    urls = (
      '/', 'index',
      '',  'index'    )

Το πρώτο μέρος είναι μια [κανονική έκφραση](http://osteele.com/tools/rework/) που ταιριάζει ένα URL, όπως τα `/`, `/help/faq`, `/item/(\d+)`, κτλ (σημ: το `\d+` ταιριάζει μια ακολουθία αριθμών). Οι παρενθέσεις σώζουν το κείμενο που ταιριάχτηκε με τα δεδομένα για περαιτέρω χρήση. Το δεύτερο μέρος είναι το όνομα της κλάσης στην οποία στέλνουμε το αίτημα, όπως: `index`, `view`, `welcomes.hello` (η οποία παίρνει την κλάση `hello` από το `welcomes`) ή `get_\1`. Το `\1` αντικαθίσταται από το πρώτο μέρος της κανονικής έκφρασης που σώθηκε νωρίτερα· τα υπόλοιπα κομμάτια της κανονικής έκφρασης που σώθηκαν περνάνε στην συνάρτησή σας.

Η γραμμή μας λέει πως θέλουμε το URL `/` (σημ: η πρώτη σελίδα) να το χειρίζεται η κλάση με όνομα `index`.

Τώρα πρέπει να γράψουμε την κλάση `index`. Παρόλο που οι περισσότεροι άνθρωποι δεν το προσέχουν καθώς κινούνται στο δίκτυο, ο μπράουζερ χρησιμοποιεί μια γλώσσα γνωστή ως HTTP για επικοινωνία με το Παγκόσμιο Ιστό. Οι λεπτομέρειες δεν είναι σημαντικές, αλλά η βασική ιδέα είναι πως οι επισκέπτες του Ιστού ζητάνε από τους σέρβερ να εκτελέσουν καθορισμένες λειτουργίες (όπως `GET` ή `POST`) πάνω σε URL (όπως `/` ή `/foo?f=1`).

Το `GET` είναι αυτό με το οποίο είμαστε όλοι εξοικειωμένοι, αυτό που χρησιμοποιούμε όταν ζητάμε μια ιστοσελίδα. Όταν γράφετε `harvard.edu` στο μπράουζερ, αυτός ουσιαστικά ζητά από τον σέρβερ του Χάρβαρντ να φέρει (`GET`) το `/`. Το δεύτερο πιο γνωστό, το `POST`, συχνά χρησιμοποιείται όταν υποβάλουμε κάποιες φόρμες, όπως μια αίτηση για αγορά. Χρησιμοποιούμε το `POST` όταν η πράξη της υποβολής ενός αιτήματος _κάνει κάτι_ (χρεώνει την πιστωτική μας κάρτα και εκτελεί την παραγγελία). Αυτό είναι ουσιώδες, καθώς τα URL που τα κάνουμε `GET` μπορούμε να τα χρησιμοποιήσουμε εδώ κι εκεί, ακόμη και να τα ταξινομήσουμε σε μια μηχανή αναζήτησης, που είναι αυτό που θέλουμε για τις περισσότερες σελίδες, αλλά οπωσδήποτε όχι για πράγματα όπως η διαχείριση μιας παραγγελίας (σκεφτείτε το Google να προσπαθεί να αγοράσει τα πάντα από το σάιτ σας!).

Στον κώδικά μας με το web.py, κάνουμε αυτή την διάκριση σαφή:

    class index:
      def GET(self):
          print "Hello, world!"

Αυτή η συνάρτηση `GET` θα κληθεί από το web.py κάθε φορά που κάποιος κάνει μια αίτηση `GET` για το `/`.

Ωραία, τώρα χρειάζεται να το τελειώσουμε με μια τελική γραμμή που να λέει στο web.py να αρχίζει να εξυπηρετεί τις σελίδες.

    if __name__ == "__main__": web.run(urls, globals())

Αυτό λέει στο web.py να σερβίρει τα URL που του δώσαμε παραπάνω, ψάχνοντας στις κλάσεις από τον καθολικό χώρο ονομάτων (namespace) του αρχείου.

Τώρα, προσέξτε, πως ενώ μιλάω πολύ, έχουμε γράψει μόνο πέντε γραμμές κώδικα. Μόνο αυτό χρειάζεστε για να φτιάξετε μια πλήρη web application. Αν πάτε στον φλοιό και γράψετε:

    $ python code.py
    Launching server: http://0.0.0.0:8080/

θα έχετε την εφαρμογή σας να τρέχει σ' έναν πραγματικό σέρβερ στον υπολογιστή σας. Επισκεφθείτε το URL και θα δείτε το "Hello, world!" (Μπορείτε να προσθέσετε  μια διεύθυνση IP και μια θύρα μετά το "code.py" για να ρυθμίσετε που θα τρέξει το web.py τον σέρβερ. Μπορείτε επίσης να διαλέξετε να τρέξετε έναν fastcgi σέρβερ ή έναν cgi.)

Σημείωση: Μπορείτε να ορίσετε τον αριθμό θύρας αν δεν σας αρέσει ο προκαθορισμένος:

    $ python code.py 1234


## Κατά την ανάπτυξη

Το web.py έχει μερικά εργαλεία που μας βοηθάνε στο debbuging. Πριν το `if __name__` στην τελευταία γραμμή, προσθέστε:

    web.webapi.internalerror = web.debugerror

Αυτό μας δίνει κάπως πιο βοηθητικά μηνύματα σφαλμάτων. Και στην τελευταία γραμμή προσθέστε `web.reloader` ώστε να είναι έτσι:

    if __name__ == "__main__": web.run(urls, globals(), web.reloader)

Αυτό λέει στο web.py να χρησιμοποιήσει το "ενδιάμεσο" κομμάτι κώδικα web.reloader (το ενδιάμεσο είναι ένα κομμάτι κώδικα, σαν περίβλημα, που προσθέτει κάποιες λειτουργίες στον σέρβερ μας), που φορτώνει τα αρχεία μας όταν τα αλλάζουμε, ώστε να βλέπουμε τις αλλαγές στον μπράουζερ απευθείας. (Για σημαντικές αλλαγές όμως, χρειάζεται να ξαναξεκινάμε τον σέρβερ). Μάλλον θα θέλετε να το βγάλετε όταν κάνετε το σάιτ σας δημόσιο, αλλά είναι σπουδαίο κατά την ανάπτυξη. Υπάρχει επίσης ο `web.profiler`, που εκτυπώνει πληροφορίες για το πόση ώρα έκανε κάθε συνάρτηση κατά την εκτέλεση, στο τέλος της σελίδας, ώστε να κάνετε τον κώδικά σας πιο γρήγορο.

## Πρότυπα

Το να γράφουμε HTML μέσα από την Python είναι επίπονο· έχει περισσότερο γούστο να γράφουμε Python μέσα σε HTML. Ευτυχώς, το web.py το καθιστά εύκολο αυτό.

Σημείωση: Παλαιότερες εκδόσεις του web.py χρησιμοποιούσαν τα [Πρότυπα Cheetah](http://www.cheetahtemplate.org/). Είναι, βεβαίως, στην ευχέρειά σας να χρησιμοποιήσετε αυτό ή οποιοδήποτε άλλο πρόγραμμα με το web.py, αλλά δεν υποστηρίζετε πλέον επίσημα.

Ας φτιάξουμε έναν νέο κατάλογο για τα πρότυπά μας (θα τον λέμε `templates`). Εκεί μέσα, θα φτιάξουμε ένα αρχείο που το όνομά του τελειώνει σε HTML (ας πούμε index.html). Τώρα, μέσα στο αρχείο αυτό, μπορούμε να γράψουμε απλή HTML:

    <em>Hello</em>, world!

Ή, μπορούμε να χρησιμοποιήσουμε την γλώσσα προτύπου του web.py για να προσθέσουμε κώδικα στην HTML:

    $def with (name)

    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

Σημείωση: για τώρα, απαιτούνται τέσσερα ακριβώς κενά.

Όπως βλέπετε, το πρότυπο μοιάζει αρκετά με αρχείο Python, εκτός της δήλωσης `def with` στην κορυφή (που λέει με τι καλείται το πρότυπο) και τα δολλάρια που προστίθενται στην αρχή κάθε γραμμής κώδικα. Για την ώρα, το template.py απαιτεί η δήλωσω `$def` να είναι στην πρώτη γραμμή του αρχείου. Επίσης, προσέξτε πως το web.py αυτόματα κρύβει κάθε μεταβλητή που χρησιμοποιείται, ούτως ώστε αν για κάποιο λόγο το `name` περιέχει HTML, αυτό θα εμφανιζόταν κανονικά ως κείμενο. Αν δεν θέλετε αυτή την λειτουργία, γράψτε `$:name` αντί για `$name`.

Τώρα, πίσω στο `code.py`. Υπό την πρώτη γραμμή, προσθέστε:

    render = web.template.render('templates/')

Αυτό λέει στο web.py να ψάξει για πρότυπα στον κατάλογο `templates`. Μετά, αλλάξτε το `index.GET` σε:

    name = 'Bob'
    print render.index(name)

('index' είναι το όνομα του προτύπου και 'name' το όρισμα που του περνάμε).

Πηγαίντε στο σάιτ σας και τώρα πρέπει να λέει γεια τον Μπομπ.

Συμβουλή ανάπτυξης: Προσθέστε `cache=False` στο τέλος της κλήσης του `render` ώστε το web.py να φορτώνει αυτόματα όποιες αλλαγές έχετε κάνει στην σελίδα.

Αλλά, ας υποθέσουμε πώς θέλουμε οι άνθρωποι να βάζουν το δικό τους όνομα. Αντικαταστήστε τις δύο παραπάνω γραμμές με τις παρακάτω:

    i = web.input(name=None)
    print render.index(i.name)

Πηγαίντε στο `/` και πρέπει να χαιρετάει τον κόσμο. Πηγαίντε στο `/?name=Joe` και θα χαιρετάει τον Τζο.

Βέβαια, έχοντας το `?` στο URL είναι κάθως απωθητικό. Γι' αυτό αλλάξετε τα URL στην κορυφή με:

    '/(.*)', 'index'

και αλλάξτε τον ορισμό του `index.GET` σε:

    def GET(self, name):
        print render.index(name)

και διαγράψτε την γραμμή που ορίζει το όνομα. Τώρα πηγαίντε στο `/Joe` και θα χαιρετάει τον Τζο.

Αν θέλετε να μάθετε περισσότερα για τα πρότυπα στο web.py, επισκεφτείτε την σελίδα [templetor](http://webpy.org/templetor).

## Βάσεις

...
---
layout: default
title: web.py 0.2 tutorial
---

# web.py 0.2 tutorial

{{OldVersionWarning("/tutorial3.en")}}

## Starting

So you know Python and want to make a website. web.py provides the code to make that easy.

If you want to do the whole tutorial, you'll need to have installed Python, web.py, flup, psycopg2, and Postgres (or equivalent database and Python driver). For details, see [webpy.org](http://webpy.org/).

If you have an existing web.py project, take a look at the [upgrade](http://webpy.infogami.com/upgrade_to_point2) page for info on migrating.

Let's get started.

## URL Handling

The most important part of any website is its URL structure. Your URLs aren't just the thing that your visitors see and email to their friends, they also provide a mental model of how your website works. On popular sites like [del.icio.us](http://del.icio.us/), the URLs are even part of the user interface. web.py makes it easy to make great URLs.

To get started with your web.py application, open up a new text file (let's call it `code.py`) and type:

    import web

This imports the web.py module.

Now we need to tell web.py our URL structure. Let's start out with something simple:

    urls = (
      '/', 'index',
      '',  'index'    )

The first part is a [regular expressions](http://osteele.com/tools/rework/) that matches a URL, like `/`, `/help/faq`, `/item/(\d+)`, etc. (i.e. `\d+` would match a sequence of digits). The parentheses say to capture that piece of the matched data for use later on. The second part is the name of a class to send the request to, like `index`, `view`, `welcomes.hello` (which gets the `hello` class of the `welcomes` module), or `get_\1`. `\1` is replaced by the first capture of your regular expression; any remaining captures get passed to your function.

This line says we want the URL `/` (i.e. the front page) to be handled by the class named `index`.

Now we need to write the `index` class. While most people don't notice it just browsing around, your browser uses a language known as HTTP for communicating with the World Wide Web. The details aren't important, but the basic idea is that Web visitors ask web servers to perform certain functions (like `GET` or `POST`) on URLs (like `/` or `/foo?f=1`). 

`GET` is the one we're all familiar with, the one used to request the text of a web page. When you type `harvard.edu` into your web browser, it literally asks the Harvard web server to `GET /`.  The second-most famous, `POST`, is often used when submitting certain kinds of forms, like a request to purchase something. You use `POST` whenever the act of submitting a request _does something_ (like charge your credit card and process an order). This is key, because `GET` URLs can be passed around and indexed by search engines, which you definitely want for most of your pages but definitely _don't_ want for things like processing orders (imagine if Google tried to buy everything on your site!).

In our web.py code, we make the distinction between the two clear:

    class index:
        def GET(self):
            print "Hello, world!"

This `GET` function will now get called by web.py anytime some makes a `GET` request for `/`.

Alright, now we just need to finish up with a final line telling web.py to start serving web pages:

    if __name__ == "__main__": web.run(urls, globals())

This tells web.py to serve the URLs we listed above, looking up the classes in the global namespace of this file.

Now notice that although I've been talking a lot here, we only really have five or so lines of code. That's all you need to make a complete web.py application. If you go to your command line and type:

    $ python code.py
    Launching server: http://0.0.0.0:8080/

You now have your web.py application running a real web server on your computer. Visit that URL and you should see "Hello, world!" (You can add an IP address/port after the "code.py" bit to control where web.py launches the server. You can also tell it to run a `fastcgi` or `scgi` server.)

**Note:** You can specify the port number to use on the command line like this
if you can't or don't want to use the default:

    $ python code.py 1234

## Developing

web.py also has a few tools to help us with debugging. Before the `if __name__` on last line, add:

    web.webapi.internalerror = web.debugerror

This will give you more helpful error messages. And on the last line add `web.reloader` so that it reads:

    if __name__ == "__main__": web.run(urls, globals(), web.reloader)
    
This tells web.py to use the web.reloader "middleware" (middleware is a wrapper function to add some functionality to your web server) which reloads your files whenever you edit them, so that you can see the changes in your web browser right away. (For some serious changes, though, you'll still have to restart the server.) You'll probably want to take this out when you make your site public, but it's great while developing. There's also `web.profiler`, which outputs information about how much time each function took at the end of each web page, so that you can make your code faster.

## Templating

Writing HTML from inside Python can get cumbersome; it's much more fun to write Python from inside HTML. Luckily, web.py makes that pretty easy.

**Note:** Old versions of web.py used [Cheetah templates](http://www.cheetahtemplate.org/). You are, of course, welcome to use that or any other software with web.py, but it is no longer officially supported.

Let's make a new directory for our templates (we'll call it `templates`). Inside, make a new file whose name ends with HTML (we'll call it `index.html`). Now, inside, you can just write normal HTML:

    <em>Hello</em>, world!

Or you can use web.py's templating language to add code to your HTML:

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

**Note: Currently, four spaces are required for indentation.**

As you can see, the templates look a lot like Python files except for the `def with` statement at the top (saying what the template gets called with) and the `$`s placed in front of any code.  Currently, template.py requires the `$def` statement to be the first line of the file.  Also, note that web.py automatically escapes any variables used here, so that if for some reason `name` is set to a value containing some HTML, it will get properly escaped and appear as plain text. If you want to turn this off, write `$:name` instead of `$name`.

Now go back to `code.py`. Under the first line, add:

    render = web.template.render('templates/')

This tells web.py to look for templates in your templates directory. Then change `index.GET` to:

    name = 'Bob'    
    print render.index(name)

('index' is the name of the template and 'name' is the argument passed to it)

Visit your site and it should say hello to Bob. 

**Development tip:** Add , `cache=False` to the end of your `render` call to have web.py reload your templates every time you visit the page.

But let's say we want to let people enter their own name in. Replace the two lines we added above with:

    i = web.input(name=None)
    print render.index(i.name)

Visit `/` and it should say hello to the world. Visit `/?name=Joe` and it should say hello to Joe.

Of course, having that `?` in the URL is kind of ugly. Instead, change your URL line at the top to:

    '/(.*)', 'index'

and change the definition of `index.GET` to:

    def GET(self, name):
        print render.index(name)

and delete the line setting name. Now visit `/Joe` and it should say hello to Joe.

If you wish to learn more about web.py templates, vist the [templetor page](/templetor).

## Databasing

**Note:** Before you can start using a database, make sure you have the appropriate database library installed.  For MySQL databases, use [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) and for Postgres use [psycopg2](http://initd.org/pub/software/psycopg/).

Above your `web.run` line add:

    web.config.db_parameters = dict(dbn='postgres', user='username', pw='password', db='dbname')

(Adjust these -- especially `username`, `password`, and `dbname` -- for your setup. MySQL users will also want to change `dbn` definition to `mysql`.)

If you're running a web application, that's all you need to do -- web.py will automatically handle connecting and disconnecting from the database. But if you're working from the command line or starting your own thread, you need to call `web.load()` to connect and `web.unload()` to disconnect.

Using your database engines admin interface, create a simple table in your database:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

And an initial row:

    INSERT INTO todo (title) VALUES ('Learn web.py');

Return to editing `code.py` and change `index.GET` to the following, replacing the entire function:

    def GET(self):
        todos = web.select('todo')
        print render.index(todos)

and change back the URL handler to take just `/` as in:

    '/', 'index',

Edit and replace the entire contents of `index.html` so that it reads:

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

Visit your site again and you should see your one todo item: "Learn web.py". Congratulations! You've made a full application that reads from the database. Now let's let it write to the database as well.

At the end of `index.html`, add:

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

And change your URLs list to read:

    '/', 'index',
    '/add', 'add'

(You've got to be very careful about those commas.  If you omit them, Python adds the strings together and sees `'/index/addadd'` instead of your list of URLs!)

Now add another class:

    class add:
        def POST(self):
            i = web.input()
            n = web.insert('todo', title=i.title)
            web.seeother('/')

(Notice how we're using `POST` for this?)

`web.input` gives you access to any variables the user submitted through a form. 

Note: In order to access data from multiple identically-named items, in a list format (e.g.: a series of check-boxes all with the attribute name="name") use:

    post_data=web.input(name=[])

`web.insert` inserts values into the database table `todo` and gives you back the ID of the new row. `seeother` redirects users to that URL.

Some quick additional notes: `web.transact()` starts a transaction. `web.commit()` commits it; `web.rollback()` rolls it back. `web.update` works just like `web.insert` except instead of returning the ID it takes it (or a string `WHERE` clause) after the table name.

`web.input`, `web.query`, and other functions in web.py return "Storage objects", which are just like dictionaries except you can do `d.foo` in addition to `d['foo']`. This really cleans up some code.

You can find the full details on these and all the web.py functions in [the documentation](/docs).

This ends the tutorial for now. Take a look at the documentation for lots more cool stuff you can do with web.py.
---
layout: default
title: tutorial2.es
---

# tutorial2.es

## Tutorial de web.py 0.2
Esta es la versión en español del tutorial en [Inglés](http://webpy.infogami.com/tutorial2.en) de web.py v 0.2, que se encuentra en este mismo sitio. El trabajo de traducción está en desarrollo. Todo aquel que desee colaborar sólo debe crear su cuenta.

## Iniciando.

Si usted conoce Python y quiere hacer un sitio web, web.py le provee con el código para hacerlo fácilmente.

Si quiere seguir todo el tutorial, necesitará tener instalado Python, web.py, flup, psycopg2 y Postgres (o una base de datos equivalente y el driver de Python correspondiente). Para más detalles, consulte [webpy.org](http://www.webpy.org).

Si usted ya tiene funcionando un proyecto con otra versión de web.py, dele un vistazo a la información sobre migración en la [página](http://webpy.infogami.com/upgrade_to_point2) de actualización.

Ya podemos comenzar.

## Manejo de URLs

La parte más importante de cualquier sitio web es la estructura de sus [URLs](http://es.wikipedia.org/wiki/URL). Las URLs de su sitio web no son simplemente "cosas" que los visitantes al web miran y envían por correo electrónico a sus amigos, sino que también proveen un modelo mental de como su sitio web funciona. En sitios populares (en inglés), tales como [del.icio.us](http://del.icio.us/), las URLs son inclusive parte del interfaz con el usuario. web.py facilita definir buenos URLs.

Para comenzar una aplicación con web.py, abra un nuevo archivo de texto (vamos a llamarlo 'code.py') y escriba:

    import web

Esto importa el modulo web.py.

A continuación, deberá decirle a web.py cual será la estructura de URLs. Se puede comenzar con algo sencillo como:

    urls = (
      '/', 'index'    )

La primera partes es una [expresión regular](http://osteele.com/tools/rework/) que coincide con una URL, como `/`, `/help/faq`, `/item/(\d+)`, etc. (El `\d+` coincide con una secuencia de dígitos). La segunda parte es el nombre de la clase que será llamada cuando el URL de una página coincida con al expresión regular.

Esta linea dice que queremos que el URL `/` (ej: la página principal) debe ser manejada por la clase llamada `index`.

Por lo tanto, todo lo que se require es escribir la clase `index`. Aunque la mayoría de las personas no lo saben, su navegador web, utiliza un lenguaje conocido como HTTP para comunicarse con la World Wide Web. Los detalles no son relevantes, pero la idea básica es que los visitantes de su sitio web le solicitan al servidor de web que realice una función especifica (como `GET` o `POST`) con las URLs (como en `/` o `/foo?f=1`).


`GET` es el que nos resulta familiar a todos, es el que se usa para pedir el texto de una página web. Cuando escribe `harvard.edu` en su navegador web, éste le pide literarmente al servidor web de Harvard que `GET /`. El segundo más famoso, `POST`, se usa a menudo para enviar ciertos tipos de formularios, como una petición de compra de algún artículo. Usted usa `POST` siempre que el acto de enviar un formulario _hace algo_ (como utilizar su tarjeta de crédito y procesar un recibo). Esta es la clave, porque las `GET` URLs pueden circular y se indexadas por los motores de búsqueda, lo que realmente quieres para la mayoría de tus páginas pero, definitivamente, _no quieres_ que procesen recibos (¡imagina que Google intentase comprar todo lo que hay en tu sitio web!).

En el código de nuestro web.py, distinguiremos las dos claramente:

    class index:
        def GET(self):
            print "Hello, world!"
Esta función `GET` será llamada por web.py siempre que alguien realice una petición `GET` de `/`.

Bien, ahora sólo tenemos que acabar con una linea final que le diga a web.py que empiece a servir páginas web:

    if __name__ == "__main__": web.run(urls, globals())

Esto le dice a web.py que sirva las URLs que listamos arriba, buscando las clases en el espacio de nombres global de este archivo.

Ahora fíjese en que, aunque hemos hablado un montón, sólo hemos escrito unas cinco lineas de código. Es todo lo que necesitas para construir una aplicación web.py completa. Si abre su linea de comandos y escribe:

    $ python code.py
    Launching server: http://0.0.0.0:8080/

Ahora su aplicación web.py está ejecutando un servidor web real en su ordenador. Si visita esa URL debería ver "Hello, world!" (Puede añadir una dirección IP y un puerto después de las lineas de "code.py" para controlar dónde lanza web.py el servidor. También puede indicarle que ejecute un servidor `fastcgi` o `scgi`.)

## Desarrollo

web.py tiene algunas herramientas que nos ayudaran a debuggear. Antes de 'if __name__' en la ultima linea debemos agregar:

    web.webapi.internalerror = web.debugerror

Esto nos dara mas informacion sobre los errores sucedidos. Y en la ultima linea debemos agregar `web.reloader` para que se vea de la siguiente forma:

    if __name__ == "__main__": web.run(urls, globals(), web.reloader)

Esto le avisa a web.py que utilice web.reloader "middleware" (middleware es una funcion wrapper para agregarle mas funcionalidad al servidor web que hagamos) el cual recarga todos los archivos cada vez que los editemos, y de esta manera veremos los cambios en el navegador web directamente (aunque para algunos cambios mayores, habra que reiniciar al servidor de todas formas).  Probablemente quieras sacar esto cuando hagas publico al sitio, pero es realmente util cuando lo estemos desarrollando. Tambien hay un `web.profiler`, el cual da informacion sobre cuanto tiempo tomo cada funcion al final de cada pagina, para tener en cuenta a la hora de optimizar al codigo.

## Uso de Plantillas.

Escribir HTML dentro de Python puede volverse un problema, es mucho mas divertido escribir Python dentro de HTML. Por suerte web.py hace que esto sea realmente facil

**Nota: web.py actualmente soporta [Cheetah templates](http://www.cheetahtemplate.org/).  Lea al  [tutorial](http://webpy.org/tutorial) principal para mas informacion.

Primero debemos crear un directorio para nuestras plantillas (lo vamos a llamar `templates`). 
Dentro crearemos un archivo con extension .html (lo vamos a llamar `index.html`)
Ahora, simplemente podemos empezar a escribir HTML:

    <em>Hola</em>, mundo!

O podemos usar web.py para escribir al codigo dentro del HTML:

    $def with (nombre)
    
    $if nombre:
        Solo queria decirle <em>hola</em> a $nombre.
    $else:
        <em>Hola</em>, mundo!

**Nota: Actualmente, cuatro espacios son requeridos para indentacion.**

Como podemos ver, las plantillas se asemejan bastante al codigo en Python, excepto que la declaracion `def with` al principio (avisando que puede ser llamado `with`) y por el `$` antes de cada linea de codigo Python. Actualmente, template.py requiere la declaracion $def como primer linea del archivo. Tambien,  notar que web.py automaticamente escapa a cualquier variable usada aqui, por lo que si por alguna razon `nombre` se le setea algun valor que contenga HTML, esta va a ser escapada y sera mostrada como texto plano. Si queremos que esto no suceda, debemos utilizar `$:nombre` en lugar de `$nombre`.

Ahora, volviendo a `code.py`. Debajo de la primer linea, agregamos:

    render = web.template.render('templates/')

Esto le dice a web.py que revise a las plantillas de tu directorio templates.Entonces cambiamos `index.GET` a:

    nombre = 'Roberto'
    print render.index.(nombre)

Visitamos el sitio y este deberia decirle hola a Roberto.

**Tip de desarrollo:** Agregar `cache=False` al final de tu llamada `render` hace que nuestras plantillas no sean guardadas en la memoria cache.

Ahora cambiamos la linea URL a:

    '/(.*)', 'index'

y cambiamos la definicion de `index.GET` a :

    def GET(self, nombre):

y borramos la linea seteando nombre. Con visitar `/` deberia saludar a todo el mundo, y al visitar `/Juan` solamente deberia saludar a Juan.

If you wish to learn more about web.py templates, vist the [templetor page](/templetor).
Si desea conocer mas sobre las plantillas en web.py, visite la [pagina templetor](/templetor).

## Base de Datos

Antes de la linea 'web.run' incluir:

    web.config.db_parameters = dict(dbn='postgres', user='username', pw='password', db='dbname')

(Cambie los valores --particularmente `username`, `password`, y `dbname` -- para que coincida con su configuración. Los usuarios de MySQL deberán cambiar 'dbn' a 'mysql'.)

Cree una tabla sencilla en su base de datos:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

E incluya un registro (fila):

    INSERT INTO todo (title) VALUES ('Learn web.py');

Vuelva al código `code.py`, modifique `index.GET` por:

    def GET(self):
        todos = web.select('todo')
        print render.index(todos)

and change back the URL handler to take just `/`.

Edit `index.html` so that it reads:

    $def with (todos)
    <ul>    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>    </ul>
Visit your site again and you should see your one todo item: "Learn web.py". Congratulations! You've made a full application that reads from the database. Now let's let it write to the database as well.

At the end of `index.html`, add:

    <form method="post" action="add">    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>    </form>
And change your URLs list to read:

    '/', 'index',
    '/add', 'add'
(You've got to be very careful about those commas.  If you omit them, Python adds the strings together and sees `'/index/addadd'` instead of your list of URLs!)

Now add another class:

    class add:
        def POST(self):
            i = web.input()
            n = web.insert('todo', title=i.title)
    	    web.seeother('/')

(Notice how we're using `POST` for this?)

`web.input` gives you access to any variables the user submitted through a form. `web.insert` inserts values into the database table `todo` and gives you back the ID of the new row. `seeother` redirects users to that ID.

Quickly: `web.transact()` starts a transaction. `web.commit()` commits it; `web.rollback()` rolls it back. `web.update` works just like `web.insert` except instead of returning the ID it takes it (or a string `WHERE` clause) after the table name.

`web.input`, `web.query`, and other functions in web.py return "Storage objects", which are just like dictionaries except you can do `d.foo` in addition to `d['foo']`. This really cleans up some code.

Usted puede encontrar todos los detalles sobre lo tratado en este tutorial y lo relacionado a las funciones de web.py en [la documentación](http://webpy.infogami.com/docs).

Con esto se termina este tutorial. Dele una lectura a la documentación, donde encontrará gran cantidad de material e información de lo que puede hacer con web.py
---
layout: default
title: web.py 0.2 tutorial
---

# web.py 0.2 tutorial

## Installation
Vous  connaissez Python et vous voulez construire un site web. Web.py fournit le code pour faire cela d'une manière simple.

Si vous voulez faire l’ensemble de ce tutoriel vous devrez installer Python, web.py, flup, psycopg2 et Postgres (ou une autre base de données avec son driver pour Python, par exemple : MySQL et mysqldb). Pour plus de détails voir le site de [webpy.org](http://webpy.org/).

Si vous avez un projet web.py existant, regardez la page de [upgrade](http://webpy.infogami.com/upgrade_to_point2) pour plus d’informations sur la migration vers la nouvelle version.



## Gestion des URLs
La partie la plus importante pour chaque site web  est la structure des URLs. Les URLs ne sont pas seulement ce que les visiteurs regarde et partage avec d’autres amis, mais ils sont aussi un modèle mental qui indique comment un Site Web fonctionne. (Dans les sites populaires comme [del.icio.us](http://del.icio.us/), les URLs font partie de l’interface de l’utilisateur). Pour cela Web.py facilite la création et la gestion des URL.

Pour commencer l’application  web.py , Créez un nouveau fichier et appelez le code.py par exemple et écrivez ceci dedans:

    import web

Ceci importera le module web.py.

Maintenant on implémente la structure de nos URLs, on commence par quelque chose de simple, ajoutez cela :

    urls = (
      '/', 'index'    )


La première partie est l’[expression régulière](http://osteele.com/tools/rework/)  qui représente un chemin. Par exemple : ‘/’, ‘/aide/faq’, ‘/article/(\d+)’, etc. Le \d+ représente une séquence de chiffres. Les parenthèses (..) servent à capturer les éléments retournés pour plus tard. La deuxième partie est le nom d’une classe à laquelle envoyer la requête, comme view, welcomes.hello (qui utilise la classe hello du module welcomes), ou bien get_\1. \1 est remplacé par la première capture de l’expression régulière. Toutes captures restantes seront passées à la fonction.

La ligne ('/', 'index') dis qu’on a besoin de l’URL ‘/’ (i.e la page d’accueil) qui sera prit en charge  par la classe nommé ‘index’.

Maintenant on écrit le code de la classe index:

    class index:
        def GET(self):
            print " Bonjour, monde !"

Comme vous avez pu le deviner, `GET` est appelé par web.py lorsque quelqu’un appelle la méthode HTTP GET sur votre URL ‘/’ (c’est-à-dire quand ils la visitent avec un navigateur web). La dernière ligne renvoie le texte brut “Bonjour, monde !” au visiteur.

Tous est bon maintenant, on aura besoin que de finir en ajoutant la ligne qui démarre l’application web

    if __name__ == "__main__": web.run(urls, globals())

Ceci dit à web.py de lancer votre application avec `urls` en regardant toutes les classes présentes dans le fichier.

Pour lancer le serveur web faisant tourner votre application tapez dans une invite de commande:

    $ python code.py
    Launching server: http://0.0.0.0:8080/

Maintenant si vous visitez http://0.0.0.0:8080/ avec un navigateur web, vous devriez voir apparaître “Bonjour, monde !”.

**Note:** vous pouvez spécifier le port en le passant comme paramètre

    $ python code.py 1234

Puis visiter la page : http://0.0.0.0:1234/

(La suite à accomplir...)
---
layout: default
title: web.py 0.2 チュートリアル
---

# web.py 0.2 チュートリアル

## はじめに

Python を使ってウェブサイトを作りたい。web.py は、これを簡単に実現するコードを提供するものだ。

チュートリアルにあることをすべて実行するには、Python、web.py、flup、psycopg2、PostgreSQL（または同等のデータベースと Python 用のドライバ）が必要だ。詳しくは [webpy.org](/) を参照のこと。

すでに web.py をインストールしてある場合は、[upgrade](/upgrade_to_point2) のページに移行の仕方について書いてあるので読んでほしい。

それでははじめよう。

## URL のハンドリング

どんなウェブサイトであっても、もっとも重要な部分となるのが URL の構造だ。URL は、訪問者がメールで知人にあなたのサイトのことを教えるときに使われるというばかりではない。君のサイトがどんなふうに動くのかというメンタルなモデルを表現するものでもあるのだ。[del.icio.us](http://del.icio.us/) などのポピュラーなサイトでは、URL はユーザーインターフェースの一部にさえなっている。web.py ならグレートな URL を簡単に構築できる。

web.py アプリケーションをはじめるにあたって、新しくテキストファイルを開いて（'code.py' と呼ぶことにする）次のようにタイプする。

    import web

これは web.py のモジュールをインポートしている。

それでは web.py にわれらがサイトの URL 構造を伝えることにする。まずはシンプルなところから。

    urls = (
        '/', 'index',
        '', 'index',
    )

最初の部分は URL にマッチする[正規表現](http://osteele.com/tools/rework/)で、`/`、`/help/faq`、`/item/(\d+)` などとすることができる。（`\d+` は数字の並びにマッチする。括弧でくくって、マッチした部分をあとで使えるように保存させている。）２番目のはリクエストが送られるクラスの名前で、`index`、`view`、`welcomes.hello` （これは `welcomes` モジュールの `hello` クラスを指している）、あるいは `get_\1` などとする。`\1` は、保存した正規表現の１番目のマッチ部分に置き換えられる。保存した残りのマッチ部分は関数を通して渡される。

上の例は、`/` という URL（つまりサイトのフロントページだ）は `index` というクラスで処理されると言っていることになる。

さて次に `index` クラスを書く。ほとんどの人は気にすることもなくブラウジングをしているけれども、ブラウザはワールド・ワイド・ウェブと交信するにあたって HTTP という言葉を用いている。細かいことは重要ではないが、基本的な概念としては、訪問者はウェブサーバに対して、（GET とか POST といった）ある function 〔機能／関数〕を URL （`/` とか `/foo?f=1`）について実行するよう問い合わせている。

GET はもうおなじみの代物だが、これはウェブページのテキストを要求するのに使われる。ブラウザに `harvard.edu` と打ち込むと、これは文字通りハーバードのウェブサーバに対して `GET /` と問い合わせることになる。つぎに有名なのが POST で、これは何かを登録するといったように、ある種のフォームを送信する時に使われる。（クレジットカードに課金して注文を行うといったような）リクエストを送信してなんらかの処理が行われる場合であればいつでも POST を使うことができる。ここがポイントなのだが、というのも、GET の URL は検索エンジンに巡回されてインデックス化されうるからで、これはいかにもほとんどのページについて望むところではあるが、一方で検索エンジンから注文を受けるようなことにはなってほしくないだろう（Google が自分のサイトの全商品を片っ端から買おうとしているところを想像してみればいい！）。

われらが web.py のコードではこのふたつは明確に区別される。

    class index:
        def GET(self):
            print "Hello, world!"

これで、web.py は `/` に対する GET リクエストに対していつでもこの `GET` 関数を呼び出すようになる。

さて、あとは仕上げに web.py がウェブページのサービスを始めるように最後の一行を書き足すだけだ。

    if __name__ == "__main__": web.run(urls, globals())

これは web.py に、はじめに書いた URL をサービスさせてクラス名をこのファイルのグローバルな名前空間で探し出せと伝えていることになる。

ここまでいろいろと述べてきたが、これまででコードは 5行ちょっとしか書いてないことに注目してほしい。ひとそろいのウェブアプリケーションを作るのに必要なのはこれですべてなのだ。コマンドラインから次のように打ち込んでみよう。

    $ python code.py
    Launching server: http://0.0.0.0:8080/

これで、君の web.py アプリケーションが君のコンピュータ上ででほんもののウェブサーバとして動く。この URL を訪問してみれば、"Hello, world!" と表示されるはずだ（"code.py" の部分に続けて IP アドレスとポート番号を指定して、web.py がどこでサーバを起動するかを指定できる。fastcgi や scgi サーバとして起動させることも可能だ）。

## 開発

web.py にはデバッグに役立つツールもいくつか用意されている。最終行の `'if __name__'` の前に、次の一行を足してみる。

    web.webapi.internalerror = web.debugerror

これでより役に立つエラーメッセージを見られるようになるだろう。また、最後の一行に `web.reloader` を付け足して次のようにする。

    if __name__ == "__main__": web.run(urls, globals(), web.reloader)

これは web.py に、`web.reloader` “ミドルウェア” を使うように伝えている（ミドルウェアというのはウェブサーバになんらかの機能を追加するためのラッパー関数だ）。これはファイルを編集したら即座にそれらを再読み込みして、変更箇所をすぐにブラウザ上で確認できるようにする。（もっとも、これを使っていても、大掛かりな変更を施した場合にはサーバを再起動させる必要があるけれども）。サイトを公開する時にはこの機能は外しておきたいと思うだろうが、開発段階ではとても役に立つ。`web.profiler` というのもあり、これは各ページの末尾に、各関数でどれだけ時間がかかったかについての情報を出力する。これを見ればコードのどこを改善すれば処理が速くなるかがわかるはずだ。

## テンプレート処理

Python のコード中に HTML のコードを書くのはやっかいなものだ。HTML のコード中に Python のコードを書ければずっと楽だろう。幸運なことに、web.py なら簡単にそれを実現できる。

ノート: web.py は現在のところ [Cheetah](http://www.cheetahtemplate.org/) テンプレートもサポートしている。詳しくは旧版のチュートリアルを参照のこと。

それではテンプレート用のディレクトリを作成しよう（`'templates'` とする）。この中に、名前が html で終わる新しいファイルを作成する（`'index.html'` としよう）。このファイルには普通の HTML を書けばよい。

    <em>Hello</em>, world!

web.py のテンプレート用言語を使って、HTML にコードを埋め込むこともできる。

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

ノート: 現時点では、インデントは 4つのスペースで行う必要がある。

見てわかるとおり、テンプレートは先頭の `def with` ステートメント（これはテンプレートが呼ばれる時に渡される引数を宣言している）と各行の先頭に `$` 記号が置かれていることを除けば、Python のコードによく似ている。今のところ、template.py では `$def` ステートメントがファイルの１行目になければならないことになっている。また、web.py はここで使われるすべての変数を自動的にエスケープ処理することにも注意しよう。これはつまり、もしなんらかの理由により name に HTML のコードを含む値がセットされた場合でも、それらは適切にエスケープ処理されて、プレーンなテキストとして表示されるということだ。この機能を無効にしたければ、`$name` のかわりに `$:name` と書く。 

さて `code.py` に戻ろう。１行目の下に次のように書き加える。

    render = web.template.render('templates/')

これは web.py に先ほど作った `templates` ディレクトリからテンプレートを探すよう伝えている。続いて `index.GET` を次のように変更する。

    name = 'Bob'
    print render.index(name)

（`'index'` はテンプレートの名前で、`'name'` はそれに渡される引数を表している。）

このサイトを訪問してみれば、Bob に挨拶しているページが表示されるはずだ。

開発豆知識: `render` を呼び出す時に `cache=False` と引数を加えると、web.py はページを表示するごとにテンプレートを再読み込みするようになる。

続いて URL 一覧の部分を次のようにしてみよう。

    '/(.*)', 'index'

そして `index.GET` の定義を次のようにする。

    def GET(self, name):

そして `name = 'Bob'` と決め打ちしていた行を削除する。こうすると、`/` を訪問すれば 'Hello, world!' を表示し、`/Joe` にアクセスすれば Joe に挨拶するようになる。

web.py のテンプレート処理についてもっと知りたければ、[template](/templetor) のページを参照のこと。

## データベース処理

ノート: データベースを使う前に、適切なデータベース用のライブラリがインストールされていることを確認すること。MySQL データベースには [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307)、PostgreSQL には [psycopg2](http://initd.org/pub/software/psycopg/) が必要だ。 

ソースコードの `web.run` がある行の前に、次のように書き加える。

    web.config.db_parameters = dict(dbn='postgres', user='username', pw='password', db='dbname')

（これらの値、とくに `username`、`password`、`dbname` の値は各自の環境に合わせて書き換えること。MySQL を使っているのであれば `dbn` の値も `'mysql'` にする。）

データベースに単純なテーブルを作成する。

    CREATE TABLE todo {
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'
    };

そして最初のレコードを追加する。

    INSERT INTO todo (title) VALUES ('Learn web.py');

`code.py` に戻り、`index.GET` を次のように変更する。

    def GET(self):
        todos = web.select('todo')
        print render.index(todos)

そして URL ハンドラを `/` のみに戻す。

`index.html` は以下のようにする。

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

再びサイトにアクセスしてみると、"Learn web.py" という todo アイテムが表示されているはずだ。おめでとう！　データベースからデータを取得するウェブアプリケーションの一丁あがりだ。今度はデータベースへの書き込みもできるようにしてみよう。

{index.html` に、次のように書き加える。

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

そして URL 一覧を次のようにする。

    '/', 'index',
    '/add', 'add'

（カンマの打ち忘れに注意すること。これを入れ忘れると、Python は 文字列を連結してしまうので、URL のリストではなく `'/index/addadd'` だと見なされてしまう！）

続いて新しいクラスを追加。

    class add:
        def POST(self):
            i = web.input()
            n = web.insert('todo', title=i.title)
            web.seeothrer('/')

（`POST` を使う理由はわかってるよね？）

ユーザーがフォームを通して送信した値には、`web.input` のようにしてアクセスできる。`web.insert` はデータベースの todo テーブルに値を挿入して、新しくできたレコードの ID を返す。`seeother` は指定した URL にユーザーをリダイレクトする。

駆け足で紹介: `web.transact()` でトランザクションを開始する。`web.commit()` でそれをコミットし、`web.rollback()` でロールバック。`web.update` は `web.insert` に似ているが、新しい ID を返すのではなく、テーブル名に続けて ID を引数に取ってそのレコードを更新する。

`web.input` や `web.query`、またその他いくつかの web.py 関数は「ストレージオブジェクト」というものを返す。これは辞書オブジェクトに似ているが、`d['foo']` だけでなく `d.foo` のようにアクセスできるところが違っている。これのおかげで、コードがずいぶんすっきりしたものになるはずだ。
[ドキュメント](/docs)には、これまでに挙げてきたものに限らず、web.py のすべての関数についてその詳細が書かれている。

チュートリアルは以上だ。web.py でできるクールなことについてもっと知りたければドキュメントを見てほしい。
---
layout: default
title: web.py 0.2 tutorial
---

# web.py 0.2 tutorial

* [english](/tutorial2.en)
* [简体中文](http://www.dup2.org/files/web.py%200.2%20tutorial.html)
* [Español](/tutorial2.es)
* [Português (Brasil)](/tutorial2.pt-br)
* [Русский](/tutorial2.ru)
* [日本語](/tutorial2.ja)
* [Deutsch](/tutorial2.de)
* [Françai](/tutorial2.fr)<a href="http://www.from-thailand.com/" title="Grossiste, Décoration asiatique, Thailande, Import Export" alt="Grossiste, Décoration asiatique, Import Export, Thailande">s</a>
* [Polish](/tutorial2.pl)
* [ελληνικά](/turorial2.el)























---
layout: default
title: web.py 0.2 tutorial
---

# web.py 0.2 tutorial

## Startujemy

A więc potrafisz programować w Pythonie i pragniesz zrobić swoją stronę. Z web.py to zadanie staje się wyjątkowo łatwe.

Jeżeli masz zamiar przejść przez cały tutorial, będziesz potrzebował mieć zainstalowane: Python, web.py, flup, psycopg2 i Postgress (lub inną bazę danych oraz pythonowy driver do niej). Po szczegóły zerknij na [webpy.org](http:webpy.org/).

Jeżeli masz już istniejący projekt stworzony z użyciem web.py, zajrzyj na stronę opisującą [upgrade](http://webpy.infogami.com/upgrade_to_point2). Znajdziesz tam informacje przydatne podczas migracji.

A więc zaczynamy.

## Obsługa URL

Jednym z ważniejszych aspektów w projekcie serwisu webowego jest jego struktura odnośników (urli). Są one nie tylko tym, co osoby odwiedzający stronę widzą i ewentualnie przekazują swoim znajomym, ale także dają wyobrażenie o tym, jak twój serwis działa. Niektóre popularne serwisy jak [del.icio.us](http://del.icio.us/) uczyniły odnośniki częścią interfejsu użytkownika. web.py umożliwia stworzenie świetnych odnośników w prosty sposób.

Żeby zacząć przygodę z web.py, otwórz nowy plik tekstowy (nazwijmy go code.py) i napisz w nim:

    import web

Instrukcja ta spowoduje zaimportowanie modułu web.py.

Teraz trzeba wskazać strukturę odnośników, jaką ma obsługiwać web.py. Zacznijmy od czegoś naprawdę prostego:

    urls = (
      '/', 'index',
      '',  'index'    )

Pierwsza część każdego wpisu to [wyrażenie regularne](http://osteele.com/tools/rework/) do którego będzie porównywany odnośnik, np. `/`, `/help/faq`, `/item/(\d+)`, itp. (`\d+` zostanie dopasowane do sekwencji cyfr, czyli liczby). Nawiasy powodują "złapanie" części odnośnika z celu dalszego użycia. Druga część wpisu to nazwa pythonowej klasy, która ma obsłużyć zapytanie dla danego odnośnika, np. `index`, `view`, `welcomes.hello` (czyli klasa hello w module welcomes) lub `get_\1`. `\1` zostanie zastąpione przez pierwsze dopasowanie wyrażenia regularnego, reszta dopasowań zostanie przekazana jako parametry do klasy.

Powyższy kod oznacza, że chcemy aby odnośnik `/` (to jest strona powitalna) była obsługiwana przez klasę nazwaną `index`.

Teraz trzeba ową klasę napisać. Prawdopodobie większość osób nawet nie zauważa tego, że przeglądarka używa protokołu zwanego HTTP do komunikacji z siecią WWW. Nie są tutaj istotne szczegóły, ale podstawowa idea jest taka, że serwery WWW są proszone o wykonanie pewnych funkcji (jak `GET` lub `POST`) przy użyciu odnośników (jak `/` lub `/foo?f=1`).

Funkcja `GET` jest tą najbardziej popularną i najczęściej używaną do pobrania z serwera strony web. Wpisując w przeglądarce adres `harvard.edu` w istocie przeglądarka poprosi serwer Harvardu o wykonanie funkcji `GET /`. Drugą najpopularniejszą funkcją jest `POST`. Najczęściej używana jest do wysyłania rozmaitych formularzy, np. z prośba o kupienie czegoś. 
 
W naszym kodzie rozróżnienie tych dwóch funkcji jest bardzo proste i czytelne:

    class index:
        def GET(self):
            print "Hello, world!"

Zdefiniowana funkcja `GET` będzie wywołana przez web.py za każdym razem gdy serwer dostanie prośbę o odnośnik `/`.

Dobrze, teraz jeszcze musimy dopisać ostatnią linijkę uruchamiającą web.py:

    if __name__ == "__main__": web.run(urls, globals())

Kod ten mówi web.py żeby dostarczał odnośniki wymienione powyżej, używając do tego klass zdefiniowanych w głównej przestrzeni nazw tego pliku.

Warto zauważyć, że pomimo długiego opisu, tak naprawdę napisaliśmy mniej więcej 5 linii kodu. Tylko tyle potrzeba, aby stworzyć kompletną aplikację web.py. Można ją teraz uruchomić w ten sposób:

    $ python code.py
    Launching server: http://0.0.0.0:8080/

Właśnie uruchomiłeś swoją własną aplikację web.py i serwer www na swoim komputerze. Wpisz w przeglądarkę ten adres aby zobaczyć "Hello, world!" (możesz dopisać po code.py adress ip/port, możesz też polecić uruchomienie serwera `fastcgi` lub `scgi`).

**Uwaga:** Możesz podać numer portu na którym ma działać serwer jeżeli nie chcesz lub nie możesz użyć tego domyślnego:

    $ python code.py 1234

## Rozwijanie aplikacji

web.py posiada kilka narzędzi pomocnych w tropieniu i usuwaniu ewentualnych błędów. Przed `if __name__` w ostatniej linijce dopisz:

    web.webapi.internalerror = web.debugerror

Spowoduje to wyświetlanie bardziej przyjaznych komunikatów o błędach. Dodatkowo w ostatniej linijce dopisz `web.reloader`:

    if __name__ == "__main__": web.run(urls, globals(), web.reloader)
    
Spowoduje to użycie middleware'u web.reloader, który będzie przeładowywał twoje pliki z kodem za każdym razem gdy coś w nich zmienisz, tak abyś widział te zmiany od razu w działającym serwerze. Chociaż mimo wszystko, poważniejsze zmiany w kodzie i tak będą wymagały restartu serwera. Prawdopodobnie będziesz chciał wyłączyć tą opcję w docelowej wersji serwisu, ale jest to spore ułatwienie na czas kodowania. Dostępny jest także `web.profiler`, który dostarcza informacje o tym jak szybko (lub wolno) są wykonywane twoje funkcje.

## Szablony

Pisanie kodu HTML bezpośrednio w Pytonie jest niezbyt wygodne. Zdecydowanie ciekawsze jest pisanie kodu Pythona wewnątrz HTML. Na szczęście web.py czyni to całkiem łatwym.

**Uwaga:** Stare wersje web.py używały [Cheetah](http://www.cheetahtemplate.org/). Możesz oczywiście nadal używać tych lub innych szablonów, ale Cheetah nie są już oficjalnie wspierane.

(translation is in progress...)

Let's make a new directory for our templates (we'll call it `templates`). Inside, make a new file whose name ends with HTML (we'll call it `index.html`). Now, inside, you can just write normal HTML:

    <em>Hello</em>, world!

Or you can use web.py's templating language to add code to your HTML:

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

**Note: Currently, four spaces are required for indentation.**

As you can see, the templates look a lot like Python files except for the `def with` statement at the top (saying what the template gets called with) and the `$`s placed in front of any code.  Currently, template.py requires the `$def` statement to be the first line of the file.  Also, note that web.py automatically escapes any variables used here, so that if for some reason `name` is set to a value containing some HTML, it will get properly escaped and appear as plain text. If you want to turn this off, write `$:name` instead of `$name`.

Now go back to `code.py`. Under the first line, add:

    render = web.template.render('templates/')

This tells web.py to look for templates in your templates directory. Then change `index.GET` to:

    name = 'Bob'    
    print render.index(name)

('index' is the name of the template and 'name' is the argument passed to it)

Visit your site and it should say hello to Bob. 

**Development tip:** Add , `cache=False` to the end of your `render` call to have web.py reload your templates every time you visit the page.

But let's say we want to let people enter their own name in. Replace the two lines we added above with:

    i = web.input(name=None)
    print render.index(i.name)

Visit `/` and it should say hello to the world. Visit `/?name=Joe` and it should say hello to Joe.

Of course, having that `?` in the URL is kind of ugly. Instead, change your URL line at the top to:

    '/(.*)', 'index'

and change the definition of `index.GET` to:

    def GET(self, name):
        print render.index(name)

and delete the line setting name. Now visit `/Joe` and it should say hello to Joe.

If you wish to learn more about web.py templates, vist the [templetor page](/templetor).

## Databasing

**Note:** Before you can start using a database, make sure you have the appropriate database library installed.  For MySQL databases, use [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) and for Postgres use [psycopg2](http://initd.org/pub/software/psycopg/).

Above your `web.run` line add:

    web.config.db_parameters = dict(dbn='postgres', user='username', pw='password', db='dbname')

(Adjust these -- especially `username`, `password`, and `dbname` -- for your setup. MySQL users will also want to change `dbn` definition to `mysql`.)

If you're running a web application, that's all you need to do -- web.py will automatically handle connecting and disconnecting from the database. But if you're working from the command line or starting your own thread, you need to call `web.load()` to connect and `web.unload()` to disconnect.

Using your database engines admin interface, create a simple table in your database:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

And an initial row:

    INSERT INTO todo (title) VALUES ('Learn web.py');

Return to editing `code.py` and change `index.GET` to the following, replacing the entire function:

    def GET(self):
        todos = web.select('todo')
        print render.index(todos)

and change back the URL handler to take just `/` as in:

    '/', 'index',

Edit and replace the entire contents of `index.html` so that it reads:

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

Visit your site again and you should see your one todo item: "Learn web.py". Congratulations! You've made a full application that reads from the database. Now let's let it write to the database as well.

At the end of `index.html`, add:

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

And change your URLs list to read:

    '/', 'index',
    '/add', 'add'

(You've got to be very careful about those commas.  If you omit them, Python adds the strings together and sees `'/index/addadd'` instead of your list of URLs!)

Now add another class:

    class add:
        def POST(self):
            i = web.input()
            n = web.insert('todo', title=i.title)
    	    web.seeother('/')

(Notice how we're using `POST` for this?)

`web.input` gives you access to any variables the user submitted through a form. 

Note: In order to access data from multiple identically-named items, in a list format (e.g.: a series of check-boxes all with the attribute name="name") use:

    post_data=web.input(name=[])

`web.insert` inserts values into the database table `todo` and gives you back the ID of the new row. `seeother` redirects users to that URL.

Some quick additional notes: `web.transact()` starts a transaction. `web.commit()` commits it; `web.rollback()` rolls it back. `web.update` works just like `web.insert` except instead of returning the ID it takes it (or a string `WHERE` clause) after the table name.

`web.input`, `web.query`, and other functions in web.py return "Storage objects", which are just like dictionaries except you can do `d.foo` in addition to `d['foo']`. This really cleans up some code.

You can find the full details on these and all the web.py functions in [the documentation](/docs).

This ends the tutorial for now. Take a look at the documentation for lots more cool stuff you can do with web.py.
---
layout: default
title: tutorial do web.py 0.2
---

# tutorial do web.py 0.2

## Começando

Então você sabe Python e quer fazer um site. O web.py fornece o código que torna essa uma tarefa fácil.

Se você quiser fazer o tutorial inteiro, você precisará destes programas: Python, web.py, flup, psycopg2 e Postgres (ou um banco de dados equivalente e adaptador correspondente para Python). Para detalhes, veja [webpy.org](http://webpy.org/).

Se você já tem um projeto web.py, dê uma olhada na página de [atualização](http://webpy.infogami.com/upgrade_to_point2) (em inglês) para informações sobre migração.

Vamos começar.

## Tratamento de URLs

A parte mais importante de qualquer site é a estrutura de suas URLs. Suas URLs não são simplesmente aquela coisa que os visitantes vêem e mandam para seus amigos; elas também criam um modelo mental de como seu site funciona. Em sites populares como o [del.icio.us](http://del.icio.us/), as URLs são até uma parte da interface com o usuário. O web.py faz com que criar boas URLs seja fácil.

Para começar sua aplicação com web.py, abra um novo arquivo de texto (vamos chamá-lo de 'codigo.py') e digite:

    import web

Isso serve para importar o módulo do web.py.

Agora precisamos dizer ao web.py qual será nossa estrutura de URLs. Vamos começar com algo simples:

    urls = (
      '/', 'index'    )

A primeira parte é uma [expressão regular](http://osteele.com/tools/rework/) que corresponde a uma URL, como `/`, `/ajuda/faq`, `/item/(\d+)`, etc. (`\d+` corresponde a uma seqüência de dígitos. Os parênteses pedem que aquela parte da correspondência seja "capturada" para ser usada mais tarde.) A segunda parte é o nome de uma classe para a qual a requisição HTTP deve ser enviada, como `index`, `view`, `welcomes.hello` (este último corresponde à classe `hello` do módulo `welcomes`), ou `get_\1`. `\1` é substituído pela primeira captura feita pela sua expressão regular; as capturas que sobrarem são passadas para a sua função.

Essa linha diz que queremos que a URL `/` (i.é., a página inicial) seja tratada pela classe chamada `index`.

Agora precisamos escrever a classe `index`. Apesar de a maioria das pessoas não perceber enquanto navega por aí, seu navegador usa uma linguagem conhecida como HTTP para comunicar-se com a internet. Os detalhes não são importantes, mas o princípio básico é que os visitantes da Web pedem aos servidores web que realizem certas funções (como `GET` ou `POST`) em URLs (como `/` ou `/foo?f=1`). 

`GET` é a função com a qual estamos todos acostumados: é a usada para pedir o texto de uma página da web. Quando você digita `harvard.edu` no seu navegador, ele literalmente pede ao servidor web de Harvard `GET /`.  A segunda mais famosa, `POST`, é comumente usada ao enviar certos tipos de formulários, como um pedido para comprar algo. Você usar `POST` sempre que o envio de um pedido _faz alguma coisa_ (como cobrar de seu cartão de crédito e processar um pedido). Isso é crucial, pois URLs do tipo `GET` podem ser transmitidas por aí e indexadas por mecanismos de busca -- você quer isso para a maioria das suas página, mas com certeza _não_ para coisas como processar pedidos (imagine se o Google tentasse comprar tudo no seu site!).

No nosso código para o web.py, a distinção entre os dois é clara:

    class index:
        def GET(self):
            print "Olá, mundo!"
Essa função `GET` será chamada pelo web.py sempre que alguém fizer um pedido `GET` para a URL `/`.

Ok, agora só falta terminar com uma linha que manda o web.py começar a servir as páginas da web:

    if __name__ == "__main__": web.run(urls, globals())

Isso manda o web.py servir as URLs que listamos acima, procurando as classes no nome de espaços global para o arquivo atual.

Perceba que, embora eu esteja falando bastante, nós só temos umas cinco linhas de código. É só isso que você precisa para fazer uma aplicação completa com o web.py. Se você for até sua linha de comando e digitar:

    $ python codigo.py
    Launching server: http://0.0.0.0:8080/

Você terá sua aplicação web.py executando um servidor web de verdade no seu computador. Visite essa URL e você deverá ver "Olá, mundo!" (Você pode adicionar um endereço IP/porta depois de "codigo.py" para controlar onde o web.py executa o servidor. Você também pode fazê-lo rodar um servidor `fastcgi` ou `scgi`.)

**Nota:** Você pode especificar o número de porta a usar pela linha de comando desta maneira, se não puder ou não quiser usar o padrão:

    $ python codigo.py 1234

## Desenvolvimento

O web.py também tem algumas ferramentas para nos ajudar com a depuração. Antes do 'if __name__' na última linha, adicione:

    web.webapi.internalerror = web.debugerror

Isso lhe fornecerá mensagens de erro mais úteis, quando for o caso. Coloque também na última linha `web.reloader`, de modo que ela se torne:

    if __name__ == "__main__": web.run(urls, globals(), web.reloader)
    
Isso diz ao web.py que use o "middleware" web.reloader (middleware é uma função intermediária que adiciona certos recursos ao seu servidor web), que recarrega seus arquivos assim que você os edita, de modo que você pode imediatamente ver as alterações no seu navegador. (Contudo, para algumas alterações mais drásticas, você ainda precisará reiniciar o servidor.) Você provavelmente deverá tirar isso ao deixar seu site público, mas é um recurso excelente durante o desenvolvimento. Também há o `web.profiler`, que, no final de cada página, fornece informações sobre quanto tempo cada função tomou, de modo que você possa tornar seu código mais rápido.

## Templating

Escrever HTML de dentro do Python pode tornar-se um empecilho; é muito mais divertido escrever código Python de dentro do HTML. Por sorte, o web.py torna isso bastante fácil.

**Nota:** Versões antigas do web.py usavam [Cheetah templates](http://www.cheetahtemplate.org/). Você é, é claro, livre para usar esse ou qualquer outro software com o web.py, mas ele não é mais suportado oficialmente.

Vamos criar um novo diretório para nossos templates (vamos chamá-lo de `templates`). Dentro dele, crie um novo arquivo cujo nome termine em HTML (vamos chamá-lo de `index.html`). Agora, dentro dele, você pode escrever código HTML normal:

    <em>Olá</em>, mundo!

Ou você pode usar a linguagem de templates do web.py para adicionar código ao seu HTML:

    $def with (nome)
    
    $if nome:
        Eu só queria dizer <em>olá</em> para $nome.
    $else:
        <em>Olá</em>, mundo!

**Nota: Atualmente, é necessário usar quatro espaços para a indentação.**

Como você pode ver, os templates parecem-se bastante com arquivos Python, exceto pela instrução `def with` no começo (ela diz com que parâmetros o template é chamado) e os `$`s colocados na frente de qualquer código.  Atualmente, o template.py requer que a instrução $def seja a primeira linha do arquivo.  Além disso, note que o web.py "escapa" as variáveis que forem usadas -- de modo que se, por alguma razão, o valor da variável `nome` conntém algum código HTML, ela será devidamente "escapada" e aparecerá como texto puro. Se você não deseja esse comportamento, use `$:nome` em vez de `$nome`.

Agora volte ao `codigo.py`. Abaixo da primeira linha, insira:

    render = web.template.render('templates/')

Isso manda o web.py procurar por templates no seu diretório `templates`. Então altere a função `index.GET` para:

    nome = 'João'
    print render.index(nome)

('index' é o nome do template, e 'nome' é o parâmetro passado para ele)

Visite seu site e ele deverá dizer olá para o João.

**Dica para o desenvolvimento:** Adicione `cache=False` ao final da sua chamada a `render` para que o web.py recarregue seus templates toda vez que você entrar na sua página.

Agora mude sua URL para:

    '/(.*)', 'index'
e troque a definição de `index.GET` para:

    def GET(self, nome):

e apague a linha que define `nome`. Visite `/` e a página deverá dizer olá ao mundo. Visite `/José` e ela deverá dizer olá ao José.

Se você quer aprender mais sobre os templates do web.py, visite a página do [templetor](/templetor) (em inglês).

## Bancos de dados

Nota: Antes de poder começar a usar um banco de dados, certifique-se de que tem a biblioteca correspondente instalada. Para bancos de dados MySQL, use [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307); para o Postgres, use o [psycopg2](http://initd.org/pub/software/psycopg/).

Acima da sua linha `web.run`, adicione:

    web.config.db_parameters = dict(dbn='postgres', user='nome_do_usuario', pw='senha', db='nome_do_banco_de_dados')

(Modifique isto -- especialmente `nome_do_usuario`, `senha`, and `nome_do_banco_de_dados` -- para os valores correspondentes à sua configuração. Usuários do MySQL também devem trocar `dbn` por `mysql`.)

Crie uma tabela simples no seu banco de dados:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

E uma linha inicial:

    INSERT INTO todo (title) VALUES ('Aprender web.py');

Voltando ao `codigo.py`, modifique a função `index.GET` para:

    def GET(self):
        todos = web.select('todo')
        print render.index(todos)

e modifique o tratador de URLs de volta para simplesmente `/`.

Edite o `index.html` de modo que ele se torne:

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>    </ul>
Visite novamente seu site, e você deverá ver uma tarefa na lista: "Aprender web.py". Parabéns! Você fez uma aplicação completa que lê dados de um banco de dados. Agora vamos também gravar dados no banco de dados.

No final de `index.html`, insira:

    <form method="post" action="add">    <p><input type="text" name="title" /> <input type="submit" value="Adicionar" /></p>    </form>
E modifique sua lista de URLs para que fique assim:

    '/', 'index',
    '/add', 'add'
(Você deve ser muito cuidadoso com essas vírgulas.  Se você as omitir, o Python juntará as strings e verá `'/index/addadd'` no lugar da sua lista de URLs!)

Agora adicione outra classe:

    class add:
        def POST(self):
            i = web.input()
            n = web.insert('todo', title=i.title)
    	    web.seeother('/')

(Viu como estamos usando o método `POST` para isso?)

`web.input` lhe dá acesso às variáveis que o usuário enviou através de um formulário.  Para obter dados de elementos com nomes idênticos em formato de lista (por exemplo, uma série de caixas de verificação com o atributo name="nome"), use:

    post_data=web.input(nome=[])

`web.insert` insere valores na tabela `todo` do banco de dados e lhe devolve o ID da nova linha. `seeother` redireciona os usuários para esse ID.

Rapidinhas: `web.transact()` inicia uma transação. `web.commit()` confirma a transação e armazena os dados; `web.rollback()` desfaz as alterações. `web.update` funciona como `web.insert`, recebendo (em vez de devolver) um ID (ou uma string com uma sentença `WHERE`) após o nome da tabela.

`web.input`, `web.query` e outras funções do web.py devolvem "Objetos de armazenamento", que são como dicionários mas também permitem que você use `d.foo` além de `d['foo']`. Isso realmente deixa certos códigos mais limpos.

Você pode encontrar todos os detalhes sobre essas e todas as outras funções do web.py na [documentação](http://new.webpy.org/docs) (em inglês).

Isso termina o tutorial por enquanto. Dê uma olhada na documentação para ver o monte de coisas legais que você pode fazer com o web.py.
---
layout: default
title: tutorial2.ru
---

# tutorial2.ru

## Установка

Для нормальной работы программ с web.py необходимы сам web.py, flup и библиотеки баз данных.
Скачайте в один и тот же каталог следующие файлы:

* web.py (лучше из svn, командой **svn co http://webpy.org/svn/trunk/web**)
* flup - **wget http://www.saddi.com/software/flup/dist/flup-r2016.tar.gz**


после этого разожмите последний архив, скопируйте содержимое папки flup в каталог, где вы работаете, и удалите ненужный хлам. Например так:

    $ tar xf flup-r2016.tar.gz
    $ mv flup{-r2016/flup,}
    $ rm -r flup-r2016*

Таким образом мы подготовили среду для разработки.

## Поддержка URL

Самая важная часть любого файла это структура его URL. Эти адреса - не только буквы, которые ваши посетители видят и отправляют по почте друзьям, это ментальная модель работы вебсайта.
На популярных сайтах, таких как [del.icio.us](http://del.icio.us/), URL это вообще часть пользовательского интерфейса. web.py легко позволяет сделать клевые URLы.

Откройте в текстовом редакторе новый файл, назвав его ну... скажем... **poluekt.py**.
Шучу. Удобнее будет **code.py**. Впишите в него главную строку:

    import web

так импортируются функции фреймворка **web.py**.

    urls = (
       '/', 'index'    )

Это ваш лист соответствия urlов и функций. Первая  часть - регулярное выражение с помощью которого определяется путь. Например **'/'**, или **'/help/faq'**, или даже **/item/(\d+)**. Строка **d+** обозначает "некоторая ненулевая последовательность цифр", подробнее смотрите об этом в [Python Regex HowTo](http://www.amk.ca/python/howto/regex/) или воспользуйтесь [удобной генерилкой regex](http://osteele.com/tools/rework/). Скобки вокруг **\d+** нужны для того, чтобы удобно исользовать эти цифры в дальнейшем. Вторая часть - имя класса, которому будет передан запрос. Например, **'index'**, **'welcomes.hello'** (то есть класс **hello** из модуля **welcomes**) или **'get_\1'**. **\1** заменяется на первое совпадание выделенного регулярного выражения. Все остальные элементы выделенного регулярного выражения (помните **(\d+)**? ) передаются в класс-обработчик.


Собственно в нашем случае сказано что URL "/" (т.е. первая страница) будет обрабатываться классом **'index'**

Теперь нам надо написать сам класс. В то время как большая часть людей не обращая ни на что внимание бродит по сайтам, внутри веба используется архитектурный стиль, известный как REST. Детали не так уж и важны, но основная идея в том, что посетители сайтов просят сервер применить определенные действия (например "GET" и "POST") на ссылки (такие как "/" или "/wtf?f=1").

"GET" это то, к чему мы все привыкли, он используется чтобы получить содержимое страницы. Когда вы открываете сайт "yandex.ru" в своем браузере, на самом деле вы как бы просите Яндекс взять ("GET" от английского "to get" - брать) страницу '/', командой "GET /". "POST", вторая популярная функция, от английского to post - записать, внести в списки. Логично предположить что с помощью этой команды вы просите _что-либо_сделать_, например зачарджить кредитную карту и подтвердить заказ. В этом и есть фича, потому что "GET" может свободно использоваться везде, например индексироваться яндексом, что не слишком хорошо для страниц с заказами. Представьте себе что робот яндекса пришел на ваш сайт и заказал все товары!

## Разработка

В нашем коде для web.py мы сделаем так:

    class index:
       def GET(self):
            print "Превед, Орлы!!!"            # Таким образом постетителю страницы '/' будет показан русский вариант строки "Hello World!".
    if __name__ == "__main__": web.run(urls, globals())

Этот страшный набор букв говорит, что нужно запустить наше веб-приложение при исполнении файла.
Первый аргумент вызова **web.run**, urls, это тот самый список-соответствие url'ов и функций, описаный выше.

У web.py также есть средства для отладки, например добавьте перед последней строкой:
    web.webapi.internalerror = web.debugerror

Теперь при ошибке вы будете читать нормальный, человеко-читаемый бэктрейс. Если в последней строке вписать последним аргументом **web.reloader** будет еще лучше.
Это очень удобная опция, заставляющая web.py перезагружать исполняемый файл каждый раз, когда в нем что-то изменено. Постарайтесь не забыть убрать и этот параметр перед публичным запуском вашей страницы. Кстати, если вместо **web.reloader** вписать **web.profiler** можно будет узнавать сколько времени занимает та или иная функция при выдаче страницы. Говоря человеческим языком, это *профайлер*, то есть средство, помогающее оптимизировать скорость работы скрипта.

Настало время запускать наше приложение. Просто выполните команду

    $ python code.py

и приложение запустит маленький веб-сервер, который будет отвечать на адрес **http://localhost:8080/**.
Вы можете изменить порт по умолчанию на другой, указав номер порта в качестве параметра, например так:

    $ python code.py 6060

Вы также можете запускать этот скрипт как **CGI** или **FastCGI** скрипт -- он автоматически распознает подобные вещи.
На самом деле web.py использует **WSGI**, так что ваше приложение может работать с любым интерфейсом к web для
python, в том числе **scgi** и **mod_python**.

Теперь, если вы откроете свой браузер на ссылке [http://localhost:8080/](http://localhost:8080/), ваше приложение поздаровается с вами.

## Шаблоны

Написание HTML внутри кода на Python это отвратительно. Куда веселее писать на Python внутри HTML. К счастью web.py позволяет нам это делать, с легкостью.

Cоздадим каталог для наших темплейтов (назовем его... ммм.... "templates"). Внутри этого каталога создадим файлик с расширением .html (скажем **index.html**). Теперь внутри это файла напиешем нормальный HTML:

    <em>Превед</em>, орлы!

Или используем специальный синтаксис темплейтов web.py, например так:

    $def with (name)    
    $if name:
        <em>Превед</em> тебе, дорогой $name.
        Твой Медвед.
    $else:
        <em>Превед</em>, орлы!

Как видите теплейты очень похожи на обычный python за исключением оператора `def with` в начале (он говорит о параметрах, которые используются в темплейте) и символа `$` расположеного в начале каждой строки с кодом. Заметьте также что web.py автоматически ескейпит все переменные, использованные в примере, таким образом, что  если по каким-либо причинам переменная `name` будет содержать HTML, то при выводе они будут заэскейплены и показаны пользователю как текст. Чтобы выключить эскейпинг используйте синтаксис `$:name` вместо `$name`.

Вернемся к коду. Под первой строкой, сразу после импортов впишите:
 
    render = web.template.render('templates/')

Это обьяснит библиотеке, где же именно искать темплейты. Теперь поменяйте `index.GET` на:

    name = 'balbes'    print render.index(name)

Зайдите на ваш сайт и присмотритесь к надписи **Превед** тебе, дорогой balbes.

(**Заметка для девелоперов:** добавьте `, cache=True` в конце вызова `render` чтобы web.py кешировал ваши темплейты.)

## Забавные URLы

Теперь измените ваш список URLов на такой:

    '/(.*)', 'index'
и поправьте определение `index.GET` на:

    def GET(self, name):

Удалите строку, устанавливающую name. Теперь если зайти просто на `/` то увидите "Превед, орлы". А вот если зайти на `/balbes` - будет куда интереснее.
Таким образом выделенное выражение **(.*)** передалось в функцию в качестве первого параметра - **name**.

## Базы Данных

Ниже строки с **web.run** впишите:

    web.config.db_parameters = dict(dbn='mysql', user='me', pw='pass', db='dbname')

конечно же вам нужно изменить эти параметры, чтобы иметь доступ к базе данных.
Создайте простую табличку, например такую:

    CREATE TABLE todo (
        id unique AUTO_INCREMENT primary key,
        title text,
        created timestam default now()
    );

и вставьте в нее строчку с примером:

    INSERT INTO todo (title) VALUES ('Заучить web.py');


В **index.py** давайте опять переделаем `index.GET`:

    def GET(self):
        todos = web.select('todo')
        print render.index(todos)

И снова вернем список листов, так чтобы 'GET /' обращался на index.
Черт, теперь выкиньте все из **index.html** и пишите сначала:
    $def with (todos)
    <ul>    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>    
    </ul>
Посетив вашу уже немаленькую веб-страничку, вы увидите один элемент:  'Заучить web.py'.
Допишите в конец этого же файла:

    <form method="post" action="add">        <p>            <input type="text" name="title" />                <input type="submit" value="Add" />        </p>    </form>
Измените ваш список ссылок **urls** вот так:

    '/', 'index',
    '/add', 'add'
Обратите внимание на запятые. Помните, что в Python две строки написанные без запятых просто обьединяются.
Добавим еще один класс -  **add**:

    class add:
        def POST(self):
            i = web.input()
            n = web.insert('todo', title=i.title)
        web.seeother('./#t'+str(n))

**web.insert** возвращает идентификатор свежевставленного элемента, а команда **web.seeother** пересылает пользователя на этот новый элемент. 

Еще одна штука - вот в строчке **i = web.input** мы получили в переменной i все параметры, переданные из формы пользователем. Красиво и просто, правда?

В темпе вальса: **web.transact()** начинает транзакцию, **web.commit()** коммитит её, **web.rollback()**, что логично, откатывает её. **web.update** работает точно также как **web.insert** за исключением того, что вместо возврата нового элемента она обновляет уже сохраненный элемент по его id (или по строке, которая подставляется в WHERE запроса)

В общем это всё к чему - теперь вы можете добавлять новые элементы в список.

Объект-хранилище
----------------

И **web.input**, и **web.query**, а также большинство других функций **web.py** возвращают в качестве результата объект-хранилище. Этот объект похож на стандартный dictionary языка python, однако позволяет обращаться к элементам не только через d['figna'], но и d.figna, что на 3 символа короче :)

Куки
----

А также спамы и трояны...

Куки работают также, как и **web.input**. **web.cookies()** возвращает объект-хранилище с набором кук, пришедших от браузера. Вы можете изменять их функцией **web.setcookie(name, value, expires="")**, где name - имя куки, value - значение, а expires, соответственно, срок истечения действия куки.

И **web.input**, и **web.cookies** в качестве параметра принимают названия и пары ключ-значение. 
Например, вызвав **web.input('color', times=1)** вы поймаете ошибку, если в форме не окажется элемента **color**, или если в элементе **times** не будет единица.

Типовой паттерн использования:

    try:
        i = web.input('foo', bar=2)
    except KeyError:
        return web.badrequest()

*Пока всё, ребята. В следующий раз я раскажу вам про модуль forms.
Комментарии? Вопросы? Мнения? Предложения? мой адрес - <bobuk@justos.org>*
---
layout: default
title: web.py 0.3 向导
---

# web.py 0.3 向导

<p>

</p><h2>开始</h2>
<p>所以，你知道Python和想一个网站。 web.py提供了代码，以容易。
</p>
<p>If you want to do the whole tutorial, you'll need to have installed Python, web.py, flup, psycopg2, and Postgres (or equivalent database and Python driver). For details, see <a href="http://webpy.org/">webpy.org</a>.
</p>
<p>If you have an existing web.py project, take a look at the <a href="/docs/0.3/upgrade">upgrade</a> page for info on migrating.
</p>
<p>Let's get started.
</p>

<h2>URL Handling</h2>
<p>The most important part of any website is its URL structure. Your URLs aren't just the thing that your visitors see and email to their friends, they also provide a mental model of how your website works. On popular sites like <a href="http://del.icio.us/">del.icio.us</a>, the URLs are even part of the user interface. web.py makes it easy to make great URLs.
</p>
<p>To get started with your web.py application, open up a new text file (let's call it <code>code.py</code>) and type:
</p>
<pre><code>import web
</code></pre><p>This imports the web.py module.
</p>
<p>Now we need to tell web.py our URL structure. Let's start out with something simple:
</p>
<pre><code>urls = (
  '/', 'index'
)
</code></pre><p>The first part is a <a href="http://osteele.com/tools/rework/">regular expressions</a> that matches a URL, like <code>/</code>, <code>/help/faq</code>, <code>/item/(\d+)</code>, etc. (i.e. <code>\d+</code> would match a sequence of digits). The parentheses say to capture that piece of the matched data for use later on. The second part is the name of a class to send the request to, like <code>index</code>, <code>view</code>, <code>welcomes.hello</code> (which gets the <code>hello</code> class of the <code>welcomes</code> module), or <code>get_\1</code>. <code>\1</code> is replaced by the first capture of your regular expression; any remaining captures get passed to your function.
</p>
<p>This line says we want the URL <code>/</code> (i.e. the front page) to be handled by the class named <code>index</code>.
</p>
<p>Now we need to create an application specifying the urls.
</p>
<pre><code>app = web.application(urls, globals())
</code></pre><p>This tells web.py to create an application with the URLs we listed above, looking up the classes in the global namespace of this file.
</p>
<p>Now we need to write the <code>index</code> class. While most people don't notice it just browsing around, your browser uses a language known as HTTP for communicating with the World Wide Web. The details aren't important, but the basic idea is that Web visitors ask web servers to perform certain functions (like <code>GET</code> or <code>POST</code>) on URLs (like <code>/</code> or <code>/foo?f=1</code>). 
</p>
<p><code>GET</code> is the one we're all familiar with, the one used to request the text of a web page. When you type <code>harvard.edu</code> into your web browser, it literally asks the Harvard web server to <code>GET /</code>.  The second-most famous, <code>POST</code>, is often used when submitting certain kinds of forms, like a request to purchase something. You use <code>POST</code> whenever the act of submitting a request <em>does something</em> (like charge your credit card and process an order). This is key, because <code>GET</code> URLs can be passed around and indexed by search engines, which you definitely want for most of your pages but definitely <em>don't</em> want for things like processing orders (imagine if Google tried to buy everything on your site!).
</p>
<p>In our web.py code, we make the distinction between the two clear:
</p>
<pre><code>class index:
    def GET(self):
        return "Hello, world!"
</code></pre><p>This <code>GET</code> function will now get called by web.py anytime some makes a <code>GET</code> request for <code>/</code>.
</p>
<p>Alright, now we just need to finish up with a final line telling web.py to start serving web pages:
</p>
<pre><code>if __name__ == "__main__": app.run()
</code></pre><p>This tells web.py to serve the application we created above.
</p>
<p>Now notice that although I've been talking a lot here, we only really have five or so lines of code. That's all you need to make a complete web.py application. If you go to your command line and type:
</p>
<pre><code>$ python code.py
http://0.0.0.0:8080/
</code></pre><p>You now have your web.py application running a real web server on your computer. Visit that URL and you should see "Hello, world!" (You can add an IP address/port after the "code.py" bit to control where web.py launches the server. You can also tell it to run a <code>fastcgi</code> or <code>scgi</code> server.)
</p>
<p><strong>Note:</strong> You can specify the port number to use on the command line like this
   if you can't or don't want to use the default:
</p>
<pre><code>$ python code.py 1234
</code></pre>
<h2>Templating</h2>
<p>Writing HTML from inside Python can get cumbersome; it's much more fun to write Python from inside HTML. Luckily, web.py makes that pretty easy.
</p>
<p><strong>Note:</strong> Old versions of web.py used <a href="http://www.cheetahtemplate.org/">Cheetah templates</a>. You are, of course, welcome to use that or any other software with web.py, but it is no longer officially supported.
</p>
<p>Let's make a new directory for our templates (we'll call it <code>templates</code>). Inside, make a new file whose name ends with HTML (we'll call it <code>index.html</code>). Now, inside, you can just write normal HTML:
</p>
<pre><code>&lt;em&gt;Hello&lt;/em&gt;, world!
</code></pre><p>Or you can use web.py's templating language to add code to your HTML:
</p>
<pre><code>$def with (name)

$if name:
    I just wanted to say &lt;em&gt;hello&lt;/em&gt; to $name.
$else:
    &lt;em&gt;Hello&lt;/em&gt;, world!
</code></pre><p>As you can see, the templates look a lot like Python files except for the <code>def with</code> statement at the top (saying what the template gets called with) and the <code>$</code>s placed in front of any code.  Currently, template.py requires the <code>$def</code> statement to be the first line of the file.  Also, note that web.py automatically escapes any variables used here, so that if for some reason <code>name</code> is set to a value containing some HTML, it will get properly escaped and appear as plain text. If you want to turn this off, write <code>$:name</code> instead of <code>$name</code>.
</p>
<p>Now go back to <code>code.py</code>. Under the first line, add:
</p>
<pre><code>render = web.template.render('templates/')
</code></pre><p>This tells web.py to look for templates in your templates directory. Then change <code>index.GET</code> to:
</p>
<pre><code>name = 'Bob'    
return render.index(name)
</code></pre><p>('index' is the name of the template and 'name' is the argument passed to it)
</p>
<p>Visit your site and it should say hello to Bob. 
</p>
<p>But let's say we want to let people enter their own name in. Replace the two lines we added above with:
</p>
<pre><code>i = web.input(name=None)
return render.index(i.name)
</code></pre><p>Visit <code>/</code> and it should say hello to the world. Visit <code>/?name=Joe</code> and it should say hello to Joe.
</p>
<p>Of course, having that <code>?</code> in the URL is kind of ugly. Instead, change your URL line at the top to:
</p>
<pre><code>'/(.*)', 'index'
</code></pre><p>and change the definition of <code>index.GET</code> to:
</p>
<pre><code>def GET(self, name):
    return render.index(name)
</code></pre><p>and delete the line setting name. Now visit <code>/Joe</code> and it should say hello to Joe.
</p>
<p>If you wish to learn more about web.py templates, vist the <a href="/docs/0.3/templetor" class="internal">templetor page</a>.
</p>

<h2>Databasing</h2>
<p><strong>Note:</strong> Before you can start using a database, make sure you have the appropriate database library installed.  For MySQL databases, use <a href="http://sourceforge.net/project/showfiles.php?group_id=22307">MySQLdb</a> and for Postgres use <a href="http://initd.org/pub/software/psycopg/">psycopg2</a>.
</p>
<p>First you need to create a database object.
</p>
<pre><code>db = web.database(dbn='postgres', user='username', pw='password', db='dbname')
</code></pre><p>(Adjust these -- especially <code>username</code>, <code>password</code>, and <code>dbname</code> -- for your setup. MySQL users will also want to change <code>dbn</code> definition to <code>mysql</code>.)
</p>
<p>That's all you need to do -- web.py will automatically handle connecting and disconnecting from the database.
</p>
<p>Using your database engine's admin interface, create a simple table in your database:
</p>
<pre><code>CREATE TABLE todo (
  id serial primary key,
  title text,
  created timestamp default now(),
  done boolean default 'f'    );
</code></pre><p>And an initial row:
</p>
<pre><code>INSERT INTO todo (title) VALUES ('Learn web.py');
</code></pre><p>Return to editing <code>code.py</code> and change <code>index.GET</code> to the following, replacing the entire function:
</p>
<pre><code>def GET(self):
    todos = db.select('todo')
    return render.index(todos)
</code></pre><p>and change back the URL handler to take just <code>/</code> as in:
</p>
<pre><code>'/', 'index',
</code></pre><p>Edit and replace the entire contents of <code>index.html</code> so that it reads:
</p>
<pre><code>$def with (todos)
&lt;ul&gt;
$for todo in todos:
    &lt;li id="t$todo.id"&gt;$todo.title&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>Visit your site again and you should see your one todo item: "Learn web.py". Congratulations! You've made a full application that reads from the database. Now let's let it write to the database as well.
</p>
<p>At the end of <code>index.html</code>, add:
</p>
<pre><code>&lt;form method="post" action="add"&gt;
&lt;p&gt;&lt;input type="text" name="title" /&gt; &lt;input type="submit" value="Add" /&gt;&lt;/p&gt;
&lt;/form&gt;
</code></pre><p>And change your URLs list to read:
</p>
<pre><code>'/', 'index',
'/add', 'add'
</code></pre><p>(You've got to be very careful about those commas.  If you omit them, Python adds the strings together and sees <code>'/index/addadd'</code> instead of your list of URLs!)
</p>
<p>Now add another class:
</p>
<pre><code>class add:
    def POST(self):
        i = web.input()
        n = db.insert('todo', title=i.title)
        raise web.seeother('/')
</code></pre><p>(Notice how we're using <code>POST</code> for this?)
</p>
<p><code>web.input</code> gives you access to any variables the user submitted through a form. 
</p>
<p>Note: In order to access data from multiple identically-named items, in a list format (e.g.: a series of check-boxes all with the attribute name="name") use:
</p>
<pre><code>post_data=web.input(name=[])
</code></pre><p><code>db.insert</code> inserts values into the database table <code>todo</code> and gives you back the ID of the new row. <code>seeother</code> redirects users to that URL.
</p>
<p>Some quick additional notes: <code>db.update</code> works just like <code>db.insert</code> except instead of returning the ID it takes it (or a string <code>WHERE</code> clause) after the table name.
</p>
<p><code>web.input</code>, <code>db.query</code>, and other functions in web.py return "Storage objects", which are just like dictionaries except you can do <code>d.foo</code> in addition to <code>d['foo']</code>. This really cleans up some code.
</p>
<p>You can find the full details on these and all the web.py functions in <a href="/docs/0.3">the documentation</a>.
</p>

<h2>Developing</h2>
<p>web.py also has a few tools to help us with debugging. When running with the built-in webserver, it starts the application in debug mode. In debug mode any changes to code and templates are automatically reloaded and error messages will have more helpful information.
</p>
<p>The debug is not enabled when the application is run in a real webserver. If you want to disable the debug mode, you can do so by adding the following line before creating your application/templates.
</p>
<pre><code>web.config.debug = False
</code></pre><p>This ends the tutorial for now. Take a look at the documentation for lots more cool stuff you can do with web.py.
</p>





<div id="dateline">
    <a href="/tutorial3.en?m=edit" accesskey="e">Edit</a>
    <a href="/tutorial3.en?m=history" accesskey="h">History</a>
    Last Modified september 23
</div>
---
layout: default
title: web.py 0.3 tutorial
---

# web.py 0.3 tutorial

Other languages : [français](/tutorial3.fr) | [chinese 简体中文](/tutorial3.zh-cn) | [japan 日本語](/tutorial2.ja) | ...

## Summary

* <a href="#starting">Starting</a>
* <a href="#urlhandling">URL Handling</a>
* <a href="#getpost">GET and POST: the difference</a>
* <a href="#start">Start the server</a>
* <a href="#templating">Templating</a>
* <a href="#forms">Forms</a>
* <a href="#databasing">Databasing</a>
* <a href="#developing">Developing</a>
* <a href="#whatnext">What next?</a>


<a name="starting"></a>
## Starting

So you know Python and want to make a website. web.py provides the code to make that easy.

If you want to do the whole tutorial, you'll need to have installed Python, web.py, flup, psycopg2, and Postgres (or equivalent database and Python driver). For details, see [webpy.org](http://webpy.org/).

If you have an existing web.py project, take a look at the [upgrade](/docs/0.3/upgrade) page for info on migrating.

Let's get started.

<a name="urlhandling"></a>
## URL Handling

The most important part of any website is its URL structure. Your URLs aren't just the thing that your visitors see and email to their friends, they also provide a mental model of how your website works. On popular sites like [del.icio.us](http://del.icio.us/), the URLs are even part of the user interface. web.py makes it easy to make great URLs.

To get started with your web.py application, open up a new text file (let's call it `code.py`) and type:

    import web

This imports the web.py module.

Now we need to tell web.py our URL structure. Let's start out with something simple:

    urls = (
      '/', 'index'
    )

The first part is a [regular expressions](http://osteele.com/tools/rework/) that matches a URL, like `/`, `/help/faq`, `/item/(\d+)`, etc. (i.e. `\d+` would match a sequence of digits). The parentheses say to capture that piece of the matched data for use later on. The second part is the name of a class to send the request to, like `index`, `view`, `welcomes.hello` (which gets the `hello` class of the `welcomes` module), or `get_\1`. `\1` is replaced by the first capture of your regular expression; any remaining captures get passed to your function.

This line says we want the URL `/` (i.e. the front page) to be handled by the class named `index`.

Now we need to create an application specifying the urls.

    app = web.application(urls, globals())

This tells web.py to create an application with the URLs we listed above, looking up the classes in the global namespace of this file.

<a name="getpost"></a>
## GET and POST: the difference


Now we need to write the `index` class. While most people don't notice it just browsing around, your browser uses a language known as HTTP for communicating with the World Wide Web. The details aren't important, but the basic idea is that Web visitors ask web servers to perform certain functions (like `GET` or `POST`) on URLs (like `/` or `/foo?f=1`). 

`GET` is the one we're all familiar with, the one used to request the text of a web page. When you type `harvard.edu` into your web browser, it literally asks the Harvard web server to `GET /`.  The second-most famous, `POST`, is often used when submitting certain kinds of forms, like a request to purchase something. You use `POST` whenever the act of submitting a request _does something_ (like charge your credit card and process an order). This is key, because `GET` URLs can be passed around and indexed by search engines, which you definitely want for most of your pages but definitely _don't_ want for things like processing orders (imagine if Google tried to buy everything on your site!).

In our web.py code, we make the distinction between the two clear:

    class index:
        def GET(self):
            return "Hello, world!"

This `GET` function will now get called by web.py anytime some makes a `GET` request for `/`.

Alright, now we just need to finish up with a final line telling web.py to start serving web pages:

    if __name__ == "__main__": app.run()

This tells web.py to serve the application we created above.

Now notice that although I've been talking a lot here, we only really have five or so lines of code. That's all you need to make a complete web.py application.

<a name="start"></a>
## Start the server

 If you go to your command line and type:

    $ python code.py
    http://0.0.0.0:8080/

You now have your web.py application running a real web server on your computer. Visit that URL and you should see "Hello, world!" (You can add an IP address/port after the "code.py" bit to control where web.py launches the server. You can also tell it to run a `fastcgi` or `scgi` server.)

**Note:** You can specify the port number to use on the command line like this
if you can't or don't want to use the default:

    $ python code.py 1234


<a name="templating"></a>
## Templating

Writing HTML from inside Python can get cumbersome; it's much more fun to write Python from inside HTML. Luckily, web.py makes that pretty easy.

**Note:** Old versions of web.py used [Cheetah templates](http://www.cheetahtemplate.org/). You are, of course, welcome to use that or any other software with web.py, but it is no longer officially supported.

Let's make a new directory for our templates (we'll call it `templates`). Inside, make a new file whose name ends with HTML (we'll call it `index.html`). Now, inside, you can just write normal HTML:

    <em>Hello</em>, world!

Or you can use web.py's templating language to add code to your HTML:

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

As you can see, the templates look a lot like Python files except for the `def with` statement at the top (saying what the template gets called with) and the `$`s placed in front of any code.  Currently, template.py requires the `$def` statement to be the first line of the file.  Also, note that web.py automatically escapes any variables used here, so that if for some reason `name` is set to a value containing some HTML, it will get properly escaped and appear as plain text. If you want to turn this off, write `$:name` instead of `$name`.

Now go back to `code.py`. Under the first line, add:

    render = web.template.render('templates/')

This tells web.py to look for templates in your templates directory. Then change `index.GET` to:

    name = 'Bob'    
    return render.index(name)

('index' is the name of the template and 'name' is the argument passed to it)

Visit your site and it should say hello to Bob. 

But let's say we want to let people enter their own name in. Replace the two lines we added above with:

    i = web.input(name=None)
    return render.index(i.name)

Visit `/` and it should say hello to the world. Visit `/?name=Joe` and it should say hello to Joe.

Of course, having that `?` in the URL is kind of ugly. Instead, change your URL line at the top to:

    '/(.*)', 'index'

and change the definition of `index.GET` to:

    def GET(self, name):
        return render.index(name)

and delete the line setting name. Now visit `/Joe` and it should say hello to Joe.

If you wish to learn more about web.py templates, vist the [templetor page](/docs/0.3/templetor).

<a name="forms"></a>
## Forms

The form module of web.py allows the ability to generate html forms, get user input, and validate it before processing it or adding it to a database.
If you want to learn more about using the module forms web.py, see the [Documentation](http://webpy.org/docs/0.3) or direct link to [Form Library](http://webpy.org/form)


<a name="databasing"></a>
## Databasing

**Note:** Before you can start using a database, make sure you have the appropriate database library installed.  For MySQL databases, use [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) and for Postgres use [psycopg2](http://initd.org/pub/software/psycopg/).

First you need to create a database object.

    db = web.database(dbn='postgres', user='username', pw='password', db='dbname')

(Adjust these -- especially `username`, `password`, and `dbname` -- for your setup. MySQL users will also want to change `dbn` definition to `mysql`.)

That's all you need to do -- web.py will automatically handle connecting and disconnecting from the database.

Using your database engines admin interface, create a simple table in your database:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default "now()",
      done boolean default 'f'
    );

And an initial row:

    INSERT INTO todo (title) VALUES ('Learn web.py');

Return to editing `code.py` and change `index.GET` to the following, replacing the entire function:

    def GET(self):
        todos = db.select('todo')
        return render.index(todos)

and change back the URL handler to take just `/` as in:

    '/', 'index',

Edit and replace the entire contents of `index.html` so that it reads:

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

Visit your site again and you should see your one todo item: "Learn web.py". Congratulations! You've made a full application that reads from the database. Now let's let it write to the database as well.

At the end of `index.html`, add:

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

And change your URLs list to read:

    '/', 'index',
    '/add', 'add'

(You've got to be very careful about those commas.  If you omit them, Python adds the strings together and sees `'/index/addadd'` instead of your list of URLs!)

Now add another class:

    class add:
        def POST(self):
            i = web.input()
            n = db.insert('todo', title=i.title)
    	    raise web.seeother('/')

(Notice how we're using `POST` for this?)

`web.input` gives you access to any variables the user submitted through a form. 

Note: In order to access data from multiple identically-named items, in a list format (e.g.: a series of check-boxes all with the attribute name="name") use:

    post_data=web.input(name=[])

`db.insert` inserts values into the database table `todo` and gives you back the ID of the new row. `seeother` redirects users to that URL.

Some quick additional notes: `db.update` works just like `db.insert` except instead of returning the ID it takes it (or a string `WHERE` clause) after the table name.

`web.input`, `db.query`, and other functions in web.py return "Storage objects", which are just like dictionaries except you can do `d.foo` in addition to `d['foo']`. This really cleans up some code.

You can find the full details on these and all the web.py functions in [the documentation](/docs/0.3).

<a name="developing"></a>
## Developing

web.py also has a few tools to help us with debugging. When running with the built-in webserver, it starts the application in debug mode. In debug mode any changes to code and templates are automatically reloaded and error messages will have more helpful information.

The debug is not enabled when the application is run in a real webserver. If you want to disable the debug mode, you can do so by adding the following line before creating your application/templates.

    web.config.debug = False

This ends the tutorial for now. Take a look at the documentation for lots more cool stuff you can do with web.py.

<a name="whatnext"></a>
## What next?

* [More documentation](/docs/0.3)
* [Forms](/form)
* [Templates](/docs/0.3/templetor)
* [Cookbook](/cookbook)
* [Code samples](/src)
---
layout: default
title: web.py 0.3 tutorial
---

# web.py 0.3 tutorial

Autre langages : [english](/tutorial3.en) | [chinese](/tutorial3.zh-cn) | [japan](/tutorial2.ja) | ...

# Sommaire


* <a href="#introduction">Prérequis</a>
* <a href="#manipurl">Manipuler les URLs</a>
* <a href="#gereurl">Gérer les URLs</a>
* <a href="#getpost">GET et POST : la différence</a>
* <a href="#index">Page index - ma première classe</a>
* <a href="#lance">Lancer le serveur</a>
* <a href="#template">Modèles, gabarits</a>
* <a href="#formulaires">Formulaires</a>
* <a href="#bd">Base de données</a>
* <a href="#affbd">Afficher le contenu d'une base de données</a>
* <a href="#ecrbd">Ecrire dans une base de données</a>
* <a href="#debug">Debugger</a>
* <a href="#apres">Et Après ?</a>

<a name="introduction"></a>
# Prérequis



Vous connaissez Python et vous désirez construire un site web. Webpy vous permettra de le faire facilement.

Si vous décidez de suivre l'ensemble de ce tutorial, vous aurez besoin d'installer Python, [web.py] (/install/fr) , flup, psycopg2 et Postgres (ou une base de donnée equivalente et les pilotes python). Pour plus de détails, veuillez consulter [webpy.org](http://webpy.org/)

Si vous possédez déjà un projet web.py existant, jetez un oeil à la page de [mise à jour](http://webpy.org/docs/0.3/upgrade) pour plus d'informations sur la migration.


# Commençons


<a name="manipurl"></a>
## Manipuler les URLs

La partie la plus importante de n'importe quel site web est la structure des URLs. Les URLs ne sont pas que des liens que vos visiteurs voient et envoient par mails à leurs amis, elles fournissent aussi un modèle mental sur la façon avec laquel un site web fonctionne. Sur des sites populaires tels que del.icio.us, les URLs font partie même de l'interface utilisateur. Web.py rend la création d'URLs facile.

Pour commencer avec votre application web.py, ouvrez un nouveau fichier texte (que nous appelerons "code.py") et tapez:

     import web

Cela importera le module web.py.

Maintenant, Nous devons donner à web.py notre structure URL. Commençons avec quelque chose de simple:

     urls = (
            '/', 'index'
            )

La première partie est une expression régulière que l'on applique à une chaîne de caractère (l'URL), telle que /, /help/faq, /item/(\d+), etc.. (Note: \d+ n'admettra qu'une séquence de chiffre). Les parenthèses signifient qu'il faut capturer la séquence pour s'en servir plus tard. La seconde partie est le nom d'une Classe vers laquelle la requête sera envoyée, comme 'index', 'view', 'welcome.hello' (qui recherchera la Classe hello du module welcome.), ou get_\1.
/1 est remplacé par la première capture de l'expression régulière; toutes les captures restantes seront passées à votre fonction. [Note traducteur : A préciser]

Cette ligne signifie que nous souhaitons l'URL / (Note: la page d'accueil) qui doit être traitée par la classe nommée 'index'.

<a name="gereurl"></a>
## Gérer les URLs

Maintenant, nous avons besoin de créer une application spécifiant les URLs.

     app = web.application(urls, globals())

Cela explique à web.py qu'il faut créer une application avec les URLs qui sont listées ci-dessus, en appelant les Classes dans l'espace de noms global de ce fichier.

<a name="getpost"></a>
## GET et POST: la différence

Alors que la plupart des gens ne le remarquent pas en naviguant simplement, votre navigateur utilise un protocole connu appelé HTTP pour communiquer avec le World Wide Web. Les détails ne sont pas importants, mais l'idée de base est que les visiteurs de sites web demandent aux serveurs de sites web de remplir certaines fonctions (telles que GET ou POST) sur les URLs (comme / ou /foo?f=1).

GET est celle que nous connaissons tous, celle qui sert à demander le texte d'une page web. Lorsque vous tapez 'harvard.edu' dans votre navigateur, cela demande littéralement au serveur web de Harvard de fournir /. La seconde fonction très célèbre, POST, est souvent utilisée lorsque vous utilisez certains types de formulaires, comme une demande d'achat d'un produit. Vous utilisez POST chaque fois que vous soumettez une demande (comme le débit de votre carte de crédit et le traitement d'une commande). Cela est essentiel, parce que GET URLs peut être transmis et indexé par les moteurs de recherche, que vous voulez certainement pour la plupart de vos pages, mais ne désirez certainement pas pour des choses comme le traitement des ordres (imaginez si Google essaye de tout acheter sur votre site!)


<a name="index"></a>
## Page index - ma première classe

Dans notre code web.py, nous faisons la distinction entre les deux clairement. Maintenant, il est nécessaire d'écrire la Classe 'index'.

     class index:
        def GET(self):
           return "Hello, world!"

Cette fonction GET sera maintenant appelée par web.py chaque fois qu'il y aura une requête GET pour /.

Très bien, maintenant nous avons juste besoin d'en finir avec une ligne finale disant à web.py de commencer à fournir des pages web:

     if __name__ == "__main__": app.run()

Cela explique à web.py qu'il faut lancer l'application que nous avons créé ci-dessus.

Maintenant notez que, bien que j'ai beaucoup parlé ici, nous avons seulement cinq ou six lignes de code tout au plus. C'est tout ce dont nous avons besoin pour créer une application web.py complète. 

<a name="lance"></a>
## Lancer le serveur

Si vous allez dans votre terminal et que vous tapez les lignes de commande suivantes :

     $ python code.py

Vous verrez s'afficher : http://0.0.0.0:8080/

Vous avez maintenant votre application web.py qui tourne comme un vrai serveur web sur votre ordinateur!

En visitant cette URL, vous devriez voir "Hello, world!" dans votre navigateur. (Vous pouvez ajouter une adresse IP/Port après la partie "code.py" pour contrôler où web.py lancera le serveur. Vous pouvez aussi lui dire de faire fonctionner un serveur fastcgi ou scgi.)

[Note traducteur : A PRECISER]

Note: Vous pouvez spécifier le numéro de port à utiliser dans la ligne de commande, si vous ne souhaitez pas utiliser le port par défaut :

     $ python code.py 1234



<a name="template"></a>
# Modèles, gabarits

Ecrire du HTML à l'intérieur de python peut être lourd et pesant. C'est bien plus amusant d'écrire du Python à l'intérieur du HTML. Par bonheur, web.py le fait très facilement.

Note: Les anciennes versions de web.py utilisent le système de gabarit de [Cheetah] (http://www.cheetahtemplate.org/). Vous êtes, evidemment, libres d'utiliser celui-ci ou n'importe quel autre logiciel de template avec web.py, mais il n'est plus officiellement supporté.

Créons un nouveau répertoire pour nos gabarits (nous l'appellerons templates). A l'intérieur, créons un nouveau fichier dont l'extension sera HTML (appelons-le index.html). Dans ce fichier, vous pouvez juste écrire du HTML classique:

     <em>Hello</em>, world!

Ou utiliser le langage de template de web.py ( [Templator](http://webpy.org/docs/0.3/templetor.fr) ) pour ajouter du code dans votre HTML:

     $def with (name)

        $if name:
           I just wanted to say <em>hello</em> to $name.
        $else:
           <em>Hello</em>, world!

Comme vous pouvez le voir, les gabarits ressemblent beaucoup à des fichiers Python, excepté la déclaration 'def' tout en haut (qui explique avec quoi le modèle est appelé) ainsi que les $s placés devant chaque code. 
Actuellement, template.py exige que la déclaration $def soit la première ligne du gabarit. Notez également que web.py encode automatiquement les variables utilisées ici, de sorte que si, pour une raison un nom est défini dans une valeur contenant du HTML, il sera proprement encodé et apparaitra comme un texte plein. 
Si vous souhaitez désactiver cette fonction, écrivez $:name à la place de $name.

Maintenant, retournons à notre "code.py". Sous la première ligne ajoutez:

     render = web.template.render('templates/')

Cela indique à web.py qu'il faut rechercher le gabarit dans le repertoire 'templates'. Maintenant modifiez le contenu de la fonction GET dans index en:

     name = 'Bob'    
     return render.index(name)

(Ici, 'index' est le nom du gabarit et 'name' est un argument qui lui est transmis)

Visitez votre site, il devrait vous afficher "I just wanted to say hello to Bob."

Mais imaginons que nous souhaitions que les gens entrent leur propre nom. Dans ce cas, remplacez les deux lignes que nous avons ajouté par:

     i = web.input(name=None)
     return render.index(i.name)

En visitant / il devrait vous afficher "Hello, world!". Mais en visitant /?name=Joe il vous affichera "I just wanted to say hello to Joe."
Naturellement, en voyant ceci, on constate que l'URL n'est pas très claire. Pour l'améliorer, modifiez votre ligne URL en haut en:

     '/(.*)', 'index'

Et modifiez la définition de la fonction GET de la classe index en:

     def GET(self, name):
        return render.index(name)

puis effaçez la ligne qui définit le nom. Maintenant, visitez /joe et il devrait vous afficher hello to Joe.

Si vous désirez en apprendre davantage sur les gabarits de web.py, visitez la page [Templetor](http://webpy.org/templetor)

<a name="formulaires"></a>
# Formulaires

Le module de formulaire de web.py permet de générer des formulaires HTML, de récuperer les entrées des utilisateurs, et les valider avant de les traiter ou les ajouter à une base de donnée.
Si vous souhaitez en apprendre plus sur l'utilisation du module de formulaires de web.py, consultez la [Documentation](http://webpy.org/docs/0.3.fr) ou la traduction française du module [Formulaires](http://webpy.org/docs/0.3/form.fr)

<a name="bd"></a>
# Base de données

Note: Avant de pouvoir utiliser une base de données, soyez certains d'avoir la librairie de la base de données appropriée déjà installée. Pour la base de donnée MySQL, utilisez MySQLdb et pour Postgres, utilisez psycopg2.

Premièrement, vous devez créer un objet database.

     db = web.database(dbn='postgres', user='username', pw='password', db='dbname')

(Adaptez ici -- particulièrement pour `username`, `password`, and `dbname` -- vos paramètres de connexion. les utilisateurs de MySQL devront modifier la définition `dbn` en `mysql`.)

C'est tout ce dont vous avez besoin -- web.py gèrera automatiquement la connexion et la déconnexion à la base de données.

<a name="affbd"></a>
## Afficher le contenu d'une base de données

Utilisez votre interface d'administration de la base de données, et créez une simple table dans la base de données:

     CREATE TABLE todo (
        id serial primary key,
        title text,
        created timestamp default now(),
        done boolean default 'f'    
        );

Ainsi qu'une ligne initiale:

     INSERT INTO todo (title) VALUES ('Learn web.py');

Revenez à "code.py" et modifiez la fonction 'GET' de la Classe 'index' de la façon suivante en remplaçant la fonction entièrement:

     def GET(self):
        todos = db.select('todo')
        return render.index(todos)

puis remodifiez le gestionnaire d'URLs pour qu'il ne prenne en compte que /:

     '/', 'index'

Editez et remplaçez le contenu entier du gabarit `index.html` de cette façon:

     $def with (todos)
        <ul>
           $for todo in todos:
              <li id="t$todo.id">$todo.title</li>
        </ul>

En visitant à nouveau votre site, vous devriez voir: "Learn web.py". 

Félicitations ! Vous venez de créer une application complète qui lit une base de données. 

<a name="ecrbd"></a>
## Ecrire dans une base données

Maintenant, nous allons écrire dans la base de données.

A la fin du gabarit `index.html`, ajoutez:

     <form method="post" action="add">
        <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
     </form>

puis modifiez la liste de vos URLs pour qu'elle ressemble à:

     '/', 'index',
     '/add', 'add'

(Vous devez être très prudents avec les virgules. Si vous en oubliez, Python joint les chaînes ensembles, et verra `/index/addadd` à la place de votre liste d'URLs!)

Maintenant, ajoutons une nouvelle Classe:

     class add:
        def POST(self):
           i = web.input()
           n = db.insert('todo', title = i.title)
           raise web.seeother('/')

(Avez-vous noté que nous utilisons la fonction `POST` pour celle-ci?)

`web.input` vous donne accès à toutes les variables de l'utilisateur soumises via un formulaire.

Note: Afin d'accéder aux données à partir de plusieurs éléments identiquement nommé, dans un format de liste (Une série de cases à cocher qui ont toutes l'attribut name="name"), utilisez:

     post_data=web.input(name=[])

`db.insert` insère les valeurs dans la table `todo` de la base de données et renvoie l'ID de la ligne créée.  
`seeother` redirige les utilisateurs vers cette URL.

Quelques notes additionnelles: 

`db.update` fonctionne comme `db.insert` excepté qu'au lieu de renvoyer l'ID, il doit recevoir en argument, après le nom de la table, soit l'ID soit une clause `WHERE` permettant d'identifier la ligne à modifier.

    
    db.update('todo', where="id = 10", title = "web.py pour les nuls")


`web.input`, `db.query`, et d'autres fonctions dans web.py renvoient des Objets de Stockage (Storage objects), qui sont comme des dictionnaires mis à part que vous pouvez écrire `d.foo` en plus de `d['foo']`. Cela rend le code plus clair.

<a name="debug"></a>
# Debugger

web.py possède aussi des outils de debugging pour nous aider. Quand nous le faisons tourner avec le server web intégré, il commence l'application en mode debuggage. Dans ce mode, toutes les modifications du code et des gabarits sont automatiquement rechargées et les messages d'erreur contiennent de précieuses informations.

Le debuggage n'est pas actif lorsque l'application tourne comme un vrai serveur. Si vous souhaitez désactiver ce mode, vous pouvez le faire en ajoutant la ligne suivante avant de créer votre application/gabarit:

     web.config.debug = False

C'est la fin du tutorial maintenant. Jetez un oeil à la [Documentation](http://webpy.org/docs/0.3.fr) pour voir ce que vous pouvez utiliser avec web.py.

Vous pourrez trouver pleins de détails de tout ceci ainsi que de toutes les fonctions web.py dans la [Documentation](http://webpy.org/docs/0.3.fr).

<a name="apres"></a>
## Et après ?

* [Plus de documentation](/docs/0.3.fr) 
* [Formulaires](/docs/0.3/form.fr) 
* [Templator: le modèle de gabarit de web.py](/docs/0.3/templetor.fr)
* [Cookbook](/cookbook/fr)
* [Exemples de codes](/src)
---
layout: default
title: web.py 0.3 tutorial
---

# web.py 0.3 tutorial

This is a work-in-progress


## TODO: app.internalerror = web.debugerror

## TODO: '$user' vs. '$:user' and '$var user:$user' vs. '$var user:$user\'

## TODO: Multiple submit buttons

## TODO: Show/hide complete code at the end of sections

TODO: move the next paragraph over to install?

To create a website with web.py you need to know the Python programming language and have it installed. Installation instructions for Python can be found at [http://python.org/](http://python.org/) .If you don't know if Python is installed on your system, open a terminal and type `python`. A great starting point to learn Python is the official [tutorial] (http://docs.python.org/tut/tut.html). If you are new to programming in general, [Think Python] (http://www.greenteapress.com/thinkpython/) is a wonderful book to understand key concepts in programming. 

## TOC

TODO: ...


## Prerequisites

This tutorial assumes that both Python and web.py are installed on your system. If this is not the case, please follow the [installation instructions] (http://webpy.org/install) before you continue.

Furthermore, basic HTML knowledge is needed to understand some examples.


## Hello Web in web.py

Open your favorite text editor and create a new file `hello.py`. In this file you will define the content and logic of your web application as well as its web addresses (URLs).

Before you are able to use the tools web.py provides, you need to import the web.py module with the following code:

    import web

In web.py web pages are mapped to Python classes. Let's create the code for the first page which is here called `hello`:

    class hello:
        def GET(self):
            return "Hello, Web!"

The `hello` class has a function named `GET` which returns "Hello, Web!". Why `GET`?

When you open a web page, your browser asks for the content of that page. This request is called the `GET` method. web.py uses the same terminology. The string your `GET` method returns is displayed in your browser.

Although the code for your first page is written, it cannot yet be opened in a browser. Let's proceed with mapping a web address (URL) to your class. Insert the following code after the import statement:

    urls = (
      '/', 'hello')

This tells web.py to map the root of your website (like http://webpy.org/) to your Python class named `hello`.

Next create an instance of a web.py application. This instance will be the mediator between your classes and the web. It will handle browser requests and serve your pages. (In short: It will do everything that you really don't want to care about.) Use the following code:

    app = web.application(urls, globals())

Note that `web.application()` gets called with two arguments. Your URL mapping (`urls`) and your global namespace which contains your `hello` class (`globals()`).

To finish your web.py application insert the following code at the end of your code:

    if __name__ == "__main__":
        app.run()

`app.run()` starts the web application to serve requested pages.

### Complete code

hello.py

    import web
    
    urls = (
      '/', 'hello')

    app = web.application(urls, globals())
    
    class hello:
        def GET(self):
            return 'Hello, web!'
    
    if __name__ == "__main__":
        app.run()

Save the file and run the following command to start your application:

    python hello.py

The first output of your application is the address of your web site. By default this is:

    http://locahost:8080/

Open this address with your web browser. That's it. Congrats! You can stop your application at any time by pressing `ctrl+c` in the terminal.

Note: You can also visit your site at `http://localhost:8080/`


## Having multiple pages

In this part you will learn how to manage multiple pages. Let's add another class to your 'Hello Web' application:

    class bye:
        def GET(self):
            return 'Bye, web!'

As mentioned above, each page needs a unique address. Modify your list of URLs as follows:

    urls = (
      '/', 'hello',
      '/bye', 'bye')

This will make your class `bye` respond to requests at `/bye/`. Now start your application and open `http://localhost:8080/bye/` in your browser.

Note: Currently you need to restart your application to see any changes. Try to pass a third argument to `web.application` and restart your application:

    app = web.application(urls, globals(), True)


Future changes can now be seen instantly, although you might need to reload a page in your browser.

### Complete code

hello.py

    import web
    
    urls = (
      '/', 'hello',
      '/bye', 'bye')
    
    app = web.application(urls, globals(), True)
    
    class hello:
        def GET(self):
            return 'Hello, web!'
    
    class bye:
        def GET(self):
            return 'Bye, web!'
    
    if __name__ == "__main__":
        app.run()


## Dynamic pages

The examples shown above are simple; all it does it display the same message, every time.  Suppose you want your app to greet people by name?

### A dynamic "Hello, world!" -- using GET and POST variables

Change the "hello" class above so it looks like this:

    class hello:
        def GET(self):
            i = web.input(name = 'web')
            return 'Hello, ' + web.websafe(i.name) + '!'
        
Run the script, and then go to http://localhost:8080/?name=Luke .  You should see "Hello, Luke!."

Here is what is happening:

When you add the "?name=Luke" to the end of your web request, you are passing the variable "name" to the web server, with a value of "Luke."

The line `i = web.input(name = "web")` creates a Storage object (a fancy type of Python dictionary) that contains all variables passed into it.  You can also do this by just calling `i = web.input()`.  Here, by putting `name = 'web'` into the call, we tell it to use the string "web" as a default, in case the user didn't pass in a "name" variable at all.

We read the "name" value from i by just saying `i.name`.  It's also possible to do `i['name']`; use the syntax you prefer.

Finally, we pass i.name through the `web.websafe` function before returning it to the user.  If your page is being served as HTML, rather than text, then this is an important security step to protect against [cross-site scripting attacks](http://en.wikipedia.org/wiki/Cross-site_scripting).  (As we will see, web.py's form templates offer built-in protection to those attacks).

### Another dynamic "Hello, world!" -- parsing URL strings

Making the user type in something like "http://localhost:8080/?name=Luke" is so 1996; wouldn't it be nicer if we could just get the user to enter "http://localhost:8080/Luke"?

Try this code:

    import web
    
    urls = (
      '/(.*)', 'hello')
    
    app = web.application(urls, globals())
    
    class hello:
        def GET(self, name):
            return 'Hello, ' + web.websafe(name) + '!'
    
    if __name__ == "__main__":
        app.run()

Notice that two things have changed:

 1. The urls has a "(.*)" thing in it
 2. The `GET` method now takes two parameters
 3. There's no more `web.input` call.

As you can see, web.py is parsing the URL for you, based on a [regular expression](http://docs.python.org/lib/re-syntax.html) that you provide in the `urls` tuple.

## HTML in Python

Until now your classes returned only simple strings. Let's add some HTML. This can be done directly from inside your `hello.py`. Replace your class `hello` with this code:

    class hello:
        def GET(self):
            return """<html>
    <head>
    <title>Hello, web!</title>
    </head>
    <body>
    <h1>web.py</h1>
    <p>Think about the <em>ideal</em> way to write a web app. Write the code to <b>make it happen</b>.</p>
    </body>
    </html>"""

Note that your page now has a custom title and HTML formatted content.

### Complete code

hello.py

    import web
    
    urls = (
      '/', 'hello',
      '/bye', 'bye')
    
    app = web.application(urls, globals(), True)
    
    class hello:
        def GET(self):
            return """<html>
    <head>
    <title>Hello, web!</title>
    </head>
    <body>
    <h1>web.py</h1>
    <p>Think about the <em>ideal</em> way to write a web app. Write the code to <b>make it happen</b>.</p>
    </body>
    </html>"""
    
    if __name__ == "__main__":
        app.run()



## HTML with site layout templates

Imagine a larger site with many pages. If all HTML for these pages is embedded into your Python code, things get messy and your code unmaintainable. Also reusing parts of your HTML code for other pages would be difficult. Therefore web.py lets you define site layout templates that can be shared between your pages.

First create a directory `templates` next to your `hello.py` file. Create a file `hello.html` and save it in `templates`. This file will contain the HTML markup that is used to render your page. Start with the following basic template:

    $def with (title, name, content)
    <html>
    <head>
    <title>$title</title>
    </head>
    <body>
    <p>You are visiting page <b>$name</b>.</p>
    <p>$content</p>
    </body>
    </html>

Create a second template `bye.html`:

    $def with (title, name, *numbers)
    <html>
    <head>
    <title>$title</title>
    </head>
    <body>
    <p>You are visiting page <b>$name</b>.</p>
    <p>Find the answer to all questions below:
    $for number in numbers:
        <p>$number</p>
    </body>
    </html>

Besides defining a page structure, these templates will use variables. The first line of `hello.html` (`def with (title, name, number)`) will tell web.py that this template needs to be called with three arguments. Wherever `$title` is used in the template the actual value of `title` is inserted.

Arguments of `bye.html` are `title`, `name` and an arbitrary number of numbers (`*numbers`). All arguments beside `title` and `name` are put into the list `numbers`. This list is then iterated (`$for number in numbers:`) and each number (`number`) is written in its own paragraph. You see that `$` is not only used to access template variables but also to evaluate (safe) Python code like `for` loops or `if` statements.

Now insert the following line before your class definitions to create a so called template renderer. The location of your templates is passed to the renderer as an argument:

    render = web.template.render('templates/')

Next modify your classes to render your pages using the two different templates:

    class hello:
        def GET(self):
            return render.hello("Templates demo", "Hello", "A long time ago...")
    
    class bye:
        def GET(self):
            return render.bye("Templates demo", "Bye", "14", "8", "25", "42", "19")
    
Open the pages in your browser. web.py fetches your templates and dynamically inserts the values that you passed to your templates.

### Complete code

hello.py

    import web
    
    urls = (
      '/', 'hello',
      '/bye/', 'bye')
    
    app = web.application(urls, globals(), True)
    
    render = web.template.render('templates/')
    
    class hello:
        def GET(self):
            return render.hello("Templates demo", "Hello", "A long time ago...")
    
    class bye:
        def GET(self):
            return render.bye("Templates demo", "Bye", "14", "8", "25", "42", "19")
            
    if __name__ == "__main__":
        app.run()
        
templates/hello.html

    $def with (title, name, content)
    <html>
    <head>
    <title>$title</title>
    </head>
    <body>
    <p>You are visiting page <b>$name</b>.</p>
    <p>$content</p>
    </body>
    </html>

templates/bye.html

    $def with (title, name, *numbers)
    <html>
    <head>
    <title>$title</title>
    </head>
    <body>
    <p>You are visiting page <b>$name</b>.</p>
    <p>Find the answer to all questions below:
    $for number in numbers:
        <p>$number</p>
    </body>
    </html>


## Using a base layout (template inheritance)

The previous example defined two templates but both had duplicate code. In most cases your pages share a lot of common code like a navigation bar or a footer. Let's create a file `base.html` which contains all the code your pages share with each other:

    $def with (page)
    <html>
    <head>
    <title>$page.title</title>
    </head>
    <body>
    <p>You are visiting page <b>$page.name</b>.</p>
    $:page
    </body>
    </html>

This base template receives only one variable `page`. `$page.title` is a placeholder for a variable named `title` defined in a child template. `$:page` is a placeholder for everything else that you put in your child template. Modify `hello.html` to be a child template:

    $def with (title, name, content)
    $var title:$title
    $var name:$name
    <p>$content</p>

The previously duplicated code for the HTML body, the page title and the current page information is gone. Instead `$var title:$title` tells the base template to use the local `title` as `$page.title`. The remaining line `<p>$content</p>` will be available in the base template as `$:page`.

Modify `bye.html` accordingly:

    $def with (title, name, *numbers)
    $var title:$title
    $var name:$name
    <p>Find the answer to all questions below:</p>
    $for number in numbers:
        <p>$number</p>

The last step is to tell web.py to use `base.html` as the base template. Use the following code (you might need to replace your previous code):

    render = web.template.render('templates/', base='base')

Both `hello.html` and `bye.html` will now use `base.html`.

### Complete code

hello.py

    import web
    
    urls = (
      '/', 'hello',
      '/bye/', 'bye')
    
    app = web.application(urls, globals(), autoreload=True)
    
    render = web.template.render('templates/', base='base')
    
    class hello:
        def GET(self):
            return render.hello("Templates demo", "Hello", "A long time ago...")
    
    class bye:
        def GET(self):
            return render.bye("Templates demo", "Bye", "14", "8", "25", "42", "19")
    
    if __name__ == "__main__":
        app.run()

base.html

    $def with (page)
    <html>
    <head>
    <title>$page.title</title>
    </head>
    <body>
    <p>You are visiting page <b>$page.name</b>.</p>
    $:page
    </body>
    </html>

hello.html

    $def with (title, name, content)
    $var title:$title
    $var name:$name
    <p>$content</p>

bye.html

    $def with (title, name, *numbers)
    $var title:$title
    $var name:$name
    <p>Find the answer to all questions below:</p>
    $for number in numbers:
        <p>$number</p>


## Static content

Now that your application serves HTML formatted content, you probably want to include static files like images or css style files. To achieve this create a directeory called `static` next to your `hello.py` file. Put a picture file (here called `logo.png`) in your `static` directory. Then include the file on your page:

    class hello:
        def GET(self):
            return """<img src="./static/logo.png">"""

### Complete code

hello.py

    import web
    
    urls = (
      '/', 'hello')
    
    app = web.application(urls, globals(), web.reloader)
    
    class hello:
        def GET(self):
            return """<img src="./static/logo.png">"""
    
    if __name__ == "__main__":
        app.run()


## User input (HTML forms and the `POST` method) [cookbook] (http://webpy.org/form)

Until now `GET` functions were introduced to serve pages but there was no way a user could send data back to your application. A function called `POST` will allow this. To use `POST` you need to create form fields on your page where a user can input his data. Let's make `hello.py` return a page that contains HTML forms using web.py `form` module. To reduce typing add the following import statement:

    from web import form

Now define a form before your classes in `hello.py`. This example only uses a single input field. Visit the [cookbook] (http://webpy.org/form) for more advanced types. The following code gives you a text box with validation of the input:

    number_form = form.Form( 
        form.Textbox('number',
                     form.notnull,
                     form.regexp('^-?\d+$', 'Not a number.'),
                     form.Validator('Not greater than 10.', lambda x: int(x)>10),
                     description='Enter a number greater than 10:'
                     ))

`form.Textbox()` creates an HTML text box. The first parameter specifies its name: `'number'`.  Most often you will want to validate the input of a user instantly and allow him to correct errors. `form.notnull` makes it a required field that cannot be left empty. `form.regexp()` matches the input with the given regular expression. Here it is checked if the input is a number. `form.Validator()` additionally checks if the input is a number greater ten. And finally, `description` is the text that is printed in front of the text box.

Now make your template `hello.html` accept and display a form:

    $def with (form)
    <form name="test" method="POST"> 
    $if not form.valid: <p>Sorry, your input was invalid.</p>
    $:form.render()
    <input type="submit" value="Check" />
    </form>

Notice that the template will print an error message if the form input is invalid.

And finally your `hello` class needs the following `GET` and `POST` methods:

    class hello:
        def GET(self):
            my_form = number_form()
            return render.hello(my_form)
    
        def POST(self): 
            my_form = number_form() 
            if not my_form.validates(): 
                return render.hello(my_form)
            else:
                number = my_form['number'].value
                if int(number) % 2:
                    return "Your number %s is odd." % number
                else:
                    return "Your number %s is even." % number

When you visit `hello` in your browser, the `GET` method creates an instance of your form and returns the rendered page. Enter a number greater 10 and press the `Check` button. Now the `POST` method is invoked to process your input. Because the `GET` and `POST` methods cannot access the same form instance a new one is created. `form.validates()` checks the input you entered. But how does it know what you have entered? By default the `validates()` method fetches your input from `web.input()` where it is stored as soon as you press the `Check` button. In case your input is invalid, the form is returned again. Else `my_form['number'].value` is retrieved which is the number you entered and your application will tell you if you entered an even or odd number.

Note: You cannot access form values before having validated the form!

Now go back and try some invalid input. First leave the text field blank and press `Check`. You will be informed that you left a required field blank. Enter some text and you will get a "Not a number" message. This is due to the regular expression check. And finally try some number that is not greater than ten. The form input will not be validated and you are advised to enter a number greater ten.

### Complete code

hello.py 

    import web
    from web import form
    
    urls = (
      '/', 'hello')
    
    app = web.application(urls, globals(), web.reloader)
    render = web.template.render('templates/')
    
    number_form = form.Form( 
        form.Textbox('number',
                     form.notnull,
                     form.regexp('^-?\d+$', 'Not a number.'),
                     form.Validator('Not greater 10.', lambda x: int(x)>10),
                     description='Enter a number greater 10:'
                     ))
    
    class hello:
        def GET(self):
            my_form = number_form()
            return render.hello(my_form)
    
        def POST(self): 
            my_form = number_form() 
            if not my_form.validates(): 
                return render.hello(my_form)
            else:
                number = my_form['number'].value
                if int(number) % 2:
                    return "Your number %s is odd." % number
                else:
                    return "Your number %s is even." % number
    
    if __name__ == "__main__":
        app.run()

hello.html

    $def with (form)
    <form name="test" method="POST"> 
    $if not form.valid: <p>Sorry, your input was invalid.</p>
    $:form.render()
    <input type="submit" value="Check" />
    </form>


## Sessions [cookbook] (http://webpy.org/cookbook/sessions)

ATTENTION: Sessions cannot be used with `web.reloader` at the time of this writing! It is a known bug.

Many sites need to distinguish its visitors. Imagine you want to show the user the number of pages he visited on your page. Each visitor has a unique number. To allow separate tracking web.py uses so called sessions. Each visitor gets his very own session object in which his unique number is saved. First create a session object in `hello.py`. Put this line after your `app` is initialized:

    session = web.session.Session(app, web.session.DiskStore('sessions'), initializer={'count': 0})

This creates a session object. The first parameter is simply the application the session object is used for. `web.session.DiskStore('sessions')` tells web.py to store sessions on disk (database storage is possible as well, see this [cookbook] (http://webpy.org/cookbook/sessions) entry). The third optional parameter initializes the session data dictionary for each user. Here each session object starts with zero visited pages (`count`). web.py creates a directory `sessions` to store session data on disk. Modify your classes in `hello.py` like this:

    class hello:
        def GET(self):
            session.count += 1
            return "You visited " + str(session.count) + " pages."
    
    class bye:
        def GET(self):
            session.kill()
            return ("Bye, web!")
            
Each time you visit `hello`, the number of pages you visited is incremented (`session.count += 1`). If you visit `bye` the session is killed (`session.kill()`). The next time you visit `hello`, a new session will be created and the counter will be zero again.

### Complete code

hello.py

    import web
    web.config.debug=False
    
    urls = (
      '/', 'hello',
      '/bye/', 'bye')

        
    app = web.application(urls, globals())
    session = web.session.Session(app, web.session.DiskStore('sessions'),
                                  initializer={'count': 0})
    
    class hello:
        def GET(self):
            session.count += 1
            return "You visited " + str(session.count) + " pages."
    
    class bye:
        def GET(self):
            session.kill()
            return ("Bye, web!")
    
    if __name__ == "__main__":
        app.run()


## User authentication

This is an example of user authentication using a session cookie, the most common method.  Most often user authentication is done by providing functions to login and logout a user. Additionally, users often are able to register or delete their account.

### Complete code

hello.py

    import web
    from web import form
    
    import random
    from hashlib import sha1
    
    # A simple user object that doesn't store passwords in plain text
    # see http://en.wikipedia.org/wiki/Salt_(cryptography)
    class PasswordHash(object):
        def __init__(self, password_):
            self.salt = "".join(chr(random.randint(33,127)) for x in xrange(64))
            self.saltedpw = sha1(password_ + self.salt).hexdigest()
        def check_password(self, password_):
            """checks if the password is correct"""
            return self.saltedpw == sha1(password_ + self.salt).hexdigest()
    
    # Note: a secure application would never store passwords in plaintext in the source code
    users = {
        'Kermit' : PasswordHash('frog'), 
        'ET' : PasswordHash('eetee'),  
        'falken' : PasswordHash('joshua') } 
    
    
    urls = ('/', 'hello',
            '/logout/', 'logout',
            '/register/', 'register')
    
    app = web.application(urls, globals())
    render = web.template.render('templates/')

    if web.config.get('_session') is None:
        session = web.session.Session(app, web.session.DiskStore('sessions'),
                                  initializer={'user': 'anonymous'})
        web.config._session = session
    else:
        session = web.config._session
    
    signin_form = form.Form(form.Textbox('username',
                                         form.Validator('Unknown username.',
                                                        lambda x: x in users.keys()),
                                         description='Username:'),
                            form.Password('password',
                                          description='Password:'),
                            validators = [form.Validator("Username and password didn't match.",
                                          lambda x: users[x.username].check_password(x.password)) ])
    
    signup_form = form.Form(form.Textbox('username',
                                         form.Validator('Username already exists.',
                                                        lambda x: x not in users.keys()),
                                         description='Username:'),
                            form.Password('password',
                                          description='Password:'),
                            form.Password('password_again',
                                          description='Repeat your password:'),
                            validators = [form.Validator("Passwords didn't match.",
                                          lambda i: i.password == i.password_again)])
    
    
    class hello:
        def GET(self):
            my_signin = signin_form()
            return render.hello(session.user, my_signin)
    
        def POST(self): 
            my_signin = signin_form() 
            if not my_signin.validates(): 
                return render.hello(session.user, my_signin)
            else:
                session.user = my_signin['username'].value
                return render.hello(session.user, my_signin)
    
    
    class logout:
        def GET(self):
            session.kill()
            raise web.seeother('/')
    
    
    class register:
        def GET(self):
            my_signup = signup_form()
            return render.signup(my_signup)
    
        def POST(self):
            my_signup = signup_form()
            if not my_signup.validates(): 
                return render.signup(my_signup)
            else:
                username = my_signup['username'].value
                password = my_signup['password'].value
                users[username] = PasswordHash(password)
                raise web.seeother('/')
    
    if __name__ == "__main__":
        app.run()
        
hello.html

    $def with (user, form)
    $if user == 'anonymous':
        <p>You are not logged in.</p>
        <p>
          <form name="test" method="POST"> 
          $:form.render()
          <input type="submit" name="button" value="Login" />
          </form>
        </p>
        <p><a href="./register/">Register</a></p>
    $else:
        <p>You are logged in as: $user</p>
        <p><a href="./logout/">Logout</a></p>

signup.html

    $def with (form)
    <form name="test" method="POST"> 
    $:form.render()
    <input type="submit" value="Register" />
    </form>

## Deployment

Advantages / disadvantages of different solutions: App Engine, servers...



TODO: ...
---
layout: default
title: web.py 0.3 新手指南
---

# web.py 0.3 新手指南

* [开始](#starting)
* [URL处理](#urlhandling)
* [GET和POST的区别](#getpost)
* [启动服务](#start)
* [模板](#templating)
* [表单](#forms)
* [数据库](#databasing)
* [开发](#developing)
* [下一步做什么?](#whatnext)

## 开始

你知道Python同时你希望制作一个网站。 那么web.py正好提供了一种简单的方法。

如果你希望读完整个指南， 你需要安装Python, web.py, flup, psycopg2, 和Postgres (或者等价的数据库和Python驱动)。 详细，可以查看 [webpy.org](http://webpy.org/).

如果你已经有了一个web.py项目，请看看[升级](/docs/0.3/upgrade) 页面的相关信息。

准备开始。

<a name="urlhandling"> </a>
## URL 处理

任何网站最重要的部分就是它的URL结构。你的URL并不仅仅只是访问者所能看到并且能发给朋友的。它还规定了你网站运行的心智模型。在一些类似[del.icio.us](http://del.icio.us/)的流行网站 , URL甚至是UI的一部分。 web.py使这类强大的URL成为可能。

在开始你的web.py程序之前,打开一个文本文件（文件名为code.py）输入:

    import web

这条语句会导入web.py模块。

现在我们需要把我们的URL结构告诉web.py。让我从下面这个简单的例子开始:

    urls = (
      '/', 'index'
    )

第一部分是匹配URL的[正则表达式](http://osteele.com/tools/rework/)，像`/`、`/help/faq`、`/item/(\d+)`等(`\d+`将匹配数字)。圆括号表示捕捉对应的数据以便后面使用。第二部分是接受请求的类名称，像`index`、`view`、`welcomes.hello` (`welcomes`模块的`hello`类)，或者`get_\1`。`\1` 会被正则表达式捕捉到的内容替换，剩下来捕捉的的内容将被传递到你的函数中去。

这行表示我们要URL`/`(首页)被一个叫`index`的类处理。

现在我们需要创建一个列举这些url的application。

    app = web.application(urls, globals())

这会告诉web.py去创建一个基于我们刚提交的URL列表的application。这个application会在这个文件的全局命名空间中查找对应类。

<a name="getpost"> </a>
## GET和POST: 区别

现在我们需要来写`index`类。虽然大多数人只会看看，并不会注意你的浏览器在使用用于与万维网通信的HTTP语言。具体的细节并不重要，但是要理解web访问者请求web服务器去根据URL(像`/`、`/foo?f=1`)执行一个合适的函数（像`GET`、`POST`）的基本思想。

`GET`是我们都熟悉的。它用于请求网页文本。当你在浏览器输入`harvard.edu`，它会直接访问Harvard的web服务器，去`GET /`。 第二个最有名的是`POST`，它经常被用在提交form，比如请求买什么东西。每当提交一个去做什么事情(像使用信用卡处理一笔交易)的请求时，你可以使用`POST`。这是关键，因为`GET`的URL可以被搜索引擎索引，并通过搜索引擎访问。虽然大部分页面你希望被索引，但是少数类似订单处理的页面你是不希望被索引的 (想象一下Google尝试去购买你网站上的所有东西)。

在我们web.py的代码中，我们将这两个方法明确区分:

    class index:
        def GET(self):
            return "Hello, world!"

当有人用`GET`请求`/`时，这个`GET`函数随时会被web.py调用。

好了，限制我们只需要最后一句就写完了。这行会告诉web.py开始提供web页面:

    if __name__ == "__main__": app.run()

这会告诉web.py为我们启动上面我们写的应用。


现在注意，即使我已经在这里说了很多，但我们真正有5行这些代码。这就是你需要编写的一个完整的web.py应用。
为了更方便的使用，你的完整代码应该像下面这样:

    import web
    
    urls = (
        '/', 'index'
    )
    
    class index:
        def GET(self):
            return "Hello, world!"
    
    if __name__ == "__main__":
        app = web.application(urls, globals())
        app.run()

		

<a name="start"> </a>
## 启动服务

 如果你在命令行下面，请输入::
    $ python code.py
    http://0.0.0.0:8080/

现在你的web.py应用正运行在你电脑上的一个真正的web服务器上。 访问那个URL，然后你应该看到"Hello, world!" (你可以通过把IP地址/端口加在"code.py"的后面，来控制web.py在哪里启动服务器。你也可以让它运行在`fastcgi`或`scgi`服务器上)。

**注意:** 如果你不能或者不想使用默认端口，你可以使用这样的命令来指定端口号:

    $ python code.py 1234

	

<a name="templating"> </a>
## 模板

在 Python 中写 HTML 不是聪明的选择，相反在 HTML 中写 Python 则有趣的多。幸运的是，`web.py` 让这件事情做得简单而又漂亮。

**注意：** 老版本的 `web.py` 使用 [Cheetah 模板系统](http://www.cheetahtemplate.org/)，你可以也欢迎使用其他模板系统，但它可能不会被长久支持。

给模板新建一个目录（命名为 `templates`），在该目录下新建一个以 `.html` 结尾的文件，内容如下：

    <em>Hello</em>, world!

你也可以在模板中使用 `web.py` 模板支持代码：

    $def with (name)
    
    $if name:
        I just wanted to say <em>hello</em> to $name.
    $else:
        <em>Hello</em>, world!

如上，该模板看起来就像 python 文件一样，除了顶部的 `def with` (表示从模板将从这后面取值)和总是位于代码段之前的`$`。当前，`template.py` 首先请求模板文件的首行 `$def` 。当然，你要注意 `web.py` 将会转义任何任何用到的变量，所以当你将 `name` 的值设为是一段 HTML 时，它会被转义显示成纯文本。如果要关闭该选项，可以写成 `$:name` 来代替 `$name`。

回看再看 `code.py`。在第一行之下添加：

    render = web.template.render('templates/')

这会告诉web.py到你的模板目录中去查找模板。然后把 `index.GET`改成:
告诉 `web.py` 在你的模板目录下查找模板文件。修改 `index.GET` ：

    name = 'Bob'    
    return render.index(name)

（'index' 是模板的名字，'name' 是传入模板的一个参数）

访问站点它将显示 hello Bob。

但是如果我们想让用户自行输入他的名字，么办？如下：

    i = web.input(name=None)
    return render.index(i.name)

访问 `/` 将显示 hello world，访问 `/?name=Joe` 将显示 hello Joe。

URL 的后面的 `?` 看起来不好看？修改下 URL 配置：

    '/(.*)', 'index'

然后修改下 `index.GET`：

    def GET(self, name):
        return render.index(name)

现在访问 `/Joe` 看看，它会显示 hello Joe。

如果学习更多关于 web.py 的模板处理，请访问 [web.py 模板](/docs/0.3/templetor).

<a name="forms"> </a>
## 表单

web.py的form模块能够帮助你生成HTML表单；获取用户的输入，并在处理或添加到数据库之前对其进行内容的验证。
如果你要学习更多关于form模块的使用，请查看[帮助文档](/docs/0.3)或者[Form](/form)类库的链接


<a name="databasing"> </a>
## 数据库操作

**注意:** 在你开始使用数据库之前，确保你已经安装了合适的数据库访问库。比如对于MySQL数据库，使用 [MySQLdb](http://sourceforge.net/project/showfiles.php?group_id=22307) ，对于Postgres数据库使用[psycopg2](http://initd.org/pub/software/psycopg/)。

首先你需要创建一个数据库对象。

    db = web.database(dbn='postgres', user='username', pw='password', db='dbname')

(根据需要修改这里 -- 尤其是`username` 、 `password` 、 `dbname` -- 。 MySQL用户还需要把 `dbn` 定义改为 `mysql`。)

这就是所有你需要做的 -- web.py将会自动处理与数据库的连接和断开。

使用的的数据库引擎管理工具，在你的库中创建一个简单的表:

    CREATE TABLE todo (
      id serial primary key,
      title text,
      created timestamp default now(),
      done boolean default 'f'    );

然后初始化行:

    INSERT INTO todo (title) VALUES ('Learn web.py');

我们回来继续编辑 `code.py` ，把 `index.GET` 改成下面的样子，替换整个函数:

    def GET(self):
        todos = db.select('todo')
        return render.index(todos)

然后把URL列表改回来，只保留 `/`:

    '/', 'index',

像这样编辑并替换 `index.html` 的全部内容:

    $def with (todos)
    <ul>
    $for todo in todos:
        <li id="t$todo.id">$todo.title</li>
    </ul>

再访问你的网站，然后你可以看到你的todo item: "Learn web.py"。恭喜你！你已经完整地写好了一个可以从数据库读取数据的程序。现在让我们同样再写一个可以把数据写入数据库的程序。

在 `index.html`尾部添加:

    <form method="post" action="add">
    <p><input type="text" name="title" /> <input type="submit" value="Add" /></p>
    </form>

然后把你的URL列表改为:

    '/', 'index',
    '/add', 'add'

(你必须要非常小心那些逗号。如果你省略他们，Python会把所有字符串连接起来,变成 `'/index/addadd'`)

现在添加另一个类:

    class add:
        def POST(self):
            i = web.input()
            n = db.insert('todo', title=i.title)
    	    raise web.seeother('/')

(注意现在我们正在使用 `POST`)

`web.input` 可以让你访问用户通过form提交的任何数据。

注意: 如果要访问多个相同名字的字段，请使用list的格式(比如:一串name="name"的多选框):

    post_data=web.input(name=[])

`db.insert` 把数据插入数据表 `todo` ，然后把新的行号返回给你。 `seeother` 把用户重定向到指定的URL。

一些快速补充说明: `db.update` 与 `db.insert` 差不多，除了它返回的行号是直接从sql语句里面提取的(`WHERE ID=2`)。

`web.input`、 `db.query`已经其他web.py中的函数返回"Storage objects"，这些东西就像字典，你除了可以 `d['foo']`之外，你还可以 `d.foo`。这可以让代码更加干净。

你可以在[the documentation](/docs/0.3)找到这方面具体的细节以及所有web.py的函数说明。

<a name="developing"> </a>
## 开发

web.py 还有一些帮助我们debug的工具。当它在内建的服务器中运行时，它会一debug模式启动程序。在debug模式中，任何代码、模板的修改，都会让服务器重新加载它们，然后还会输出有用的错误消息。

只有在生产环境中debug模式是关闭的。如果你想禁用debug模式，你可以在创建程序/模板前添加像这样的行。

    web.config.debug = False

我们的指南就到这里了。如果要做更多很酷的东西，你可以先查看一下文档。

<a name="whatnext"> </a>
## 下一步是什么?

* [更多文档](/docs/0.3)
* [Cookbook](/cookbook)
* [code samples](/src)
---
layout: default
title: Upgrade to web.py 0.2
---

# Upgrade to web.py 0.2

If you are migrating from the "one big file" version of web.py to the .2 version, you have to make some changes to your code.  


### Downloading web.py 0.2

From the command line, cd to the directory you wish to install web.py and run the following command:

    svn export http://webpy.org/svn/trunk/web/ 

Remove web.py and web.pyc from the loadpath.

### web.run()

Most importantly, upvars() was removed.  We have to change the run line from:

    if __name__ == '__main__': web.run(urls)

to:

    if __name__ == "__main__": web.run(urls, globals())


### web.config

If you use a db, change `web.db_parameters` and `web.db_printing` to `web.config.db_paramters` and `web.config.db_printing` respectively.


### debugging

web.py 0.1:

    web.internalerror = web.debugerror
    if __name__ == '__main__': web.run(urls, web.reloader)

web.py 0.2

    web.webapi.internalerror = web.debugerror
    if __name__ == "__main__": web.run(urls, globals(), web.reloader)

### fastcgi with apache

web.py 0.1:

    web.runwsgi = web.runfcgi

web.py 0.2:

    def runfcgi_apache(func):
      web.wsgi.runfcgi(func, None)

    web.wsgi.runwsgi = runfcgi_apache
---
layout: default
title: Usage
---

# Usage

1.  [Hello World](#hello)

<h2 id=hello>Hello World</h2>

<pre class=prettyprint><code>"""
hello world

"""

import web

resources = (
  r'/(.*)', 'Hello'
)
webapp = web.application(resources, globals())

class Hello:
  """
  say Hello
  
  """
  
  def GET(self, name):
    if not name: 
        name = 'World'
    return 'Hello ' + name + '!'

if __name__ == '__main__':
  webapp.run()</code></pre>

[ [download](/usage/hello.py?format=raw) ]

<script src=http://angelo.gladding.name/assets/jquery.js></script>
<script src=http://angelo.gladding.name/assets/webpy/js-prettify/prettify.js></script>
<script src=http://angelo.gladding.name/assets/webpy/enliven.js></script>
<style>
@import url(http://angelo.gladding.name/assets/webpy/js-prettify/prettify.css);
@import url(http://angelo.gladding.name/assets/webpy/changes.css);
</style>
---
layout: default
title: Templating
---

# Templating

<a name="introduction"></a>
# Introduction

<style>
pre {
    background-color:#F0F0F0;
    border:1px solid #CCCBBA;
       padding: 10px 10px 10px 20px;
}
code {
    background: inherit;
    color: inherit;
}
.warning {
    border: 1px solid #FFAAAA;
    padding: 10px;
    background-color: #FFF0F0;
}
</style>


The web.py template language, called `Templetor` is designed to bring the power of Python to templates.
Instead of inventing new syntax for templates, it re-uses python syntax. 
If you know Python programming language, you will be at home.

Here is a simple template:

    $def with (name)
    Hello $name!

The first line says that the template is defined with one argument called `name`.
`$name` in the second line will be replaced with the value of name when the template is rendered.

<div class="warning">
For upgrading from web.py 0.2 templates see <a href="#upgrading">upgrading</a> section.
</div>

<a name="using"></a>
# Using the template system

The most common way of rendering templates is this:

    render = web.template.render('templates')
    print render.hello('world')
   
The `render` function takes the template root as argument. `render.hello(..)` calls the template `hello.html` with the given arguments.
In fact, it looks for the files matching `hello.*` in the template root and picks the first matching file.

However you can also create template from a file using `frender`.

    hello = web.template.frender('templates/hello.html')
    print hello('world')
    
And if you have the template as a string:

    template = "$def with (name)\nHello $name"
    hello = web.template.Template(template)
    print hello('world')

<a name="syntax"></a>
# Syntax

## Expression Substitution

Special character `$` is used to specify python expressions. Expression can be enclosed in `()` or `{}` for explicit grouping.

    Look, a $string. 
    Hark, an ${arbitrary + expression}. 
    Gawk, a $dictionary[key].function('argument'). 
    Cool, a $(limit)ing.

## Assignments

Sometimes you may want to define new variables and re-assign some variables.
    
    $ bug = get_bug(id)
    <h1>$bug.title</h1>
    <div>
        $bug.description
    <div>

Notice the space after `$` in the assignment. It is required to differentiate assignment from expression substitution.

## Filtering 

By default, Templetor uses `web.websafe` filter to do HTML-encoding.

    >>> render.hello("1 < 2")
    "Hello 1 &lt; 2"

To turnoff filter use `:` after `$`. For example:

    The following will not be html escaped.
    $:form.render()
    
## Newline suppression

Newline can be suppressed by adding `\` character at the end of line. 

    If you put a backslash \ 
    at the end of a line \ 
    (like these) \ 
    then there will be no newline.
    
## Escaping $

Use `$$` to get `$` in the output.

    Can you lend me $$50?
    
## Comments

`$#` is used as comment indicator. Anything starting with $# till end of the line is ignored.

    $# this is a comment
    Hello $name.title()! $# display the name in title case

## Control Structures

The template system supports `for`, `while`, `if`, `elif` and `else`.
Just like in python, body of the statement is indented.

    $for i in range(10): 
        I like $i

    $for i in range(10): I like $i
        
    $while a:
        hello $a.pop()

    $if times > max: 
        Stop! In the name of love. 
    $else: 
        Keep on, you can do it.

The for loop sets a number of variables available within the loop:

    loop.index: the iteration of the loop (1-indexed)
    loop.index0: the iteration of the loop (0-indexed)
    loop.first: True if first iteration
    loop.last: True if last iteration
    loop.odd: True if an odd iteration
    loop.even: True if an even iteration
    loop.parity: "odd" or "even" depending on which is true
    loop.parent: the loop above this in nested loops
    
Sometimes these can be very handy.

    <table>
    $for c in ["a", "b", "c", "d"]:
        <tr class="$loop.parity">
            <td>$loop.index</td>
            <td>$c</td>
        </tr>
    </table>
    
## Other Statements

### def

You can define a new template function using `$def`. Keyword arguments are also supported.

    $def say_hello(name='world'):
        Hello $name!
    
    $say_hello('web.py')
    $say_hello()

Another example:
        
    $def tr(values):
        <tr>
        $for v in values:
            <td>$v</td>
        </tr>

    $def table(rows):
        <table>
        $for row in rows:
            $:row
        </table>
    
    $ data = [['a', 'b', 'c'], [1, 2, 3], [2, 4, 6], [3, 6, 9] ]
    $:table([tr(d) for d in data])
    
### code

Arbitrary python code can be written using the `code` block.

    $code:
        x = "you can write any python code here"
        y = x.title()
        z = len(x + y)
        
        def limit(s, width=10):
            """limits a string to the given width"""
            if len(s) >= width:
                return s[:width] + "..."
            else:
                return s
                
    And we are back to template.
    The variables defined in the code block can be used here.
    For example, $limit(x)
    
### var

The `var` block can be used to define additional properties in the template result.

    $def with (title, body)
    
    $var title: $title
    $var content_type: text/html
    
    <div id="body">
    $body
    </div>
    
The result of the above template can be used as follows:

    >>> out = render.page('hello', 'hello world')
    >>> out.title
    u'hello'
    >>> out.content_type
    u'text/html'
    >>> str(out)
    '\n\n<div>\nhello world\n</div>\n'

<a name="builtins"></a>
# builtins and globals

Just like any Python function, template can also access builtins along with its arguments and local variables.
Some common builtin functions like `range`, `min`, `max` etc. and boolean values `True` and `False` are made available to all the templates.
Apart from the builtins, application specific globals can be specified to make them accessible in all the templates.

Globals can be specified as an argument to `web.template.render`.

    import web
    import markdown
    
    globals = {'markdown': markdown.markdown}
    render = web.template.render('templates', globals=globals)

Builtins that are exposed in the templates can be controlled too.

    # disable all builtins
    render = web.template.render('templates', builtins={})

<a name="security"></a>
# Security

One of the design goals of Templetor is to allow untrusted users to write templates.

To make the template execution safe, the following are not allowed in the templates.

* Unsafe statements like `import`, `exec` etc.
* Accessing attributes starting with `_`
* Unsafe builtins like `open`, `getattr`, `setattr` etc.

`SecurityException` is raised if your template uses any of these.

<a name="upgrading"></a>
# Upgrading from web.py 0.2 templates

The new implementation is mostly compatible with the earlier implementation. However some cases might not work because of the following reasons.

* Template output is always storage like `TemplateResult` object, however converting it to `unicode` or `str` gives the result as unicode/string.
* Reassigning a global value will not work. The following will not work if x is a global.
    
        $ x = x + 1
    
The following are still supported but not preferred.

* Using `\$` for escaping dollar. Use `$$` instead.
* Modifying `web.template.Template.globals`. pass globals to `web.template.render` as argument instead.

<script src=http://angelo.gladding.name/assets/jquery.js></script>
<script src=http://angelo.gladding.name/assets/webpy/js-prettify/prettify.js></script>
<script src=http://angelo.gladding.name/assets/webpy/enliven.js></script>

<style>
@import url(http://angelo.gladding.name/assets/webpy/js-prettify/prettify.css);
@import url(http://angelo.gladding.name/assets/webpy/changes.css);
</style>
---
layout: default
title: Prueba
---

# Prueba

Prueba1
