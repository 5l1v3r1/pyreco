__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Runtime Dynamic Models documentation build configuration file, created by
# sphinx-quickstart on Wed Jun  8 01:55:36 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Runtime Dynamic Models'
copyright = u'2011, Will Hardy'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'RuntimeDynamicModelsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('pdfindex', 'RuntimeDynamicModels.tex', u'Runtime Dynamic Models Documentation',
   u'Will Hardy', 'howto'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'runtimedynamicmodels', u'Runtime Dynamic Models Documentation',
     [u'Will Hardy'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Runtime Dynamic Models'
epub_author = u'Will Hardy'
epub_publisher = u'Will Hardy'
epub_copyright = u'2011, Will Hardy'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = models
# This is a placeholder app, to hold all of the dynamic survey response models
# from the surveymaker app. This was recommended on the Django wiki, and I 
# haven't yet confirmed if this is necessary.

########NEW FILE########
__FILENAME__ = default
# Django settings for dynamic_models project.

import os
PROJECT_DIR = os.path.join(os.path.dirname(__file__), '..')
project_dir = lambda p: os.path.join(PROJECT_DIR, p)


DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
     ('Will Hardy', 'dynamic_models@willhardy.com.au'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'test.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/Amsterdam'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-au'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = project_dir('media')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '/media/'

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = project_dir('static_root')

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    project_dir('static'),
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'j#amlng(qj_byjnbdgdx^@9la&996zozl+k#5usab2sp%!t3eb'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'dynamic_models.urls'

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    }
}


TEMPLATE_DIRS = (
    project_dir('templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.admin',
    'surveymaker',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'console': {
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
        'surveymaker': { 
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = admin
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

from django.contrib import admin 
from django.db.models.signals import post_save

from . import models
from . import utils

class QuestionInline(admin.TabularInline):
    model = models.Question

class SurveyAdmin(admin.ModelAdmin):
    inlines = [QuestionInline]

admin.site.register(models.Survey, SurveyAdmin)

# Go through all the current loggers in the database, and register an admin
for survey in models.Survey.objects.all():
    utils.reregister_in_admin(admin.site, survey.Response)

# Update definitions when they change
def survey_post_save(sender, instance, created, **kwargs):
    utils.reregister_in_admin(admin.site, instance.Response)
post_save.connect(survey_post_save, sender=models.Survey)


########NEW FILE########
__FILENAME__ = dynamic_models
# -*- coding: UTF-8 -*-
import logging

from django.db import models
from django.utils.hashcompat import md5_constructor
from django.core.cache import cache

from . import utils

def get_survey_response_model(survey, regenerate=False, notify_changes=True):
    """ Takes a survey object and returns a model for survey responses. 
        Setting regenerate forces a regeneration, regardless of cached models.
        Setting notify_changes updates the cache with the current hash.
    """
    name = filter(str.isalpha, survey.slug.encode('ascii', 'ignore'))
    _app_label = 'responses'
    _model_name = 'Response'+name

    # Skip regeneration if we have a valid cached model
    cached_model = utils.get_cached_model(_app_label, _model_name, regenerate)
    if cached_model is not None:
        return cached_model

    # Collect the dynamic model's class attributes
    attrs = {
        '__module__': __name__, 
        '__unicode__': lambda s: '%s response' % name
    }

    class Meta:
        app_label = 'responses'
        verbose_name = survey.name + ' Response'
    attrs['Meta'] = Meta

    # Add a field for each question
    questions = survey.question_set.all()
    for question in questions:
        field_name = question.slug.replace('-','_').encode('ascii', 'ignore')
        attrs[field_name] = question.get_field()

    # Add a hash representing this model to help quickly identify changes
    attrs['_hash'] = generate_model_hash(survey)

    # A convenience function for getting the data in a predictablly ordered tuple
    attrs['data'] = property(lambda s: tuple(getattr(s, q.slug) for q in questions))

    model = type('Response'+name, (models.Model,), attrs)

    # You could create the table and columns here if you're paranoid that it
    # hasn't happened yet. 
    #utils.create_db_table(model)
    # Be wary though, that you won't be able to rename columns unless you
    # prevent the following line from being run.
    #utils.add_necessary_db_columns(model)

    if notify_changes:
        utils.notify_model_change(model)

    return model


def build_existing_survey_response_models():
    """ Builds all existing dynamic models at once. """
    # To avoid circular imports, the model is retrieved from the model cache
    Survey = models.get_model('surveymaker', 'Survey')
    for survey in Survey.objects.all():
        Response = get_survey_response_model(survey)
        # Create the table if necessary, shouldn't be necessary anyway
        utils.create_db_table(Response)
        # While we're at it...
        utils.add_necessary_db_columns(Response)


def generate_model_hash(survey):
    """ Take a survey object and generate a suitable hash for the relevant
        aspect of responses model. 
        For our survey model, a list of the question slugs 
    """
    return md5_constructor(survey.get_hash_string()).hexdigest()


########NEW FILE########
__FILENAME__ = fields
# -*- coding: UTF-8 -*-
from decimal import Decimal

from django.db import models


# Callables that return a django model field, they will be mapped to
# available field types. 
# They must accept arguments such as blank and choices

def get_decimal_field(**kwargs):
    kwargs.setdefault('max_digits', 6)
    kwargs.setdefault('decimal_places', 2)
    kwargs.setdefault('null', True)
    if 'choices' in kwargs:
        kwargs['choices'] = [(Decimal(k),v) for k,v in kwargs['choices']]
    return models.DecimalField(**kwargs)

def get_char_field(**kwargs):
    kwargs.setdefault('max_length', 255)
    kwargs.setdefault('default', "")
    return models.CharField(**kwargs)

def get_text_field(**kwargs):
    kwargs.setdefault('default', "")
    return models.TextField(**kwargs)

def get_integer_field(**kwargs):
    kwargs.setdefault('null', True)
    if 'choices' in kwargs:
        kwargs['choices'] = [(int(k),v) for k,v in kwargs['choices']]
    return models.IntegerField(**kwargs)


ANSWER_FIELDS = {
    'ShortText': get_char_field,
    'LongText': get_text_field,
    'Integer': get_integer_field,
    'Decimal': get_decimal_field,
    }

ANSWER_TYPES = (
    ('ShortText', 'Short text'),
    ('LongText', 'Long text'),
    ('Integer', 'Number'),
    ('Decimal', 'Decimal number'),
    )


########NEW FILE########
__FILENAME__ = models
# -*- coding: UTF-8 -*-

from django.core.exceptions import ValidationError
from django.db import models
from django.db.models.signals import post_save, pre_save, pre_delete, post_delete
from django.utils import simplejson

from . import fields
from . import utils
from . import signals
from .dynamic_models import get_survey_response_model, build_existing_survey_response_models


# Build all existing survey response models as soon as possible
# This is optional, but is nice as it avoids building the model when the
# first relevant view is loaded.
utils.when_classes_prepared('surveymaker', ['Survey', 'Question'], 
                                build_existing_survey_response_models)


class Survey(models.Model):
    name = models.CharField(max_length=255, default="")
    slug = models.SlugField(unique=True)

    def __unicode__(self):
        return self.name

    def clean(self):
        if not self.slug.isalpha():
            raise ValidationError("Please leave out your non-alpha chars for this slug.")
        if Survey.objects.filter(pk=self.pk).exclude(slug=self.slug).exists():
            raise ValidationError("This is just a simple example, please don't go rename the slug.")

    @property
    def Response(self):
        " Convenient access the relevant model class for the responses "
        return get_survey_response_model(self)

    def get_survey_response_model(self, regenerate=False, notify_changes=True):
        return get_survey_response_model(self, regenerate=regenerate, notify_changes=notify_changes)

    def get_hash_string(self):
        """ Return a string to describe the parts of the questions that are
            relevant to the generated dynamic model (the Response model)
        """
        # Only use the fields that are relevant
        val = [(q.slug, q.required, q.question, q.choices, q.rank) for q in self.question_set.all()]
        return simplejson.dumps(val)


class Question(models.Model):
    survey      = models.ForeignKey(Survey)
    question    = models.CharField(max_length=255, default="")
    slug        = models.SlugField()
    answer_type = models.CharField(max_length=32, choices=fields.ANSWER_TYPES)
    choices     = models.CharField(max_length=1024, default="", blank=True, 
                    help_text="comma separated choices, keep them shortish")
    required    = models.BooleanField(default=False)
    rank        = models.PositiveIntegerField(default=5)

    def get_field(self):
        kwargs = {}
        kwargs['blank'] = not self.required
        kwargs['verbose_name'] = self.question
        if self.choices.strip():
            kwargs['choices'] = [(x.strip(), x.strip()) for x in self.choices.split(",")]

        try:
            return fields.ANSWER_FIELDS[self.answer_type](**kwargs)
        except KeyError:
            return None

    def clean(self):
        if not all(x.isalpha() or x in "_" for x in self.slug) or not self.slug[0].isalpha():
            raise ValidationError("Please use only alpha/underscore characters in this slug.")
        if self.answer_type == "Choice" and not self.choices.strip():
            raise ValidationError("Choice type requires some choices")

    class Meta:
        ordering = ['rank']
        unique_together = ['survey', 'slug']


# Connect signals
pre_save.connect(signals.question_pre_save, sender=Question)
post_save.connect(signals.question_post_save, sender=Question)
post_delete.connect(signals.question_post_delete, sender=Question)
post_save.connect(signals.survey_post_save, sender=Survey)
pre_delete.connect(signals.survey_pre_delete, sender=Survey)


########NEW FILE########
__FILENAME__ = signals
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

from django.contrib import admin
from django.core.exceptions import ObjectDoesNotExist

from . import utils


def question_pre_save(sender, instance, **kwargs):
    """ An optional signal to detect renamed slugs. 
        This will rename the column so that the data is migrated.
    """
    Question = sender
    try:
        # Try to detect if a question has been given a new slug (which would
        # require a column rename)
        if instance.pk:
            instance._old_slug = Question.objects.filter(pk=instance.pk).exclude(slug=instance.slug).get().slug

    # Fixture loading will not have a related survey object, so we can't use it
    # This won't be a problem because we're only looking for renamed slugs
    except ObjectDoesNotExist:
        pass


def question_post_save(sender, instance, created, **kwargs):
    """ Adapt tables to any relavent changes:
        If the question slug has been renamed, rename the database column.
    """
    try:
        # Regenerate our response model, which may have changed
        Response = instance.survey.get_survey_response_model(regenerate=True, notify_changes=False)

        # If we previously identified a renamed slug, then rename the column
        if hasattr(instance, '_old_slug'):
            utils.rename_db_column(Response, instance._old_slug, instance.slug)
            del instance._old_slug

        # If necessary, add any new columns
        utils.add_necessary_db_columns(Response)

        # Reregister the Survey model in the admin
        utils.reregister_in_admin(admin.site, Response)

        # Tell other process to regenerate their models
        utils.notify_model_change(Response)

    except ObjectDoesNotExist:
        return


def question_post_delete(sender, instance, **kwargs):
    """ If you delete a question from a survey, update the model. 
    """
    Response = instance.survey.get_survey_response_model(regenerate=True, notify_changes=True)


def survey_post_save(sender, instance, created, **kwargs):
    """ Ensure that a table exists for this logger. """

    # Force our response model to regenerate
    Response = instance.get_survey_response_model(regenerate=True, notify_changes=False)

    # Create a new table if it's missing
    utils.create_db_table(Response)

    # Reregister the model in the admin
    utils.reregister_in_admin(admin.site, Response)

    # Tell other process to regenerate their models
    utils.notify_model_change(Response)


def survey_pre_delete(sender, instance, **kwargs):
    Response = instance.Response

    # delete the data tables? (!)
    #utils.delete_db_table(Response)

    # unregister from the admin site
    utils.unregister_from_admin(admin.site, Response)



########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

from django.db import connection, DatabaseError
from django.db import models
from django.contrib.admin.sites import NotRegistered
from django.db.models.signals import class_prepared
from django.db.models.loading import cache as app_cache

from django.core.urlresolvers import clear_url_caches
from django.utils.importlib import import_module
from django.core.cache import cache
from django.conf import settings

import logging
from south.db import db

logger = logging.getLogger('surveymaker')


def unregister_from_admin(admin_site, model):
    " Removes the dynamic model from the given admin site "

    # First deregister the current definition
    # This is done "manually" because model will be different
    # db_table is used to check for class equivalence.
    for reg_model in admin_site._registry.keys():
        if model._meta.db_table == reg_model._meta.db_table:
            del admin_site._registry[reg_model]

    # Try the normal approach too
    try:
        admin_site.unregister(model)
    except NotRegistered:
        pass

    # Reload the URL conf and clear the URL cache
    # It's important to use the same string as ROOT_URLCONF
    reload(import_module(settings.ROOT_URLCONF))
    clear_url_caches()


def reregister_in_admin(admin_site, model, admin_class=None):
    " (re)registers a dynamic model in the given admin site "

    # We use our own unregister, to ensure that the correct
    # existing model is found 
    # (Django's unregister doesn't expect the model class to change)
    unregister_from_admin(admin_site, model)
    admin_site.register(model, admin_class)

    # Reload the URL conf and clear the URL cache
    # It's important to use the same string as ROOT_URLCONF
    reload(import_module(settings.ROOT_URLCONF))
    clear_url_caches()


def when_classes_prepared(app_name, dependencies, fn):
    """ Runs the given function as soon as the model dependencies are available.
        You can use this to build dyanmic model classes on startup instead of
        runtime. 

        app_name       the name of the relevant app
        dependencies   a list of model names that need to have already been 
                       prepared before the dynamic classes can be built.
        fn             this will be called as soon as the all required models 
                       have been prepared

        NB: The fn will be called as soon as the last required
            model has been prepared. This can happen in the middle of reading
            your models.py file, before potentially referenced functions have
            been loaded. Becaue this function must be called before any 
            relevant model is defined, the only workaround is currently to 
            move the required functions before the dependencies are declared.

        TODO: Allow dependencies from other apps?
    """
    dependencies = [x.lower() for x in dependencies]

    def _class_prepared_handler(sender, **kwargs):
        """ Signal handler for class_prepared. 
            This will be run for every model, looking for the moment when all
            dependent models are prepared for the first time. It will then run
            the given function, only once.
        """
        sender_name = sender._meta.object_name.lower()
        already_prepared = set(app_cache.app_models.get(app_name,{}).keys() + [sender_name])

        if (sender._meta.app_label == app_name and sender_name in dependencies
          and all([x in already_prepared for x in dependencies])):
            db.start_transaction()
            try:
                fn()
            except DatabaseError:
                # If tables are  missing altogether, not much we can do
                # until syncdb/migrate is run. "The code must go on" in this 
                # case, without running our function completely. At least
                # database operations will be rolled back.
                db.rollback_transaction()
            else:
                db.commit_transaction()
                # TODO Now that the function has been run, should/can we 
                # disconnect this signal handler?
    
    # Connect the above handler to the class_prepared signal
    # NB: Although this signal is officially documented, the documentation
    # notes the following:
    #     "Django uses this signal internally; it's not generally used in 
    #      third-party applications."
    class_prepared.connect(_class_prepared_handler, weak=False)


def get_cached_model(app_label, model_name, regenerate=False, get_local_hash=lambda i: i._hash):

    # If this model has already been generated, we'll find it here
    previous_model = models.get_model(app_label, model_name)

    # Before returning our locally cached model, check that it is still current
    if previous_model is not None and not regenerate:
        CACHE_KEY = utils.HASH_CACHE_TEMPLATE % (app_label, model_name)
        if cache.get(CACHE_KEY) != get_local_hash(previous_model):
            logging.debug("Local and shared dynamic model hashes are different: %s (local) %s (shared)" % (get_local_hash(previous_model), cache.get(CACHE_KEY)))
            regenerate = True

    # We can force regeneration by disregarding the previous model
    if regenerate:
        previous_model = None
        # Django keeps a cache of registered models, we need to make room for
        # our new one
        utils.remove_from_model_cache(app_label, model_name)

    return previous_model


def remove_from_model_cache(app_label, model_name):
    """ Removes the given model from the model cache. """
    try:
        del app_cache.app_models[app_label][model_name.lower()]
    except KeyError:
        pass

def create_db_table(model_class):
    """ Takes a Django model class and create a database table, if necessary.
    """
    # XXX Create related tables for ManyToMany etc

    db.start_transaction()
    table_name = model_class._meta.db_table

    # Introspect the database to see if it doesn't already exist
    if (connection.introspection.table_name_converter(table_name) 
                        not in connection.introspection.table_names()):

        fields = _get_fields(model_class)

        db.create_table(table_name, fields)
        # Some fields are added differently, after table creation
        # eg GeoDjango fields
        db.execute_deferred_sql()
        logger.debug("Created table '%s'" % table_name)

    db.commit_transaction()


def delete_db_table(model_class):
    table_name = model_class._meta.db_table
    db.start_transaction()
    db.delete_table(table_name)
    logger.debug("Deleted table '%s'" % table_name)
    db.commit_transaction()


def _get_fields(model_class):
    """ Return a list of fields that require table columns. """
    return [(f.name, f) for f in model_class._meta.local_fields]


def add_necessary_db_columns(model_class):
    """ Creates new table or relevant columns as necessary based on the model_class.
        No columns or data are renamed or removed.
        This is available in case a database exception occurs.
    """
    db.start_transaction()

    # Create table if missing
    create_db_table(model_class)

    # Add field columns if missing
    table_name = model_class._meta.db_table
    fields = _get_fields(model_class)
    db_column_names = [row[0] for row in connection.introspection.get_table_description(connection.cursor(), table_name)]

    for field_name, field in fields:
        if field.column not in db_column_names:
            logger.debug("Adding field '%s' to table '%s'" % (field_name, table_name))
            db.add_column(table_name, field_name, field)


    # Some columns require deferred SQL to be run. This was collected 
    # when running db.add_column().
    db.execute_deferred_sql()

    db.commit_transaction()


def rename_db_column(model_class, old_name, new_name):
    """ Rename a sensor's database column. """
    table_name = model_class._meta.db_table
    db.start_transaction()
    db.rename_column(table_name, old_name, new_name) 
    logger.debug("Renamed column '%s' to '%s' on %s" % (old_name, new_name, table_name))
    db.commit_transaction()


def notify_model_change(model):
    """ Notifies other processes that a dynamic model has changed. 
        This should only ever be called after the required database changes have been made.
    """
    CACHE_KEY = HASH_CACHE_TEMPLATE % (model._meta.app_label, model._meta.object_name) 
    cache.set(CACHE_KEY, model._hash)
    logger.debug("Setting \"%s\" hash to: %s" % (model._meta.verbose_name, model._hash))


HASH_CACHE_TEMPLATE = 'dynamic_model_hash_%s-%s'

########NEW FILE########
__FILENAME__ = views
# -*- coding: UTF-8 -*-

from .models import Survey

from django import forms
from django.shortcuts import render_to_response, get_object_or_404, redirect
from django.template.context import RequestContext

def all_survey_responses(request):
    template_name = "surveymaker/all.html"

    surveys = [(survey, survey.Response.objects.all()) 
                                    for survey in Survey.objects.all()]
    return render_to_response(template_name, {'surveys': surveys}, 
                                context_instance=RequestContext(request))


def get_response_form(response):
    class FormMeta:
        model = response
    return type('ResponseForm', (forms.ModelForm,), {'Meta': FormMeta})


def survey_form(request, survey_slug):
    template_name = "surveymaker/survey_form.html"
    survey = get_object_or_404(Survey, slug=survey_slug)
    Response = survey.Response
    ResponseForm = get_response_form(Response)

    if request.method == "POST":
        form = ResponseForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('surveymaker_index')
    else:
        form = ResponseForm()

    return render_to_response(template_name, {'form': form, 'survey': survey}, 
                                context_instance=RequestContext(request))


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    url(r'^$', 'surveymaker.views.all_survey_responses', name='surveymaker_index'),
    url(r'^(?P<survey_slug>.*)/new/$', 'surveymaker.views.survey_form', name='surveymaker_form'),
    url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
