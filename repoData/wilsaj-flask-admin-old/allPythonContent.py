__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask-Admin documentation build configuration file, created by
# sphinx-quickstart on Sat Feb 12 13:20:00 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
sys.path.append(os.path.abspath('_themes'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask-Admin'
copyright = u'2011, Andy Wilson'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = False

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask_small'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {'index_logo': False,
                      'github_fork': 'wilsaj/flask-admin'
                      }

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flask-Admindoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask-Admin.tex', u'Flask-Admin Documentation',
   u'Andy Wilson', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flask-admin', u'Flask-Admin Documentation',
     [u'Andy Wilson'], 1)
]


########NEW FILE########
__FILENAME__ = view_decorator
from functools import wraps
import sys

from flask import Flask, g, redirect, render_template, request, session, url_for
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from sqlalchemy import create_engine, Table
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, Text, String, Float, Time, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.schema import ForeignKey

Base = declarative_base()

# ----------------------------------------------------------------------
# Association tables
# ----------------------------------------------------------------------
course_student_association_table = Table(
    'course_student_association',
    Base.metadata,
    Column('student_id', Integer, ForeignKey('student.id')),
    Column('course_id', Integer, ForeignKey('course.id')))


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class Course(Base):
    __tablename__ = 'course'

    id = Column(Integer, primary_key=True)
    subject = Column(String)
    teacher_id = Column(Integer, ForeignKey('teacher.id'), nullable=False)
    start_time = Column(Time)
    end_time = Column(Time)

    teacher = relationship('Teacher', backref='courses')
    students = relationship('Student',
                            secondary=course_student_association_table,
                            backref='courses')

    def __repr__(self):
        return self.subject


class Student(Base):
    __tablename__ = 'student'

    id = Column(Integer, primary_key=True)
    name = Column(String(120), unique=True)

    def __repr__(self):
        return self.name


class Teacher(Base):
    __tablename__ = 'teacher'

    id = Column(Integer, primary_key=True)
    name = Column(String(120), unique=True)

    def __repr__(self):
        return self.name


def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user' not in session:
            return redirect(url_for('.login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'

    app.engine = create_engine(database_uri, convert_unicode=True)
    db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False, bind=app.engine))
    datastore = SQLAlchemyDatastore(
        (Course, Student, Teacher), db_session)
    admin_blueprint = admin.create_admin_blueprint(
        datastore, view_decorator=login_required)

    @admin_blueprint.route('/login/', methods=('GET', 'POST'))
    def login():
        if request.form.get('username', None):
            session['user'] = request.form['username']
            return redirect(request.args.get('next', url_for('admin.index')))
        else:
            if request.method == 'POST':
                return render_template("login.html",
                                       bad_login=True)
            else:
                return render_template("login.html")

    @admin_blueprint.route('/logout/')
    def logout():
        del session['user']
        return redirect('/')

    @app.route('/')
    def go_to_admin():
        return redirect('/admin/')

    app.register_blueprint(admin_blueprint, url_prefix='/admin')

    return app


if __name__ == '__main__':
    app = create_app('sqlite:///simple.db')
    Base.metadata.create_all(bind=app.engine)
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = composite_keys
import sys

from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from sqlalchemy import create_engine, Table
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Time
from sqlalchemy.orm import relationship
from sqlalchemy.schema import ForeignKey


Base = declarative_base()


class Student(Base):
    __tablename__ = 'student'

    student_id = Column(Integer, primary_key=True)
    name = Column(String(120), primary_key=True)

    def __repr__(self):
        return self.name


class Teacher(Base):
    __tablename__ = 'teacher'

    id = Column(Integer, primary_key=True)
    name = Column(String(120), unique=True)

    def __repr__(self):
        return self.name


def create_app(database_uri='sqlite://', pagination=25):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'
    engine = create_engine(database_uri, convert_unicode=True)
    app.db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False,
        bind=engine))
    datastore = SQLAlchemyDatastore(
        (Student, Teacher), app.db_session, exclude_pks=False)
    admin_blueprint = admin.create_admin_blueprint(
        datastore, list_view_pagination=pagination)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    Base.metadata.create_all(bind=engine)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')

    return app


if __name__ == '__main__':
    app = create_app('sqlite:///composite.db')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = custom_form
import sys

from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from sqlalchemy import create_engine
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Boolean, Column, Integer, Text, String, Float, Time
from sqlalchemy.orm import synonym
from werkzeug import check_password_hash, generate_password_hash
from wtforms import Form, validators
from wtforms.fields import BooleanField, TextField, PasswordField


Base = declarative_base()


class User(Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True)
    username = Column(String(80), unique=True)
    _password_hash = Column('password', String(80), nullable=False)
    is_active = Column(Boolean, default=True)

    def __init__(self, username="", password="", is_active=True):
        self.username = username
        self.password = password
        self.is_active = is_active

    def check_password(self, password):
        return check_password_hash(self.pw_hash, password)

    @property
    def password(self):
        return self._password_hash

    @password.setter
    def password(self, password):
        self._password_hash = generate_password_hash(password)

    password = synonym('_password_hash', descriptor=password)

    def __repr__(self):
        return self.username

    __mapper_args__ = {
        'order_by': username
        }


class UserForm(Form):
    """
    Form for creating or editting User object (via the admin). Define
    any handling of fields here. This form class also has precedence
    when rendering forms to a webpage, so the model-generated fields
    will come after it.
    """
    username = TextField(u'User name',
                         [validators.required(), validators.length(max=80)])
    password = PasswordField('Change Password',
                             [validators.optional(),
                              validators.equal_to('confirm_password')])
    confirm_password = PasswordField()
    is_active = BooleanField(default=True)


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'
    engine = create_engine(database_uri, convert_unicode=True)
    db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False,
        bind=engine))
    datastore = SQLAlchemyDatastore(
        (User,), db_session, model_forms={'User': UserForm})
    admin_blueprint = admin.create_admin_blueprint(
        datastore)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    Base.metadata.create_all(bind=engine)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')

    return app


if __name__ == '__main__':
    app = create_app('sqlite:///simple.db')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = multiple
import sys

from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from sqlalchemy import create_engine, Table
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, Text, String, Float, Time, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.schema import ForeignKey


Base = declarative_base()

# ----------------------------------------------------------------------
# Association tables
# ----------------------------------------------------------------------
course_student_association_table = Table(
    'course_student_association',
    Base.metadata,
    Column('student_id', Integer, ForeignKey('student.id')),
    Column('course_id', Integer, ForeignKey('course.id')))


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class Course(Base):
    __tablename__ = 'course'

    id = Column(Integer, primary_key=True)
    subject = Column(String)
    teacher_id = Column(Integer, ForeignKey('teacher.id'), nullable=False)
    start_time = Column(Time)
    end_time = Column(Time)

    teacher = relationship('Teacher', backref='courses')
    students = relationship('Student',
                            secondary=course_student_association_table,
                            backref='courses')

    def __repr__(self):
        return self.subject


class Student(Base):
    __tablename__ = 'student'

    id = Column(Integer, primary_key=True)
    name = Column(String(120), unique=True)

    def __repr__(self):
        return self.name


class Teacher(Base):
    __tablename__ = 'teacher'

    id = Column(Integer, primary_key=True)
    name = Column(String(120), unique=True)

    def __repr__(self):
        return self.name


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'

    app.engine = create_engine(database_uri, convert_unicode=True)
    app.db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False, bind=app.engine))
    datastore1 = SQLAlchemyDatastore(
        (Student, Teacher), app.db_session)
    admin_blueprint1 = admin.create_admin_blueprint(
        datastore1, name='admin1')
    datastore2 = SQLAlchemyDatastore(
        (Course,), app.db_session)
    admin_blueprint2 = admin.create_admin_blueprint(
        datastore2, name='admin2')
    app.register_blueprint(admin_blueprint1, url_prefix='/admin1')
    app.register_blueprint(admin_blueprint2, url_prefix='/admin2')
    Base.metadata.create_all(bind=app.engine)
    return app


if __name__ == '__main__':
    app = create_app('sqlite:///simple.db')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = simple
import sys

from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from sqlalchemy import create_engine, Table
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Time
from sqlalchemy.orm import relationship
from sqlalchemy.schema import ForeignKey


Base = declarative_base()

# ----------------------------------------------------------------------
# Association tables
# ----------------------------------------------------------------------
course_student_association_table = Table(
    'course_student_association',
    Base.metadata,
    Column('student_id', Integer, ForeignKey('student.id')),
    Column('course_id', Integer, ForeignKey('course.id')))


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class Course(Base):
    __tablename__ = 'course'

    id = Column(Integer, primary_key=True)
    subject = Column(String)
    teacher_id = Column(Integer, ForeignKey('teacher.id'), nullable=False)
    start_time = Column(Time)
    end_time = Column(Time)

    teacher = relationship('Teacher', backref='courses')
    students = relationship('Student',
                            secondary=course_student_association_table,
                            backref='courses')

    def __repr__(self):
        return self.subject


class Student(Base):
    __tablename__ = 'student'

    id = Column(Integer, primary_key=True)
    name = Column(String(120), unique=True)

    def __repr__(self):
        return self.name


class Teacher(Base):
    __tablename__ = 'teacher'

    id = Column(Integer, primary_key=True)
    name = Column(String(120), unique=True)

    def __repr__(self):
        return self.name


def create_app(database_uri='sqlite://', pagination=25):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'
    engine = create_engine(database_uri, convert_unicode=True)
    app.db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False,
        bind=engine))
    datastore = SQLAlchemyDatastore(
        (Course, Student, Teacher), app.db_session)
    admin_blueprint = admin.create_admin_blueprint(
        datastore, list_view_pagination=pagination)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    Base.metadata.create_all(bind=engine)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')

    return app


if __name__ == '__main__':
    app = create_app('sqlite:///simple.db')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = flaskext_sa_example
from flask import Flask, redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from flaskext.sqlalchemy import SQLAlchemy

from datetime import datetime

db = SQLAlchemy()


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True)
    email = db.Column(db.String(120), unique=True)

    def __init__(self, username=None, email=None):
        self.username = username
        self.email = email

    def __repr__(self):
        return '<User %r>' % self.username


class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(80))
    body = db.Column(db.Text)
    pub_date = db.Column(db.DateTime)

    category_id = db.Column(db.Integer, db.ForeignKey('category.id'))
    category = db.relationship('Category',
        backref=db.backref('posts', lazy='dynamic'))

    def __init__(self, title=None, body=None, category=None, pub_date=None):
        self.title = title
        self.body = body
        if pub_date is None:
            pub_date = datetime.utcnow()
        self.pub_date = pub_date
        self.category = category

    def __repr__(self):
        return '<Post %r>' % self.title


class Category(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50))

    def __init__(self, name=None):
        self.name = name

    def __repr__(self):
        return '<Category %r>' % self.name


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = database_uri
    app.config['SECRET_KEY'] = 'seeeeecret'

    db.init_app(app)
    datastore = SQLAlchemyDatastore(
        (User, Post, Category), db.session)
    admin_blueprint = admin.create_admin_blueprint(datastore)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    db.create_all(app=app)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')
    return app

if __name__ == '__main__':
    app = create_app('sqlite:///flask_sqlalchemy_example.db')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = flaskext_sa_multi_pk
from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from flaskext.sqlalchemy import SQLAlchemy

db = SQLAlchemy()


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class Address(db.Model):
    __tablename__ = 'address'

    shortname = db.Column(db.Unicode(100), primary_key=True, unique=True,
                          index=True)

    name = db.Column(db.UnicodeText)
    street = db.Column(db.UnicodeText)
    zipcode = db.Column(db.Integer)
    city = db.Column(db.UnicodeText)
    country = db.Column(db.UnicodeText)

    # backref
    location = db.relationship('Location', backref='address')

    def __repr__(self):
        return self.shortname


class Location(db.Model):
    __tablename__ = 'location'

    address_shortname = db.Column(db.Unicode(100),
                                  db.ForeignKey('address.shortname'),
                                  primary_key=True)
    room = db.Column(db.Unicode(100), primary_key=True)
    position = db.Column(db.Unicode(100), primary_key=True)

    db.PrimaryKeyConstraint('address_shortname', 'room', 'position',
                            name='location_key')

    asset = db.relationship(
        'Asset', backref='location',
        lazy='select',
        primaryjoin='(Location.room==Asset.location_room) &'\
            '(Location.address_shortname==Asset.address_shortname) &'\
            '(Location.position==Asset.location_position)')

    # additional fields in real world example

    def __repr__(self):
        return u"%s|%s|%s" % (self.address_shortname, self.room,
                              self.position)


class Asset(db.Model):
    __tablename__ = 'asset'

    id = db.Column(db.Integer, primary_key=True)

    name = db.Column(db.UnicodeText)

    # 1*n relation to location-table
    address_shortname = db.Column(db.Unicode(100))
    location_room = db.Column(db.Unicode(100))
    location_position = db.Column(db.Unicode(100))

    __table_args__ = (
        db.ForeignKeyConstraint(['address_shortname', 'location_room',
                                 'location_position'],
                                ['location.address_shortname',
                                 'location.room',
                                 'location.position'],
                                use_alter=True,
                                name='fk_location_asset'),)

    def __repr__(self):
        return self.name


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = database_uri
    app.config['SECRET_KEY'] = 'not secure'
    db.init_app(app)
    datastore = SQLAlchemyDatastore(
        (Address, Location, Asset), db.session, exclude_pks=False)
    admin_blueprint = admin.create_admin_blueprint(datastore)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    db.create_all(app=app)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')
    return app


if __name__ == '__main__':
    app = create_app('sqlite:///multi_pks.db')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = flaskext_sa_simple
from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from flaskext.sqlalchemy import SQLAlchemy

db = SQLAlchemy()

# ----------------------------------------------------------------------
# Association tables
# ----------------------------------------------------------------------
course_student_association_table = db.Table(
    'course_student_association',
    db.Column('student_id', db.Integer, db.ForeignKey('student.id')),
    db.Column('course_id', db.Integer, db.ForeignKey('course.id')))


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class Course(db.Model):
    __tablename__ = 'course'

    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String)
    teacher_id = db.Column(db.Integer,
                           db.ForeignKey('teacher.id'), nullable=False)
    start_time = db.Column(db.Time)
    end_time = db.Column(db.Time)

    teacher = db.relationship('Teacher', backref='courses')
    students = db.relationship('Student',
                               secondary=course_student_association_table,
                               backref='courses')

    def __repr__(self):
        return self.subject


class Student(db.Model):
    __tablename__ = 'student'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), unique=True)

    def __repr__(self):
        return self.name


class Teacher(db.Model):
    __tablename__ = 'teacher'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), unique=True)

    def __repr__(self):
        return self.name


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = database_uri
    app.config['SECRET_KEY'] = 'not secure'
    db.init_app(app)
    datastore = SQLAlchemyDatastore(
        (Course, Student, Teacher), db.session)
    admin_blueprint = admin.create_admin_blueprint(datastore)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    db.create_all(app=app)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')
    return app


if __name__ == '__main__':
    app = create_app('sqlite:///simple.db')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = simple
import sys

from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.mongoalchemy import MongoAlchemyDatastore
from mongoalchemy.document import Document
from mongoalchemy import fields, session
from wtforms import fields as wtfields
from wtforms import Form


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class Course(Document):
    subject = fields.StringField()
    start_date = fields.DateTimeField()
    end_date = fields.DateTimeField()

    def __repr__(self):
        return self.subject


class Student(Document):
    name = fields.StringField()

    def __repr__(self):
        return self.name


class Teacher(Document):
    name = fields.StringField()

    def __repr__(self):
        return self.name


# ----------------------------------------------------------------------
# Forms
# ----------------------------------------------------------------------
class CourseForm(Form):
    subject = wtfields.TextField(u'Subject')


def create_app(mongo_database='simple-example', pagination=25):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'
    app.db_session = session.Session.connect(mongo_database)
    datastore = MongoAlchemyDatastore(
        (Course, Student, Teacher), app.db_session)
    admin_blueprint = admin.create_admin_blueprint(
        datastore, list_view_pagination=pagination)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')

    return app


if __name__ == '__main__':
    app = create_app()
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = core
class AdminDatastore(object):
    """A base class for admin datastore objects. All datastores used
    in Flask-Admin should subclass this object and define the
    following methods.
    """

    def create_model_pagination(self, model_name, page, per_page=25):
        """Returns a pagination object for the list view."""
        raise NotImplementedError()

    def delete_model_instance(self, model_name, model_keys):
        """Deletes a model instance. Returns True if model instance
        was successfully deleted, returns False otherwise.
        """
        raise NotImplementedError()

    def find_model_instance(self, model_name, model_keys):
        """Returns a model instance, if one exists, that matches
        model_name and model_keys. Returns None if no such model
        instance exists.
        """
        raise NotImplementedError()

    def get_model_class(self, model_name):
        """Returns a model class, given a model name."""
        raise NotImplementedError()

    def get_model_form(self, model_name):
        """Returns a form, given a model name."""
        raise NotImplementedError()

    def get_model_keys(self, model_instance):
        """Returns the keys for a given a model instance. This should
        be an iterable (e.g. list or tuple) containing the keys.
        """
        raise NotImplementedError()

    def list_model_names(self):
        """Returns a list of model names available in the datastore."""
        raise NotImplementedError()

    def save_model(self, model_instance):
        """Persists a model instance to the datastore. Note: this
        could be called when a model instance is added or edited.
        """
        raise NotImplementedError()

    def update_from_form(self, model_instance, form):
        """Returns a model instance whose values have been updated
        with the values from a given form.
        """
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = mongoalchemy
# -*- coding: utf-8 -*-
"""
    flask.ext.datastore.mongoalchemy
    ~~~~~~~~~~~~~~


    :copyright: (c) 2011 by wilsaj.
    :license: BSD, see LICENSE for more details.
"""
from __future__ import absolute_import

import types

import mongoalchemy as ma
from mongoalchemy.document import Document
from wtforms import fields as f
from wtforms import form, validators, widgets
from wtforms.form import Form

from flask.ext.admin.datastore import AdminDatastore
from flask.ext.admin import wtforms as admin_wtf
from flask.ext.admin import util


class MongoAlchemyDatastore(AdminDatastore):
    """A datastore for accessing MongoAlchemy document models.

    The `models` parameter should be either a module or an iterable
    that contains the MongoAlchemy models that will be made available
    through the admin interface.

    `db_session` should be an initialized MongoAlchemy session
    object. See the `MongoAlchemy documentation`_ for information on
    how to do that.

    By default, a form for adding and editing data will be
    automatically generated for each MongoAlchemy model. Only
    primitive MongoAlchemy types are supported so if you need to
    support other fields you will need to create custom forms. You can
    also use custom forms if you want more control over form behavior.
    To use custom forms, set the `model_forms` parameter to be a dict
    with model names as keys matched to custom forms for the forms you
    want to override. Forms should be WTForms form objects; see the
    `WTForms documentation`_ for more information on how to configure
    forms.

    A dict with model names as keys, mapped to WTForm Form objects
    that should be used as forms for creating and editing instances of
    these models.

    .. _MongoAlchemy documentation: http://www.mongoalchemy.org/api/session.html
    .. _WTForms documentation: http://wtforms.simplecodes.com/
    """
    def __init__(self, models, db_session, model_forms=None):
        self.model_classes = {}
        self.model_forms = model_forms
        self.db_session = db_session

        if not self.model_forms:
            self.model_forms = {}

        if type(models) == types.ModuleType:
            self.model_classes = dict(
                [(k, v) for k, v in models.__dict__.items()
                 if issubclass(v, Document)])
        else:
            self.model_classes = dict(
                [(model.__name__, model)
                 for model in models
                 if issubclass(model, Document)])

        if self.model_classes:
            self.form_dict = dict(
                [(k, _form_for_model(v, db_session,))
                 for k, v in self.model_classes.items()])
            for model_name, form in self.model_forms.items():
                if model_name in self.form_dict:
                    self.form_dict[model_name] = form

    def create_model_pagination(self, model_name, page, per_page=25):
        """Returns a pagination object for the list view."""
        model_class = self.get_model_class(model_name)
        query = self.db_session.query(model_class).skip(
            (page - 1) * per_page).limit(per_page)
        return MongoAlchemyPagination(page, per_page, query)

    def delete_model_instance(self, model_name, model_keys):
        """Deletes a model instance. Returns True if model instance
        was successfully deleted, returns False otherwise.
        """
        model_class = self.get_model_class(model_name)
        try:
            model_instance = self.find_model_instance(model_name, model_keys)
            self.db_session.remove(model_instance)
            return True
        except ma.query.BadResultException:
            return False

    def find_model_instance(self, model_name, model_keys):
        """Returns a model instance, if one exists, that matches
        model_name and model_keys. Returns None if no such model
        instance exists.
        """
        model_key = model_keys[0]
        model_class = self.get_model_class(model_name)
        return self.db_session.query(model_class).filter(
            model_class.mongo_id == model_key).one()

    def get_model_class(self, model_name):
        """Returns a model class, given a model name."""
        return self.model_classes.get(model_name, None)

    def get_model_form(self, model_name):
        """Returns a form, given a model name."""
        return self.form_dict.get(model_name, None)

    def get_model_keys(self, model_instance):
        """Returns the keys for a given a model instance."""
        return [model_instance.mongo_id]

    def list_model_names(self):
        """Returns a list of model names available in the datastore."""
        return self.model_classes.keys()

    def save_model(self, model_instance):
        """Persists a model instance to the datastore. Note: this
        could be called when a model instance is added or edited.
        """
        return model_instance.commit(self.db_session.db)

    def update_from_form(self, model_instance, form):
        """Returns a model instance whose values have been updated
        with the values from a given form.
        """
        for field in form:
            # handle FormFields that were generated for mongoalchemy
            # TupleFields as a special case
            if field.__class__ == f.FormField:
                data_tuple = tuple([subfield.data for subfield in field])
                setattr(model_instance, field.name, data_tuple)
                continue

            # don't use the mongo id from the form - it comes from the
            # key/url and if someone tampers with the form somehow, we
            # should ignore that
            elif field.name != 'mongo_id':
                setattr(model_instance, field.name, field.data)
        return model_instance


class MongoAlchemyPagination(util.Pagination):
    def __init__(self, page, per_page, query, *args, **kwargs):
        super(MongoAlchemyPagination, self).__init__(
            page, per_page, total=query.count(), items=query.all(),
            *args, **kwargs)


def _form_for_model(document_class, db_session):
    """returns a wtform Form object for a given document model class.
    """
    #XXX: needs to be implemented
    return model_form(document_class)


#-----------------------------------------------------------------------
# mongo alchemy form generation: to be pushed upstream
#-----------------------------------------------------------------------
class DisabledTextInput(widgets.TextInput):
    def __call__(self, field, **kwargs):
        kwargs['disabled'] = 'disabled'
        return super(DisabledTextInput, self).__call__(field, **kwargs)


def converts(*args):
    def _inner(func):
        func._converter_for = frozenset(args)
        return func
    return _inner


class ModelConverterBase(object):
    def __init__(self, converters, use_mro=True):
        self.use_mro = use_mro

        if not converters:
            converters = {}

        for name in dir(self):
            obj = getattr(self, name)
            if hasattr(obj, '_converter_for'):
                for classname in obj._converter_for:
                    converters[classname] = obj

        self.converters = converters

    def convert(self, model, ma_field, field_args):
        default = getattr(ma_field, 'default', None)

        if default == ma.util.UNSET:
            default = None

        kwargs = {
            'validators': [],
            'filters': [],
            'default': default,
        }

        if field_args:
            kwargs.update(field_args)

        if not ma_field.required:
            kwargs['validators'].append(validators.Optional())

        types = [type(ma_field)]

        converter = None
        for ma_field_type in types:
            type_string = '%s.%s' % (
                ma_field_type.__module__, ma_field_type.__name__)
            if type_string.startswith('mongoalchemy.fields'):
                type_string = type_string[20:]

            if type_string in self.converters:
                converter = self.converters[type_string]
                break
        else:
            for ma_field_type in types:
                if ma_field_type.__name__ in self.converters:
                    converter = self.converters[ma_field_type.__name__]
                    break
            else:
                return
        return converter(model=model, ma_field=ma_field, field_args=kwargs)


class ModelConverter(ModelConverterBase):
    def __init__(self, extra_converters=None):
        super(ModelConverter, self).__init__(extra_converters)

    @converts('BoolField')
    def conv_Bool(self, ma_field, field_args, **extra):
        return f.BooleanField(**field_args)

    @converts('DateTimeField')
    def conv_DateTime(self, ma_field, field_args, **extra):
        # TODO: add custom validator for date range
        field_args['widget'] = admin_wtf.DateTimePickerWidget()
        return f.DateTimeField(**field_args)

    @converts('EnumField')
    def conv_Enum(self, model, ma_field, field_args, **extra):
        converted_field = self.convert(model, ma_field.item_type, {})
        converted_field.kwargs['validators'].append(
            validators.AnyOf(ma_field.values, values_formatter=str))
        return converted_field

    @converts('FloatField')
    def conv_Float(self, ma_field, field_args, **extra):
        if ma_field.min or ma_field.max:
            field_args['validators'].append(
                validators.NumberRange(min=ma_field.min, max=ma_field.max))
        return f.FloatField(**field_args)

    @converts('IntField')
    def conv_Int(self, ma_field, field_args, **extra):
        if ma_field.min or ma_field.max:
            field_args['validators'].append(
                validators.NumberRange(min=ma_field.min, max=ma_field.max))
        return f.IntegerField(**field_args)

    @converts('ObjectIdField')
    def conv_ObjectId(self, field_args, **extra):
        widget = DisabledTextInput()
        return f.TextField(widget=widget, **field_args)

    @converts('StringField')
    def conv_String(self, ma_field, field_args, **extra):
        if ma_field.min or ma_field.max:
            min = ma_field.min or -1
            max = ma_field.max or -1
            field_args['validators'].append(
                validators.Length(min=min, max=max))
        return f.TextField(**field_args)

    @converts('TupleField')
    def conv_Tuple(self, model, ma_field, field_args, **extra):
        def convert_field(field):
            return self.convert(model, field, {})
        fields = map(convert_field, ma_field.types)
        fields_dict = dict([('%s_%s' % (ma_field._name, i), field)
                            for i, field in enumerate(fields)])

        class ConvertedTupleForm(Form):
            def process(self, formdata=None, obj=None, **kwargs):
                # if the field is being populated from a mongoalchemy
                # TupleField, obj will be a tuple object so we can set
                # the fields by reversing the field name to get the
                # index and then passing that along to wtforms in the
                # kwargs dict
                if type(obj) == tuple:
                    for name, field in self._fields.items():
                        tuple_index = int(name.split('_')[-1])
                        kwargs[name] = obj[tuple_index]
                super(ConvertedTupleForm, self).process(
                    formdata, obj, **kwargs)

        fields_form = type(ma_field._name + 'Form', (ConvertedTupleForm,), fields_dict)
        return f.FormField(fields_form)


def model_fields(model, only=None, exclude=None, field_args=None,
                 converter=None):
    """
    Generate a dictionary of fields for a given MongoAlchemy model.

    See `model_form` docstring for description of parameters.
    """
    if not issubclass(model, Document):
        raise TypeError('model must be a mongoalchemy document model')

    converter = converter or ModelConverter()
    field_args = field_args or {}

    ma_fields = ((name, field) for name, field in model.get_fields().items())
    if only:
        ma_fields = (x for x in ma_fields if x[0] in only)
    elif exclude:
        ma_fields = (x for x in ma_fields if x[0] not in exclude)

    field_dict = {}
    for name, field in ma_fields:
        wtfield = converter.convert(model, field, field_args.get(name))
        if wtfield is not None:
            field_dict[name] = wtfield

    return field_dict


def model_form(model, base_class=Form, only=None, exclude=None,
               field_args=None, converter=None):
    """
    Create a wtforms Form for a given MongoAlchemy model class::

        from wtforms.ext.mongoalchemy.orm import model_form
        from myapp.models import User
        UserForm = model_form(User)

    :param model:
        A MongoAlchemy mapped model class.
    :param base_class:
        Base form class to extend from. Must be a ``wtforms.Form`` subclass.
    :param only:
        An optional iterable with the property names that should be included in
        the form. Only these properties will have fields.
    :param exclude:
        An optional iterable with the property names that should be excluded
        from the form. All other properties will have fields.
    :param field_args:
        An optional dictionary of field names mapping to keyword arguments used
        to construct each field object.
    :param converter:
        A converter to generate the fields based on the model properties. If
        not set, ``ModelConverter`` is used.
    """
    field_dict = model_fields(model, only, exclude, field_args, converter)
    return type(model.__name__ + 'Form', (base_class, ), field_dict)

########NEW FILE########
__FILENAME__ = sqlalchemy
# -*- coding: utf-8 -*-
"""
    flask.ext.datastore.sqlalchemy
    ~~~~~~~~~~~~~~

    Defines a SQLAlchemy datastore.

    :copyright: (c) 2011 by wilsaj.
    :license: BSD, see LICENSE for more details.
"""
from __future__ import absolute_import

import datetime
from functools import wraps
import inspect
import os
import time
import types

import flask
from flask import flash, render_template, redirect, request, url_for
from flask.ext.sqlalchemy import Pagination
import sqlalchemy as sa
from sqlalchemy.orm.exc import NoResultFound
from wtforms import validators, widgets
from wtforms.ext.sqlalchemy.orm import model_form, converts, ModelConverter
from wtforms.ext.sqlalchemy import fields as sa_fields

from flask.ext.admin.wtforms import *
from flask.ext.admin.datastore import AdminDatastore


class SQLAlchemyDatastore(AdminDatastore):
    """A datastore class for accessing SQLAlchemy models.

    The `models` parameter should be either a module or an iterable
    (like a tuple or a list) that contains the SQLAlchemy models that
    will be made available through the admin interface.

    `db_session` should be the SQLAlchemy session that the datastore
    will use to access the database. The session should already be
    bound to an engine. See the `SQLAlchemy in Flask`_ documentation
    for more information on how to configure the session.

    By default, a form for adding and editing data will be
    automatically generated for each SQLAlchemy model. You can also
    create custom forms if you need more control over what the forms
    look like or how they behave. To use custom forms, set the
    `model_forms` parameter to be a dict with model names as keys
    matched to custom forms for the forms you want to override. Forms
    should be WTForms form objects; see the `WTForms documentation`_
    for more information on how to configure forms.

    Finally, the `exclude_pks` parameter can be used to specify
    whether or not to automatically exclude fields representing the
    primary key in auto-generated forms. The default is True, so the
    generated forms will not expose the primary keys of your
    models. This is usually a good idea if you are using a primary key
    that doesn't have any meaning outside of the database, like an
    auto-incrementing integer, because changing a primary key changes
    the nature of foreign key relationships. If you want to expose the
    primary key, set this to False.

    .. _SQLAlchemy in Flask: http://flask.pocoo.org/docs/patterns/sqlalchemy/
    .. _WTForms documentation: http://wtforms.simplecodes.com/
    """
    def __init__(self, models, db_session, model_forms=None, exclude_pks=True):
        self.model_classes = {}
        self.model_forms = model_forms
        self.db_session = db_session

        if not self.model_forms:
            self.model_forms = {}

        #XXX: fix base handling so it will work with non-Declarative models
        if type(models) == types.ModuleType:
            self.model_classes = dict(
                [(k, v) for k, v in models.__dict__.items()
                 if isinstance(v, sa.ext.declarative.DeclarativeMeta)
                 and k != 'Base'])
        else:
            self.model_classes = dict(
                [(model.__name__, model)
                 for model in models
                 if isinstance(model, sa.ext.declarative.DeclarativeMeta)
                 and model.__name__ != 'Base'])

        if self.model_classes:
            self.form_dict = dict(
                [(k, _form_for_model(v, db_session,
                                     exclude_pk=exclude_pks))
                 for k, v in self.model_classes.items()])
            for model_name, form in self.model_forms.items():
                if model_name in self.form_dict:
                    self.form_dict[model_name] = form

    def create_model_pagination(self, model_name, page, per_page=25):
        """Returns a pagination object for the list view."""
        model_class = self.model_classes[model_name]
        model_instances = self.db_session.query(model_class)
        offset = (page - 1) * per_page
        items = model_instances.limit(per_page).offset(offset).all()
        return Pagination(model_instances, page, per_page,
                          model_instances.count(), items)

    def delete_model_instance(self, model_name, model_keys):
        """Deletes a model instance. Returns True if model instance
        was successfully deleted, returns False otherwise.
        """
        model_instance = self.find_model_instance(model_name, model_keys)
        if not model_instance:
            return False
        self.db_session.delete(model_instance)
        self.db_session.commit()
        return True

    def find_model_instance(self, model_name, model_keys):
        """Returns a model instance, if one exists, that matches
        model_name and model_keys. Returns None if no such model
        instance exists.
        """
        model_class = self.get_model_class(model_name)
        pk_query_dict = {}

        for key, value in zip(_get_pk_names(model_class), model_keys):
            pk_query_dict[key] = value

        try:
            return self.db_session.query(model_class).filter_by(
                **pk_query_dict).one()
        except NoResultFound:
            return None

    def get_model_class(self, model_name):
        """Returns a model class, given a model name."""
        return self.model_classes[model_name]

    def get_model_form(self, model_name):
        """Returns a form, given a model name."""
        return self.form_dict[model_name]

    def get_model_keys(self, model_instance):
        """Returns the keys for a given a model instance."""
        return [getattr(model_instance, value)
                for value in _get_pk_names(model_instance)]

    def list_model_names(self):
        """Returns a list of model names available in the datastore."""
        return self.model_classes.keys()

    def save_model(self, model_instance):
        """Persists a model instance to the datastore. Note: this
        could be called when a model instance is added or edited.
        """
        self.db_session.add(model_instance)
        self.db_session.commit()

    def update_from_form(self, model_instance, form):
        """Returns a model instance whose values have been updated
        with the values from a given form.
        """
        for name, field in form._fields.iteritems():
            field.populate_obj(model_instance, name)

        return model_instance


def _form_for_model(model_class, db_session, exclude=None, exclude_pk=True):
    """Return a form for a given model. This will be a form generated
    by wtforms.ext.sqlalchemy.model_form, but decorated with a
    QuerySelectField for foreign keys.
    """
    if not exclude:
        exclude = []

    model_mapper = sa.orm.class_mapper(model_class)
    relationship_fields = []

    pk_names = _get_pk_names(model_class)

    if exclude_pk:
        exclude.extend(pk_names)

    # exclude any foreign_keys that we have relationships for;
    # relationships will be mapped to select fields by the
    # AdminConverter
    exclude.extend([relationship.local_side[0].name
                    for relationship in model_mapper.iterate_properties
                    if isinstance(relationship,
                                  sa.orm.properties.RelationshipProperty)
                    and relationship.local_side[0].name not in pk_names])
    form = model_form(model_class, exclude=exclude,
                      converter=AdminConverter(db_session))

    return form


def _get_pk_names(model):
    """Return the primary key attribute names for a given model
    (either instance or class).
    """
    model_mapper = model.__mapper__

    return [prop.key for prop in model_mapper.iterate_properties
            if isinstance(prop, sa.orm.properties.ColumnProperty) and \
                prop.columns[0].primary_key]


def _query_factory_for(model_class, db_session):
    """Return a query factory for a given model_class. This gives us
    an all-purpose way of generating query factories for
    QuerySelectFields.
    """
    def query_factory():
        return sorted(db_session.query(model_class).all(), key=repr)

    return query_factory


class AdminConverter(ModelConverter):
    """Subclass of the wtforms sqlalchemy Model Converter that handles
    relationship properties and uses custom widgets for date and
    datetime objects.
    """
    def __init__(self, db_session, *args, **kwargs):
        self.db_session = db_session
        super(AdminConverter, self).__init__(*args, **kwargs)

    def convert(self, model, mapper, prop, field_args):
        if not isinstance(prop, sa.orm.properties.ColumnProperty) and \
               not isinstance(prop, sa.orm.properties.RelationshipProperty):
            # XXX We don't support anything but ColumnProperty and
            # RelationshipProperty at the moment.
            return

        if isinstance(prop, sa.orm.properties.ColumnProperty):
            if len(prop.columns) != 1:
                raise TypeError('Do not know how to convert multiple-'
                                'column properties currently')

            column = prop.columns[0]

#            default_value = None
#            if hasattr(column, 'default'):      #always is True
#                default_value = column.default

            default_value = getattr(column, 'default', None)

            if default_value is not None and \
                    not callable(default_value.arg):
                # for the default value such as number or string
                default_value = default_value.arg

            kwargs = {
                'validators': [],
                'filters': [],
                'default': default_value,
            }
            if field_args:
                kwargs.update(field_args)
            if hasattr(column, 'nullable') and column.nullable:
                kwargs['validators'].append(validators.Optional())
            if self.use_mro:
                types = inspect.getmro(type(column.type))
            else:
                types = [type(column.type)]

            converter = None
            for col_type in types:
                type_string = '%s.%s' % (col_type.__module__,
                                         col_type.__name__)
                if type_string.startswith('sqlalchemy'):
                    type_string = type_string[11:]
                if type_string in self.converters:
                    converter = self.converters[type_string]
                    break
            else:
                for col_type in types:
                    if col_type.__name__ in self.converters:
                        converter = self.converters[col_type.__name__]
                        break
                else:
                    return
            return converter(model=model, mapper=mapper, prop=prop,
                             column=column, field_args=kwargs)

        if isinstance(prop, sa.orm.properties.RelationshipProperty):
#            if prop.direction == sa.orm.interfaces.MANYTOONE and \
#                   len(prop.local_remote_pairs) != 1:
#                raise TypeError('Do not know how to convert multiple'
#                                '-column properties currently')
#            elif prop.direction == sa.orm.interfaces.MANYTOMANY and \
#                     len(prop.local_remote_pairs) != 2:
#                raise TypeError('Do not know how to convert multiple'
#                                '-column properties currently')

            local_column = prop.local_remote_pairs[0][0]
            foreign_model = prop.mapper.class_

            if prop.direction == sa.orm.properties.MANYTOONE:
                return sa_fields.QuerySelectField(
                    prop.key,
                    query_factory=_query_factory_for(foreign_model,
                                                     self.db_session),
                    allow_blank=local_column.nullable)
            if prop.direction == sa.orm.properties.MANYTOMANY:
                return sa_fields.QuerySelectMultipleField(
                    prop.key,
                    query_factory=_query_factory_for(foreign_model,
                                                     self.db_session),
                    allow_blank=local_column.nullable)

    @converts('Date')
    def conv_Date(self, field_args, **extra):
        field_args['widget'] = DatePickerWidget()
        return wtf_fields.DateField(**field_args)

    @converts('DateTime')
    def conv_DateTime(self, field_args, **extra):
        # XXX: should show disabled (greyed out) w/current value,
        #      indicating it is updated internally?
        if hasattr(field_args['default'], 'arg'):
            if inspect.isfunction(field_args['default'].arg):
                return None
        field_args['widget'] = DateTimePickerWidget()
        return wtf_fields.DateTimeField(**field_args)

    @converts('Time')
    def conv_Time(self, field_args, **extra):
        field_args['widget'] = TimePickerWidget()
        return TimeField(**field_args)

########NEW FILE########
__FILENAME__ = util
import math


# original source:  http://flask.pocoo.org/snippets/44/
class Pagination(object):
    def __init__(self, page, per_page, total, items):
        self.page = page
        self.per_page = per_page
        self.total = total
        self.items = items

    @property
    def pages(self):
        return int(math.ceil(self.total / float(self.per_page)))

    @property
    def has_prev(self):
        return self.page > 1

    @property
    def has_next(self):
        return self.page < self.pages

    def iter_pages(self, left_edge=2, left_current=2,
                   right_current=5, right_edge=2):
        last = 0
        for num in xrange(1, self.pages + 1):
            if num <= left_edge or \
               (num > self.page - left_current - 1 and \
                num < self.page + right_current) or \
               num > self.pages - right_edge:
                if last + 1 != num:
                    yield None
                yield num
                last = num

########NEW FILE########
__FILENAME__ = wtforms
# -*- coding: utf-8 -*-
"""
    flask.ext.wtforms
    ~~~~~~~~~~~~~~


    :copyright: (c) 2011 by wilsaj.
    :license: BSD, see LICENSE for more details.
"""
from __future__ import absolute_import

import datetime
import time

from wtforms import fields as wtf_fields
from wtforms import widgets, validators


class TimeField(wtf_fields.Field):
    """A text field which stores a `time.time` matching a format."""
    widget = widgets.TextInput()

    def __init__(self, label=None, validators=None,
                 format='%H:%M:%S', **kwargs):
        super(TimeField, self).__init__(label, validators, **kwargs)
        self.format = format

    def _value(self):
        if self.raw_data:
            return u' '.join(self.raw_data)
        else:
            return self.data and self.data.strftime(self.format) or u''

    def process_formdata(self, valuelist):
        if valuelist:
            time_str = u' '.join(valuelist)
            try:
                timetuple = time.strptime(time_str, self.format)
                self.data = datetime.time(*timetuple[3:6])
            except ValueError:
                self.data = None
                raise


class DatePickerWidget(widgets.TextInput):
    """
    TextInput widget that adds a 'datepicker' class to the html input
    element; this makes it easy to write a jQuery selector that adds a
    UI widget for date picking.
    """
    def __call__(self, field, **kwargs):
        c = kwargs.pop('class', '') or kwargs.pop('class_', '')
        kwargs['class'] = u'datepicker %s' % c
        return super(DatePickerWidget, self).__call__(field, **kwargs)


class DateTimePickerWidget(widgets.TextInput):
    """TextInput widget that adds a 'datetimepicker' class to the html
    adds a UI widget for datetime picking.
    """
    def __call__(self, field, **kwargs):
        c = kwargs.pop('class', '') or kwargs.pop('class_', '')
        kwargs['class'] = u'datetimepicker %s' % c
        return super(DateTimePickerWidget, self).__call__(field, **kwargs)


class TimePickerWidget(widgets.TextInput):
    """TextInput widget that adds a 'timepicker' class to the html
    input element; this makes it easy to write a jQuery selector that
    adds a UI widget for time picking.
    """
    def __call__(self, field, **kwargs):
        c = kwargs.pop('class', '') or kwargs.pop('class_', '')
        kwargs['class'] = u'timepicker %s' % c
        return super(TimePickerWidget, self).__call__(field, **kwargs)


def has_file_field(form):
    """Test whether or not a form has a FileField in it. This is used
    to know whether or not we need to set enctype to
    multipart/form-data.
    """
    for field in form:
        if isinstance(field, wtf_fields.FileField):
            return True

    return False

########NEW FILE########
__FILENAME__ = custom_form
import sys

from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from sqlalchemy import create_engine
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Boolean, Column, Integer, Text, String, Float, Time
from sqlalchemy.orm import synonym
from werkzeug import check_password_hash, generate_password_hash
from wtforms import Form, validators
from wtforms.fields import BooleanField, TextField, PasswordField


Base = declarative_base()


class User(Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True)
    username = Column(String(80), unique=True)
    _password_hash = Column('password', String(80), nullable=False)
    is_active = Column(Boolean, default=True)

    def __init__(self, username="", password="", is_active=True):
        self.username = username
        self.password = password
        self.is_active = is_active

    # use 2.5-compatible properties
    def check_password(self, password):
        return check_password_hash(self.pw_hash, password)

    def get_password(self):
        return self._password_hash

    def set_password(self, value):
        self._password = value

    password = property(get_password, set_password, None, "password property")

    # @property
    # def password(self):
    #     return self._password_hash

    # @password.setter
    # def password(self, password):
    #     self._password_hash = generate_password_hash(password)

    password = synonym('_password_hash', descriptor=password)

    def __repr__(self):
        return self.username

    __mapper_args__ = {
        'order_by': username
        }


class UserForm(Form):
    """
    Form for creating or editting User object (via the admin). Define
    any handling of fields here. This form class also has precedence
    when rendering forms to a webpage, so the model-generated fields
    will come after it.
    """
    username = TextField(u'User name',
                         [validators.required(), validators.length(max=80)])
    password = PasswordField('Change Password',
                             [validators.optional(),
                              validators.equal_to('confirm_password')])
    confirm_password = PasswordField()
    is_active = BooleanField(default=True)


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'
    engine = create_engine(database_uri, convert_unicode=True)
    db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False,
        bind=engine))
    datastore = SQLAlchemyDatastore(
        (User,), db_session, model_forms={'User': UserForm})
    admin_blueprint = admin.create_admin_blueprint(
        datastore)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    Base.metadata.create_all(bind=engine)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')

    return app


if __name__ == '__main__':
    app = create_app('sqlite:///simple.db')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = deprecation
import sys

from flask import Flask,  redirect
from flask.ext import admin
from sqlalchemy import create_engine, Table
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Time
from sqlalchemy.orm import relationship
from sqlalchemy.schema import ForeignKey
import wtforms as wtf

Base = declarative_base()


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class TestModel(Base):
    __tablename__ = 'test'

    id = Column(Integer, primary_key=True)


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'
    engine = create_engine(database_uri, convert_unicode=True)
    app.db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False,
        bind=engine))
    admin_blueprint = admin.create_admin_blueprint(
        (TestModel,), app.db_session)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    Base.metadata.create_all(bind=engine)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')

    return app


if __name__ == '__main__':
    app = create_app('sqlite://')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = filefield
import sys

from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from sqlalchemy import create_engine, Table
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Time
from sqlalchemy.orm import relationship
from sqlalchemy.schema import ForeignKey
import wtforms as wtf

Base = declarative_base()


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class TestModel(Base):
    __tablename__ = 'test'

    id = Column(Integer, primary_key=True)


class FileForm(wtf.Form):
    """
    A form with a filefield on it.
    """
    filefield = wtf.fields.FileField()


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'
    engine = create_engine(database_uri, convert_unicode=True)
    app.db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False,
        bind=engine))
    datastore = SQLAlchemyDatastore(
        (TestModel,), app.db_session, model_forms={'TestModel': FileForm})
    admin_blueprint = admin.create_admin_blueprint(datastore)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    Base.metadata.create_all(bind=engine)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')

    return app


if __name__ == '__main__':
    app = create_app('sqlite://')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = mongoalchemy_datastore
#!/usr/bin/env python
from __future__ import absolute_import

from unittest import TestCase
from mongoalchemy import fields as ma_fields
from mongoalchemy.document import Document
from flask.ext.admin.datastore.mongoalchemy import model_form
from wtforms import fields as wtf_fields
from wtforms.form import Form


def assert_convert(ma_field, wtf_field):
    """helper function for testing that MongoAlchemy fields get
    converted to proper wtforms fields
    """
    class TestModel(Document):
        required_field = ma_field(required=True)
        not_required_field = ma_field(required=False)

    form = model_form(TestModel)

    assert form.required_field.field_class == wtf_field

    not_required_validator_names = [
        validator.__class__.__name__
        for validator in form.not_required_field.kwargs['validators']]

    assert 'Optional' in not_required_validator_names


def assert_min_max_number_range(ma_field):
    class TestModel(Document):
        min_field = ma_field(min_value=5)
        max_field = ma_field(max_value=19)
        min_max_field = ma_field(min_value=11, max_value=21)

    form = model_form(TestModel)
    min_validator = [
        validator for validator in form.min_field.kwargs['validators']
        if validator.__class__.__name__ == 'NumberRange'][0]
    max_validator = [
        validator for validator in form.max_field.kwargs['validators']
        if validator.__class__.__name__ == 'NumberRange'][0]
    min_max_validator = [
        validator for validator in form.min_max_field.kwargs['validators']
        if validator.__class__.__name__ == 'NumberRange'][0]

    assert min_validator.min == 5
    assert not min_validator.max
    assert max_validator.max == 19
    assert not max_validator.min
    assert min_max_validator.min == 11
    assert min_max_validator.max == 21


def assert_min_max_length(ma_field):
    class TestModel(Document):
        min_field = ma_field(min_length=5)
        max_field = ma_field(max_length=19)
        min_max_field = ma_field(min_length=11, max_length=21)

    form = model_form(TestModel)
    min_validator = [
        validator for validator in form.min_field.kwargs['validators']
        if validator.__class__.__name__ == 'Length'][0]
    max_validator = [
        validator for validator in form.max_field.kwargs['validators']
        if validator.__class__.__name__ == 'Length'][0]
    min_max_validator = [
        validator for validator in form.min_max_field.kwargs['validators']
        if validator.__class__.__name__ == 'Length'][0]

    assert min_validator.min == 5
    assert min_validator.max == -1
    assert max_validator.max == 19
    assert max_validator.min == -1
    assert min_max_validator.min == 11
    assert min_max_validator.max == 21


class ConversionTest(TestCase):
    def test_bool_field_conversion(self):
        assert_convert(ma_fields.BoolField, wtf_fields.BooleanField)

    def test_datetime_field_conversion(self):
        assert_convert(ma_fields.DateTimeField, wtf_fields.DateTimeField)

    def test_enum_field_conversion(self):
        class TestModel(Document):
            int_field = ma_fields.EnumField(ma_fields.IntField(), 4, 6, 7)

        form = model_form(TestModel)
        assert form.int_field.field_class == wtf_fields.IntegerField
        assert form.int_field.kwargs['validators'][0].values == (4, 6, 7)

    def test_float_field_conversion(self):
        assert_convert(ma_fields.FloatField, wtf_fields.FloatField)
        assert_min_max_number_range(ma_fields.IntField)

    def test_int_field_conversion(self):
        assert_convert(ma_fields.IntField, wtf_fields.IntegerField)
        assert_min_max_number_range(ma_fields.IntField)

    def test_objectid_field_conversion(self):
        assert_convert(ma_fields.ObjectIdField, wtf_fields.TextField)

    def test_string_field_conversion(self):
        assert_convert(ma_fields.StringField, wtf_fields.TextField)
        assert_min_max_length(ma_fields.StringField)

    def test_tuple_field_conversion(self):
        class TestModel(Document):
            tuple_field = ma_fields.TupleField(
                ma_fields.IntField(), ma_fields.BoolField(),
                ma_fields.StringField())

        unbound_form = model_form(TestModel)
        form = unbound_form()
        assert form.tuple_field.tuple_field_0.__class__ == wtf_fields.IntegerField
        assert form.tuple_field.tuple_field_1.__class__ == wtf_fields.BooleanField
        assert form.tuple_field.tuple_field_2.__class__ == wtf_fields.TextField


if __name__ == '__main__':
    from unittest import main
    main()

########NEW FILE########
__FILENAME__ = sqlalchemy_with_defaults
import sys

from flask import Flask,  redirect
from flask.ext import admin
from flask.ext.admin.datastore.sqlalchemy import SQLAlchemyDatastore
from sqlalchemy import create_engine, Table
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Numeric
from sqlalchemy.orm import relationship
from sqlalchemy.schema import ForeignKey
import wtforms as wtf

Base = declarative_base()


# ----------------------------------------------------------------------
# Models
# ----------------------------------------------------------------------
class TestModel(Base):
    __tablename__ = 'test'

    id = Column(Integer, primary_key=True)
    int_value = Column(Integer, default="2194112")
    str_value = Column(String, default="128uasdn1uinvuio12ioj!!@Rfja")
    num_value = Column(Numeric, default=22341.29)


def create_app(database_uri='sqlite://'):
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'not secure'
    engine = create_engine(database_uri, convert_unicode=True)
    app.db_session = scoped_session(sessionmaker(
        autocommit=False, autoflush=False, bind=engine))
    datastore = SQLAlchemyDatastore(
        (TestModel,), app.db_session)
    admin_blueprint = admin.create_admin_blueprint(datastore)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    Base.metadata.create_all(bind=engine)

    @app.route('/')
    def go_to_admin():
        return redirect('/admin')

    return app


if __name__ == '__main__':
    app = create_app('sqlite://')
    app.run(debug=True)

########NEW FILE########
__FILENAME__ = test_admin
from __future__ import with_statement

from datetime import datetime
import sys
import unittest

from flask import Flask
import sqlalchemy as sa

from flask.ext import admin
from flask.ext.testing import TestCase

sys.path.append('./example/')

from example.declarative import simple
from example.declarative import multiple
from example.authentication import view_decorator
from example.flask_sqlalchemy import flaskext_sa_simple
from example.flask_sqlalchemy import flaskext_sa_example
from example.flask_sqlalchemy import flaskext_sa_multi_pk
from example.mongoalchemy import simple as ma_simple
import test.custom_form
import test.deprecation
import test.filefield
import test.sqlalchemy_with_defaults
from test.mongoalchemy_datastore import ConversionTest


class SimpleTest(TestCase):
    TESTING = True

    def create_app(self):
        app = simple.create_app('sqlite://')
        teacher = simple.Teacher(name="Mrs. Jones")
        app.db_session.add(teacher)
        app.db_session.add(simple.Student(name="Stewart"))
        app.db_session.add(simple.Student(name="Mike"))
        app.db_session.add(simple.Student(name="Jason"))
        app.db_session.add(simple.Course(subject="maths", teacher=teacher))
        app.db_session.commit()
        return app

    def test_basic(self):
        rv = self.client.get('/')
        self.assert_redirects(rv, '/admin')

    def test_index(self):
        rv = self.client.get('/admin/')
        self.assert_200(rv)

    def test_list(self):
        rv = self.client.get('/admin/list/Student/?page=1')
        self.assert_200(rv)

    def test_edit(self):
        rv = self.client.post('/admin/edit/Course/1/',
                              data=dict(students=[1]))
        course = self.app.db_session.query(simple.Course).filter_by(id=1).one()
        self.assertEqual(len(course.students), 1)
        student = self.app.db_session.\
                  query(simple.Student).filter_by(id=1).one()
        self.assertEqual(len(student.courses), 1)
        self.assert_redirects(rv, '/admin/list/Course/')

    def test_add(self):
        self.assertEqual(self.app.db_session.query(simple.Teacher).count(), 1)
        rv = self.client.post('/admin/add/Teacher/',
                              data=dict(name='Mr. Kohleffel'))
        self.assertEqual(self.app.db_session.query(simple.Teacher).count(), 2)
        self.assert_redirects(rv, '/admin/list/Teacher/')

    def test_delete(self):
        self.assertEqual(self.app.db_session.query(simple.Student).count(), 3)
        rv = self.client.get('/admin/delete/Student/2/')
        self.assertEqual(self.app.db_session.query(simple.Student).count(), 2)
        self.assert_redirects(rv, '/admin/list/Student/')

        rv = self.client.get('/admin/delete/Student/2/')
        self.assert_200(rv)
        assert "Student not found" in rv.data


class MultipleTest(TestCase):
    TESTING = True

    def create_app(self):
        app = multiple.create_app('sqlite://')
        return app

    def test_admin1(self):
        rv = self.client.get('/admin1/')
        assert "Student" in rv.data
        assert "Course" not in rv.data

    def test_admin2(self):
        rv = self.client.get('/admin2/')
        assert "Student" not in rv.data
        assert "Course" in rv.data


class ViewDecoratorTest(TestCase):
    TESTING = True

    def create_app(self):
        self.app = view_decorator.create_app('sqlite://')
        return self.app

    def test_add_redirect(self):
        rv = self.client.get('/admin/add/Student/')
        self.assert_redirects(rv, "/admin/login/?next=http%3A%2F%2Flocalhost%2Fadmin%2Fadd%2FStudent%2F")

    def test_delete_redirect(self):
        rv = self.client.get('/admin/delete/Student/1/')
        self.assert_redirects(rv, "/admin/login/?next=http%3A%2F%2Flocalhost%2Fadmin%2Fdelete%2FStudent%2F1%2F")

    def test_edit_redirect(self):
        rv = self.client.get('/admin/edit/Student/1/')
        self.assert_redirects(rv, "/admin/login/?next=http%3A%2F%2Flocalhost%2Fadmin%2Fedit%2FStudent%2F1%2F")

    def test_index_redirect(self):
        rv = self.client.get('/admin/')
        self.assert_redirects(rv, "/admin/login/?next=http%3A%2F%2Flocalhost%2Fadmin%2F")

    def test_list_redirect(self):
        rv = self.client.get('/admin/list/Student/')
        self.assert_redirects(rv, "/admin/login/?next=http%3A%2F%2Flocalhost%2Fadmin%2Flist%2FStudent%2F")

    def test_login_logout(self):
        rv = self.client.post('/admin/login/',
                             data=dict(username='test',
                                       password='test'))
        self.assert_redirects(rv, '/admin/')

        rv = self.client.get('/admin/')
        self.assert200(rv)

        rv = self.client.get('/admin/logout/')
        self.assert_redirects(rv, '/')

        rv = self.client.get('/admin/')
        self.assert_redirects(rv, "/admin/login/?next=http%3A%2F%2Flocalhost%2Fadmin%2F")


class CustomFormTest(TestCase):
    TESTING = True

    def create_app(self):
        app = test.custom_form.create_app('sqlite://')
        return app

    def test_custom_form(self):
        rv = self.client.get('/admin/add/User/')
        assert "User name" in rv.data
        assert "Change Password"  in rv.data
        assert "Confirm Password"  in rv.data
        assert "Is Active"  in rv.data
        assert "_password_hash" not in rv.data


class SQLAlchemyWithDefaultsTest(TestCase):
    TESTING = True

    def create_app(self):
        app = test.sqlalchemy_with_defaults.create_app('sqlite://')
        return app

    def test_defaults_work(self):
        rv = self.client.get('/admin/add/TestModel/')
        assert "2194112" in rv.data
        assert "128uasdn1uinvuio12ioj!!@Rfja" in rv.data
        assert "22341.29"  in rv.data


class FlaskSQLAlchemySimpleTest(SimpleTest):
    TESTING = True

    def create_app(self):
        app = flaskext_sa_simple.create_app('sqlite://')

        # set app.db_session to the db.session so the SimpleTest tests
        # will work
        app.db_session = flaskext_sa_simple.db.session

        # need to grab a request context since we use db.init_app() in
        # our application
        with app.test_request_context():
            teacher = flaskext_sa_simple.Teacher(name="Mrs. Jones")
            flaskext_sa_simple.db.session.add(teacher)
            flaskext_sa_simple.db.session.add(flaskext_sa_simple.Student(name="Stewart"))
            flaskext_sa_simple.db.session.add(flaskext_sa_simple.Student(name="Mike"))
            flaskext_sa_simple.db.session.add(flaskext_sa_simple.Student(name="Jason"))
            flaskext_sa_simple.db.session.add(flaskext_sa_simple.Course(subject="maths", teacher=teacher))
            flaskext_sa_simple.db.session.commit()
        return app


class FlaskSQLAlchemyExampleTest(TestCase):
    TESTING = True

    def create_app(self):
        app = flaskext_sa_example.create_app('sqlite://')
        return app

    def test_index(self):
        # just make sure the app is initialized and works
        rv = self.client.get('/admin/')
        self.assert_200(rv)


class FlaskSQLAlchemyMultiPKsTest(TestCase):
    TESTING = True

    def create_app(self):
        app = flaskext_sa_multi_pk.create_app('sqlite://')

        # set app.db_session to the db.session so the SimpleTest tests
        # will work
        app.db_session = flaskext_sa_multi_pk.db.session

        # need to grab a request context since we use db.init_app() in
        # our application
        with app.test_request_context():
            address = flaskext_sa_multi_pk.Address(
                shortname=u'K2',
                name=u'K-II',
                street=u'Hauptstrasse 1',
                zipcode='10000',
                city=u'Berlin',
                country=u'Germany')
            flaskext_sa_multi_pk.db.session.add(address)
            flaskext_sa_multi_pk.db.session.flush()
            location = flaskext_sa_multi_pk.Location(
                address_shortname=address.shortname,
                room=u'2.01',
                position=u'left side')
            flaskext_sa_multi_pk.db.session.add(location)
            flaskext_sa_multi_pk.db.session.flush()
            flaskext_sa_multi_pk.db.session.add(
                flaskext_sa_multi_pk.Asset(name=u'asset1',
                                           address_shortname=address.shortname,
                                           location_room=location.room,
                                           location_position=location.position))
            flaskext_sa_multi_pk.db.session.commit()
        return app

    def test_index(self):
        # just make sure the app is initialized and works
        rv = self.client.get('/admin/')
        self.assert_200(rv)

    def test_list_asset(self):
        rv = self.client.get('/admin/list/Asset/?page=1')
        self.assert_200(rv)

    def test_list_location(self):
        rv = self.client.get('/admin/list/Location/')
        self.assert_200(rv)

    def test_view_location(self):
        rv = self.client.get('/admin/edit/Location/K2/2.01/left%20side/')
        self.assert_200(rv)

    def test_add_location(self):
        self.assertEqual(self.app.db_session.query(
                flaskext_sa_multi_pk.Location).count(), 1)
        rv = self.client.post('/admin/add/Location/',
                              data=dict(address=u'K2',
                                        address_shortname=u'K2',
                                        room=u'2.03',
                                        position=u''))
        self.assertEqual(self.app.db_session.query(
                flaskext_sa_multi_pk.Location).count(), 2)
        rv = self.client.get('/admin/edit/Location/K2/2.03/%1A/')
        assert 'edit-form' in rv.data

    def test_edit_location(self):
        rv = self.client.post('/admin/edit/Location/K2/2.01/left%20side/',
                              data=dict(address=u'K2',
                                        address_shortname=u'K2',
                                        room=u'2.01',
                                        position='right side'))
        rv = self.client.get('/admin/edit/Location/K2/2.01/right%20side/')
        self.assert_200(rv)


class ExcludePKsTrueTest(TestCase):
    TESTING = True

    def create_app(self):
        app = Flask(__name__)
        app.config['SECRET_KEY'] = 'not secure'
        engine = sa.create_engine('sqlite://', convert_unicode=True)
        app.db_session = sa.orm.scoped_session(sa.orm.sessionmaker(
            autocommit=False, autoflush=False,
            bind=engine))
        admin_blueprint = admin.create_admin_blueprint(
            (simple.Course, simple.Student, simple.Teacher),
            app.db_session, exclude_pks=True)
        app.register_blueprint(admin_blueprint, url_prefix='/admin')
        simple.Base.metadata.create_all(bind=engine)
        return app

    def test_exclude_pks(self):
        rv = self.client.get('/admin/add/Student/')
        assert "Id" not in rv.data


class ExcludePKsFalseTest(TestCase):
    TESTING = True

    def create_app(self):
        app = Flask(__name__)
        app.config['SECRET_KEY'] = 'not secure'
        engine = sa.create_engine('sqlite://', convert_unicode=True)
        app.db_session = sa.orm.scoped_session(sa.orm.sessionmaker(
            autocommit=False, autoflush=False,
            bind=engine))
        admin_blueprint = admin.create_admin_blueprint(
            (simple.Course, simple.Student, simple.Teacher),
            app.db_session, exclude_pks=False)
        app.register_blueprint(admin_blueprint, url_prefix='/admin')
        simple.Base.metadata.create_all(bind=engine)
        return app

    def test_exclude_pks(self):
        rv = self.client.get('/admin/add/Student/')
        assert "Id" in rv.data


class SmallPaginationTest(TestCase):
    TESTING = True

    def create_app(self):
        app = simple.create_app('sqlite://', pagination=25)
        for i in range(500):
            app.db_session.add(simple.Student(name="Student%s" % i))
        app.db_session.commit()
        return app

    def test_low_list_view_pagination(self):
        rv = self.client.get('/admin/list/Student/?page=1')
        assert '<a href="/admin/list/Student/?page=2">></a>' in rv.data


class LargePaginationTest(TestCase):
    TESTING = True

    def create_app(self):
        app = simple.create_app('sqlite://', pagination=1000)
        for i in range(50):
            app.db_session.add(simple.Student(name="Student%s" % i))
        app.db_session.commit()
        return app

    def test_high_list_view_pagination(self):
        rv = self.client.get('/admin/list/Student/')
        assert '<a href="/admin/list/Student/?page=2">></a>' not in rv.data


class FileFieldTest(TestCase):
    TESTING = True

    def create_app(self):
        app = test.filefield.create_app('sqlite://')
        test_model = test.filefield.TestModel()
        app.db_session.add(test_model)
        app.db_session.commit()
        return app

    def test_file_field_enctype_rendered_on_add(self):
        rv = self.client.get('/admin/add/TestModel/')
        assert 'enctype="multipart/form-data"' in rv.data

    def test_file_field_enctype_rendered_on_edit(self):
        rv = self.client.get('/admin/edit/TestModel/1/')
        assert 'enctype="multipart/form-data"' in rv.data


class DeprecationTest(TestCase):
    """test that the old deprecated method of calling
    create_admin_blueprint still works
    """
    TESTING = True

    def create_app(self):
        app = test.deprecation.create_app('sqlite://')
        return app

    def test_index(self):
        rv = self.client.get('/admin/')
        self.assert_200(rv)


class MASimpleTest(TestCase):
    TESTING = True

    def create_app(self):
        app = ma_simple.create_app('masimple-test')
        # clear db of test objects first
        app.db_session.remove_query(ma_simple.Course).execute()
        app.db_session.remove_query(ma_simple.Teacher).execute()
        app.db_session.remove_query(ma_simple.Student).execute()
        app.db_session.insert(ma_simple.Course(
                subject="Maths",
                start_date=datetime(2011, 8, 12),
                end_date=datetime(2011,12,16)))
        app.db_session.insert(ma_simple.Student(name="Stewart"))
        app.db_session.insert(ma_simple.Student(name="Mike"))
        app.db_session.insert(ma_simple.Student(name="Jason"))
        return app

    def test_basic(self):
        rv = self.client.get('/')
        self.assert_redirects(rv, '/admin')

    def test_index(self):
        rv = self.client.get('/admin/')
        self.assert_200(rv)

    def test_list(self):
        rv = self.client.get('/admin/list/Student/?page=1')
        self.assert_200(rv)

    def test_edit(self):
        course = self.app.db_session.query(ma_simple.Course).\
            filter(ma_simple.Course.subject == 'Maths').one()
        course_dict = dict([(key, str(getattr(course, key)))
                             for key in course.get_fields()])
        course_dict['end_date'] = "2012-05-31 00:00:00"
        rv = self.client.post('/admin/edit/Course/%s/' % course.mongo_id,
                              data=course_dict)
        new_course = self.app.db_session.query(ma_simple.Course).\
            filter(ma_simple.Course.subject == 'Maths').one()

        self.assertEqual(new_course.end_date, datetime(2012, 5, 31))
        self.assert_redirects(rv, '/admin/list/Course/')

    def test_add(self):
        self.assertEqual(self.app.db_session.query(ma_simple.Teacher).count(), 0)
        rv = self.client.post('/admin/add/Teacher/',
                              data=dict(name='Mr. Kohleffel'))
        self.assertEqual(self.app.db_session.query(ma_simple.Teacher).count(), 1)
        self.assert_redirects(rv, '/admin/list/Teacher/')

    def test_delete(self):
        student_query = self.app.db_session.query(ma_simple.Student)
        self.assertEqual(student_query.count(), 3)
        student = student_query.first()
        rv = self.client.get('/admin/delete/Student/%s/' % student.mongo_id)
        self.assertEqual(student_query.count(), 2)
        self.assert_redirects(rv, '/admin/list/Student/')

        rv = self.client.get('/admin/delete/Student/%s/' % student.mongo_id)
        self.assert_200(rv)
        assert "Student not found" in rv.data


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(SimpleTest))
    suite.addTest(unittest.makeSuite(MultipleTest))
    suite.addTest(unittest.makeSuite(ViewDecoratorTest))
    suite.addTest(unittest.makeSuite(CustomFormTest))
    suite.addTest(unittest.makeSuite(FlaskSQLAlchemySimpleTest))
    suite.addTest(unittest.makeSuite(FlaskSQLAlchemyExampleTest))
    suite.addTest(unittest.makeSuite(FlaskSQLAlchemyMultiPKsTest))
    suite.addTest(unittest.makeSuite(SQLAlchemyWithDefaultsTest))
    suite.addTest(unittest.makeSuite(ExcludePKsTrueTest))
    suite.addTest(unittest.makeSuite(ExcludePKsFalseTest))
    suite.addTest(unittest.makeSuite(SmallPaginationTest))
    suite.addTest(unittest.makeSuite(LargePaginationTest))
    suite.addTest(unittest.makeSuite(FileFieldTest))
    suite.addTest(unittest.makeSuite(DeprecationTest))
    suite.addTest(unittest.makeSuite(ConversionTest))
    suite.addTest(unittest.makeSuite(MASimpleTest))
    return suite

if __name__ == '__main__':
    test_suite = suite()
    unittest.TextTestRunner(verbosity=2).run(test_suite)

########NEW FILE########
