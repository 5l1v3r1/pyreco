__FILENAME__ = conf
# -*- coding: utf-8 -*-

import mixpanel

# -- Extra opts ------------

#Show the __init__ methods in docs
autoclass_content = "both"

# -- General configuration ----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'mixpanel-celery'
copyright = u'2013, Wes Winham'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = mixpanel.__version__
# The full version, including alpha/beta/rc tags.
release = mixpanel.__release__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['.build']

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'mixpanel-celerydoc'


# -- Options for LaTeX output -------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
latex_documents = [
  ('index', 'mixpanel-celery.tex', u'Mixpanel-Celery Documentation',
   u'Wes Winham', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = settings
"""Default configuration values and documentation"""

from django.conf import settings
import os

if os.getenv('DJANGO_SETTINGS_MODULE', None) is None:
    settings.configure()

"""
.. data:: MIXPANEL_API_TOKEN

    API token for your Mixpanel account. This configures the Mixpanel account
    where all of the action will be.

    You can find this on the ``API Information`` tab on your
    `mixpanel account page`_

    .. _`mixpanel account page`: http://mixpanel.com/user/account/
"""
MIXPANEL_API_TOKEN = getattr(settings, 'MIXPANEL_API_TOKEN', None)

"""
.. data:: MIXPANEL_RETRY_DELAY

    Number of seconds to wait before retrying an event-tracking request that
    failed because of an invalid server response. These failed responses are
    usually 502's or 504's because Mixpanel is under increased load.

    Defaults to 5 minutes.
"""
MIXPANEL_RETRY_DELAY = getattr(settings, 'MIXPANEL_RETRY_DELAY', 60*5)

"""
.. data:: MIXPANEL_DISABLE

    Set to ``True`` to disable mixpanel-celery; no events will be sent to
    Mixpanel.
"""
MIXPANEL_DISABLE = getattr(settings, 'MIXPANEL_DISABLE', False)

"""
.. data:: MIXPANEL_MAX_RETRIES

    Number of retry attempts to make before raising an exception.

    Defaults to 5 attempts.
"""
MIXPANEL_MAX_RETRIES = getattr(settings, 'MIXPANEL_MAX_RETRIES', 5)

"""
.. data:: MIXPANEL_API_TIMEOUT

    Number of seconds to wait before timing out a request the mixpanel api
    server. The default 30-second timeout can cause your job queue to become
    swamped.

    Defaults to 5 seconds.
"""
MIXPANEL_API_TIMEOUT = getattr(settings, 'MIXPANEL_API_TIMEOUT', 5)

"""
.. data:: MIXPANEL_API_SERVER

    URL for the mixpanel api server. This probably shouldn't change.
"""
MIXPANEL_API_SERVER = getattr(settings, 'MIXPANEL_API_SERVER',
                               'api.mixpanel.com')

"""
.. data:: MIXPANEL_TRACKING_ENDPOINT

    URL endpoint for registering events. defaults to ``/track/``

    Mind the slashes.
"""
MIXPANEL_TRACKING_ENDPOINT = getattr(settings, 'MIXPANEL_TRACKING_ENDPOINT',
                               '/track/')

"""
.. data:: MIXPANEL_PEOPLE_ENDPOINT

    URL endpoint for registering events to the People API.
    defaults to ``/engage/``

    Mind the slashes.
"""
MIXPANEL_PEOPLE_ENDPOINT = getattr(settings, 'MIXPANEL_PEOPLE_ENDPOINT',
                               '/engage/')

"""
.. data:: MIXPANEL_DATA_VARIABLE

    Name of the http GET variable used for transferring property information
    when registering events.
"""
MIXPANEL_DATA_VARIABLE = getattr(settings, 'MIXPANEL_DATA_VARIABLE',
                               'data')


"""
.. data:: MIXPANEL_FUNNEL_EVENT_ID

    The event identifier that indicates that a funnel is being tracked and not
    just a normal event.
"""
MIXPANEL_FUNNEL_EVENT_ID = getattr(settings, 'MIXPANEL_FUNNEL_EVENT_ID',
                               'mp_funnel')

"""
.. data:: MIXPANEL_TEST_ONLY

    If this value is True, then events will be sent to Mixpanel with the property
    test = 1 so that no events will actually be logged.
"""
MIXPANEL_TEST_ONLY = getattr(settings, 'MIXPANEL_TEST_ONLY', False)

########NEW FILE########
__FILENAME__ = context_processors
from django.conf import settings


def api_key(request):
    return {'MIXPANEL_API_TOKEN': settings.MIXPANEL_API_TOKEN}

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tasks
import base64
import datetime
import httplib
import json
import logging
import socket
import urllib

from celery.task import Task
from celery.registry import tasks

from mixpanel.conf import settings as mp_settings


class EventTracker(Task):
    """
    Task to track a Mixpanel event.
    """
    name = "mixpanel.tasks.EventTracker"
    max_retries = mp_settings.MIXPANEL_MAX_RETRIES
    endpoint = mp_settings.MIXPANEL_TRACKING_ENDPOINT

    class FailedEventRequest(Exception):
        """
        The attempted recording event failed because of a non-200 HTTP return
        code.
        """

    def run(
        self, event_name, properties=None, token=None, test=None, **kwargs
    ):
        """
        Track an event occurrence to mixpanel through the API.

        ``event_name`` is the string for the event/category you'd like to log
        this event under
        ``properties`` is (optionally) a dictionary of key/value pairs
        describing the event.
        ``token`` is (optionally) your Mixpanel api token. Not required if
        you've already configured your MIXPANEL_API_TOKEN setting.
        ``test`` is an optional override to your
        `:data:mixpanel.conf.settings.MIXPANEL_TEST_ONLY` setting for
        determining if the event requests should actually be stored on the
        Mixpanel servers.
        """
        l = self.get_logger(**kwargs)
        if mp_settings.MIXPANEL_DISABLE:
            l.info("Mixpanel disabled; not recording event: <%s>" % event_name)
            return False

        l.info("Recording event: <%s>" % event_name)

        # Celery 3.x changed the way the logger could be accessed
        if hasattr(l, 'getEffectiveLevel'):
            # celery 3.x
            effective_level = l.getEffectiveLevel()
        else:
            # Fall back to celery 2.x support
            effective_level = l.logger.getEffectiveLevel()

        if effective_level == logging.DEBUG:
            httplib.HTTPConnection.debuglevel = 1

        is_test = self._is_test(test)
        generated_properties = self._handle_properties(properties, token)

        url_params = self._build_params(
            event_name,
            generated_properties,
            is_test,
        )
        l.debug("url_params: <%s>" % url_params)
        conn = self._get_connection()

        try:
            result = self._send_request(conn, url_params)
        except EventTracker.FailedEventRequest as e:
            conn.close()
            l.info("Event failed. Retrying: <%s>" % event_name)
            EventTracker.retry(
                exc=e,
                countdown=mp_settings.MIXPANEL_RETRY_DELAY,
            )
            return
        conn.close()
        if result:
            l.info("Event recorded/logged: <%s>" % event_name)
        else:
            l.info("Event ignored: <%s>" % event_name)

        return result

    def _is_test(self, test):
        """
        Determine whether this event should be logged as a test request,
        meaning it won't actually be stored on the Mixpanel servers. A return
        result of 1 means this will be a test, 0 means it won't as per the API
        spec.

        Uses ``:mod:mixpanel.conf.settings.MIXPANEL_TEST_ONLY`` as the default
        if no explicit test option is given.
        """
        if test == None:
            test = mp_settings.MIXPANEL_TEST_ONLY

        if test:
            return 1
        return 0

    def _handle_properties(self, properties, token):
        """
        Build a properties dictionary, accounting for the token.
        """
        if properties == None:
            properties = {}

        if not properties.get('token', None):
            if token is None:
                token = mp_settings.MIXPANEL_API_TOKEN
            properties['token'] = token

        l = self.get_logger()
        l.debug('pre-encoded properties: <%s>' % repr(properties))

        return properties

    def _get_connection(self):
        server = mp_settings.MIXPANEL_API_SERVER

        # Wish we could use python 2.6's httplib timeout support
        socket.setdefaulttimeout(mp_settings.MIXPANEL_API_TIMEOUT)
        return httplib.HTTPConnection(server)

    def _build_params(self, event, properties, is_test):
        """
        Build HTTP params to record the given event and properties.
        """
        params = {'event': event, 'properties': properties}
        return self._encode_params(params, is_test)

    def _encode_params(self, params, is_test):
        """
        Encodes data and returns the urlencoded parameters
        """
        data = base64.b64encode(json.dumps(params))

        data_var = mp_settings.MIXPANEL_DATA_VARIABLE
        return urllib.urlencode({data_var: data, 'test': is_test})

    def _send_request(self, connection, params):
        """
        Send a an event with its properties to the api server.

        Returns ``true`` if the event was logged by Mixpanel.
        """

        try:
            connection.request('GET', '%s?%s' % (self.endpoint, params))

            response = connection.getresponse()
        except socket.error, message:
            raise EventTracker.FailedEventRequest(
                "The tracking request failed with a socket error. "
                "Message: [%s]" % message
            )

        if response.status != 200 or response.reason != 'OK':
            raise EventTracker.FailedEventRequest(
                "The tracking request failed. "
                "Non-200 response code was: "
                "[%s] reason: [%s]" % (response.status, response.reason)
            )

        # Successful requests will generate a log
        response_data = response.read()
        if response_data != '1':
            return False

        return True

tasks.register(EventTracker)


class PeopleTracker(EventTracker):
    endpoint = mp_settings.MIXPANEL_PEOPLE_ENDPOINT
    event_map = {
        'set': '$set',
        'add': '$add',
        'track_charge': '$append',
    }

    def run(
        self, event_name, properties=None, token=None, test=None, **kwargs
    ):
        """
        Track an People event occurrence to mixpanel through the API.

        ``event_name`` is one of the following strings: set, add, track_charge
        ``properties`` a dictionary of key/value pairs to pass to Mixpanel.
        Must include a ``distinct_id`` key to identify the person.
        The ``track_charge`` event requires an ``amount`` key.
        ``token`` is (optionally) your Mixpanel api token. Not required if
        you've already configured your MIXPANEL_API_TOKEN setting.
        ``test`` is an optional override to your
        `:data:mixpanel.conf.settings.MIXPANEL_TEST_ONLY` setting for
        determining if the event requests should actually be stored on the
        Mixpanel servers.
        """
        return super(PeopleTracker, self).run(
            event_name,
            properties=properties,
            token=token,
            test=test,
            **kwargs
        )

    def _build_params(self, event, properties, is_test):
        """
        Build HTTP params to record the given event and properties.
        """
        mp_key = self.event_map[event]
        params = {
            '$token': properties['token'],
            '$distinct_id': properties['distinct_id'],
        }
        if event == 'track_charge':
            time = properties.get('time', datetime.datetime.now().isoformat())
            transactions = dict(
                (k, v) for (k, v) in properties.iteritems()
                if not k in ('token', 'distinct_id', 'amount')
            )

            transactions['$time'] = time
            transactions['$amount'] = properties['amount']
            params[mp_key] = {'$transactions': transactions}

        else:
            # strip token and distinct_id out of the properties and use the
            # rest for passing with $set and $increment
            params[mp_key] = dict(
                (k, v) for (k, v) in properties.iteritems()
                if not k in ('token', 'distinct_id')
            )

        return self._encode_params(params, is_test)

tasks.register(PeopleTracker)


class FunnelEventTracker(EventTracker):
    """
    Task to track a Mixpanel funnel event.
    """
    name = "mixpanel.tasks.FunnelEventTracker"
    max_retries = mp_settings.MIXPANEL_MAX_RETRIES

    class InvalidFunnelProperties(Exception):
        """Required properties were missing from the funnel-tracking call"""
        pass

    def run(
        self, funnel, step, goal, properties, token=None, test=None, **kwargs
    ):
        """
        Track an event occurrence to mixpanel through the API.

        ``funnel`` is the string for the funnel you'd like to log
        this event under
        ``step`` the step in the funnel you're registering
        ``goal`` the end goal of this funnel
        ``properties`` is a dictionary of key/value pairs
        describing the funnel event. A ``distinct_id`` is required.
        ``token`` is (optionally) your Mixpanel api token. Not required if
        you've already configured your MIXPANEL_API_TOKEN setting.
        ``test`` is an optional override to your
        `:data:mixpanel.conf.settings.MIXPANEL_TEST_ONLY` setting for
        determining if the event requests should actually be stored on the
        Mixpanel servers.
        """
        l = self.get_logger(**kwargs)
        l.info("Recording funnel: <%s>-<%s>" % (funnel, step))
        properties = self._handle_properties(properties, token)

        is_test = self._is_test(test)
        properties = self._add_funnel_properties(
            properties,
            funnel,
            step,
            goal,
        )

        url_params = self._build_params(
            mp_settings.MIXPANEL_FUNNEL_EVENT_ID,
            properties,
            is_test,
        )
        l.debug("url_params: <%s>" % url_params)
        conn = self._get_connection()

        try:
            result = self._send_request(conn, url_params)
        except EventTracker.FailedEventRequest as e:
            conn.close()
            l.info("Funnel failed. Retrying: <%s>-<%s>" % (funnel, step))
            FunnelEventTracker.retry(
                exc=e,
                countdown=mp_settings.MIXPANEL_RETRY_DELAY,
            )
            return
        conn.close()
        if result:
            l.info("Funnel recorded/logged: <%s>-<%s>" % (funnel, step))
        else:
            l.info("Funnel ignored: <%s>-<%s>" % (funnel, step))

        return result

    def _add_funnel_properties(self, properties, funnel, step, goal):
        if 'distinct_id' not in properties:
            raise FunnelEventTracker.InvalidFunnelProperties(
                "A 'distinct_id' must be given to record a funnel event"
            )
        properties['funnel'] = funnel
        properties['step'] = step
        properties['goal'] = goal

        return properties

tasks.register(FunnelEventTracker)

########NEW FILE########
__FILENAME__ = test_mixpanel
import unittest
import mixpanel


class TestInitFile(unittest.TestCase):

    def test_version(self):
        self.assertTrue(mixpanel.VERSION)
        self.assertEquals(len(mixpanel.VERSION), 4)

    def test_meta(self):
        for m in ("__author__", "__contact__", "__homepage__",
                "__docformat__", "__version__", "__release__", "__doc__"):
            self.assertTrue(getattr(mixpanel, m, None))
########NEW FILE########
__FILENAME__ = test_tasks
import base64
import logging
import unittest
import urllib
import urlparse
from datetime import datetime

import mock
try:
    from celery.tests.utils import eager_tasks
except ImportError:
    # Celery 3.1 removed the eager_tasks decorator
    from mixpanel.tests.utils import eager_tasks

from django.utils import simplejson

from mixpanel.tasks import EventTracker, PeopleTracker, FunnelEventTracker
from mixpanel.conf import settings as mp_settings


class FakeDateTime(datetime):
    "A fake replacement for datetime that can be mocked for testing."
    def __new__(cls, *args, **kwargs):
        return datetime.__new__(datetime, *args, **kwargs)


class EventTrackerTest(unittest.TestCase):
    def setUp(self):
        mp_settings.MIXPANEL_API_TOKEN = 'testtesttest'
        mp_settings.MIXPANEL_API_SERVER = 'api.mixpanel.com'
        mp_settings.MIXPANEL_TRACKING_ENDPOINT = '/track/'
        mp_settings.MIXPANEL_TEST_ONLY = True
        mp_settings.MIXPANEL_DISABLE = False

    def test_disable(self):
        et = EventTracker()
        mp_settings.MIXPANEL_DISABLE = True

        def _fake_get_connection():
            assert False, "Should bail out before trying to get a connection."
        et._get_connection = _fake_get_connection

        et('foo')

    def test_handle_properties_w_token(self):
        et = EventTracker()

        properties = et._handle_properties({}, 'foo')
        self.assertEqual('foo', properties['token'])

    def test_handle_properties_no_token(self):
        et = EventTracker()
        mp_settings.MIXPANEL_API_TOKEN = 'bar'

        properties = et._handle_properties({}, None)
        self.assertEqual('bar', properties['token'])

    def test_handle_properties_empty(self):
        et = EventTracker()
        mp_settings.MIXPANEL_API_TOKEN = 'bar'

        properties = et._handle_properties(None, None)
        self.assertEqual('bar', properties['token'])

    def test_handle_properties_given(self):
        et = EventTracker()

        properties = et._handle_properties({'token': 'bar'}, None)
        self.assertEqual('bar', properties['token'])

        properties = et._handle_properties({'token': 'bar'}, 'foo')
        self.assertEqual('bar', properties['token'])

    def test_is_test(self):
        et = EventTracker()

        self.assertEqual(et._is_test(None), 1)
        self.assertEqual(et._is_test(False), 0)
        self.assertEqual(et._is_test(True), 1)

        mp_settings.MIXPANEL_TEST_ONLY = False
        self.assertEqual(et._is_test(None), 0)
        self.assertEqual(et._is_test(False), 0)
        self.assertEqual(et._is_test(True), 1)

    def test_build_params(self):
        et = EventTracker()

        event = 'foo_event'
        is_test = 1
        properties = {'token': 'testtoken'}
        params = {'event': event, 'properties': properties}

        url_params = et._build_params(event, properties, is_test)

        expected_params = urllib.urlencode({
            'data': base64.b64encode(simplejson.dumps(params)),
            'test': is_test,
        })

        self.assertEqual(expected_params, url_params)

    @mock.patch('mixpanel.tasks.datetime.datetime', FakeDateTime)
    def test_build_people_track_charge_params(self):
        self.maxDiff = None
        et = PeopleTracker()
        now = datetime.now()
        FakeDateTime.now = classmethod(lambda cls: now)
        event = u'track_charge'
        is_test = 1
        properties = {u'amount': 11.77, u'distinct_id': u'test_id',
                      u'token': u'testtoken', u'extra': u'extra'}
        expected = {
            u'$append': {
                u'$transactions': {
                    u'$amount': 11.77,
                    u'$time': unicode(now.isoformat()),
                    u'extra': 'extra'
                }
            },
            u'$distinct_id': u'test_id',
            u'$token': u'testtoken',
        }
        url_params = et._build_params(event, properties, is_test)
        parsed = dict(urlparse.parse_qsl(url_params, True))
        parsed[u'data'] = simplejson.loads(base64.b64decode(parsed['data']))

        expected_params = {
            u'data': expected,
            u'test': unicode(is_test),
        }

        self.assertEqual(expected_params, parsed)

    def test_build_people_set_params(self):
        et = PeopleTracker()
        event = 'set'
        is_test = 1
        properties = {'stuff': 'thing', 'blue': 'green',
                      'distinct_id': 'test_id', 'token': 'testtoken'}
        expected = {
            '$distinct_id': 'test_id',
            '$set': {
                'stuff': 'thing',
                'blue': 'green',
            },
            '$token': 'testtoken',
        }
        url_params = et._build_params(event, properties, is_test)
        expected_params = urllib.urlencode({
            'data': base64.b64encode(simplejson.dumps(expected)),
            'test': is_test,
        })

        self.assertEqual(expected_params, url_params)

    def test_run(self):
        # "correct" result obtained from: http://mixpanel.com/api/docs/console
        et = EventTracker()
        result = et.run('event_foo', {})

        self.assertTrue(result)

    def test_old_run(self):
        """non-recorded events should return False"""
        et = EventTracker()
        # Times older than 3 hours don't get recorded according to:
        # http://mixpanel.com/api/docs/specification
        # requests will be rejected that are 3 hours older than present time
        result = et.run('event_foo', {'time': 1245613885})

        self.assertFalse(result)

    def test_debug_logger(self):
        et = EventTracker()
        result = et.run('event_foo', {}, loglevel=logging.DEBUG)

        self.assertTrue(result)


class BrokenRequestsTest(unittest.TestCase):

    def setUp(self):
        mp_settings.MIXPANEL_API_TOKEN = 'testtesttest'
        mp_settings.MIXPANEL_TEST_ONLY = True
        mp_settings.MIXPANEL_API_SERVER = 'api.mixpanel.com'
        mp_settings.MIXPANEL_TRACKING_ENDPOINT = '/track/'
        EventTracker.endpoint = mp_settings.MIXPANEL_TRACKING_ENDPOINT

    def tearDown(self):
        EventTracker.endpoint = mp_settings.MIXPANEL_TRACKING_ENDPOINT

    def test_failed_request(self):
        EventTracker.endpoint = 'brokenurl'

        with eager_tasks():
            result = EventTracker.delay('event_foo')

        self.assertNotEqual(result.traceback, None)

    def test_failed_socket_request(self):
        mp_settings.MIXPANEL_API_SERVER = '127.0.0.1:60000'

        with eager_tasks():
            result = EventTracker.delay('event_foo')
        self.assertNotEqual(result.traceback, None)


class FunnelEventTrackerTest(unittest.TestCase):
    def setUp(self):
        mp_settings.MIXPANEL_API_TOKEN = 'testtesttest'
        mp_settings.MIXPANEL_API_SERVER = 'api.mixpanel.com'
        mp_settings.MIXPANEL_TRACKING_ENDPOINT = '/track/'
        mp_settings.MIXPANEL_TEST_ONLY = True

    def test_afp_validation(self):
        fet = FunnelEventTracker()

        funnel = 'test_funnel'
        step = 'test_step'
        goal = 'test_goal'

        # neither
        properties = {}
        self.assertRaises(FunnelEventTracker.InvalidFunnelProperties,
                          fet._add_funnel_properties,
                          properties, funnel, step, goal)

        # only distinct
        properties = {'distinct_id': 'test_distinct_id'}
        fet._add_funnel_properties(properties, funnel, step, goal)

        # only ip
        properties = {'ip': 'some_ip'}
        self.assertRaises(FunnelEventTracker.InvalidFunnelProperties,
                          fet._add_funnel_properties,
                          properties, funnel, step, goal)

        # both
        properties = {'distinct_id': 'test_distinct_id',
                      'ip': 'some_ip'}
        fet._add_funnel_properties(properties, funnel, step, goal)

    def test_afp_properties(self):
        fet = FunnelEventTracker()

        funnel = 'test_funnel'
        step = 'test_step'
        goal = 'test_goal'

        properties = {'distinct_id': 'test_distinct_id'}

        funnel_properties = fet._add_funnel_properties(properties, funnel,
                                                       step, goal)

        self.assertEqual(funnel_properties['funnel'], funnel)
        self.assertEqual(funnel_properties['step'], step)
        self.assertEqual(funnel_properties['goal'], goal)

    def test_run(self):
        funnel = 'test_funnel'
        step = 'test_step'
        goal = 'test_goal'

        fet = FunnelEventTracker()
        result = fet.run(funnel, step, goal, {'distinct_id': 'test_user'})

        self.assertTrue(result)

########NEW FILE########
__FILENAME__ = utils
from __future__ import with_statement

from contextlib import contextmanager
from functools import wraps

from celery.app import app_or_default


# Ported from Celery 3.0, because this was removed in Celery 3.1
@contextmanager
def eager_tasks():
    app = app_or_default()

    prev = app.conf.CELERY_ALWAYS_EAGER
    app.conf.CELERY_ALWAYS_EAGER = True
    try:
        yield True
    finally:
        app.conf.CELERY_ALWAYS_EAGER = prev


def with_eager_tasks(fun):

    @wraps(fun)
    def _inner(*args, **kwargs):
        app = app_or_default()
        prev = app.conf.CELERY_ALWAYS_EAGER
        app.conf.CELERY_ALWAYS_EAGER = True
        try:
            return fun(*args, **kwargs)
        finally:
            app.conf.CELERY_ALWAYS_EAGER = prev

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write(
            "Error: Can't find the file 'settings.py' in the directory \
            containing %r. It appears you've customized things.\n\
            You'll have to run django-admin.py, passing it your settings\
            module.\n(If the file settings.py does indeed exist, it's\
            causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)
########NEW FILE########
__FILENAME__ = settings
# Django settings for testproj project.

import os

here = os.path.abspath(os.path.dirname(__file__))

ROOT_URLCONF = "testproj.urls"

DEBUG = True
TEMPLATE_DEBUG = DEBUG
USE_TZ = True
TIME_ZONE = 'UTC'
SITE_ID = 1
SECRET_KEY = 'testmixpanel'
ADMINS = ()
MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(here, 'mpcelery-test-db'),
        'USER': '',
        'PASSWORD': '',
        'PORT': '',
    }
}

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'djcelery',
    'mixpanel',
    'django_nose',
)

NOSE_ARGS = [
    os.path.join(here, os.pardir, 'mixpanel', 'tests'),
    os.environ.get("NOSE_VERBOSE") and "--verbose" or "",
]
TEST_RUNNER = 'django_nose.run_tests'

MIXPANEL_API_TOKEN = 'testmixpanel'

# Celery Configuration
BROKER_URL = 'memory://'
BROKER_CONNECTION_TIMEOUT = 1
BROKER_CONNECTION_RETRY = False
BROKER_CONNECTION_MAX_RETRIES = 1
# The default BROKER_POOL_LIMIT is 10, broker connections are not
# properly cleaned up on error, so the tests will run out of
# connections and result in one test hanging forever
# To prevent that, just disable it
BROKER_POOL_LIMIT = 0
CELERY_RESULT_BACKEND = 'cache'
CELERY_CACHE_BACKEND = 'locmem://'

CELERY_SEND_TASK_ERROR_EMAILS = False

import djcelery
djcelery.setup_loader()

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

urlpatterns = patterns('',

)
########NEW FILE########
