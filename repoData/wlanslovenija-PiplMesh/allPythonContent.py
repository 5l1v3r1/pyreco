__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PiplMesh documentation build configuration file, created by
# sphinx-quickstart on Tue Feb 28 22:56:01 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PiplMesh'
copyright = u'2012, wlan slovenija'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'piplmeshdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'piplmesh.tex', u'PiplMesh Documentation',
   u'wlan slovenija', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'piplmesh', u'PiplMesh Documentation',
     [u'wlan slovenija'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'piplmesh', u'PiplMesh Documentation',
   u'wlan slovenija', 'PiplMesh', 'Social networking portal for wireless networks.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
	'python': ('http://python.readthedocs.org/en/latest/', None),
	'django': ('http://django.readthedocs.org/en/latest/', None),
}

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import imp, os, sys

if __name__ == '__main__':
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'piplmesh.settings')

    from django.core import management

    original_get_commands = management.get_commands

    # We override get_commands with a version which loads automatically all management
    # commands from all panels so that it is not necessary to list panels manually
    # in INSTALLED_APPS to get their commands (which makes their tests being loaded twice)
    def get_commands():
        commands = original_get_commands()

        # Find and load the management module for all panels
        path = imp.find_module('piplmesh')[1]
        panels_directory = imp.find_module('panels', [path])[1]
        for directory in os.listdir(panels_directory):
            app_name = 'piplmesh.panels.%s' % directory
            try:
                path = management.find_management_module(app_name)
                commands.update(dict([(name, app_name) for name in management.find_commands(path)]))
            except ImportError:
                pass

        return commands

    management.get_commands = get_commands

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)
########NEW FILE########
__FILENAME__ = models
import uuid

from django import dispatch
from django.db import models as django_models
from django.utils import timezone

import mongoengine

from pushserver import signals

from mongo_auth.contrib import models

from .. import panels

def generate_channel_id():
    return uuid.uuid4()

class Connection(mongoengine.EmbeddedDocument):
    http_if_none_match = mongoengine.StringField()
    http_if_modified_since = mongoengine.StringField()
    channel_id = mongoengine.StringField()

class User(models.User):
    channel_id = mongoengine.UUIDField(default=generate_channel_id)

    connections = mongoengine.ListField(mongoengine.EmbeddedDocumentField(Connection))
    connection_last_unsubscribe = mongoengine.DateTimeField()
    is_online = mongoengine.BooleanField(default=False)

    # TODO: Model for panel settings should be more semantic.
    panels_collapsed = mongoengine.DictField()
    panels_order = mongoengine.DictField()

    @django_models.permalink
    def get_absolute_url(self):
        return ('profile', (), {'username': self.username})

    def get_profile_url(self):
        return self.get_absolute_url()

    def get_panels(self):
        # TODO: Should return only panels user has enabled (should make sure users can enable panels only in the way that dependencies are satisfied)
        return panels.panels_pool.get_all_panels()

    def get_user_channel(self):
        """
        User channel is a HTTP push channel dedicated to the user. We make it private by making
        it unguessable and we cycle it regularly (every time user disconnects from all channels).
        """

        return 'user/%s' % self.channel_id

@dispatch.receiver(signals.channel_subscribe)
def process_channel_subscribe(sender, request, channel_id, **kwargs):
    request.user.update(
        push__connections={
            'http_if_none_match': request.META['HTTP_IF_NONE_MATCH'],
            'http_if_modified_since': request.META['HTTP_IF_MODIFIED_SINCE'],
            'channel_id': channel_id,
        }
    )

@dispatch.receiver(signals.channel_unsubscribe)
def process_channel_unsubscribe(sender, request, channel_id, **kwargs):
    # Importing here to prevent circular imports
    from mongo_auth import backends

    backends.User.objects(
        id=request.user.id,
        connections__http_if_none_match=request.META['HTTP_IF_NONE_MATCH'],
        connections__http_if_modified_since=request.META['HTTP_IF_MODIFIED_SINCE'],
        connections__channel_id=channel_id,
    ).update_one(unset__connections__S=1)

    request.user.update(
        pull__connections=None,
        set__connection_last_unsubscribe=timezone.now(),
    )

########NEW FILE########
__FILENAME__ = authorization
from mongoengine import queryset
from tastypie import authorization as tastypie_authorization

class PostAuthorization(tastypie_authorization.Authorization):
    def apply_limits(self, request, object_list):
        if request and hasattr(request, 'user'):
            object_list = object_list.filter(queryset.Q(author=request.user) | queryset.Q(is_published=True))
        else:
            object_list = object_list.filter(is_published=True)

        return object_list

class NotificationAuthorization(tastypie_authorization.Authorization):
    def apply_limits(self, request, object_list):
        if request and hasattr(request, 'user'):
            return object_list.filter(recipient=request.user)
        else:
            # TODO: Should be in fact empty queryset, https://github.com/MongoEngine/mongoengine/issues/127
            return []

########NEW FILE########
__FILENAME__ = base
from django.utils import timezone

import mongoengine

from mongo_auth import backends

class AuthoredEmbeddedDocument(mongoengine.EmbeddedDocument):
    created_time = mongoengine.DateTimeField(default=lambda: timezone.now(), required=True)
    author = mongoengine.ReferenceField(backends.User, required=True)

class AuthoredDocument(mongoengine.Document):
    created_time = mongoengine.DateTimeField(default=lambda: timezone.now(), required=True)
    author = mongoengine.ReferenceField(backends.User, required=True)

    meta = {
        'abstract': True,
    }

########NEW FILE########
__FILENAME__ = fields
from tastypie_mongoengine import fields

class CustomReferenceField(fields.ReferenceField):
    """
    Reference field which allows custom getter to access attribute.
    """

    def __init__(self, getter, setter, *args, **kwargs):
        super(CustomReferenceField, self).__init__(attribute=None, *args, **kwargs)

        self._getter = getter
        self._setter = setter

    def dehydrate(self, bundle):
        self.attribute = '_temp_proxy'
        setattr(bundle.obj, self.attribute, self._getter(bundle.obj))
        try:
            return super(CustomReferenceField, self).dehydrate(bundle)
        finally:
            delattr(bundle.obj, self.attribute)
            self.attribute = None

    def hydrate(self, bundle):
        value = super(CustomReferenceField, self).hydrate(bundle)

        if value is None:
            return value

        return self._setter(value)

########NEW FILE########
__FILENAME__ = models
from django.utils import timezone

import bson
import mongoengine

from tastypie_mongoengine import fields

from mongo_auth import backends

from . import base

POST_MESSAGE_MAX_LENGTH = 500
COMMENT_MESSAGE_MAX_LENGTH = 300

class HugRunParent(base.AuthoredEmbeddedDocument):
    """
    This class defines intermediate document type for both hugs and runs.
    """

    id = mongoengine.ObjectIdField(primary_key=True, default=lambda: bson.ObjectId())

    # So that we can access both pk and id
    pk = fields.link_property('id')

class Hug(HugRunParent):
    """
    This class defines document type for hugs.
    """

class Run(HugRunParent):
    """
    This class defines document type for runs.
    """

class Comment(base.AuthoredEmbeddedDocument):
    """
    This class defines document type for comments on posts.
    """

    id = mongoengine.ObjectIdField(primary_key=True, default=lambda: bson.ObjectId())
    message = mongoengine.StringField(max_length=COMMENT_MESSAGE_MAX_LENGTH, required=True)

    hugs = mongoengine.ListField(mongoengine.EmbeddedDocumentField(Hug), default=lambda: [], required=False)
    hugs_count = mongoengine.IntField()
    runs = mongoengine.ListField(mongoengine.EmbeddedDocumentField(Run), default=lambda: [], required=False)
    runs_count = mongoengine.IntField()

    # So that we can access both pk and id
    pk = fields.link_property('id')

class Attachment(base.AuthoredEmbeddedDocument):
    """
    This class defines document type for attachments on posts.
    """

class Post(base.AuthoredDocument):
    """
    This class defines document type for posts.
    """

    updated_time = mongoengine.DateTimeField()

    message = mongoengine.StringField(max_length=POST_MESSAGE_MAX_LENGTH, required=True)

    comments = mongoengine.ListField(mongoengine.EmbeddedDocumentField(Comment), default=lambda: [], required=False)
    attachments = mongoengine.ListField(mongoengine.EmbeddedDocumentField(Attachment), default=lambda: [], required=False)

    hugs = mongoengine.ListField(mongoengine.EmbeddedDocumentField(Hug), default=lambda: [], required=False)
    hugs_count = mongoengine.IntField()
    runs = mongoengine.ListField(mongoengine.EmbeddedDocumentField(Run), default=lambda: [], required=False)
    runs_count = mongoengine.IntField()

    subscribers = mongoengine.ListField(mongoengine.ReferenceField(backends.User), default=lambda: [], required=False)

    # TODO: Prevent posting comments if post is not published
    # TODO: Prevent adding attachments if post is published
    # TODO: Prevent marking post as unpublished once it was published
    is_published = mongoengine.BooleanField(default=False, required=True)

    def save(self, *args, **kwargs):
        self.updated_time = timezone.now()

        self.hugs_count = len(self.hugs)
        self.runs_count = len(self.runs)

        for comment in self.comments:
            comment.hugs_count = len(comment.hugs)
            comment.runs_count = len(comment.runs)

        return super(Post, self).save(*args, **kwargs)

    def get_comment(self, comment_pk):
        # TODO: Would it be faster to traverse in reversed direction? Because probably last comments are fetched more often in practice?
        # TODO: Should we cache information about mappings between IDs and comments?
        for comment in self.comments:
            if comment.pk == comment_pk:
                return comment

        raise IndexError("Comment with primary key '%s' not found in post '%s'." % (comment_pk, self.pk))

class Notification(mongoengine.Document):
    """
    This class defines document type for notifications.
    """

    created_time = mongoengine.DateTimeField(required=True)
    recipient = mongoengine.ReferenceField(backends.User, required=True)
    read = mongoengine.BooleanField(default=False)
    post = mongoengine.ReferenceField(Post)
    comment = mongoengine.ObjectIdField()

class UploadedFile(base.AuthoredDocument):
    """
    This class document type for uploaded files.
    """

    filename = mongoengine.StringField(required=True)
    content_type = mongoengine.StringField()

class ImageAttachment(Attachment):
    """
    This class defines document type for image attachments.
    """

    image_file = mongoengine.ReferenceField(UploadedFile, required=True)
    image_description = mongoengine.StringField(default='', required=True)

class LinkAttachment(Attachment):
    """
    This class defines document type for link attachments
    """

    link_url = mongoengine.URLField(required=True)
    link_caption = mongoengine.StringField(default='', required=True)
    link_description = mongoengine.StringField(default='', required=True)
########NEW FILE########
__FILENAME__ = resources
from tastypie import authorization as tastypie_authorization, fields as tastypie_fields

from tastypie_mongoengine import fields as tastypie_mongoengine_fields, paginator, resources

from mongo_auth import backends

from piplmesh.api import authorization, fields, models as api_models, signals, tasks

class UserResource(resources.MongoEngineResource):
    class Meta:
        queryset = backends.User.objects.all()
        fields = ('username', 'is_online')
        allowed_methods = ()

class UploadedFileResource(resources.MongoEngineResource):
    class Meta:
        queryset = api_models.UploadedFile.objects.all()
        allowed_methods = ()

class AuthoredResource(resources.MongoEngineResource):
    created_time = tastypie_fields.DateTimeField(attribute='created_time', null=False, readonly=True)
    author = tastypie_mongoengine_fields.ReferenceField(to='piplmesh.api.resources.UserResource', attribute='author', null=False, full=True, readonly=True)

    def hydrate(self, bundle):
        bundle = super(AuthoredResource, self).hydrate(bundle)
        bundle.obj.author = bundle.request.user
        return bundle

class HugRunResourceParent(AuthoredResource):
    def obj_create(self, bundle, request=None, **kwargs):
        bundle = super(HugRunResourceParent, self).obj_create(bundle, request=request, **kwargs)

        # By default,hug or run author is subscribed to the post
        if bundle.obj.author not in self.instance.subscribers:
            self.instance.subscribers.append(bundle.obj.author)
            self.instance.save()

        return bundle

    def only_one_hug_or_run(self, list1, list2, object):
        for item in list1:
            if object.author == item.author and object != item:
                list1.remove(object)
                return

        for item in list2:
            if object.author == item.author:
                list2.remove(item)
                return

class RunResource(HugRunResourceParent):
    class Meta:
        object_class = api_models.Run
        allowed_methods = ('get', 'post', 'delete')
        # TODO: Make proper authorization, current implementation is for development use only
        authorization = tastypie_authorization.Authorization()

    def obj_create(self, bundle, request=None, **kwargs):
        bundle = super(RunResource, self).obj_create(bundle, request=request, **kwargs)

        self.only_one_hug_or_run(self.instance.runs, self.instance.hugs, bundle.obj)

        self.instance.save()

        # TODO: Should use the signal to push to all clients information about the new run

        return bundle

class HugResource(HugRunResourceParent):
    class Meta:
        object_class = api_models.Hug
        allowed_methods = ('get', 'post', 'delete')
        # TODO: Make proper authorization, current implementation is for development use only
        authorization = tastypie_authorization.Authorization()

    def obj_create(self, bundle, request=None, **kwargs):
        bundle = super(HugResource, self).obj_create(bundle, request=request, **kwargs)

        self.only_one_hug_or_run(self.instance.hugs, self.instance.runs, bundle.obj)

        self.instance.save()

        # TODO: Should use the signal to push to all clients information about the new run

        return bundle

class CommentResource(AuthoredResource):
    def obj_create(self, bundle, request=None, **kwargs):
        bundle = super(CommentResource, self).obj_create(bundle, request=request, **kwargs)

        # By default, comment author is subscribed to the post
        if bundle.obj.author not in self.instance.subscribers:
            self.instance.subscribers.append(bundle.obj.author)
            self.instance.save()

        signals.comment_created.send(sender=self, comment=bundle.obj, post=self.instance, request=request or bundle.request, bundle=bundle)

        # We process notifications asynchronously as it could
        # take long and we want REST request to finish quick
        tasks.process_notifications_on_new_comment.delay(bundle.obj.pk, self.instance.pk)

        return bundle

    class Meta:
        object_class = api_models.Comment
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        # TODO: Make proper authorization, current implementation is for development use only
        authorization = tastypie_authorization.Authorization()
        paginator_class = paginator.Paginator

class NotificationResource(resources.MongoEngineResource):
    post = tastypie_mongoengine_fields.ReferenceField(to='piplmesh.api.resources.PostResource', attribute='post', null=False, full=False, readonly=True)
    comment = fields.CustomReferenceField(to='piplmesh.api.resources.CommentResource', getter=lambda obj: obj.post.get_comment(obj.comment), setter=lambda obj: obj.pk, null=False, full=True, readonly=True)

    @classmethod
    def api_field_options(cls, name, field, options):
        # We cannot simply call super(NotificationResource, cls).api_field_options(name, field, options)
        # because api_field_options is called in metaclass class constructor before the class has
        # been created, so NotificationResource does not yet exist
        # It is in fact probably wrong to call class methods on the class which does not really yet
        # exist, but this is how Tastypie has it, so we are mostly stuck with it
        me = next(c for c in cls.__mro__ if c.__module__ == __name__ and c.__name__ == 'NotificationResource')
        options = super(me, cls).api_field_options(name, field, options)

        # We are setting readonly flag to all fields except "read" flag, because
        # we do not want clients to change other values of notifications
        if name != 'read':
            options['readonly'] = True
        return options

    class Meta:
        queryset = api_models.Notification.objects.all()
        allowed_methods = ('get', 'patch',)
        authorization = authorization.NotificationAuthorization()
        excludes = ('recipient',)

class ImageAttachmentResource(AuthoredResource):
    image_file = tastypie_mongoengine_fields.ReferenceField(to='piplmesh.api.resources.UploadedFileResource', attribute='image_file', null=False, full=True)
    image_description = tastypie_fields.CharField(attribute='image_description', default='', null=False, blank=True)

    class Meta:
        object_class = api_models.ImageAttachment

class LinkAttachmentResource(AuthoredResource):
    link_caption = tastypie_fields.CharField(attribute='link_caption', default='', null=False, blank=True)
    link_description = tastypie_fields.CharField(attribute='link_description', default='', null=False, blank=True)

    class Meta:
        object_class = api_models.LinkAttachment

class AttachmentResource(AuthoredResource):
    class Meta:
        object_class = api_models.Attachment
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        # TODO: Make proper authorization, current implementation is for development use only
        authorization = tastypie_authorization.Authorization()

        polymorphic = {
            'image': ImageAttachmentResource,
            'link': LinkAttachmentResource,
        }

class PostResource(AuthoredResource):
    """
    Query set is ordered by updated time for following reasons:
     * those who open web page anew will get posts in updated time order
     * others with already opened page will get updated posts again as they
       will request them based on ID of current newest post

    This is useful if we would like to show on the client side that post has been updated
    (but we do not necessary have to reorder them, this depends on the client code).
    """

    updated_time = tastypie_fields.DateTimeField(attribute='updated_time', null=False, readonly=True)
    comments = tastypie_mongoengine_fields.EmbeddedListField(of='piplmesh.api.resources.CommentResource', attribute='comments', default=lambda: [], null=True, full=False)
    attachments = tastypie_mongoengine_fields.EmbeddedListField(of='piplmesh.api.resources.AttachmentResource', attribute='attachments', default=lambda: [], null=True, full=True)
    runs = tastypie_mongoengine_fields.EmbeddedListField(of='piplmesh.api.resources.RunResource', attribute='runs', default=lambda: [], null=True, full=True)
    hugs = tastypie_mongoengine_fields.EmbeddedListField(of='piplmesh.api.resources.HugResource', attribute='hugs', default=lambda: [], null=True, full=True)

    def obj_create(self, bundle, request=None, **kwargs):
        bundle = super(PostResource, self).obj_create(bundle, request=request, **kwargs)

        # By default, post author is subscribed to the post
        bundle.obj.subscribers.append(bundle.obj.author)
        bundle.obj.save()

        signals.post_created.send(sender=self, post=bundle.obj, request=request or bundle.request, bundle=bundle)

        return bundle

    def obj_update(self, bundle, request=None, **kwargs):
        bundle = super(PostResource, self).obj_update(bundle, request=request, **kwargs)

        signals.post_updated.send(sender=self, post=bundle.obj, request=request or bundle.request, bundle=bundle)

        return bundle

    class Meta:
        queryset = api_models.Post.objects.all().order_by('-updated_time')
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = authorization.PostAuthorization()
        paginator_class = paginator.Paginator

########NEW FILE########
__FILENAME__ = signals
from django import dispatch

# Signals dispatched when resources are created
post_created = dispatch.Signal(providing_args=('post', 'request', 'bundle'))
comment_created = dispatch.Signal(providing_args=('comment', 'post', 'request', 'bundle'))

# Signals dispatched when resources are updated
post_updated = dispatch.Signal(providing_args=('post', 'request', 'bundle'))

########NEW FILE########
__FILENAME__ = tasks
from celery import task

from . import models

@task.task
def process_notifications_on_new_comment(comment_pk, post_pk):
    post = models.Post.objects.get(pk=post_pk)
    comment = post.get_comment(comment_pk)

    for subscriber in post.subscribers:
        if subscriber != comment.author:
            models.Notification.objects.create(created_time=comment.created_time, recipient=subscriber, post=post, comment=comment_pk)

########NEW FILE########
__FILENAME__ = test_basic
import datetime, time, urlparse

from django.core import urlresolvers
from django.test import client, utils
from django.utils import simplejson as json, timezone

from tastypie_mongoengine import test_runner

from mongo_auth import backends

from pushserver import signals

from piplmesh.frontend import tasks

@utils.override_settings(DEBUG=True, CELERY_ALWAYS_EAGER=True, CELERY_EAGER_PROPAGATES_EXCEPTIONS=True, PUSH_SERVER_IGNORE_ERRORS=True)
class BasicTest(test_runner.MongoEngineTestCase):
    api_name = 'v1'
    user_username = 'test_user'
    user_password = 'foobar'
    
    user_username2 = 'test_user2'
    user_password2 = 'foobar2'

    def setUp(self):
        self.user = backends.User.create_user(username=self.user_username, password=self.user_password)
        self.user2 = backends.User.create_user(username=self.user_username2, password=self.user_password2)

        self.client = client.Client()
        self.assertTrue(self.client.login(username=self.user_username, password=self.user_password))
        self.client2 = client.Client()
        self.assertTrue(self.client2.login(username=self.user_username2, password=self.user_password2))

        self.updates_data = []
        signals.post_send_update.connect(self._on_update, dispatch_uid='send-update')

    def tearDown(self):
        signals.post_send_update.disconnect(dispatch_uid='send-update')
        self.updates_data = []

    def _on_update(self, channel_id, data, already_serialized, request, response, **kwargs):
        self.updates_data.append({
            'channel_id': channel_id,
            'data': data,
            'already_serialized': already_serialized,
            'request': request,
            'response': response,
        })

    def resourceListURI(self, resource_name):
        return urlresolvers.reverse('api_dispatch_list', kwargs={'api_name': self.api_name, 'resource_name': resource_name})

    def resourcePK(self, resource_uri):
        match = urlresolvers.resolve(resource_uri)
        return match.kwargs['pk']

    def resourceDetailURI(self, resource_name, resource_pk):
        return urlresolvers.reverse('api_dispatch_detail', kwargs={'api_name': self.api_name, 'resource_name': resource_name, 'pk': resource_pk})

    def fullURItoAbsoluteURI(self, uri):
        scheme, netloc, path, query, fragment = urlparse.urlsplit(uri)
        return urlparse.urlunsplit((None, None, path, query, fragment))

    def test_basic(self):
        # Creating a post

        response = self.client.post(self.resourceListURI('post'), '{"message": "Test post."}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        post_uri = response['location']

        response = self.client.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['message'], 'Test post.')
        self.assertEqual(response['author']['username'], self.user_username)
        self.assertNotEqual(response['created_time'], None)
        self.assertNotEqual(response['updated_time'], None)
        self.assertEqual(response['comments'], [])
        self.assertEqual(response['attachments'], [])
        self.assertEqual(response['is_published'], False)

        post_created_time = response['created_time']
        post_updated_time = response['updated_time']

        # Delay so next update will be for sure different
        time.sleep(1)

        # Test authorization
        response = self.client2.get(post_uri, content_type='application/json')
        self.assertEqual(response.status_code, 404)

        # Adding an attachment

        attachments_resource_uri = self.fullURItoAbsoluteURI(post_uri) + 'attachments/'

        response = self.client.post(attachments_resource_uri, '{"link_url": "http://wlan-si.net/", "link_caption": "wlan slovenija"}', content_type='application/json; type=link')
        self.assertEqual(response.status_code, 201)

        attachment_uri = response['location']

        response = self.client.get(attachment_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['link_url'], 'http://wlan-si.net/')
        self.assertEqual(response['link_caption'], 'wlan slovenija')
        self.assertEqual(response['link_description'], '')
        self.assertEqual(response['author']['username'], self.user_username)

        response = self.client.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['attachments'][0]['link_url'], 'http://wlan-si.net/')
        self.assertEqual(response['attachments'][0]['link_caption'], 'wlan slovenija')
        self.assertEqual(response['attachments'][0]['link_description'], '')
        self.assertEqual(response['created_time'], post_created_time)
        self.assertNotEqual(response['updated_time'], post_updated_time)

        post_updated_time = response['updated_time']

        # Delay so next update will be for sure different
        time.sleep(1)

        # Publishing a post

        response = self.client.patch(post_uri, '{"is_published": true}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.client.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['is_published'], True)
        
        # Test authorization
        response = self.client2.get(post_uri, content_type='application/json')
        self.assertEqual(response.status_code, 200)

        # Checking updates

        self.assertEqual(len(self.updates_data), 1)
        self.assertEqual(self.updates_data[0]['channel_id'], tasks.HOME_CHANNEL_ID)
        self.assertTrue(self.updates_data[0]['already_serialized'])

        post = json.loads(self.updates_data[0]['data'])

        self.assertEqual(post['type'], 'post_published')
        self.assertEqual(post['post']['message'], 'Test post.')
        self.assertEqual(post['post']['author']['username'], self.user_username)
        self.assertEqual(post['post']['comments'], [])
        self.assertEqual(post['post']['attachments'][0]['link_url'], 'http://wlan-si.net/')
        self.assertEqual(post['post']['attachments'][0]['link_caption'], 'wlan slovenija')
        self.assertEqual(post['post']['attachments'][0]['link_description'], '')
        self.assertEqual(post['post']['created_time'], post_created_time)
        self.assertEqual(post['post']['is_published'], True)

        # Adding a comment

        comments_resource_uri = self.fullURItoAbsoluteURI(post_uri) + 'comments/'

        response = self.client.post(comments_resource_uri, '{"message": "Test comment."}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        comment_uri = response['location']

        response = self.client.get(comment_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['message'], 'Test comment.')
        self.assertEqual(response['author']['username'], self.user_username)

        response = self.client.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['comments'][0], self.fullURItoAbsoluteURI(comment_uri))
        self.assertEqual(response['created_time'], post_created_time)
        self.assertNotEqual(response['updated_time'], post_updated_time)

        post_updated_time = response['updated_time']

        # Delay so next update will be for sure different
        time.sleep(1)

        # Adding hug on post

        hugs_resource_uri = self.fullURItoAbsoluteURI(post_uri) + 'hugs/'

        response = self.client.post(hugs_resource_uri, content_type='application/json')
        self.assertEqual(response.status_code, 201)

        hug_uri = response['location']

        response = self.client.get(hug_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['author']['username'], self.user_username)

        response = self.client.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['hugs'][0]['resource_uri'], self.fullURItoAbsoluteURI(hug_uri))
        self.assertEqual(response['created_time'], post_created_time)
        self.assertNotEqual(response['updated_time'], post_updated_time)

        post_updated_time = response['updated_time']

        # Delay so next update will be for sure different
        time.sleep(1)

        # Adding run on post

        runs_resource_uri = self.fullURItoAbsoluteURI(post_uri) + 'runs/'

        response = self.client.post(runs_resource_uri, content_type='application/json')
        self.assertEqual(response.status_code, 201)

        run_uri = response['location']

        response = self.client.get(run_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['author']['username'], self.user_username)

        response = self.client.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['runs'][0]['resource_uri'], self.fullURItoAbsoluteURI(run_uri))
        self.assertEqual(response['created_time'], post_created_time)
        self.assertNotEqual(response['updated_time'], post_updated_time)

        self.assertEqual(response['hugs'], [])

        previous_runs = response['runs']

        post_updated_time = response['updated_time']

        # Delay so next update will be for sure different
        time.sleep(1)


        # Adding another hug on post by client 2

        hugs_resource_uri = self.fullURItoAbsoluteURI(post_uri) + 'hugs/'

        response = self.client2.post(hugs_resource_uri, content_type='application/json')
        self.assertEqual(response.status_code, 201)

        hug_uri = response['location']

        response = self.client2.get(hug_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['author']['username'], self.user_username2)

        response = self.client2.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['runs'], previous_runs)

        self.assertEqual(response['hugs'][0]['resource_uri'], self.fullURItoAbsoluteURI(hug_uri))
        self.assertEqual(response['created_time'], post_created_time)
        self.assertNotEqual(response['updated_time'], post_updated_time)

        post_updated_time = response['updated_time']

        # Delay so next update will be for sure different
        time.sleep(1)

    def test_notification(self):
        # Creating a post

        response = self.client.post(self.resourceListURI('post'), '{"message": "Test post for notifications.", "is_published": true}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        post_uri = response['location']

        response = self.client.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['comments'], [])
        self.assertEqual(response['is_published'], True)

        # Adding a comment

        comments_resource_uri = self.fullURItoAbsoluteURI(post_uri) + 'comments/'

        response = self.client2.post(comments_resource_uri, '{"message": "Test comment 1."}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        comment_uri = response['location']
        
        response = self.client2.get(comment_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['message'], 'Test comment 1.')

        # Verifying notification

        response = self.client.get(self.resourceListURI('notification'))
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['objects']), 1)

        notification_uri = response['objects'][0]['resource_uri']

        self.assertEqual(response['objects'][0]['comment']['message'], 'Test comment 1.')
        self.assertEqual(response['objects'][0]['comment']['author']['username'], self.user_username2)
        self.assertEqual(response['objects'][0]['comment']['created_time'], response['objects'][0]['created_time'])
        self.assertEqual(response['objects'][0]['post'], self.fullURItoAbsoluteURI(post_uri))
        self.assertEqual(response['objects'][0]['read'], False)

        # Checking updates

        self.assertEqual(len(self.updates_data), 3)
        self.assertEqual(self.updates_data[0]['channel_id'], tasks.HOME_CHANNEL_ID)
        self.assertEqual(self.updates_data[2]['channel_id'], self.user.get_user_channel())
        self.assertTrue(self.updates_data[2]['already_serialized'])

        notification = json.loads(self.updates_data[2]['data'])

        self.assertEqual(notification['type'], 'notification')
        self.assertEqual(notification['notification']['comment']['message'], 'Test comment 1.')
        self.assertEqual(notification['notification']['comment']['author']['username'], self.user_username2)
        self.assertEqual(notification['notification']['post'], self.fullURItoAbsoluteURI(post_uri))
        self.assertEqual(notification['notification']['read'], False)

        # Marking notification as read

        response = self.client.patch(notification_uri, '{"read": true}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.client.get(notification_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['read'], True)

        # Testing readonly field

        created_time = response['created_time']

        response = self.client.patch(notification_uri, '{"created_time": "%s"}' % (timezone.now() + datetime.timedelta(seconds=30)).isoformat(), content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.client.get(notification_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        # Field has not changed
        self.assertEqual(response['created_time'], created_time)

    def test_newline_post(self):
        # Creating a post with a message containing newlines

        post = {
            'message': "Test post.\nAnother line.\nAnd another.",
        }

        response = self.client.post(self.resourceListURI('post'), json.dumps(post), content_type='application/json')
        self.assertEqual(response.status_code, 201)

        post_uri = response['location']

        response = self.client.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['message'], post['message'])
        self.assertEqual(response['author']['username'], self.user_username)
        self.assertNotEqual(response['created_time'], None)
        self.assertNotEqual(response['updated_time'], None)
        self.assertEqual(response['comments'], [])
        self.assertEqual(response['attachments'], [])
        self.assertEqual(response['is_published'], False)

########NEW FILE########
__FILENAME__ = test_bugs
import datetime

from tastypie_mongoengine import test_runner

import pytz

from django.utils import timezone, translation

from tastypie.utils import formatting

class BugsTest(test_runner.MongoEngineTestCase):
    def test_format_date(self):
        paris_tz = pytz.timezone('Europe/Paris')
        d = paris_tz.localize(datetime.datetime(2012, 3, 3, 1, 30))

        tz = timezone.get_current_timezone()
        timezone.activate(pytz.timezone('America/New_York'))

        lang = translation.get_language()
        translation.activate('sl')

        try:
            self.assertEqual(formatting.format_datetime(d), 'Sat, 03 Mar 2012 01:30:00 +0100')
        finally:
            timezone.activate(tz)
            translation.activate(lang)
########NEW FILE########
__FILENAME__ = context_processors
from django.conf import settings
from django.utils import translation

from piplmesh import urls
from piplmesh.frontend import forms, tasks

def global_vars(request):
    """
    Adds global context variables to the context.
    """
    context = {
        # Constants
        'HOME_CHANNEL_ID': tasks.HOME_CHANNEL_ID,
        'SEARCH_ENGINE_UNIQUE_ID': settings.SEARCH_ENGINE_UNIQUE_ID,
        'API_NAME': urls.API_NAME,

        # Variables
        'logo_url': "piplmesh/images/logo-%s.png" % translation.get_language(),
    }

    # Location
    if getattr(request, 'user', None) and request.user.is_authenticated() and request.user.is_staff:
        context.update({
            'location_form': forms.LocationForm(initial={'location': forms.initial_location(request)}),
        })

    return context

########NEW FILE########
__FILENAME__ = debug
from django import forms
from django.views import generic as generic_views
from django.utils.translation import ugettext_lazy as _

class UploadForm(forms.Form):
    file = forms.FileField(label=_("File"))

class UploadFormView(generic_views.TemplateView):
    template_name = 'debug/uploadform.html'

    def get_context_data(self, **kwargs):
        context = super(UploadFormView, self).get_context_data(**kwargs)
        context.update({
            'form': UploadForm(),
        })
        return context

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.forms import widgets
from django.utils.translation import ugettext_lazy as _

from piplmesh import nodes

NO_MOCKING_ID = ''

class ContactForm(forms.Form):
    """
    Class with the contact form.
    """

    subject = forms.CharField(label=_("Subject"))
    email = forms.EmailField(label=_("Your e-mail address"))
    message = forms.CharField(widget=widgets.Textarea())

def location_choices():
    yield (NO_MOCKING_ID, _("Don't mock location"))
    for node in nodes.get_all_nodes():
        yield (node.get_full_node_id(), node.name)

def initial_location(request):
    if nodes.is_mocking(request):
        return request.node.get_full_node_id()
    else:
        return NO_MOCKING_ID

class LocationForm(forms.Form):
    location = forms.ChoiceField(choices=location_choices(), label=_("Location"), required=False)

########NEW FILE########
__FILENAME__ = middleware
from django import http
from django.conf import settings
from django.core import urlresolvers

from piplmesh import nodes

class NodesMiddleware(object):
    def process_request(self, request):
        outside_url = urlresolvers.reverse('outside')
        request.node = nodes.get_node(request)

        if request.path == outside_url:
            if request.node is None:
                # We do nothing special for outside view if request
                # is from outside and without geolocation data
                return None
            elif settings.DEBUG:
                # We allow access if request is from inside if DEBUG is true
                # (So that we can test the view)
                request.node = None
                return None
            else:
                # Otherwise we redirect to home
                return http.HttpResponseRedirect(urlresolvers.reverse('home'))

        for exception in getattr(settings, 'NODES_MIDDLEWARE_EXCEPTIONS', ()):
            if request.path.startswith(exception):
                return None

        if request.node is None:
            # Outside request and without geolocation data, we redirect
            return http.HttpResponseRedirect(outside_url)
        else:
            # Inside request, or request with geolocation data, we do not do anything
            return None

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tasks
import datetime

from django.utils import timezone

from celery import task

from mongo_auth import backends

from pushserver.utils import updates

from piplmesh.account import models
from piplmesh.utils import decorators

HOME_CHANNEL_ID = 'home'
CHECK_ONLINE_USERS_INTERVAL = 10 # seconds
CHECK_ONLINE_USERS_RECONNECT_TIMEOUT = 2 * CHECK_ONLINE_USERS_INTERVAL

@task.periodic_task(run_every=datetime.timedelta(seconds=CHECK_ONLINE_USERS_INTERVAL))
@decorators.single_instance_task(timeout=10 * CHECK_ONLINE_USERS_INTERVAL) # Maximum time for one task to finish is 10x the interval
def check_online_users():
    for user in backends.User.objects(
        is_online=False,
        connections__not__in=([], None), # None if field is missing altogether, not__in seems not to be equal to nin
    ):
        if backends.User.objects(
            pk=user.pk,
            is_online=False,
            connections__not__in=([], None), # None if field is missing altogether, not__in seems not to be equal to nin
        ).update(set__is_online=True):
            updates.send_update(
                HOME_CHANNEL_ID,
                {
                    'type': 'user_connect',
                    'user': {
                        'username': user.username,
                        'profile_url': user.get_profile_url(),
                        'image_url': user.get_image_url(),
                    },
                }
            )

    for user in backends.User.objects(
        is_online=True,
        connections__in=([], None), # None if field is missing altogether
        connection_last_unsubscribe__lt=timezone.now() - datetime.timedelta(seconds=CHECK_ONLINE_USERS_RECONNECT_TIMEOUT),
    ):
        if backends.User.objects(
            pk=user.pk,
            is_online=True,
            connections__in=([], None), # None if field is missing altogether
            connection_last_unsubscribe__lt=timezone.now() - datetime.timedelta(seconds=CHECK_ONLINE_USERS_RECONNECT_TIMEOUT),
        ).update(set__is_online=False):
            # On user disconnect we cycle channel_id, this is to improve security if somebody
            # intercepted current channel_id as there is no authentication on HTTP push channels
            # This is the best place to cycle channel_id as we know that user does not listen
            # anymore to any channel
            user.reload()
            user.channel_id = models.generate_channel_id()
            user.save()

            updates.send_update(
                HOME_CHANNEL_ID,
                {
                    'type': 'user_disconnect',
                    'user': {
                        'username': user.username,
                        'profile_url': user.get_absolute_url(),
                        'image_url': user.get_image_url(),
                    },
                }
            )

@task.task
def send_update(serialized_update):
    updates.send_update(HOME_CHANNEL_ID, serialized_update, True)

########NEW FILE########
__FILENAME__ = views
import traceback

from django import dispatch, http
from django.conf import settings
from django.contrib import messages
from django.core import exceptions, mail, urlresolvers
from django.core.files import storage
from django.test import client
from django.utils import simplejson
from django.utils.translation import ugettext_lazy as _
from django.views import generic as generic_views

from mongoengine import signals as mongoengine_signals

from tastypie import http as tastypie_http

from mongogeneric import detail

from mongo_auth import backends

from pushserver.utils import updates

from piplmesh import nodes
from piplmesh.nodes import models as nodes_models
from piplmesh.api import models as api_models, resources, signals
from piplmesh.frontend import forms, tasks

class HomeView(generic_views.TemplateView):
    template_name = 'home.html'

# TODO: Get HTML5 geolocation data and store it into request session
class OutsideView(generic_views.TemplateView):
    template_name = 'outside.html'

class SearchView(generic_views.TemplateView):
    template_name = 'search.html'

class AboutView(generic_views.TemplateView):
    template_name = 'about.html'

class PrivacyView(generic_views.TemplateView):
    template_name = 'privacy.html'

class ContactView(generic_views.FormView):
    """
    This view checks if all contact data are valid and then sends e-mail to site managers.
    
    User is redirected back to the contact page.
    """

    template_name = 'contact.html'
    success_url = urlresolvers.reverse_lazy('contact')
    form_class = forms.ContactForm

    def form_valid(self, form):
        mail.mail_managers(form.cleaned_data['subject'], form.cleaned_data['message'], form.cleaned_data['email'])
        messages.success(self.request, _("Thank you. Your message has been successfully sent."))
        return super(ContactView, self).form_valid(form)

class UserView(detail.DetailView):
    """
    This view checks if user exist in database and returns his user page (profile).
    """

    template_name = 'user.html'
    document = backends.User
    slug_field = 'username'
    slug_url_kwarg = 'username'

class LocationView(generic_views.FormView):
    form_class = forms.LocationForm

    # TODO: Redirect to initiator page
    success_url = urlresolvers.reverse_lazy('home')

    def form_valid(self, form):
        location = form.cleaned_data['location']

        if location == forms.NO_MOCKING_ID:
            nodes.flush_session(self.request)
        else:
            node_backend, node_id = nodes_models.Node.parse_full_node_id(location)
            self.request.session[nodes.SESSION_KEY] = node_id
            self.request.session[nodes.BACKEND_SESSION_KEY] = node_backend
            self.request.session[nodes.MOCKING_SESSION_KEY] = True

        return super(LocationView, self).form_valid(form)

    def form_invalid(self, form):
        messages.error(self.request, form.errors)
        return http.HttpResponseRedirect(self.get_success_url())

    def dispatch(self, request, *args, **kwargs):
        if request.user and request.user.is_authenticated() and request.user.is_staff:
            return super(LocationView, self).dispatch(request, *args, **kwargs)
        raise exceptions.PermissionDenied

def upload_view(request):
    if request.method != 'POST':
        return http.HttpResponseBadRequest()

    resource = resources.UploadedFileResource()

    # TODO: Provide some user feedback while uploading

    uploaded_files = []
    for field, files in request.FILES.iterlists():
        for file in files:
            # We let storage decide a name
            filename = storage.default_storage.save('', file)

            uploaded_file = api_models.UploadedFile()
            uploaded_file.author = request.user
            uploaded_file.filename = filename
            uploaded_file.content_type = file.content_type
            uploaded_file.save()

            uploaded_files.append({
                'filename': filename,
                'resource_uri': resource.get_resource_uri(uploaded_file)
            })

    # TODO: Create background task to process uploaded file (check content type (both in GridFS file and UploadedFile document), resize images)

    return resource.create_response(request, uploaded_files, response_class=tastypie_http.HttpAccepted)

@dispatch.receiver(signals.post_created)
@dispatch.receiver(signals.post_updated)
def send_update_on_published_post(sender, post, request, bundle, **kwargs):
    """
    Sends update through push server when a post is published.
    """

    # TODO: Send this only the first time the post is published or every time? When are other cases when "post_updated" is triggered?
    if post.is_published:
        output_bundle = sender.full_dehydrate(bundle)
        output_bundle = sender.alter_detail_data_to_serialize(request, output_bundle)

        serialized_update = sender.serialize(request, {
            'type': 'post_published',
            'post': output_bundle.data,
        }, 'application/json')

        # We send update asynchronously as it could block and we
        # want REST request to finish quick
        tasks.send_update.delay(serialized_update)

@dispatch.receiver(signals.comment_created)
def send_update_on_comment(sender, comment, post, request, bundle, **kwargs):
    """
    Sends update through push server when a comment is made.
    """

    output_bundle = sender.full_dehydrate(bundle)
    output_bundle = sender.alter_detail_data_to_serialize(request, output_bundle)

    serialized_update = sender.serialize(request, {
        'type': 'comment_made',
        'comment': output_bundle.data,
        'post_id': post.id,
    }, 'application/json')

    # We send update asynchronously as it could block and we
    # want REST request to finish quick
    tasks.send_update.delay(serialized_update)

@mongoengine_signals.post_save.connect_via(sender=api_models.Notification)
def send_update_on_new_notification(sender, document, created, **kwargs):
    """
    Sends update through push server to the user when a new notification is created.

    Important: This signal should be processed only asynchronously (background task) as
    it can block. So currently it is assumed that notification documents are created
    only in background tasks.
    """

    if not created:
        return

    notification = document

    def test_if_running_as_celery_worker():
        # Used in tests
        if getattr(settings, 'CELERY_ALWAYS_EAGER', False):
            return True

        for filename, line_number, function_name, text in traceback.extract_stack():
            if 'celery' in filename:
                return True
        return False

    assert test_if_running_as_celery_worker()

    # Dummy request object, it is used in serialization to get JSONP callback name, but we
    # want always just JSON, so we can create dummy object and hopefuly get away with it
    request = client.RequestFactory().request()

    from piplmesh import urls

    bundle = urls.notification_resource.build_bundle(obj=notification, request=request)
    output_bundle = urls.notification_resource.full_dehydrate(bundle)
    output_bundle = urls.notification_resource.alter_detail_data_to_serialize(request, output_bundle)

    serialized = urls.notification_resource.serialize(request, {
        'type': 'notification',
        'notification': output_bundle.data,
    }, 'application/json')
    updates.send_update(notification.recipient.get_user_channel(), serialized, True)

def panels_collapse(request):
    if request.method == 'POST':
        request.user.panels_collapsed[request.POST['name']] = True if request.POST['collapsed'] == 'true' else False
        request.user.save()
        return http.HttpResponse()
    else:
        return http.HttpResponse(simplejson.dumps(request.user.panels_collapsed), mimetype='application/json')

def panels_order(request):
    if request.method == 'POST':
        panels = []

        for name, column in zip(request.POST.getlist('names'), request.POST.getlist('columns')):
            column = int(column)
            if column == len(panels):
                panels.append([])
            panels[column].append(name)

        request.user.panels_order[request.POST['number_of_columns']] = panels
        request.user.save()

        return http.HttpResponse()
    else:
        number_of_columns = request.GET['number_of_columns']
        panels = request.user.panels_order.get(number_of_columns, [])
        return http.HttpResponse(simplejson.dumps(panels), mimetype='application/json')

########NEW FILE########
__FILENAME__ = backends
import copy, random

from . import data

class NodeBackend(object):
    def get_full_name(self):
        return '%s.%s' % (self.__module__, self.__class__.__name__)

class RandomNodesBackend(NodeBackend):
    def get_source_node(self, request):
        """
        Returns a node at random.
        """

        node_id = random.randrange(len(data.nodes))
        node = copy.copy(data.nodes[node_id])
        node.id = node_id
        node.backend = self
        return node

    def get_closest_node(self, request, latitude, longitude):
        """
        Because searching for real closest node is complex,
        it just returns a random node.
        """

        node_id = random.randrange(len(data.nodes))
        node = copy.copy(data.nodes[node_id])
        node.id = node_id
        node.backend = self
        return node

    def get_node(self, node_id):
        try:
            node = copy.copy(data.nodes[int(node_id)])
            node.id = node_id
            node.backend = self
            return node
        except IndexError:
            return None

    def get_all_nodes(self):
        for i, node in enumerate(data.nodes):
            node = copy.copy(node)
            node.id = i
            node.backend = self
            yield node

########NEW FILE########
__FILENAME__ = data
# -*- coding: utf-8 -*-

# Temporary hard-coded data about active wlan slovenija wireless nodes

from . import models

nodes = [
    models.Node(None, 'pekarna-1', 'Ob železnici 16', 46.5507723961, 15.6441316009, 'https://nodes.wlan-si.net/node/pekarna-1/'),
    models.Node(None, 'tdk-13', 'Trg Dušana Kvedra 13', 46.5354454118, 15.6331425905, 'https://nodes.wlan-si.net/node/tdk-13/'),
    models.Node(None, 'postaja-5', 'postaja-5', 45.8640653, 15.0928333, 'https://nodes.wlan-si.net/node/postaja-5/'),
    models.Node(None, 'pestike-22c', 'pestike22c', 46.3486240538, 16.0341539397, 'https://nodes.wlan-si.net/node/pestike-22c/'),
    models.Node(None, 'brilejeva-9', 'Brilejeva 9', 46.0856069557, 14.4722664356, 'https://nodes.wlan-si.net/node/brilejeva-9/'),
    models.Node(None, 'urban-1', 'Urban nad Mariborom', 46.6037895779, 15.6035497785, 'https://nodes.wlan-si.net/node/urban-1/'),
    models.Node(None, 'slatina-59', 'slatina-59', 46.3425, 15.9647, 'https://nodes.wlan-si.net/node/slatina-59/'),
    models.Node(None, 'vareja-mde', 'vareja 2a', 46.3657127, 15.9309187, 'https://nodes.wlan-si.net/node/vareja-mde/'),
    models.Node(None, 'slatina-77-vzhod', 'Slatina 77', 46.3415599652, 15.9706113342, 'https://nodes.wlan-si.net/node/slatina-77-vzhod/'),
    models.Node(None, 'gruskovec-44', 'gruskovec 44', 46.3414515801, 16.0151528122, 'https://nodes.wlan-si.net/node/gruskovec-44/'),
    models.Node(None, 'gruskovec-46', 'gruskovec 46', 46.3424833311, 16.0161323554, 'https://nodes.wlan-si.net/node/gruskovec-46/'),
    models.Node(None, 'rozmanova-12-i', 'Rozmanova 12', 46.0537441268, 14.5170834661, 'https://nodes.wlan-si.net/node/rozmanova-12-i/'),
    models.Node(None, 'fri', 'Tržaška 25', 46.0445688554, 14.4893038273, 'https://nodes.wlan-si.net/node/fri/'),
    models.Node(None, 'bukovje-f', 'bukovje-f', 45.9682882378, 13.5914518833, 'https://nodes.wlan-si.net/node/bukovje-f/'),
    models.Node(None, 'bezena-111', 'Bezena 111', 46.527557007, 15.6675767899, 'https://nodes.wlan-si.net/node/bezena-111/'),
    models.Node(None, 'rozmanova-2-ii', 'Rozmanova 2', 46.0524842492, 14.5169761777, 'https://nodes.wlan-si.net/node/rozmanova-2-ii/'),
    models.Node(None, 'slatina77-jug', 'slatina-77', 46.3414710848, 15.9701607231, 'https://nodes.wlan-si.net/node/slatina77-jug/'),
    models.Node(None, 'hladilniska-26', 'hladilniška', 46.062824, 14.609134, 'https://nodes.wlan-si.net/node/hladilniska-26/'),
    models.Node(None, 'krizisce-e', 'krizisce-e', 45.9653095871, 13.5774114133, 'https://nodes.wlan-si.net/node/krizisce-e/'),
    models.Node(None, 'pekarna-2', 'Ob železnici 16', 46.5509310302, 15.6441396475, 'https://nodes.wlan-si.net/node/pekarna-2/'),
    models.Node(None, 'levstikovtrg-7', 'Levstikov trg 7', 46.0462088801, 14.5065236092, 'https://nodes.wlan-si.net/node/levstikovtrg-7/'),
    models.Node(None, 'trzaska-12', 'Tržaška 12', 46.04639728, 14.4907951355, 'https://nodes.wlan-si.net/node/trzaska-12/'),
    models.Node(None, 'slatina-81', 'slatina-81', 46.3435114823, 15.96774745, 'https://nodes.wlan-si.net/node/slatina-81/'),
    models.Node(None, 'podgorci-novi', 'podgorci', 46.425638455, 16.064441085, 'https://nodes.wlan-si.net/node/podgorci-novi/'),
    models.Node(None, 'kumrovska-9', 'Kumrovška 9', 46.084484, 14.51119, 'https://nodes.wlan-si.net/node/kumrovska-9/'),
    models.Node(None, 'grintovska-22', 'Grintovška 22', 46.0817374492, 14.5109680295, 'https://nodes.wlan-si.net/node/grintovska-22/'),
    models.Node(None, 'infohit-test-1', 'Leskoškova 10, Ljubljana', 46.0661109314, 14.5570081472, 'https://nodes.wlan-si.net/node/infohit-test-1/'),
    models.Node(None, 'slatina-link-urban', 'Slatina 77 ', 46.3419668405, 15.9701514244, 'https://nodes.wlan-si.net/node/slatina-link-urban/'),
    models.Node(None, 'gruskovec-17', 'gruskovec-17', 46.3392443239, 16.0050033333, 'https://nodes.wlan-si.net/node/gruskovec-17/'),
    models.Node(None, 'ilirska-6', 'Ilirska 6', 46.0526592873, 14.5144790411, 'https://nodes.wlan-si.net/node/ilirska-6/'),
    models.Node(None, 'podgorci-streha', 'podgorci', 46.4256532457, 16.0642265083, 'https://nodes.wlan-si.net/node/podgorci-streha/'),
    models.Node(None, 'vojkova-77-ii', 'Vojkova 77', 46.0778304592, 14.5192050934, 'https://nodes.wlan-si.net/node/vojkova-77-ii/'),
    models.Node(None, 'kunaverjeva-8', 'Kunaverjeva 8', 46.0792753794, 14.4771829247, 'https://nodes.wlan-si.net/node/kunaverjeva-8/'),
    models.Node(None, 'gradisca', 'gradisca', 46.3598394488, 15.9659825565, 'https://nodes.wlan-si.net/node/gradisca/'),
    models.Node(None, 'korenjak17a-omni', 'korenjak 17a', 46.3375554907, 16.0327802898, 'https://nodes.wlan-si.net/node/korenjak17a-omni/'),
    models.Node(None, 'maliokic-41-omni', 'maliokic-41', 46.3219434112, 15.9727141861, 'https://nodes.wlan-si.net/node/maliokic-41-omni/'),
    models.Node(None, 'neubergerjeva-3', 'Neubergerjeva 3', 46.06061819, 14.5163968205, 'https://nodes.wlan-si.net/node/neubergerjeva-3/'),
    models.Node(None, 'm5-korenjak17a', 'korenjak 17a', 46.3378369664, 16.0327427389, 'https://nodes.wlan-si.net/node/m5-korenjak17a/'),
    models.Node(None, 'morjea-49', 'Morje 49/a', 46.4440677866, 15.6169024855, 'https://nodes.wlan-si.net/node/morjea-49/'),
    models.Node(None, 'maliokic-41', 'mali okic 41', 46.3219469924, 15.9722321035, 'https://nodes.wlan-si.net/node/maliokic-41/'),
    models.Node(None, 'privoz-17b', 'Privoz 17b', 46.0403525249, 14.5112013817, 'https://nodes.wlan-si.net/node/privoz-17b/'),
    models.Node(None, 'jadranska-2', 'Jadranska 2', 46.044419, 14.487786, 'https://nodes.wlan-si.net/node/jadranska-2/'),
    models.Node(None, 'brezovec-83a', 'brezovec 83a', 46.336132534, 16.0241575248, 'https://nodes.wlan-si.net/node/brezovec-83a/'),
    models.Node(None, 'slatina-40', 'slatina-40', 46.3241311141, 15.9708352096, 'https://nodes.wlan-si.net/node/slatina-40/'),
    models.Node(None, 'ascevi-luwa', 'Števerjan, Italija', 45.9683992252, 13.5797295556, 'https://nodes.wlan-si.net/node/ascevi-luwa/'),
    models.Node(None, 'moravce1', 'Vegova 21', 46.1375899401, 14.7458195686, 'https://nodes.wlan-si.net/node/moravce1/'),
    models.Node(None, 'slatina-4a', 'slatina 4a', 46.332011, 15.9741758, 'https://nodes.wlan-si.net/node/slatina-4a/'),
    models.Node(None, 'slatina-13', 'slatina-13', 46.3287892614, 15.9754607681, 'https://nodes.wlan-si.net/node/slatina-13/'),
    models.Node(None, 'm5-gradisca-slatina', 'gradisca', 46.3595210645, 15.965757251, 'https://nodes.wlan-si.net/node/m5-gradisca-slatina/'),
    models.Node(None, 'sd-cirkulane', 'cirkulane', 46.3423922296, 15.9930889608, 'https://nodes.wlan-si.net/node/sd-cirkulane/'),
    models.Node(None, 'rozmanova-3', 'Rozmanova 3', 46.0518141849, 14.5164906979, 'https://nodes.wlan-si.net/node/rozmanova-3/'),
    models.Node(None, 'glinska-9', 'Glinška 9', 46.0464268183, 14.4898295403, 'https://nodes.wlan-si.net/node/glinska-9/'),
    models.Node(None, 'sadez-3', 'sadež 3', 45.57784, 15.19215, 'https://nodes.wlan-si.net/node/sadez-3/'),
    models.Node(None, 'maliokic-17', 'maliokic-17', 46.333222061, 15.9650062324, 'https://nodes.wlan-si.net/node/maliokic-17/'),
    models.Node(None, 'zaloska-povodni-moz', 'zaloska-povodni-moz', 46.0531849569, 14.5252869129, 'https://nodes.wlan-si.net/node/zaloska-povodni-moz/'),
    models.Node(None, 'slatina77-zahod', 'slatina-77', 46.3419922705, 15.9696732761, 'https://nodes.wlan-si.net/node/slatina77-zahod/'),
    models.Node(None, 'trubarjeva-81-ii', 'Trubarjeva 81', 46.0524477337, 14.515726313, 'https://nodes.wlan-si.net/node/trubarjeva-81-ii/'),
    models.Node(None, 'pristava-34', 'pristava-34', 46.3469377938, 15.9699954987, 'https://nodes.wlan-si.net/node/pristava-34/'),
    models.Node(None, 'trubarjeva-81-i', 'Trubarjeva 81', 46.0523351003, 14.5158778578, 'https://nodes.wlan-si.net/node/trubarjeva-81-i/'),
    models.Node(None, 'scopolijeva-17', 'Scopolijeva 17', 46.0697697673, 14.4870400429, 'https://nodes.wlan-si.net/node/scopolijeva-17/'),
    models.Node(None, 'hrvatskitrg-2', 'Hrvatski trg 2', 46.0524448485, 14.5178934932, 'https://nodes.wlan-si.net/node/hrvatskitrg-2/'),
    models.Node(None, 'ljudmila-1', 'Rimska 8', 46.0475884167, 14.5007756352, 'https://nodes.wlan-si.net/node/ljudmila-1/'),
    models.Node(None, 'agrokombinatska-6', 'agrokombinatska cesta 6', 46.062457, 14.613511, 'https://nodes.wlan-si.net/node/agrokombinatska-6/'),
    models.Node(None, 'adam-in-eva', 'V zavoju 40 B', 46.5751049, 15.6674145, 'https://nodes.wlan-si.net/node/adam-in-eva/'),
    models.Node(None, 'scedno-marj', 'scedno-marj', 45.9711114413, 13.5973012445, 'https://nodes.wlan-si.net/node/scedno-marj/'),
    models.Node(None, 'belacerkev-17', 'bela cerkev, slovenija', 45.867571, 15.276103, 'https://nodes.wlan-si.net/node/belacerkev-17/'),
    models.Node(None, 'pongrce-35', 'pongrce 35', 46.400313651, 15.7034540176, 'https://nodes.wlan-si.net/node/pongrce-35/'),
    models.Node(None, 'scedno-sta', 'Števerjan, Italija', 45.967146413, 13.5981831537, 'https://nodes.wlan-si.net/node/scedno-sta/'),
    models.Node(None, 'eipprova-19', 'Eipprova 19', 46.042880376, 14.5035436749, 'https://nodes.wlan-si.net/node/eipprova-19/'),
    models.Node(None, 'odrga-6', 'Odrga 6', 45.903516, 15.013327, 'https://nodes.wlan-si.net/node/odrga-6/'),
    models.Node(None, 'najami-9', 'Na jami 9', 46.0654223602, 14.4924527407, 'https://nodes.wlan-si.net/node/najami-9/'),
    models.Node(None, 'ribniska-14', 'Ribniška 14', 46.058069, 14.531145, 'https://nodes.wlan-si.net/node/ribniska-14/'),
    models.Node(None, 'trebinjska-4-i', 'Trebinjska 4', 46.0793969971, 14.5186927915, 'https://nodes.wlan-si.net/node/trebinjska-4-i/'),
    models.Node(None, 'vogljevogljanskacesta-50', 'voglje vogljanska cesta 50', 46.2148526006, 14.4300270081, 'https://nodes.wlan-si.net/node/vogljevogljanskacesta-50/'),
    models.Node(None, 'ziherlova-41', 'Ziherlova 41', 46.0417904825, 14.5059603453, 'https://nodes.wlan-si.net/node/ziherlova-41/'),
    models.Node(None, 'pristava-26c', 'Pristava-26c', 46.3394770285, 15.9789537193, 'https://nodes.wlan-si.net/node/pristava-26c/'),
    models.Node(None, 'osojna-pot-3', 'Osojna pot 3', 46.0472893784, 14.5090556145, 'https://nodes.wlan-si.net/node/osojna-pot-3/'),
    models.Node(None, 'maliokic-36', 'mali okic 36', 46.3212454418, 15.9696521773, 'https://nodes.wlan-si.net/node/maliokic-36/'),
    models.Node(None, 'napodrtem-18', 'Na podrtem 18', 46.5334046852, 15.6854376197, 'https://nodes.wlan-si.net/node/napodrtem-18/'),
    models.Node(None, 'zafara-3', 'Zafara 3, Zuzemberk', 45.8329856002, 14.9401187897, 'https://nodes.wlan-si.net/node/zafara-3/'),
    models.Node(None, 'peruzzijeva-14', 'Peruzzijeva 14', 46.0289418711, 14.5313072205, 'https://nodes.wlan-si.net/node/peruzzijeva-14/'),
    models.Node(None, 's56lsb', 'Sentjernejska cesta 17', 45.8016599, 15.1833667, 'https://nodes.wlan-si.net/node/s56lsb/'),
    models.Node(None, 'tbilisijska-118-c', 'Tbilisijska 118', 46.0358354689, 14.4759839773, 'https://nodes.wlan-si.net/node/tbilisijska-118-c/'),
    models.Node(None, 'stantetova-14', 'Stantetova 14', 46.5430264266, 15.626270771, 'https://nodes.wlan-si.net/node/stantetova-14/'),
    models.Node(None, 'kolodvorska-2', 'kolodvorska 2', 45.7051678083, 13.8632333279, 'https://nodes.wlan-si.net/node/kolodvorska-2/'),
    models.Node(None, 'cigaletova-15', 'Cigaletova 15', 46.0568985032, 14.506829381, 'https://nodes.wlan-si.net/node/cigaletova-15/'),
    models.Node(None, 'brezovec-80', 'brezovec ', 46.3416661295, 16.0207843746, 'https://nodes.wlan-si.net/node/brezovec-80/'),
    models.Node(None, 'metelkovamesto-1', 'Masarykova 24', 46.0564095992, 14.5172631741, 'https://nodes.wlan-si.net/node/metelkovamesto-1/'),
    models.Node(None, 'lizikejancar-6-ii', 'ul lizike jancar 6', 46.5649152079, 15.6308841705, 'https://nodes.wlan-si.net/node/lizikejancar-6-ii/'),
    models.Node(None, 'rozmanova-12-ii', 'Rozmanova 12', 46.0538252221, 14.5170432329, 'https://nodes.wlan-si.net/node/rozmanova-12-ii/'),
    models.Node(None, 'trebinjska-4-ii', 'Trebinjska 4', 46.0793988577, 14.5186927915, 'https://nodes.wlan-si.net/node/trebinjska-4-ii/'),
    models.Node(None, 'spodnjapolskava-113', 'Spodnja polskava 113', 46.4119268, 15.6373409, 'https://nodes.wlan-si.net/node/spodnjapolskava-113/'),
    models.Node(None, 'volodjeva-19', 'Volodjeva 19, Maribor', 46.5303227846, 15.6675714254, 'https://nodes.wlan-si.net/node/volodjeva-19/'),
    models.Node(None, 'mose-pijade-8', '8, moše pijade, črnomelj', 45.57894, 15.18578, 'https://nodes.wlan-si.net/node/mose-pijade-8/'),
    models.Node(None, 'jama-36a', 'Jama 36a', 46.202466187, 14.3959679618, 'https://nodes.wlan-si.net/node/jama-36a/'),
    models.Node(None, 'maliokic-4', 'maliokic-4', 46.3403266068, 15.9648935797, 'https://nodes.wlan-si.net/node/maliokic-4/'),
    models.Node(None, 'rozmanova-2-i', 'Rozmanova 2', 46.0524284677, 14.5169091225, 'https://nodes.wlan-si.net/node/rozmanova-2-i/'),
    models.Node(None, 'gerbiceva-49', 'Gerbičeva 49', 46.0397644225, 14.4891268015, 'https://nodes.wlan-si.net/node/gerbiceva-49/'),
    models.Node(None, 'spodnjiporcic-92', 'Spodnji Porčič 92', 46.5944253, 15.8536714, 'https://nodes.wlan-si.net/node/spodnjiporcic-92/'),
    models.Node(None, 'tbilisijska-118', 'tbilisijska-118', 46.0358205728, 14.4759786129, 'https://nodes.wlan-si.net/node/tbilisijska-118/'),
    models.Node(None, 'bavarska-4', 'Bavarska 4, Maribor', 46.5597979426, 15.6458079815, 'https://nodes.wlan-si.net/node/bavarska-4/'),
    models.Node(None, 'zabukovica-129', 'Zabukovica 129', 46.5343032786, 15.8127593994, 'https://nodes.wlan-si.net/node/zabukovica-129/'),
    models.Node(None, 'veljkavlahovica-62', 'Veljka Vlahovića 62', 46.5511205, 15.6765677, 'https://nodes.wlan-si.net/node/veljkavlahovica-62/'),
    models.Node(None, 'zaloska-78a-i', 'Zaloška 78a', 46.055387912, 14.5419528187, 'https://nodes.wlan-si.net/node/zaloska-78a-i/'),
    models.Node(None, 'mozirje-krajnikovo', 'Mozirje Krajnikovo', 46.3428467475, 14.9543344975, 'https://nodes.wlan-si.net/node/mozirje-krajnikovo/'),
    models.Node(None, 'neubergerjeva-16', 'Neubergerjeva 16', 46.0627878, 14.5163637, 'https://nodes.wlan-si.net/node/neubergerjeva-16/'),
    models.Node(None, 'trebinjska-4-iii', 'Trebinjska 4', 46.0793988577, 14.5185345411, 'https://nodes.wlan-si.net/node/trebinjska-4-iii/'),
    models.Node(None, 'marmeljad', 'Šentrupert', 45.9797865849, 15.1007080078, 'https://nodes.wlan-si.net/node/marmeljad/'),
    models.Node(None, 'cigaletova-10', 'Cigaletova 10', 46.0570011, 14.5070264, 'https://nodes.wlan-si.net/node/cigaletova-10/'),
    models.Node(None, 'dvorje', 'Dvorje, Cerklje na Gorenjskem', 46.260814, 14.4878189, 'https://nodes.wlan-si.net/node/dvorje/'),
    models.Node(None, 'podgozdom-25', 'Ulica pod gozdom, Črnomelj', 45.5828735162, 15.1923828722, 'https://nodes.wlan-si.net/node/podgozdom-25/'),
    models.Node(None, 'tovarnarog-3', 'Trubarjeva 72', 46.0518566265, 14.5155519247, 'https://nodes.wlan-si.net/node/tovarnarog-3/'),
    models.Node(None, 'verje', 'Medvode', 46.1467779943, 14.4203710556, 'https://nodes.wlan-si.net/node/verje/'),
    models.Node(None, 'slatina-28home', 'slatina 28', 46.325188629, 15.9763083461, 'https://nodes.wlan-si.net/node/slatina-28home/'),
    models.Node(None, 'trubarjeva-51a', 'Trubarjeva 51a', 46.0527320078, 14.5121535659, 'https://nodes.wlan-si.net/node/trubarjeva-51a/'),
    models.Node(None, 'uklanci-s', 'uklanci-s', 45.9722019827, 13.5781016348, 'https://nodes.wlan-si.net/node/uklanci-s/'),
    models.Node(None, 'gubcevaptuj-23', 'GUBČEVA 23 PTUJ', 46.4154198527, 15.8476817608, 'https://nodes.wlan-si.net/node/gubcevaptuj-23/'),
    models.Node(None, 'pristava-40', 'pristava 40b', 46.3470177, 15.9820304, 'https://nodes.wlan-si.net/node/pristava-40/'),
    models.Node(None, 'velikacolnarska-9-ii', 'Velika čolnarska 9', 46.039579165, 14.5084601641, 'https://nodes.wlan-si.net/node/velikacolnarska-9-ii/'),
    models.Node(None, 'kozarska-19', 'Kozarška 19', 46.041004296, 14.4502750039, 'https://nodes.wlan-si.net/node/kozarska-19/'),
    models.Node(None, 'podkraj-19c', 'Podkraj pri Velenju', 46.3550291836, 15.0979399681, 'https://nodes.wlan-si.net/node/podkraj-19c/'),
    models.Node(None, 'obrezna-1', 'obrežna ulica 1', 46.5575914022, 15.6280946732, 'https://nodes.wlan-si.net/node/obrezna-1/'),
    models.Node(None, 'sketova-6', 'Sketova 6', 46.0577285137, 14.5254144073, 'https://nodes.wlan-si.net/node/sketova-6/'),
    models.Node(None, 'zlatolicje-33', 'zlatolicje 33', 46.4544383953, 15.7805728912, 'https://nodes.wlan-si.net/node/zlatolicje-33/'),
    models.Node(None, 'mire-miheliceve', 'mire-miheliceve', 46.0554417671, 14.5483703167, 'https://nodes.wlan-si.net/node/mire-miheliceve/'),
    models.Node(None, 'naklo', 'naklo', 46.2734009, 14.317259, 'https://nodes.wlan-si.net/node/naklo/'),
    models.Node(None, 'testna', 'cestavkresnice', 46.0718015498, 14.635848999, 'https://nodes.wlan-si.net/node/testna/'),
    models.Node(None, 'hrastje-5a', 'hrastje 5a', 45.8145765, 15.299317, 'https://nodes.wlan-si.net/node/hrastje-5a/'),
    models.Node(None, 's53w', 'kurirčkova 45', 46.5067925724, 15.6934440136, 'https://nodes.wlan-si.net/node/s53w/'),
    models.Node(None, 'ptujskagora', 'Ptujska Gora', 46.5363539, 15.6594465, 'https://nodes.wlan-si.net/node/ptujskagora/'),
    models.Node(None, 'koroska-cesta-1-do-spet-2011', 'Koroška cesta 1', 46.5574290988, 15.6441664696, 'https://nodes.wlan-si.net/node/koroska-cesta-1-do-spet-2011/'),
    models.Node(None, 'mercnikova-1a', 'Merčnikova 1a', 46.0412700418, 14.476954937, 'https://nodes.wlan-si.net/node/mercnikova-1a/'),
    models.Node(None, 'rospoh-25a', 'Rošpoh', 46.5866329442, 15.6347304583, 'https://nodes.wlan-si.net/node/rospoh-25a/'),
    models.Node(None, 'cecovje-27', 'JN76LM', 46.5404967105, 14.9633038044, 'https://nodes.wlan-si.net/node/cecovje-27/'),
    models.Node(None, 'polana1423', 'Murska Sobota - Polana', 46.6795944656, 16.1385726929, 'https://nodes.wlan-si.net/node/polana1423/'),
    models.Node(None, 'podgozd-5', 'Novo mesto', 45.7943396305, 15.1940917969, 'https://nodes.wlan-si.net/node/podgozd-5/'),
    models.Node(None, 'm5-test-nanobrige', 'haloze', 46.3616709851, 16.0131711967, 'https://nodes.wlan-si.net/node/m5-test-nanobrige/'),
    models.Node(None, 'slatina-74', 'slatina-74', 46.3418145099, 15.9727739097, 'https://nodes.wlan-si.net/node/slatina-74/'),
    models.Node(None, 'gradisca-123', 'gradisca', 46.357157, 15.9710645, 'https://nodes.wlan-si.net/node/gradisca-123/'),
    models.Node(None, 'obgozdu-14', 'Ob gozdu 14', 46.4722857725, 15.651140213, 'https://nodes.wlan-si.net/node/obgozdu-14/'),
    models.Node(None, 'velikacolnarska-9-i', 'Velika čolnarska 9', 46.039579165, 14.5084601641, 'https://nodes.wlan-si.net/node/velikacolnarska-9-i/'),
    models.Node(None, 'bezjakova-101', 'bezjakova101', 46.5403125855, 15.5897176266, 'https://nodes.wlan-si.net/node/bezjakova-101/'),
    models.Node(None, 'lili-novy-17-c', 'lili novy', 46.0349603164, 14.4516777992, 'https://nodes.wlan-si.net/node/lili-novy-17-c/'),
    models.Node(None, 'obgozdu-20', 'Ob gozdu 20', 46.5468783353, 15.6598198414, 'https://nodes.wlan-si.net/node/obgozdu-20/'),
    models.Node(None, 'lili-novy-17', 'lili-novy-17', 46.0350422461, 14.4516670704, 'https://nodes.wlan-si.net/node/lili-novy-17/'),
    models.Node(None, 'strazaprioplotnici', 'Straža pri Oplotnici', 46.3804443303, 15.4776334763, 'https://nodes.wlan-si.net/node/strazaprioplotnici/'),
    models.Node(None, 'test-novi-fw-v4', 'stojnci ', 46.3806636598, 15.9721301796, 'https://nodes.wlan-si.net/node/test-novi-fw-v4/'),
    models.Node(None, 'staracesta-52', 'Stara cesta 52', 46.4965606332, 15.6380081177, 'https://nodes.wlan-si.net/node/staracesta-52/'),
    models.Node(None, 'ljubljanskacesta-112', 'ljubljanska cesta 112', 45.8342017, 15.1561234, 'https://nodes.wlan-si.net/node/ljubljanskacesta-112/'),
    models.Node(None, 'stefanova-15-ii', 'Štefanova 15', 46.0537786249, 14.5022857189, 'https://nodes.wlan-si.net/node/stefanova-15-ii/'),
    models.Node(None, 'sernceva-12-2', 'sernčeva ulica 12', 46.5652080507, 15.6377452612, 'https://nodes.wlan-si.net/node/sernceva-12-2/'),
    models.Node(None, 'roznadolina-ii-13', 'Rožna dolina cesta II/13, Ljubljana', 46.0462943304, 14.4837637246, 'https://nodes.wlan-si.net/node/roznadolina-ii-13/'),
    models.Node(None, 'segova-28', 'Šegova 28', 45.7979958, 15.1577231, 'https://nodes.wlan-si.net/node/segova-28/'),
    models.Node(None, 'tovarnarog-2', 'Trubarjeva 72', 46.052104574, 14.5151549578, 'https://nodes.wlan-si.net/node/tovarnarog-2/'),
    models.Node(None, 'kiberpipa', 'Kersnikova 4', 46.0557268633, 14.5040345192, 'https://nodes.wlan-si.net/node/kiberpipa/'),
    models.Node(None, 'gradenje-17', 'Gradenje 17', 45.8728451, 15.2600253, 'https://nodes.wlan-si.net/node/gradenje-17/'),
    models.Node(None, 'luksy', 'Trniče 45b', 46.4500403171, 15.7422494888, 'https://nodes.wlan-si.net/node/luksy/'),
    models.Node(None, 'kidriceva-11', 'Kidričeva 11', 45.7053491263, 13.8668167591, 'https://nodes.wlan-si.net/node/kidriceva-11/'),
    models.Node(None, 'stefanova-15-i', 'Štefanova 15', 46.0537786249, 14.5022857189, 'https://nodes.wlan-si.net/node/stefanova-15-i/'),
    models.Node(None, 'tic-vipava', 'Vipava', 45.8462639586, 13.9622336626, 'https://nodes.wlan-si.net/node/tic-vipava/'),
    models.Node(None, 'bratovbabnik-24', 'Ulica bratov Babnik 24', 46.0758356159, 14.4641876221, 'https://nodes.wlan-si.net/node/bratovbabnik-24/'),
    models.Node(None, 'trebinjska-4-iv', 'Trebinjska 4', 46.0793876944, 14.518455416, 'https://nodes.wlan-si.net/node/trebinjska-4-iv/'),
    models.Node(None, 'osjakobaaljaza', 'Kranj', 46.2564481643, 14.3501129374, 'https://nodes.wlan-si.net/node/osjakobaaljaza/'),
    models.Node(None, 'vojkova-77-i', 'Vojkova 77', 46.0777707961, 14.519162178, 'https://nodes.wlan-si.net/node/vojkova-77-i/'),
    models.Node(None, 'ljubljanska-55a', 'Ljubljanska 55a', 46.4514499583, 15.668335855, 'https://nodes.wlan-si.net/node/ljubljanska-55a/'),
    models.Node(None, 'dunajska-33', 'Dunajska 33', 46.0616778718, 14.5071029663, 'https://nodes.wlan-si.net/node/dunajska-33/'),
    models.Node(None, 'scopolijeva-53', 'Scopolijeva-53', 46.0690108, 14.4858541, 'https://nodes.wlan-si.net/node/scopolijeva-53/'),
    models.Node(None, 'tr3', 'Trg republike 3', 46.0469247457, 14.5066709525, 'https://nodes.wlan-si.net/node/tr3/'),
    models.Node(None, 'nanoska-17', 'Nanoška 17', 46.0431824791, 14.4742298126, 'https://nodes.wlan-si.net/node/nanoska-17/'),
    models.Node(None, 'staracesta-26', 'Stara Cesta 26', 46.2529387524, 14.4846582413, 'https://nodes.wlan-si.net/node/staracesta-26/'),
    models.Node(None, 'solar', 'Trubarjeva 72', 46.0516205913, 14.5151442289, 'https://nodes.wlan-si.net/node/solar/'),
    models.Node(None, 'slatina-54', 'slatina-54', 46.336, 15.96442, 'https://nodes.wlan-si.net/node/slatina-54/'),
    models.Node(None, 'slatina-55', 'slatina-55', 46.3353925225, 15.9676884415, 'https://nodes.wlan-si.net/node/slatina-55/'),
    models.Node(None, 'dravinjskivrh', 'Dravinjski Vrh', 46.4199885, 15.8699813, 'https://nodes.wlan-si.net/node/dravinjskivrh/'),
    models.Node(None, 'kajuhova-ulica-2', 'Kajuhova ulica 2', 45.57661, 15.18575, 'https://nodes.wlan-si.net/node/kajuhova-ulica-2/'),
    models.Node(None, 'stojnci-2222', 'stojnci', 46.3806044485, 15.9720979931, 'https://nodes.wlan-si.net/node/stojnci-2222/'),
    models.Node(None, 'tovarnarog-1', 'Trubarjeva 72', 46.0521380803, 14.5148974657, 'https://nodes.wlan-si.net/node/tovarnarog-1/'),
    models.Node(None, 'uklanci-d', 'Uklanci', 45.9723012797, 13.5747456551, 'https://nodes.wlan-si.net/node/uklanci-d/'),
    models.Node(None, 'berta', 'K brodu 27', 46.5510693736, 15.7046985626, 'https://nodes.wlan-si.net/node/berta/'),
    models.Node(None, 'm5-maliokic', 'mali okic', 46.3221915018, 15.9723715784, 'https://nodes.wlan-si.net/node/m5-maliokic/'),
    models.Node(None, 'gregorciceva-21', 'Gregorčičeva 21b', 46.5611542, 15.6452967, 'https://nodes.wlan-si.net/node/gregorciceva-21/'),
    models.Node(None, 'slatina-77', 'slatina-77', 46.3418414209, 15.9702680114, 'https://nodes.wlan-si.net/node/slatina-77/'),
    models.Node(None, 'brezovec-28a', 'brezovec 28a', 46.3582209773, 16.015624881, 'https://nodes.wlan-si.net/node/brezovec-28a/'),
    models.Node(None, 'maliokic-3', 'maliokic-3', 46.3397480009, 15.9649955036, 'https://nodes.wlan-si.net/node/maliokic-3/'),
    models.Node(None, 'pristava-28', 'pristava-28', 46.3419478304, 15.9761642219, 'https://nodes.wlan-si.net/node/pristava-28/'),
    models.Node(None, 'valerisce-r', 'valerisce-r', 45.967714656, 13.5766875744, 'https://nodes.wlan-si.net/node/valerisce-r/'),
    models.Node(None, 'loke-pri-mozirju', 'Loke pri Mozirju 5a', 46.3330766199, 14.9720692635, 'https://nodes.wlan-si.net/node/loke-pri-mozirju/'),
    models.Node(None, 'korenjak-17home', 'slatina 4a ', 46.3382549801, 16.033939363, 'https://nodes.wlan-si.net/node/korenjak-17home/'),
    models.Node(None, 'devina-11a', 'Devina 11a ', 46.4036911, 15.571223, 'https://nodes.wlan-si.net/node/devina-11a/'),
    models.Node(None, 'rusjanovtrg-2', 'Rusjanov trg 2', 46.0537441268, 14.5638021827, 'https://nodes.wlan-si.net/node/rusjanovtrg-2/'),
    models.Node(None, 'devinska-1', 'Devinska ulica 1', 46.3972715, 15.581594, 'https://nodes.wlan-si.net/node/devinska-1/'),
    models.Node(None, 'urban-uplink', 'Lizike Jančar 6', 46.5650568347, 15.6304764748, 'https://nodes.wlan-si.net/node/urban-uplink/'),
    models.Node(None, 'urban-2', 'Sveti Urban nad Mariborom', 46.6037895779, 15.6035497785, 'https://nodes.wlan-si.net/node/urban-2/'),
    models.Node(None, 'urban-jost', 'Jošt na Urbanu', 46.6038428343, 15.6051027775, 'https://nodes.wlan-si.net/node/urban-jost/'),
    models.Node(None, 'druga', 'Trg Miloša Zidanška 1', 46.5492759, 15.6448708, 'https://nodes.wlan-si.net/node/druga/'),
    models.Node(None, 'bukovje-mart', 'bukovje-mart', 45.969009308, 13.5898425132, 'https://nodes.wlan-si.net/node/bukovje-mart/'),
    models.Node(None, 'm5-slatina77-omni', 'slatina77', 46.3423544548, 15.9704489715, 'https://nodes.wlan-si.net/node/m5-slatina77-omni/'),
    models.Node(None, 'crnekova-12', 'crnekova 12 ', 46.5347395, 15.6349319, 'https://nodes.wlan-si.net/node/crnekova-12/'),
    models.Node(None, 'ljudmila-2', 'Rimska 8', 46.0474878894, 14.5007327199, 'https://nodes.wlan-si.net/node/ljudmila-2/'),
    models.Node(None, 'smarnagora-4-i', 'Gostilna Ledinek, Šmarna gora', 46.1297127136, 14.4637584686, 'https://nodes.wlan-si.net/node/smarnagora-4-i/'),
    models.Node(None, 'vareja-nanostationm5', 'vareja ', 46.3661497346, 15.9321684844, 'https://nodes.wlan-si.net/node/vareja-nanostationm5/'),
    models.Node(None, 'druga-link', 'Trg Miloša Zidanška 1  ', 46.5488639538, 15.6439197063, 'https://nodes.wlan-si.net/node/druga-link/'),
    models.Node(None, 'cestaktamu-12-link', 'Cesta k Tamu 12 ', 46.5276175354, 15.6671905518, 'https://nodes.wlan-si.net/node/cestaktamu-12-link/'),
    models.Node(None, 'laporje-50', 'laporje 50 slovenija', 46.3473719693, 15.5947065353, 'https://nodes.wlan-si.net/node/laporje-50/'),
    models.Node(None, 'slatina-58', 'slatina-58', 46.3414820715, 15.9649150373, 'https://nodes.wlan-si.net/node/slatina-58/'),
    models.Node(None, 'trg-svobode-3', 'trg-svobode-3', 45.570850287, 15.1927612424, 'https://nodes.wlan-si.net/node/trg-svobode-3/'),
    models.Node(None, 'repisce-51', 'repisce-51', 46.344606765, 15.9610043766, 'https://nodes.wlan-si.net/node/repisce-51/'),
    models.Node(None, 'valerisce', 'Števerjan, Italija', 45.9679766527, 13.5790586472, 'https://nodes.wlan-si.net/node/valerisce/'),
    models.Node(None, 'brezovec-85', 'brezovec 85', 46.3365957459, 16.0338964476, 'https://nodes.wlan-si.net/node/brezovec-85/'),
    models.Node(None, 'grm-7', 'Grm pri Podzemlju 7', 45.6163528121, 15.277366162, 'https://nodes.wlan-si.net/node/grm-7/'),
    models.Node(None, 'krizisce-mu', 'Krizisce-mu', 45.9748395746, 13.5850775242, 'https://nodes.wlan-si.net/node/krizisce-mu/'),
    models.Node(None, 'slatina77-sever', 'slatina77b', 46.3423302603, 15.9704825882, 'https://nodes.wlan-si.net/node/slatina77-sever/'),
    models.Node(None, 'driver', 'Celovška 108', 46.0699320348, 14.4898447395, 'https://nodes.wlan-si.net/node/driver/'),
    models.Node(None, 'bukovje-g', 'bukovje-g', 45.9707883139, 13.5879825353, 'https://nodes.wlan-si.net/node/bukovje-g/'),
    models.Node(None, 'm5-podgorci', 'podgorci 6a', 46.4254544343, 16.0643713476, 'https://nodes.wlan-si.net/node/m5-podgorci/'),
    models.Node(None, 'm5-gradisca-panel', 'gradisca', 46.3598690656, 15.9656070473, 'https://nodes.wlan-si.net/node/m5-gradisca-panel/'),
    models.Node(None, 'scedno-zv', 'Scedno', 45.9807485972, 13.5944994094, 'https://nodes.wlan-si.net/node/scedno-zv/'),
    models.Node(None, 'krizisce-m', 'krizisce-m', 45.9739000774, 13.5844445229, 'https://nodes.wlan-si.net/node/krizisce-m/'),
    models.Node(None, 'urban-s59abc', 'urban', 46.6038221953, 15.6034451723, 'https://nodes.wlan-si.net/node/urban-s59abc/'),
    models.Node(None, 'lomanose-44b', 'Lomanoše 44b', 46.6682870739, 15.9466552734, 'https://nodes.wlan-si.net/node/lomanose-44b/'),
    models.Node(None, 'stojnci-20', 'stojnci', 46.3805304337, 15.9718297722, 'https://nodes.wlan-si.net/node/stojnci-20/'),
    models.Node(None, 'smartno-sg', 'Šmartno pri Slovenj gradcu 17', 46.4942488567, 15.1069951057, 'https://nodes.wlan-si.net/node/smartno-sg/'),
    models.Node(None, 'bukovje-st', 'bukovje-st', 45.9702347673, 13.5884406567, 'https://nodes.wlan-si.net/node/bukovje-st/'),
    models.Node(None, 'mariborska-39', 'Ptuj', 46.4157615803, 15.8564016223, 'https://nodes.wlan-si.net/node/mariborska-39/'),
    models.Node(None, 'beblerjevtrg-1', 'Beblerjev trg 1', 46.0707594922, 14.547239542, 'https://nodes.wlan-si.net/node/beblerjevtrg-1/'),
    models.Node(None, 'tesna-tocka', 'Slovenska Bistrica', 46.3422191607, 15.5921516474, 'https://nodes.wlan-si.net/node/tesna-tocka/'),
    models.Node(None, 'uklanci-m', 'uklanci-m', 45.9722935437, 13.5821539164, 'https://nodes.wlan-si.net/node/uklanci-m/'),
    models.Node(None, 'brezovec-39', 'brezovec 39', 46.3471172048, 16.0176944698, 'https://nodes.wlan-si.net/node/brezovec-39/'),
    models.Node(None, 'slatina-28', 'slatina 28', 46.325188629, 15.9763083461, 'https://nodes.wlan-si.net/node/slatina-28/'),
    models.Node(None, 'zaloska-78a-ii', 'Zaloška 78a', 46.0554028028, 14.5419622064, 'https://nodes.wlan-si.net/node/zaloska-78a-ii/'),
    models.Node(None, 'pestike-26b', 'pestike 26', 46.3508566038, 16.0394997604, 'https://nodes.wlan-si.net/node/pestike-26b/'),
    models.Node(None, 'kolodvorska-34', 'Kolodvorska 34, Črnomelj', 45.575225217, 15.1905723811, 'https://nodes.wlan-si.net/node/kolodvorska-34/'),
    models.Node(None, 'drecji', 'Drecji vrh', 45.9213222, 15.1701489, 'https://nodes.wlan-si.net/node/drecji/'),
    models.Node(None, 'regenta-15', 'regenta-15', 46.6537665633, 16.1639356613, 'https://nodes.wlan-si.net/node/regenta-15/'),
    models.Node(None, 'zubina-7', 'zubina 7', 45.9474377, 14.9148863, 'https://nodes.wlan-si.net/node/zubina-7/'),
    models.Node(None, 'maliokic-36home', 'mali okič 36', 46.3212454418, 15.9696521773, 'https://nodes.wlan-si.net/node/maliokic-36home/'),
    models.Node(None, 'zaloska-povodni-moz-ii', 'zaloska-povodni-moz-ii', 46.0531874388, 14.5251166821, 'https://nodes.wlan-si.net/node/zaloska-povodni-moz-ii/'),
    models.Node(None, 'scedno-mit', 'scedno-mit', 45.9804975959, 13.595414579, 'https://nodes.wlan-si.net/node/scedno-mit/'),
    models.Node(None, 'nm-stranska-vas', 'Stranska vas 36a, 8000 Novo mesto', 45.7623960984, 15.1724785566, 'https://nodes.wlan-si.net/node/nm-stranska-vas/'),
    models.Node(None, 'serncevaulica-12', 'sernčeva ulica 12', 46.5652080507, 15.6377452612, 'https://nodes.wlan-si.net/node/serncevaulica-12/'),
    models.Node(None, 'zitna-12', 'Zitna 12', 46.548767294, 15.6430077553, 'https://nodes.wlan-si.net/node/zitna-12/'),
    models.Node(None, 'beograjska-31', 'Beograjska 31, Maribor', 46.5436894614, 15.6401136518, 'https://nodes.wlan-si.net/node/beograjska-31/'),
    models.Node(None, 'martinakrpana-5', 'Martina Krpana 5', 46.0726500679, 14.4833278656, 'https://nodes.wlan-si.net/node/martinakrpana-5/'),
    models.Node(None, 'lotmerk-hotel-1', 'Glavni trg 15, Ljutomer', 46.5179852193, 16.1968973279, 'https://nodes.wlan-si.net/node/lotmerk-hotel-1/'),
    models.Node(None, 'blejskadobrava16f', 'Blejska Dobrava', 46.4111443788, 14.0959525108, 'https://nodes.wlan-si.net/node/blejskadobrava16f/'),
    models.Node(None, 's50rm', 'Aškerčeva 24', 46.5644644, 15.6542585, 'https://nodes.wlan-si.net/node/s50rm/'),
    models.Node(None, 'oplotnica', 'partizanska cesta', 46.3906983456, 15.4513878829, 'https://nodes.wlan-si.net/node/oplotnica/'),
    models.Node(None, 'metelkovamesto-2', 'Masarykova 24', 46.0564529058, 14.5171035826, 'https://nodes.wlan-si.net/node/metelkovamesto-2/'),
    models.Node(None, 'lavriceva-16', 'Lavričeva 16', 46.5583682, 15.6357111, 'https://nodes.wlan-si.net/node/lavriceva-16/'),
    models.Node(None, 'bukovje-t', 'Bukovje', 45.9697429836, 13.5894870758, 'https://nodes.wlan-si.net/node/bukovje-t/'),
    models.Node(None, 'partizanskamaribor-57', 'partizanska 57 maribor', 46.5631379, 15.6577792, 'https://nodes.wlan-si.net/node/partizanskamaribor-57/'),
    models.Node(None, 'tocka1-crnomelj', 'Ulica pod gozdom 25, Črnomelj', 45.58183, 15.1925, 'https://nodes.wlan-si.net/node/tocka1-crnomelj/'),
    models.Node(None, 'kozarcan', 'kozarcan', 46.3418071032, 15.9740291836, 'https://nodes.wlan-si.net/node/kozarcan/'),
    models.Node(None, 'tehnoloskipark-21', 'tehnološki park 21', 46.049445099, 14.4601750374, 'https://nodes.wlan-si.net/node/tehnoloskipark-21/'),
    models.Node(None, 'smarnagora-4-ii', 'Gostilna Ledinek, Šmarna gora', 46.129584639, 14.4638335705, 'https://nodes.wlan-si.net/node/smarnagora-4-ii/'),
    models.Node(None, 'scedno-nem', 'scedno-nem', 45.9697523669, 13.5981220008, 'https://nodes.wlan-si.net/node/scedno-nem/'),
    models.Node(None, 'pohorje-s55umx', 'rače', 46.5164851056, 15.5919599533, 'https://nodes.wlan-si.net/node/pohorje-s55umx/'),
    models.Node(None, 'slatina-78', 'Slatina 78', 46.3424783932, 15.9705684189, 'https://nodes.wlan-si.net/node/slatina-78/'),
    models.Node(None, 'uklanci-j', 'uklanci-j', 45.97183611, 13.5785059333, 'https://nodes.wlan-si.net/node/uklanci-j/'),
    models.Node(None, 'seljakovo-naselje', 'Seljakovo naselje 50', 46.2285319, 14.3416032, 'https://nodes.wlan-si.net/node/seljakovo-naselje/'),
    models.Node(None, 'pohorje-s55umx-link', 'Pohorje nad Lukejom', 46.5164555735, 15.5926465988, 'https://nodes.wlan-si.net/node/pohorje-s55umx-link/'),
    models.Node(None, 'korenjak-17', 'korenjak 17', 46.3384786767, 16.0336861614, 'https://nodes.wlan-si.net/node/korenjak-17/'),
    models.Node(None, 'urban-link-slatina', 'Sveti Urban nad Mariborom', 46.6037195521, 15.603646338, 'https://nodes.wlan-si.net/node/urban-link-slatina/'),
    models.Node(None, 'lizikejancar-6', 'Lizike Jančar 6', 46.5650568347, 15.6304764748, 'https://nodes.wlan-si.net/node/lizikejancar-6/'),
    models.Node(None, 'sobetinci-25', 'Sobetinci 25', 46.4038612471, 15.9714657068, 'https://nodes.wlan-si.net/node/sobetinci-25/'),
]
########NEW FILE########
__FILENAME__ = models
from piplmesh import nodes

NODE_ID_SEPARATOR = '-'

class Node(object):
    def __init__(self, id, name, location, latitude, longitude, url):
        self.id = id
        self.name = name
        self.location = location
        self.latitude = latitude
        self.longitude = longitude
        self.url = url

        self._outside_request = False

    def is_outside_request(self):
        return self._outside_request

    def is_inside_request(self):
        return not self._outside_request

    def get_full_node_id(self):
        return '%s%s%s' % (self.backend.get_full_name(), NODE_ID_SEPARATOR, self.id)

    @classmethod
    def parse_full_node_id(cls, full_node_id):
        return full_node_id.split(NODE_ID_SEPARATOR, 1)

########NEW FILE########
__FILENAME__ = tests
from django.test import client, utils

from tastypie_mongoengine import test_runner

from piplmesh import nodes

@utils.override_settings(NODES_BACKENDS=('piplmesh.nodes.backends.RandomNodesBackend',))
class BasicTest(test_runner.MongoEngineTestCase):
    def setUp(self):
        self.factory = client.RequestFactory()

    def test_get_node(self):
        request = self.factory.get('/')
        request.session = {}

        node1 = nodes.get_node(request)
        self.assertNotEqual(node1, None)

        node2 = nodes.get_node(request)
        self.assertEqual(node1.id, node2.id)

########NEW FILE########
__FILENAME__ = base
import collections

from django.template import loader

from . import exceptions

class BasePanel(object):
    template = None
    name = None
    dependencies = ()

    def __init__(self):
        # To prevent import cycle
        from . import panels_pool

        for dependency in self.get_dependencies():
            if not panels_pool.panels_pool.has_panel(dependency):
                raise exceptions.PanelDependencyNotRegistered("Panel '%s' depends on panel '%s', but the latter is not registered" % (self.get_name(), dependency))

    @classmethod
    def get_name(cls):
        if cls.name:
            return cls.name

        # TODO: This removes Panel everywhere, not just when a suffix
        return cls.__name__.replace('Panel', '').lower()

    @classmethod
    def get_dependencies(cls):
        return cls.dependencies

    def get_template(self):
        templates = []

        if self.template:
            if isinstance(self.template, collections.Iterable):
                templates.extend(self.template)
            else:
                templates.append(self.template)

        templates.append('panel/%s/panel.html' % (self.get_name()))
        templates.append('panel/panel.html')

        return templates

    def get_context(self, context):
        context.update({
            'name': self.get_name()
        })
        
        return context

    def render(self, request, context):
        try:
            self.request = request
            template = self.get_template()
            context.update(self.get_context({}))
            try:
                return loader.render_to_string(template, context)
            finally:
                context.pop()
        finally:
            self.request = None

########NEW FILE########
__FILENAME__ = models
import mongoengine

class BicikeljStation(mongoengine.Document):
    station_id = mongoengine.IntField(required=True, unique_with=('timestamp', 'fetch_time'))
    timestamp = mongoengine.DateTimeField(required=True, unique_with=('station_id', 'fetch_time'))
    fetch_time = mongoengine.DateTimeField(required=True, unique_with=('station_id', 'timestamp'))
    name = mongoengine.StringField(required=True)
    address = mongoengine.StringField(required=True)
    location = mongoengine.GeoPointField(required=True)
    open = mongoengine.BooleanField(required=True)
    available = mongoengine.IntField(required=True)
    free = mongoengine.IntField(required=True)
    total = mongoengine.IntField(required=True)

    meta = {
        'indexes': ['station_id', 'timestamp', 'fetch_time'],
    }

########NEW FILE########
__FILENAME__ = panel
from django.utils.translation import ugettext_lazy as _

from piplmesh import panels

from . import stations

class BicikeljPanel(panels.BasePanel):
    def get_context(self, context):
        context.update({
            'header': _("Bicikelj stations"),
            # We convert iterator to list so that content is available when testing
            'stations': list(stations.get_stations_nearby(self.request.node.latitude, self.request.node.longitude)),
        })
        return context

panels.panels_pool.register(BicikeljPanel)
########NEW FILE########
__FILENAME__ = stations
import datetime, urllib2

from lxml import objectify

from django.conf import settings
from django.utils import timezone

from . import models

BICIKELJ_STATIONS_URL = 'http://www.bicikelj.si/service/carto'
BICIKELJ_INFO_URL = 'http://www.bicikelj.si/service/stationdetails/ljubljana/%d'
POLL_BICIKELJ_INTERVAL = 60 # seconds
STALE_DATA_TIME = 10 * POLL_BICIKELJ_INTERVAL

# Formula to calculate map bounds so that we can query only stations visible on the map
#
# BOUNDS_LATITUDE and BOUNDS_LONGITUDE are the distance between a node and top location
# of the map, and the distance between a node and leftmost location of the map, respectively
# BOUNDS_LATITUDE = map_height * 0.703119412486786 / 2 ^ map_zoom
# BOUNDS_LONGITUDE = map_width * 0.703119412486786 / 2 ^ map_zoom

BICIKELJ_BOUNDS_LATITUDE = 0.00557895
BICIKELJ_BOUNDS_LONGITUDE = 0.00557895

# TODO: Check if some stations nearby have data older than STALE_DATA_TIME, then display just their names, without current state information
def get_stations_nearby(latitude, longitude):
    stations_nearby_all = models.BicikeljStation.objects(
        location__near=(latitude, longitude),
        location__within_box=((latitude - BICIKELJ_BOUNDS_LATITUDE, longitude - BICIKELJ_BOUNDS_LONGITUDE), (latitude + BICIKELJ_BOUNDS_LATITUDE, longitude + BICIKELJ_BOUNDS_LONGITUDE)),
        fetch_time__gt=timezone.now() - datetime.timedelta(seconds=STALE_DATA_TIME),
    )
    if not stations_nearby_all:
        return
    newest_station = stations_nearby_all[0]
    for station in stations_nearby_all[1:]:
        if station.station_id != newest_station.station_id:
            newest_station.old_data = newest_station.fetch_time < timezone.now() - datetime.timedelta(seconds=2 * POLL_BICIKELJ_INTERVAL)
            yield newest_station
            newest_station = station
        # timestamp changes even if there is no change in stands availability and even if there is a change
        # in stands availability, it happens that timestamp does not change, so we use also fetch time
        elif station.timestamp > newest_station.timestamp:
            newest_station = station
        elif station.timestamp == newest_station.timestamp and station.fetch_time > newest_station.fetch_time:
            newest_station = station
    newest_station.old_data = newest_station.fetch_time < timezone.now() - datetime.timedelta(seconds=2 * POLL_BICIKELJ_INTERVAL)
    yield newest_station

def fetch_data():
    stations_tree = objectify.parse(urllib2.urlopen(BICIKELJ_STATIONS_URL)).getroot()
    for node in stations_tree.markers.marker:
        info_tree = objectify.parse(urllib2.urlopen(BICIKELJ_INFO_URL % int(node.attrib['number']))).getroot()
        yield {
            'station_id': int(node.attrib['number']),
            'name': node.attrib['name'],
            'address': node.attrib['address'],
            'location': (float(node.attrib['lat']), float(node.attrib['lng'])),
            'available': int(info_tree.available),
            'free': int(info_tree.free),
            'total': int(info_tree.total),
            'open': bool(info_tree.open),
        }, datetime.datetime.utcfromtimestamp(int(info_tree.updated)), timezone.now()

########NEW FILE########
__FILENAME__ = tasks
import datetime

from celery import task

from . import models, stations
from piplmesh.utils import decorators

def equal(station_dict, station_object):
    for key in station_dict.keys():
        a = getattr(station_object, key)
        b = station_dict[key]
        if isinstance(a, list):
            a = tuple(a)
        if a != b:
            return False
    return True

@task.periodic_task(run_every=datetime.timedelta(seconds=stations.POLL_BICIKELJ_INTERVAL))
@decorators.single_instance_task(timeout=10 * stations.POLL_BICIKELJ_INTERVAL) # Maximum time for one task to finish is 10x the interval
def update_station_info():
    for station, timestamp, fetch_time in stations.fetch_data():
        try:
            newest_entry = models.BicikeljStation.objects(station_id=station['station_id']).order_by('-timestamp', '-fetch_time')[0]
            if equal(station, newest_entry):
                newest_entry.fetch_time = fetch_time
                newest_entry.save()
                continue
        except IndexError:
            pass

        new_entry = models.BicikeljStation.objects.create(
            timestamp=timestamp,
            fetch_time=fetch_time,
            **station
        )
        # TODO: Send an update to clients

########NEW FILE########
__FILENAME__ = tests
import itertools

from django import template
from django.test import client, signals
from django.utils import functional

from tastypie_mongoengine import test_runner

from . import models, panel, tasks
from piplmesh import nodes

class BasicTest(test_runner.MongoEngineTestCase):
    @classmethod
    def setUpClass(cls):
        super(BasicTest, cls).setUpClass()

        # We fetch data, store it away, and delete
        tasks.update_station_info()
        cls._bicikelj_data = list(models.BicikeljStation.objects())
        models.BicikeljStation.drop_collection()

        for d in cls._bicikelj_data:
            # So that data can be reinserted
            d.pk = None

    def setUp(self):
        self.factory = client.RequestFactory()

        models.BicikeljStation.objects.insert(self._bicikelj_data, load_bulk=False, safe=True)

    def test_bicikelj(self):
        node = next(itertools.islice(nodes.get_all_nodes(), 12, 13))

        self.assertEqual(node.name, 'fri')

        request = self.factory.get('/')
        request.session = {
            nodes.SESSION_KEY: node.id,
            nodes.BACKEND_SESSION_KEY: node.backend.get_full_name(),
        }
        request.node = nodes.get_node(request)

        self.assertEqual(node.id, request.node.id)

        context = template.RequestContext(request)

        data = {}

        def store_rendered_templates(signal, sender, template, context, **kwargs):
            for d in context.dicts:
                for e in d.dicts:
                    data.update(e)

        signals.template_rendered.connect(store_rendered_templates, dispatch_uid="template-render")

        try:
            panel.BicikeljPanel().render(request, context)
        finally:
            signals.template_rendered.disconnect(dispatch_uid="template-render")

        self.assertEqual(len(data['stations']), 1)

########NEW FILE########
__FILENAME__ = panel
import random

from django.conf import settings
from django.contrib.webdesign import lorem_ipsum
from django.utils.translation import ugettext_lazy as _

from piplmesh import panels

class DummyPanel(panels.BasePanel):
    def get_context(self, context):
        context = super(DummyPanel, self).get_context(context)

        context.update({
            'header': _("Dummy panel"),
            'content': '\n\n'.join(lorem_ipsum.paragraphs(random.randint(1, 1))),
        })
        return context

if settings.DEBUG:
    panels.panels_pool.register(DummyPanel)

########NEW FILE########
__FILENAME__ = exceptions
class PanelAlreadyRegistered(Exception):
    pass

class PanelNotRegistered(Exception):
    pass

class PanelHasInvalidBase(Exception):
    pass

class PanelDependencyNotRegistered(Exception):
    pass

########NEW FILE########
__FILENAME__ = updatehoroscope
from django.core.management import base

from piplmesh.panels.horoscope import tasks

class Command(base.BaseCommand):
    help = 'Force horoscopes update.'

    def handle(self, *args, **options):
        """
        Forces horoscopes update.
        """

        verbosity = int(options['verbosity'])

        if verbosity > 1:
            self.stdout.write("Updating horoscopes...\n")

        tasks.update_horoscope.delay().wait()

        if verbosity > 1:
            self.stdout.write("Successfully updated all horoscopes.\n")

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

import mongoengine

HOROSCOPE_SIGNS = (
    ('aries', _("Aries")),
    ('pisces', _("Pisces")),
    ('taurus', _("Taurus")),
    ('gemini', _("Gemini")),
    ('cancer', _("Cancer")),
    ('leo', _("Leo")),
    ('virgo', _("Virgo")),
    ('libra', _("Libra")),
    ('scorpio', _("Scorpio")),
    ('sagittarius', _("Sagittarius")),
    ('capricorn', _("Capricorn")),
    ('aquarius', _("Aquarius")),
)

HOROSCOPE_SIGNS_DICT = dict(HOROSCOPE_SIGNS)

class Horoscope(mongoengine.Document):
    date = mongoengine.DateTimeField(required=True, unique_with=('language', 'sign'))
    language = mongoengine.StringField(choices=settings.LANGUAGES, required=True, unique_with=('date', 'sign'))
    sign = mongoengine.StringField(choices=HOROSCOPE_SIGNS, required=True, unique_with=('date', 'language'))
    forecast = mongoengine.StringField(required=True)
    
    meta = {
        'indexes': ['date', 'language', 'sign'],
    }
########NEW FILE########
__FILENAME__ = panel
import datetime

from django.utils import timezone, translation
from django.utils.translation import ugettext_lazy as _

from piplmesh import panels

from . import models, providers

HOROSCOPE_OBSOLETE = 2 # days

class HoroscopePanel(panels.BasePanel):
    def get_context(self, context):
        context = super(HoroscopePanel, self).get_context(context)
        user = self.request.user

        context.update({
            'header': _("Today's horoscope"),
        })

        if not user.birthdate:
            context.update({
                'error_birthdate': True,
            })
            return context

        try:
            provider = providers.get_provider(translation.get_language())
        except KeyError:
            context.update({
                'error_language': True,
            })
            return context

        user_sign = providers.get_horoscope_sign(user.birthdate.day, user.birthdate.month)

        try:
            horoscope = models.Horoscope.objects(
                language=translation.get_language(),
                sign=user_sign,
            ).order_by('-date').first()
        except models.Horoscope.DoesNotExist:
            context.update({
                'error_data': True,
            })
            return context
        
        if horoscope is None:
            context.update({
                'error_data': True,
            })
            return context

        if timezone.now() > horoscope.date + datetime.timedelta(days=HOROSCOPE_OBSOLETE):
            context.update({
                'error_obsolete': True,
            })
            return context

        context.update({
            'horoscope_forecast': horoscope.forecast,
            'horoscope_sign': models.HOROSCOPE_SIGNS_DICT[user_sign],
            'horoscope_date': horoscope.date,
            'horoscope_source_name': provider.get_source_name(),
            'horoscope_source_url': provider.get_source_url(),
        })

        return context

panels.panels_pool.register(HoroscopePanel)

########NEW FILE########
__FILENAME__ = providers
import datetime, re

from lxml import etree, html

PATTERN_DATE_EN = re.compile(r'(\w+)\s+(\d+),\s+(\d+)$')
PATTERN_DATE_SI = re.compile(r'(\d+).\s+(\w+):\s+$')

def get_horoscope_sign(day, month):
    """
    Based on date, returns horoscope sign key.
    """

    if month == 3:
        if day > 20:
            return 'aries'
        else:
            return 'pisces'
    elif month == 4:
        if day > 20:
            return 'taurus'
        else:
            return 'aries'
    elif month == 5:
        if day > 21:
            return 'gemini'
        else:
            return 'taurus'
    elif month == 6:
        if day > 21:
            return 'cancer'
        else:
            return 'gemini'
    elif month == 7:
        if day > 23:
            return 'leo'
        else:
            return 'cancer'
    elif month == 8:
        if day > 23:
            return 'virgo'
        else:
            return 'leo'
    elif month == 9:
        if day > 23:
            return 'libra'
        else:
            return 'virgo'
    elif month == 10:
        if day > 23:
            return 'scorpio'
        else:
            return 'libra'
    elif month == 11:
        if day > 22:
            return 'sagittarius'
        else:
            return 'scorpio'
    elif month == 12:
        if day > 22:
            return 'capricorn'
        else:
            return 'sagittarius'
    elif month == 1:
        if day < 20:
            return 'aquarius'
        else:
            return 'capricorn'
    elif month == 2:
        if day > 19:
            return 'pisces'
        else:
            return 'aquarius'

def get_all_providers():
    """
    Returns all available horoscope providers.
    """

    return HOROSCOPE_PROVIDERS

def get_provider(language):
    """
    Returns an instance of the horoscope provider for requested language, or raises ``KeyError`` if it does not exist.
    """

    for horoscope in get_all_providers():
        if horoscope.get_language() == language:
            return horoscope

    raise KeyError("Unsupported language: '%s'" % language)

def get_supported_languages():
    """
    Returns a list of supported languages (their language codes).

    That is, a list of languages provided by defined horoscope providers.
    """

    languages = []
    for horoscope in get_all_providers():
        language = horoscope.get_language()
        assert language not in languages, language
        languages.append(language)
    return languages

class HoroscopeProviderBase(object):
    """
    Base class for horoscope providers.
    """

    language = None
    source_name = None
    source_url = None

    def get_language(self):
        """
        Returns provider's language.
        """

        return self.language

    def get_source_name(self):
        """
        Returns provider's source name.
        """

        return self.source_name

    def get_source_url(self):
        """
        Returns provider's source URL.
        """

        return self.source_url

    def fetch_data(self, sign):
        return NotImplementedError

class EnglishHoroscope(HoroscopeProviderBase):
    """
    Daily English horoscope from http://findyourfate.com/.
    """

    language = 'en'
    source_name = 'Find your fate'
    source_url = 'http://findyourfate.com/'

    provider_sign_names = {
        'aries': 'Aries',
        'pisces': 'Pisces',
        'taurus': 'Taurus',
        'gemini': 'Gemini',
        'cancer': 'Cancer',
        'leo': 'Leo',
        'virgo': 'Virgo',
        'libra': 'Libra',
        'scorpio': 'Scorpio',
        'sagittarius': 'Sagittarius',
        'capricorn': 'Capricorn',
        'aquarius': 'Aquarius',
    }
    
    provider_month_names = {
        'January': 1,
        'February': 2,
        'March': 3,
        'April': 4,
        'May': 5,
        'June': 6,
        'July': 7,
        'August': 8,
        'September': 9,
        'October': 10,
        'November': 11,
        'December': 12,
    }

    def fetch_data(self, sign):
        horoscope_url = '%srss/dailyhoroscope-feed.asp?sign=%s' % (self.source_url, self.provider_sign_names[sign])
        horoscope_tree = etree.parse(horoscope_url)

        date_string = PATTERN_DATE_EN.search(horoscope_tree.findtext('.//item/title'))

        return {
            # TODO: date should be stored in correct timezone (currently it is in UTC which probably is not correct)
            'date': datetime.date(int(date_string.group(3)), self.provider_month_names[date_string.group(1)], int(date_string.group(2))),
            'forecast': horoscope_tree.findtext('.//item/description'),
        }

class SlovenianHoroscope(HoroscopeProviderBase):
    """
    Daily Slovenian horoscope from http://slovenskenovice.si/.
    """

    language = 'sl'
    source_name = 'Slovenske novice'
    source_url = 'http://www.slovenskenovice.si/'

    provider_sign_names = {
        'aries': 'oven',
        'pisces': 'ribi',
        'taurus': 'bik',
        'gemini': 'dvojcka',
        'cancer': 'rak',
        'leo': 'lev',
        'virgo': 'devica',
        'libra': 'tehtnica',
        'scorpio': 'skorpijon',
        'sagittarius': 'strelec',
        'capricorn': 'kozorog',
        'aquarius': 'vodnar',
    }

    provider_month_names = {
        'januar': 1,
        'februar': 2,
        'marec': 3,
        'april': 4,
        'maj': 5,
        'junij': 6,
        'julij': 7,
        'avgust': 8,
        'september': 9,
        'oktober': 10,
        'november': 11,
        'december': 12,
    }

    def fetch_data(self, sign):
        horoscope_url = '%slifestyle/astro/%s' % (self.source_url, self.provider_sign_names[sign])
        html_parser = html.HTMLParser(encoding='utf-8')
        horoscope_tree = html.parse(horoscope_url, html_parser)

        date_parsed = PATTERN_DATE_SI.search(horoscope_tree.findtext('.//div[@id="horoscope-sign-right"]//div[@class="view-content"]//span'))

        return {
            # TODO: .year could be the wrong value around new year
            # TODO: date should be stored in correct timezone (currently it is in UTC which probably is not correct)
            'date': datetime.date(datetime.datetime.now().year, self.provider_month_names[date_parsed.group(2)], int(date_parsed.group(1))),
            'forecast': horoscope_tree.findtext('.//div[@id="horoscope-sign-right"]//div[@class="view-content"]//strong'),
        }

HOROSCOPE_PROVIDERS = (
    EnglishHoroscope(),
    SlovenianHoroscope(),
)

########NEW FILE########
__FILENAME__ = tasks
from celery import task
from celery.task import schedules

from . import models, providers
from piplmesh.utils import decorators

CHECK_FOR_NEW_HOROSCOPE = 6 # am every day

@task.periodic_task(run_every=schedules.crontab(hour=CHECK_FOR_NEW_HOROSCOPE))
@decorators.single_instance_task()
def update_horoscope():
    """
    Task which updates horoscopes for all supported languages.

    Old horoscopes are left in the database.
    """

    for horoscope_provider in providers.get_all_providers():
        for sign in models.HOROSCOPE_SIGNS_DICT:
            horoscope_data = horoscope_provider.fetch_data(sign)

            models.Horoscope.objects(date=horoscope_data['date'], language=horoscope_provider.get_language(), sign=sign).update(set__forecast=horoscope_data['forecast'], upsert=True)
########NEW FILE########
__FILENAME__ = tests
import datetime

from django import template
from django.contrib import auth
from django.test import client, signals
from django.utils import functional, translation

from tastypie_mongoengine import test_runner

from . import models, panel, providers, tasks

class BasicTest(test_runner.MongoEngineTestCase):
    @classmethod
    def setUpClass(cls):
        super(BasicTest, cls).setUpClass()

        # We fetch data, store it away, and delete
        tasks.update_horoscope()
        cls._horoscope_data = list(models.Horoscope.objects())
        models.Horoscope.drop_collection()

        for d in cls._horoscope_data:
            # So that data can be reinserted
            d.pk = None

        # So that django_browserid logging does not complain when doing auth.authenticate
        import logging
        logging.disable(logging.CRITICAL)

    def setUp(self):
        self.factory = client.RequestFactory()
        self.language = translation.get_language()

        models.Horoscope.objects.insert(self._horoscope_data, load_bulk=False, safe=True)

    def tearDown(self):
        translation.activate(self.language)

    def _request(self):
        request = self.factory.get('/')
        request.session = {}
        request.user = auth.authenticate(request=request)
        return request

    def _render(self, request):
        context = template.RequestContext(request)

        data = {}
        on_template_render = functional.curry(client.store_rendered_templates, data)
        signals.template_rendered.connect(on_template_render, dispatch_uid='template-render')

        try:
            rendered = panel.HoroscopePanel().render(request, context)
        finally:
            signals.template_rendered.disconnect(dispatch_uid='template-render')

        return data, rendered

    def test_horoscope_esperanto(self):
        # We assume here that we do not have horoscope in Esperanto

        translation.activate('eo')

        request = self._request()

        request.user.birthdate = datetime.date(1990, 1, 1)
        request.user.save()

        data, rendered = self._render(request)

        try:
            self.assertEqual(data['context']['error_language'], True)
        except KeyError:
            print data, rendered
            raise

    def test_horoscope_slovenian(self):
        translation.activate('sl')

        request = self._request()
        data, rendered = self._render(request)

        try:
            self.assertEqual(data['context']['error_birthdate'], True)
        except KeyError:
            print data, rendered
            raise

        # TODO: Go over all signs
        request.user.birthdate = datetime.date(1990, 1, 1)
        request.user.save()

        data, rendered = self._render(request)

        try:
            self.assertEqual(translation.force_unicode(data['context']['horoscope_source_url']), providers.get_provider('sl').get_source_url())
            self.assertEqual(translation.force_unicode(data['context']['horoscope_sign']), translation.force_unicode(models.HOROSCOPE_SIGNS_DICT['aquarius']))
        except KeyError:
            print data, rendered
            raise

    def test_horoscope_english(self):
        translation.activate('en')

        request = self._request()
        data, rendered = self._render(request)

        try:
            self.assertEqual(data['context']['error_birthdate'], True)
        except KeyError:
            print data, rendered
            raise

        # TODO: Go over all signs
        request.user.birthdate = datetime.date(1990, 1, 1)
        request.user.save()

        data, rendered = self._render(request)

        try:
            self.assertEqual(translation.force_unicode(data['context']['horoscope_source_url']), providers.get_provider('en').get_source_url())
            self.assertEqual(translation.force_unicode(data['context']['horoscope_sign']), translation.force_unicode(models.HOROSCOPE_SIGNS_DICT['aquarius']))
        except KeyError:
            print data, rendered
            raise

########NEW FILE########
__FILENAME__ = panels_directories
import os, sys

from django.template import base, loader
from django.template.loaders import app_directories

from ... import panels

fs_encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()

app_template_dirs = list(app_directories.app_template_dirs)
for panel in panels.panels_pool.get_all_panels():
    template_dir = os.path.abspath(os.path.join(os.path.dirname(sys.modules[panel.__module__].__file__), 'templates'))
    if os.path.isdir(template_dir):
        app_template_dirs.append(template_dir.decode(fs_encoding))
app_directories.app_template_dirs = tuple(app_template_dirs)

# This loader is not really used, we just define it to change app_template_dirs of app_directories loader
class Loader(loader.BaseLoader):
    is_usable = True

    def load_template_source(self, template_name, template_dirs=None):
        raise base.TemplateDoesNotExist(template_name)



























########NEW FILE########
__FILENAME__ = panel
from django.utils.translation import ugettext_lazy as _

from piplmesh import panels

class MapPanel(panels.BasePanel):
    def get_context(self, context):
        context = super(MapPanel, self).get_context(context)
        
        context.update({
            'header': _("Map"),
        })
        return context

panels.panels_pool.register(MapPanel)

########NEW FILE########
__FILENAME__ = models
# We import panels through fake panel module here so that Django finds their models, tasks, etc.
from . import panel

########NEW FILE########
__FILENAME__ = panel
from django.utils.translation import ugettext_lazy as _

from mongo_auth import backends

from piplmesh import panels

class OnlineUsersPanel(panels.BasePanel):
    def get_context(self, context):
        context = super(OnlineUsersPanel, self).get_context(context)

        context.update({
            'header': _("Online users"),
            'online_users': backends.User.objects(is_online=True),
        })
        return context

panels.panels_pool.register(OnlineUsersPanel)

########NEW FILE########
__FILENAME__ = panel
import os, pkgutil

from django.utils import importlib

# A fake panel module which loads all bundled panels instead

for _, module, _ in pkgutil.iter_modules([os.path.dirname(__file__)]):
    if module in ('models', 'panel', 'tasks'):
        # Prevent failing because of circular imports (models imports panel)
        continue

    for file in ('panel', 'models', 'tasks'):
        try:
            importlib.import_module('.%s.%s' % (module, file), 'piplmesh.panels')
        except ImportError, e:
            message = str(e)
            if message != 'No module named %s' % (file,):
                raise

########NEW FILE########
__FILENAME__ = panels_pool
from django.conf import settings
from django.utils import importlib

from . import base, exceptions

class PanelsPool(object):
    def __init__(self):
        self.panels = {}
        self.discovered = False

    def discover_panels(self):
        if self.discovered:
            return
        self.discovered = True

        for app in settings.INSTALLED_APPS:
            try:
                importlib.import_module('.panel', app)
            except ImportError, e:
                message = str(e)
                if message != 'No module named panel':
                    raise

    def register(self, panel_or_iterable):
        if not hasattr(panel_or_iterable, '__iter__'):
            panel_or_iterable = [panel_or_iterable]

        for panel in panel_or_iterable:
            if not issubclass(panel, base.BasePanel):
                raise exceptions.PanelHasInvalidBase("'%s' is not a subclass of piplmesh.panels.BasePanel" % panel.__name__)

            panel_name = panel.get_name()

            if panel_name in self.panels:
                raise exceptions.PanelAlreadyRegistered("A panel with name '%s' is already registered" % panel_name)

            self.panels[panel_name] = panel

    def unregister(self, panel_or_iterable):
        if not hasattr(panel_or_iterable, '__iter__'):
            panel_or_iterable = [panel_or_iterable]

        for panel in panel_or_iterable:
            panel_name = panel.get_name()

            if panel_name not in self.panels:
                raise exceptions.PanelNotRegistered("No panel with name '%s' is registered" % panel_name)

            del self.panels[panel_name]

    def get_all_panels(self):
        self.discover_panels()

        return [panel for (_, panel) in sorted(self.panels.items())]

    def get_panel(self, panel_name):
        self.discover_panels()

        try:
            return self.panels[panel_name]
        except KeyError:
            raise exceptions.PanelNotRegistered("No panel with name '%s' is registered" % panel_name)

    def has_panel(self, panel_name):
        self.discover_panels()

        return panel_name in self.panels

panels_pool = PanelsPool()

########NEW FILE########
__FILENAME__ = finders
from django.conf import settings
from django.contrib.staticfiles import finders

from ... import panels

class PanelsDirectoriesFinder(finders.AppDirectoriesFinder):
    def __init__(self, apps=None, *args, **kwargs):
        if apps is None:
            apps = list(settings.INSTALLED_APPS)

            for panel in panels.panels_pool.get_all_panels():
                try:
                    module, _ = panel.__module__.rsplit('.', 1)
                    apps.append(module)
                except ValueError:
                    pass

            apps = tuple(apps)

        super(PanelsDirectoriesFinder, self).__init__(apps, *args, **kwargs)

########NEW FILE########
__FILENAME__ = tasks
# We import panels through fake panel module here so that Django finds their models, tasks, etc.
from . import panel

########NEW FILE########
__FILENAME__ = panels
from django import template

register = template.Library()

@register.simple_tag(takes_context=True)
def render_panel(context, panel):
    context.push()
    request = context['request']
    output = panel.render(request, context)
    context.pop()
    return output

########NEW FILE########
__FILENAME__ = tests
import os

from django.utils import unittest

def suite():
    return unittest.TestSuite((
        unittest.TestLoader().discover(
            start_dir=os.path.abspath(os.path.dirname(__file__)),
            top_level_dir=os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')),
        ),
    ))

########NEW FILE########
__FILENAME__ = updateweather
import time

from django.core.management import base

from piplmesh.panels.weather import tasks

class Command(base.BaseCommand):
    help = 'Force weather update.'

    def handle(self, *args, **options):
        """
        Forces Weather update.
        """

        verbosity = int(options['verbosity'])

        if verbosity > 1:
            self.stdout.write("Updating weather...\n")

        results = tasks.generate_weather_tasks()
        prev_completed = None
        while not results.ready():
            completed = results.completed_count()
            if prev_completed != completed:
                self.stdout.write("Completed %d/%d.\n" % (completed, len(results)))
                prev_completed = completed
            time.sleep(1)

        if verbosity > 1:
            self.stdout.write("Successfully updated weather.\n")
########NEW FILE########
__FILENAME__ = models
from django.utils.translation import ugettext_lazy as _

import mongoengine

SYMBOLS = (
    (1, _("Sun")),
    (2, _("Light cloud")),
    (3, _("Partly cloud")),
    (4, _("Cloud")),
    (5, _("Light rain and sun")),
    (6, _("Light rain, thunder and sun")),
    (7, _("Sleet and sun")),
    (8, _("Snow and sun")),
    (9, _("Light rain")),
    (10, _("Rain")),
    (11, _("Rain and thunder")),
    (12, _("Sleet")),
    (13, _("Snow")),
    (14, _("Snow and thunder")),
    (15, _("Fog")),
    (16, _("Sun (used for winter darkness)")),
    (17, _("Light cloud ( winter darkness )")),
    (18, _("Light rain and sun")),
    (19, _("Snow and sun ( used for winter darkness )")),
    (20, _("Sleet, sun and thunder")),
    (21, _("Snow, sun and thunder")),
    (22, _("Light rain and thunder")),
    (23, _("Sleet thunder")),
)

# TODO: Some fields have to be unique to make sure that there is only one entry for each time period for given location. 
# https://github.com/wlanslovenija/PiplMesh/issues/210
class Weather(mongoengine.Document):
    created = mongoengine.DateTimeField(required=True)
    latitude = mongoengine.DecimalField(required=True)
    longitude = mongoengine.DecimalField(required=True)
    model_name = mongoengine.StringField(required=True)
    
    meta = {
        'allow_inheritance': True,
    }

class Precipitation(Weather):
    date_from = mongoengine.DateTimeField(required=True)
    date_to = mongoengine.DateTimeField(required=True)
    precipitation = mongoengine.DecimalField(required=True)
    symbol = mongoengine.IntField(choices=SYMBOLS, required=True)

class State(Weather):
    at = mongoengine.DateTimeField(required=True)
    temperature = mongoengine.DecimalField(required=True)
    wind_direction = mongoengine.StringField(required=True)
    wind_angle = mongoengine.DecimalField(required=True)
    wind_speed = mongoengine.DecimalField(required=True)
    humidity = mongoengine.DecimalField(required=True)
    pressure = mongoengine.DecimalField(required=True)
    cloudiness = mongoengine.DecimalField(required=True)
    fog = mongoengine.DecimalField(required=True)
    low_clouds = mongoengine.DecimalField(required=True)
    medium_clouds = mongoengine.DecimalField(required=True)
    high_clouds = mongoengine.DecimalField(required=True)
########NEW FILE########
__FILENAME__ = panel
import datetime

from django.utils import timezone, translation
from django.utils.translation import ugettext_lazy as _

from piplmesh import nodes, panels

from . import models

WEATHER_OBSOLETE = 6 # 6 hours
FORECAST_HOUR = 14 # 14:00 o'clock or 2:00 PM
WEATHER_FORECAST_RANGE = 3 # days from being created

class WeatherPanel(panels.BasePanel): 
    def get_context(self, context):
        context = super(WeatherPanel, self).get_context(context)

        context.update({
            'header': _("Weather"),
        })
        
        latitude = self.request.node.latitude
        longitude = self.request.node.longitude
        # TODO: Check and possibly optimize
        state = models.State.objects(latitude=latitude, longitude=longitude, at__lte=datetime.datetime.now(), at__gte=(datetime.datetime.now() - datetime.timedelta(hours=WEATHER_OBSOLETE))).order_by('+created').first()
        if state is None:
            context.update({
                'error_data': True,
            })
            return context

        if timezone.now() >= state.created + datetime.timedelta(hours=WEATHER_OBSOLETE):
            context.update({
                'error_obsolete': True,
            })
            return context   
   
        context.update({
            'weather_objects': get_weather_content(latitude, longitude),
            'created': state.created,
        })
        return context

# TODO: Check and possibly optimize
def get_weather_content(latitude, longitude):
    date = datetime.datetime.now()
    for interval in range(0, WEATHER_FORECAST_RANGE):
        state = models.State.objects(latitude=latitude, longitude=longitude, at__lte=date).order_by('-at').first()
        precipitation = models.Precipitation.objects(latitude=latitude, longitude=longitude, date_from__lte=date, date_to__gte=date).order_by('-date_from').first()
        weather_object = {
            'at': state.at,
            'temperature': state.temperature,
            'symbol':  precipitation.symbol,
        }
        date += datetime.timedelta(days=1)
        date = date.replace(hour=FORECAST_HOUR, minute=0)
        yield weather_object

panels.panels_pool.register(WeatherPanel)
########NEW FILE########
__FILENAME__ = tasks
import datetime

from lxml import etree, objectify

import celery
from celery import task

from piplmesh import nodes
from piplmesh.utils import decorators

from . import models, panel

CHECK_FOR_NEW_WEATHER = 30 # minutes

SOURCE_URL = 'http://api.met.no/'

def fetch_data(latitude, longitude):
    """
    Get weather data for specific location
    """
    
    weather_url = '%sweatherapi/locationforecast/1.8/?lat=%s;lon=%s' % (SOURCE_URL, latitude, longitude)
    parser = etree.XMLParser(remove_blank_text=True)
    lookup = objectify.ObjectifyElementClassLookup()
    parser.setElementClassLookup(lookup)
    weather = objectify.parse(weather_url, parser).getroot()
    return weather

@task.periodic_task(run_every=datetime.timedelta(minutes=CHECK_FOR_NEW_WEATHER))
# TODO: This does not really help here as this task is short-lived (it just spawns new tasks), we should instead assure that no new subtasks are created before old ones finish
# We could lock before we create subtasks and at the end create new task which unlocks, and because of FIFO nature of the queue, unlock will happen after all subtasks
@decorators.single_instance_task()
def generate_weather_tasks():
    """
    Task which updates weather for all nodes.

    Obsolete data is currently left in the database.
    """ 
    
    weather_tasks = []
    # Fetching data only once per possible duplicate locations
    for latitude, longitude in {(node.latitude, node.longitude) for node in nodes.get_all_nodes()}:
        weather_tasks.append(update_weather.s(latitude, longitude))
    return celery.group(weather_tasks)()

# 20 tasks per second. Limitation by the api http://api.yr.no/conditions_service.html
@task.task(rate_limit=20) 
def update_weather(latitude, longitude):
    """
    Task which updates weather for one location.
    """ 
    
    weather_object = fetch_data(latitude, longitude)
    for product in weather_object.product.iterchildren():
        if datetime.datetime.strptime(product.attrib['to'], '%Y-%m-%dT%H:%M:%SZ') < datetime.datetime.strptime(weather_object.attrib['created'], '%Y-%m-%dT%H:%M:%SZ') + datetime.timedelta(days=panel.WEATHER_FORECAST_RANGE):
            if product.attrib['from'] == product.attrib['to']:
                models.State.objects(
                    created=datetime.datetime.strptime(weather_object.attrib['created'], '%Y-%m-%dT%H:%M:%SZ'),
                    latitude=latitude, 
                    longitude=longitude,
                    model_name=weather_object.meta.model.attrib['name'],  
                    at=datetime.datetime.strptime(product.attrib['from'], '%Y-%m-%dT%H:%M:%SZ')
                ).update(
                    set__temperature=product.location.temperature.attrib['value'],
                    set__wind_direction=product.location.windDirection.attrib['name'],
                    set__wind_angle=product.location.windDirection.attrib['deg'],
                    set__wind_speed=product.location.windSpeed.attrib['mps'],
                    set__humidity=product.location.humidity.attrib['value'],
                    set__pressure=product.location.pressure.attrib['value'],
                    set__cloudiness=product.location.cloudiness.attrib['percent'],
                    set__fog=product.location.fog.attrib['percent'],
                    set__low_clouds=product.location.lowClouds.attrib['percent'],
                    set__medium_clouds=product.location.mediumClouds.attrib['percent'],
                    set__high_clouds=product.location.highClouds.attrib['percent'],
                    upsert=True
                )
            else:
                models.Precipitation.objects(
                    created=datetime.datetime.strptime(weather_object.attrib['created'], '%Y-%m-%dT%H:%M:%SZ'),
                    latitude=latitude, 
                    longitude=longitude,
                    model_name=weather_object.meta.model.attrib['name'],
                    date_from=datetime.datetime.strptime(product.attrib['from'], '%Y-%m-%dT%H:%M:%SZ'),
                    date_to=datetime.datetime.strptime(product.attrib['to'], '%Y-%m-%dT%H:%M:%SZ')
                ).update(
                    set__precipitation=product.location.precipitation.attrib['value'],
                    set__symbol=product.location.symbol.attrib['number'],
                    upsert=True
                )
########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-
#
# Development Django settings for PiplMesh project.

import os

USE_TZ = True

MONGO_DATABASE_NAME = 'PiplMesh'
MONGO_DATABASE_OPTIONS = {
    'tz_aware': USE_TZ,
}

import mongoengine
mongoengine.connect(MONGO_DATABASE_NAME, **MONGO_DATABASE_OPTIONS)

settings_dir = os.path.abspath(os.path.dirname(__file__))

import djcelery
djcelery.setup_loader()

# Dummy function, so that "makemessages" can find strings which should be translated.
_ = lambda s: s

DEBUG = True
TEMPLATE_DEBUG = DEBUG

# A tuple that lists people who get code error notifications. When
# DEBUG=False and a view raises an exception, Django will e-mail these
# people with the full exception information. Each member of the tuple
# should be a tuple of (Full name, e-mail address).
ADMINS = ()

MANAGERS = ADMINS

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/Ljubljana'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'sl'

LANGUAGES = (
    ('sl', _('Slovenian')),
    ('en', _('English')),
)

LOCALE_PATHS = (
    os.path.join(settings_dir, 'locale'),
)

URL_VALIDATOR_USER_AGENT = 'PiplMesh'

SITE_NAME = 'PiplMesh'

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
#MEDIA_ROOT = os.path.join(settings_dir, 'media')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '/media/'

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = os.path.join(settings_dir, 'static')

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
    'piplmesh.panels.staticfiles.finders.PanelsDirectoriesFinder',
#   'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

DEFAULT_FILE_STORAGE = 'piplmesh.utils.storage.GridFSStorage'

# URL prefix for internationalization URLs
I18N_URL = '/i18n/'

# List of configured IPs from which django-pushserver passthrough callbacks are allowed
INTERNAL_IPS = (
    '127.0.0.1',
)

# URL prefix for django-pushserver passthrough callbacks
PUSH_SERVER_URL = '/passthrough/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = '02dl2nfiacp)87-1g2$=l@b(q5+qs^)qo=byzdvgx+35q)gw&^'

EMAIL_HOST = 'localhost'
EMAIL_SUBJECT_PREFIX = '[PiplMesh] '
DEFAULT_FROM_EMAIL = 'webmaster@localhost'
SERVER_EMAIL = DEFAULT_FROM_EMAIL

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
    'piplmesh.panels.loaders.panels_directories.Loader',
#   'django.template.loaders.eggs.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.static',
    'django.core.context_processors.request',
    'django.contrib.messages.context_processors.messages',
    'sekizai.context_processors.sekizai',
    'django_browserid.context_processors.browserid_form',
    'mongo_auth.contrib.context_processors.mongo_auth',
    'piplmesh.frontend.context_processors.global_vars',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'mongo_auth.middleware.LazyUserMiddleware',
    'mongo_auth.contrib.middleware.UserBasedLocaleMiddleware',
    'piplmesh.frontend.middleware.NodesMiddleware',
)

ROOT_URLCONF = 'piplmesh.urls'

MESSAGE_STORAGE = 'django.contrib.messages.storage.session.SessionStorage'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
#   os.path.join(settings_dir, 'templates'),
)

INSTALLED_APPS = (
    # Ours are first so that we can override default templates in other apps
    'piplmesh.account',
    'piplmesh.api',
    'piplmesh.frontend',
    'piplmesh.nodes',
    'piplmesh.utils',
    'piplmesh.panels',

    'django.contrib.messages',
    'django.contrib.sessions',
    'django.contrib.staticfiles',

    'pushserver',
    'djcelery',
    'tastypie',
    'tastypie_mongoengine',
    'sekizai',
    'missing',
    'django_browserid',
    'mongo_auth',
    'mongo_auth.contrib',
)

PUSH_SERVER = {
    'port': 8001,
    'address': '127.0.0.1',
    'publisher_host': '127.0.0.1:8001',
    'subscriber_host': '127.0.0.1:8001',
    'servername': URL_VALIDATOR_USER_AGENT,
    'store': {
        'type': 'memory',
        'min_messages': 0,
        'max_messages': 100,
        'message_timeout': 10,
    },
    'locations': (
        {
            'type': 'subscriber',
            'url': r'/updates/(.+)/',
            'polling': 'long',
            'create_on_get': True,
            'allow_origin': 'http://127.0.0.1:8000',
            'allow_credentials': True,
            'passthrough': 'http://127.0.0.1:8000' + PUSH_SERVER_URL,
        },
        {
            'type': 'publisher',
            'url': r'/send-update/(.+)/',
        },
    ),
}

CELERY_RESULT_BACKEND = 'mongodb'
CELERY_MONGODB_BACKEND_SETTINGS = {
    'host': '127.0.0.1',
    'port': 27017,
    'database': 'celery',
    'taskmeta_collection': 'celery_taskmeta',
}

BROKER_URL = 'mongodb://127.0.0.1:27017/celery'

CELERY_ENABLE_UTC = USE_TZ
CELERY_TIMEZONE = TIME_ZONE
CELERY_EAGER_PROPAGATES_EXCEPTIONS = True

CELERY_IMPORTS = (
    'piplmesh.frontend.views', # To connect send_update_on_new_notification signal
)

CACHES = {
    'default': {
        'BACKEND': 'piplmesh.utils.cache.MongoEngineCache',
    }
}

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

LOGIN_REDIRECT_URL = '/'
USER_CLASS = 'piplmesh.account.models.User'

SESSION_ENGINE = 'mongoengine.django.sessions'

AUTHENTICATION_BACKENDS = (
    'mongo_auth.backends.MongoEngineBackend',
    'mongo_auth.backends.FacebookBackend',
    'mongo_auth.backends.TwitterBackend',
    'mongo_auth.backends.FoursquareBackend',
    'mongo_auth.backends.GoogleBackend',
    'mongo_auth.backends.BrowserIDBackend',
    'mongo_auth.backends.LazyUserBackend',
)

TEST_RUNNER = 'tastypie_mongoengine.test_runner.MongoEngineTestSuiteRunner'
TEST_RUNNER_FILTER = (
    'piplmesh.',
)

NODES_BACKENDS = (
    'piplmesh.nodes.backends.RandomNodesBackend',
)

NODES_MIDDLEWARE_EXCEPTIONS = (
    MEDIA_URL,
    STATIC_URL,
    I18N_URL,
    PUSH_SERVER_URL,
)

# Facebook settings
# Site URL for Facebook app is set to http://127.0.0.1:8000/
# so run your development server on port 8000
# and access your site by local ip 127.0.0.1:8000 in your browser
FACEBOOK_APP_ID = '268978083181801' # Add your app ID/API key
FACEBOOK_APP_SECRET = '0d86323405308915be0564e8c00bf6e0' # Add your app secret key

# Twitter settings
TWITTER_CONSUMER_KEY = 'yeZOtec5ol5I9BGCCKpcw'
TWITTER_CONSUMER_SECRET = 'Dv80Q51jx8FWDInmZCGZs8AKDnRwAdrS0lxgZA4NWs'

# Foursquare settings
FOURSQUARE_CLIENT_ID = 'IU4LBMWT2DOCQ2JOIN3A04450HBB4GY2D5QX0WYPQ2DLP1DK'
FOURSQUARE_CLIENT_SECRET = 'UDFGDOKUSOOV0GGGI0JDHR5OOJ1KBVV3OJ50SOGFVFJ3YPKO'

# Google settings
GOOGLE_CLIENT_ID = '961599639127.apps.googleusercontent.com'
GOOGLE_CLIENT_SECRET = 'XjLBcVysDl6g0qEx_bnGUPDb'

# You can set up your own custom search engine on: http://www.google.com/cse/
# just register with you google account and crate new search engine.
# When you create new search engine, switch uniqe id with your own and new settings will apply.
# If want to change some settings that needs to be changed in the source code to take effect,
# you will be explicitly warned that you have to change the code to take effect, before you will make the change.
# Current settings are autocomplete, searching whole web.
SEARCH_ENGINE_UNIQUE_ID = '003912915932446183218:zeq20qye9oa'

CSRF_FAILURE_VIEW = 'piplmesh.frontend.views.forbidden_view'

# We are using rfc-2822 because it's better supported when parsing dates in JavaScript
TASTYPIE_DATETIME_FORMATTING = 'rfc-2822'

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from django.conf.urls import patterns, include, url
from django.contrib.staticfiles.urls import static, staticfiles_urlpatterns

from tastypie import api

from mongo_auth import models

from piplmesh.api import resources
from piplmesh.frontend import debug as debug_views, views as frontend_views
from piplmesh import panels

# PiplMesh panels auto-discovery
panels.panels_pool.discover_panels()

# So that we can access resources outside their request handlers
user_resource = resources.UserResource()
uploadedfile_resource = resources.UploadedFileResource()
post_resource = resources.PostResource()
notification_resource = resources.NotificationResource()

API_NAME = 'v1'
v1_api = api.Api(api_name=API_NAME)
v1_api.register(user_resource)
v1_api.register(uploadedfile_resource)
v1_api.register(post_resource)
v1_api.register(notification_resource)

js_info_dict = {
    'packages': (
        'django.conf',
    ),
}

I18N_URL = settings.I18N_URL.lstrip('/')
PUSH_SERVER_URL = settings.PUSH_SERVER_URL.lstrip('/')

urlpatterns = patterns('',
    url(r'^$', frontend_views.HomeView.as_view(), name='home'),
    
    url(r'^about/$', frontend_views.AboutView.as_view(), name='about'),
    url(r'^privacy/$', frontend_views.PrivacyView.as_view(), name='privacy'),
    url(r'^contact/$', frontend_views.ContactView.as_view(), name='contact'),   
    url(r'^outside/$', frontend_views.OutsideView.as_view(), name='outside'),
    url(r'^search/', frontend_views.SearchView.as_view(), name='search'),
    
    url(r'^upload/$', frontend_views.upload_view, name='upload'),

    # Mock location
    url(r'^location/$', frontend_views.LocationView.as_view(), name='mock_location'),

    # Authentication
    url(r'^', include('mongo_auth.contrib.urls')),
    url(r'^user/(?P<username>' + models.USERNAME_REGEX + ')/$', frontend_views.UserView.as_view(), name='profile'),

    # RESTful API
    url(r'^api/', include(v1_api.urls)),

    # Internationalization support
    url(r'^' + I18N_URL + 'js/$', 'django.views.i18n.javascript_catalog', js_info_dict),

    # Internals
    url(r'^' + PUSH_SERVER_URL, include('pushserver.urls')),

    # Panels
    url(r'^panels/collapse/$', frontend_views.panels_collapse, name='panels_collapse'),
    url(r'^panels/order/$', frontend_views.panels_order, name='panels_order'),
)

if getattr(settings, 'DEBUG', False):
    urlpatterns += patterns('',
        url(r'^uploadform/$', debug_views.UploadFormView.as_view()),
    )

handler403 = 'missing.views.forbidden_view'
handler404 = 'django.views.defaults.page_not_found'
handler500 = 'django.views.defaults.server_error'

if getattr(settings, 'DEBUG', False):
    urlpatterns += patterns('',
        url(r'^403/$', handler403),
        url(r'^404/$', handler404),
        url(r'^500/$', handler500),
    )

# For development, serve static and media files through Django
if getattr(settings, 'DEBUG', False):
    urlpatterns += staticfiles_urlpatterns()
    urlpatterns += static(settings.MEDIA_URL, 'piplmesh.utils.storage.serve')

########NEW FILE########
__FILENAME__ = cache
import datetime

try:
    import cPickle as pickle
except ImportError:
    import pickle

from django.core.cache.backends import base
from django.utils import timezone

import bson
import mongoengine

# TODO: Implement get_many, set_many, and delete_many

class MongoEngineCache(base.BaseCache):
    def __init__(self, location, params):
        super(MongoEngineCache, self).__init__(params)

        class Cache(mongoengine.Document):
            key = mongoengine.StringField(required=True, unique=True)
            expire = mongoengine.DateTimeField(required=True)
            value = mongoengine.DynamicField(required=True)

            meta = {
                'collection': location or 'cache',
            }

        self._cache_class = Cache

    def get(self, key, default=None, version=None):
        key = self.make_key(key, version=version)
        self.validate_key(key)

        try:
            obj = self._cache_class.objects(key=key, expire__gte=timezone.now()).get()

            if isinstance(obj.value, int):
                return obj.value
            else:
                try:
                    return pickle.loads(obj.value)
                except pickle.PickleError:
                    return default

        except self._cache_class.DoesNotExist:
            return default

    def _set(self, key, value, timeout, version, fun):
        if timeout is None:
            timeout = self.default_timeout

        key = self.make_key(key, version=version)
        self.validate_key(key)

        if isinstance(value, int):
            fun(key, value, timezone.now() + datetime.timedelta(seconds=timeout))
            return

        try:
            pickled = pickle.dumps(value, pickle.HIGHEST_PROTOCOL)
            fun(key, bson.Binary(pickled), timezone.now() + datetime.timedelta(seconds=timeout))
        except pickle.PickleError:
            pass

    def _insert(self, key, value, expire):
        self._cache_class.objects.create(key=key, value=value, expire=expire, safe=True, force_insert=True)

    def _upsert(self, key, value, expire):
        self._cache_class.objects(key=key).update(set__value=value, set__expire=expire, upsert=True, safe_update=True)

    def add(self, key, value, timeout=None, version=None):
        try:
            self._set(key, value, timeout, version, self._insert)
            return True
        except mongoengine.OperationError:
            return False

    def set(self, key, value, timeout=None, version=None):
        self._set(key, value, timeout, version, self._upsert)

    def incr(self, key, delta=1, version=None):
        key = self.make_key(key, version=version)
        self.validate_key(key)

        if self._cache_class.objects(key=key, expire__gte=timezone.now()).update(inc__value=delta, safe_update=True) == 0:
            raise ValueError

        return self.get(key, version=version)

    def has_key(self, key, version=None):
        key = self.make_key(key, version=version)
        self.validate_key(key)

        return self._cache_class.objects(key=key, expire__gte=timezone.now()).count() > 0

    def delete(self, key, version=None):
        key = self.make_key(key, version=version)
        self.validate_key(key)

        self._cache_class.objects(key=key).delete(safe=True)

    def clear(self):
        self._cache_class.drop_collection()

########NEW FILE########
__FILENAME__ = decorators
import functools

from django.core import cache

LOCK_EXPIRE = 60 * 5 # lock expires in 5 minutes

# Based on: http://stackoverflow.com/a/7668350/252025
def single_instance_task(timeout=LOCK_EXPIRE):
    def task_exc(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            lock_id = 'celery-single-instance-%s' % func.__name__
            acquire_lock = lambda: cache.cache.add(lock_id, 'true', timeout)
            release_lock = lambda: cache.cache.delete(lock_id)
            if acquire_lock():
                try:
                    return func(*args, **kwargs)
                finally:
                    release_lock()

            # TODO: Log that another task instance is already running and this one was skipped
        return wrapper
    return task_exc

########NEW FILE########
__FILENAME__ = flush
from optparse import make_option

from django.core.management import base

from mongoengine import connection

# We override Django's flush command with our own for MongoDB
# This makes also possible to run tests without relational
# database defined, because original flush command was
# throwing exceptions and preventing tests to be run

class Command(base.NoArgsCommand):
    option_list = base.NoArgsCommand.option_list + (
        make_option('--noinput', action='store_false', dest='interactive', default=True,
            help='Tells Django to NOT prompt the user for input of any kind.'),
        make_option('--database', action='store', dest='database',
            default=connection.DEFAULT_CONNECTION_NAME, help='Nominates a database to flush. '
                'Defaults to the database with alias "%s".' % connection.DEFAULT_CONNECTION_NAME),
    )
    help = ('Flushes MongoDB database. This means that all data will be removed from the database.')

    def handle_noargs(self, **options):
        database = options.get('database')
        verbosity = int(options.get('verbosity'))
        interactive = options.get('interactive')

        if not database:
            raise base.CommandError("No MongoDB database specified.")

        db = connection.get_db(database)

        if interactive:
            confirm = raw_input("""You have requested a flush of the database.
This will IRREVERSIBLY DESTROY all data currently in the '%s' database (alias '%s').
Are you sure you want to do this?

    Type 'yes' to continue, or 'no' to cancel: """ % (db.name, database))
        else:
            confirm = 'yes'

        if confirm == 'yes':
            try:
                for collection in db.collection_names():
                    if collection == 'system.indexes':
                        continue
                    db.drop_collection(collection)
            except Exception, e:
                raise base.CommandError("""Database '%s' couldn't be flushed.
The full error: %s""" % (database, e))

            if verbosity > 1:
                self.stdout.write("Database '%s' flushed.\n" % database)

        else:
            print "Flush cancelled."

########NEW FILE########
__FILENAME__ = storage
import posixpath, time, urllib, uuid

from django import http
from django.core import exceptions
from django.core.files import storage, uploadedfile
from django.conf import settings
from django.utils import http as http_utils
from django.views import static

from mongoengine.django import storage as mongoengine_storage

class GridFSStorage(mongoengine_storage.GridFSStorage):
    """
    A storage backend to store files in GridFS, with additional
    support for UploadedFile, UUID filenames, and mimetype.
    """

    def _save(self, name, content):
        if not isinstance(uploadedfile.UploadedFile, content):
            return super(GridFSStorage, self)._save(name, content)

        doc = self.document()
        field = getattr(doc, self.field)

        field.new_file(filename=name, content_type=content.content_type)
        for chunk in content.chunks():
            field.write(chunk)
        field.close()

        doc.save()

        return name

    def get_available_name(self, name):
        # We ignore given name
        name = str(uuid.uuid4())

        while self.exists(name):
            name = str(uuid.uuid4())

        return name

    def created_time(self, name):
        doc = self._get_doc_with_name(name)
        if doc:
            return getattr(doc, self.field).upload_date
        else:
            raise ValueError("No such file or directory: '%s'" % name)

    def modified_time(self, name):
        # We assume GridFS files are immutable
        # (new version is done for changes)
        return self.created_time(name)

    def mimetype(self, name):
        doc = self._get_doc_with_name(name)
        if doc:
            return getattr(doc, self.field).content_type
        else:
            raise ValueError("No such file or directory: '%s'" % name)

def serve(request, path):
    """
    Serve files from default storage.

    To use, put a URL pattern such as::

        (r'^(?P<path>.*)$', 'piplmesh.utils.storage.serve')

    in your URLconf.
    """

    if not settings.DEBUG:
        raise exceptions.ImproperlyConfigured("The view can only be used in debug mode.")
    normalized_path = posixpath.normpath(urllib.unquote(path)).lstrip('/')

    if not storage.default_storage.exists(normalized_path):
        if path.endswith('/') or path == '':
            raise http.Http404("Directory indexes are not allowed here.")
        raise http.Http404("'%s' could not be found" % path)

    try:
        mimetype = storage.default_storage.mimetype(normalized_path) or 'application/octet-stream'
    except (NotImplementedError, AttributeError):
        mimetype = 'application/octet-stream'

    try:
        modified_time = time.mktime(storage.default_storage.modified_time(normalized_path).timetuple())
    except (NotImplementedError, AttributeError):
        modified_time = None

    size = storage.default_storage.size(normalized_path)

    if modified_time is not None and not static.was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'), modified_time, size):
        return http.HttpResponseNotModified(mimetype=mimetype)

    f = storage.default_storage.open(normalized_path, 'rb')
    try:
        response = http.HttpResponse(f.read(), mimetype=mimetype)
    finally:
        f.close()

    response['Content-Length'] = size

    if modified_time is not None:
        response['Last-Modified'] = http_utils.http_date(modified_time)

    return response

########NEW FILE########
