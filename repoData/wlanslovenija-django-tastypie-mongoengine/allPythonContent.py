__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-tastypie-mongoengine documentation build configuration file, created by
# sphinx-quickstart on Thu Apr  5 10:36:30 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

import imp
module_setup = imp.load_source('module_setup', os.path.join(os.path.dirname(__file__), '..', 'setup.py'))
VERSION = module_setup.VERSION

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx', 'sphinx.ext.autodoc', 'sphinx.ext.doctest']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-tastypie-mongoengine'
copyright = u'2012, wlan slovenija'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = VERSION
# The full version, including alpha/beta/rc tags.
release = VERSION

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-tastypie-mongoenginedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'django-tastypie-mongoengine.tex', u'django-tastypie-mongoengine Documentation',
     u'wlan slovenija', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-tastypie-mongoengine', u'django-tastypie-mongoengine Documentation',
     [u'wlan slovenija'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'django-tastypie-mongoengine', u'django-tastypie-mongoengine Documentation',
     u'wlan slovenija', 'django-tastypie-mongoengine', 'Binding between django-tastypie and mongoengine.',
     'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    'python': ('http://python.readthedocs.org/en/latest/', None),
    'django': ('http://django.readthedocs.org/en/latest/', None),
}

########NEW FILE########
__FILENAME__ = fields
import tastypie
from tastypie import bundle as tastypie_bundle, exceptions, fields


def link_property(property_name):
    def getter(self):
        return getattr(self, property_name)

    def setter(self, value):
        setattr(self, property_name, value)

    return property(getter, setter)


class ObjectId(fields.ApiField):
    """
    Field for representing ObjectId from MongoDB.
    """

    dehydrated_type = 'objectid'
    help_text = "ID field"


class ApiNameMixin(object):
    def get_api_name(self):
        if getattr(self, 'api_name', None) is not None:
            return self.api_name
        if getattr(self, '_resource', None) and self._resource._meta.api_name is not None:
            return self._resource._meta.api_name
        return None


class GetRelatedMixin(object):
    def get_related_resource(self, related_instance):
        related_resource = super(GetRelatedMixin, self).get_related_resource(related_instance)
        type_map = getattr(related_resource._meta, 'polymorphic', {})
        if type_map and getattr(related_resource._meta, 'prefer_polymorphic_resource_uri', False):
            resource = related_resource._get_resource_from_class(type_map, related_instance.__class__)
            if related_resource.get_resource_uri():
                related_resource._meta.resource_name = resource._meta.resource_name
        return related_resource


class TastypieMongoengineMixin(ApiNameMixin, GetRelatedMixin):
    pass


class BuildRelatedMixin(TastypieMongoengineMixin):
    def build_related_resource(self, value, **kwargs):
        # A version of build_related_resource which allows only dictionary-like data
        if hasattr(value, 'items'):
            self.fk_resource = self.to_class(self.get_api_name())
            # We force resource to cannot be updated so that
            # it is just constructed by resource_from_data
            self.fk_resource.can_update = lambda: False
            return self.resource_from_data(self.fk_resource, value, **kwargs)
        # Or if related object already exists (this happens with PATCH request)
        elif getattr(value, 'obj', None):
            return value
        else:
            raise exceptions.ApiFieldError("The '%s' field was not given a dictionary-alike data: %s." % (self.instance_name, value))


class ReferenceField(TastypieMongoengineMixin, fields.ToOneField):
    """
    References another MongoEngine document.
    """

    dehydrated_type = 'reference'

    def __init__(self, *args, **kwargs):
        help_text = kwargs.pop('help_text', None)

        super(ReferenceField, self).__init__(*args, **kwargs)

        self._help_text = help_text

    @property
    def help_text(self):
        if not self._help_text:
            self._help_text = "Referenced document (%s). Can be either a URI or nested document data." % (self.to_class(self.get_api_name())._meta.resource_name,)
        return self._help_text

    def build_schema(self):
        resource = self.to_class(self.get_api_name())
        return {
            'reference_uri': resource.get_resource_uri(),
            'reference_schema': resource._build_reverse_url('api_get_schema', kwargs={
                'api_name': self.get_api_name(),
                'resource_name': resource._meta.resource_name,
            }),
        }


class EmbeddedDocumentField(BuildRelatedMixin, fields.ToOneField):
    """
    Embeds a resource inside another resource just like you would in MongoEngine.
    """

    is_related = False
    dehydrated_type = 'embedded'

    def __init__(self, embedded, attribute, default=fields.NOT_PROVIDED, null=False, blank=False, readonly=False, help_text=None):
        '''
        The ``embedded`` argument should point to a ``Resource`` class, not
        to a ``document``. Required.
        '''

        super(EmbeddedDocumentField, self).__init__(
            to=embedded,
            attribute=attribute,
            default=default,
            null=null,
            blank=blank,
            readonly=readonly,
            full=True,
        )

        self._help_text = help_text

    @property
    def help_text(self):
        if not self._help_text:
            self._help_text = "Embedded document (%s)." % (self.to_class(self.get_api_name())._meta.resource_name,)
        return self._help_text

    def build_schema(self):
        return {
            'embedded': {
                'fields': self.to_class(self.get_api_name()).build_schema()['fields'],
            },
        }

    def hydrate(self, bundle):
        bundle = super(EmbeddedDocumentField, self).hydrate(bundle)
        if not bundle:
            return bundle
        return bundle.obj


class EmbeddedListField(BuildRelatedMixin, fields.ToManyField):
    """
    Represents a list of embedded objects. It must be used in conjunction
    with EmbeddedDocumentField.
    """

    is_related = False
    is_m2m = False

    def __init__(self, of, attribute, **kwargs):
        self._to_class_with_listresource = None

        help_text = kwargs.pop('help_text', None)

        super(EmbeddedListField, self).__init__(to=of, attribute=attribute, **kwargs)

        self._help_text = help_text

    @property
    def help_text(self):
        if not self._help_text:
            self._help_text = "List of embedded documents (%s)." % (self.to_class(self.get_api_name())._meta.resource_name,)
        return self._help_text

    def build_schema(self):
        data = {
            'embedded': {
                'fields': self.to_class(self.get_api_name()).build_schema()['fields'],
            },
            'related_type': 'to_many',
        }

        type_map = getattr(self.to_class(self.get_api_name())._meta, 'polymorphic', {})
        if not type_map:
            return data

        data['embedded'].update({
            'resource_types': type_map.keys(),
        })

        return data

    def dehydrate(self, bundle, for_list=True):
        assert bundle.obj

        the_m2ms = None

        if isinstance(self.attribute, basestring):
            the_m2ms = getattr(bundle.obj, self.attribute)
        elif callable(self.attribute):
            the_m2ms = self.attribute(bundle)

        if not the_m2ms:
            if not self.null:
                raise exceptions.ApiFieldError("The document %r has an empty attribute '%s' and does not allow a null value." % (bundle.obj, self.attribute))
            return []

        self.m2m_resources = []
        m2m_dehydrated = []

        # the_m2ms is a list, not a queryset
        for index, m2m in enumerate(the_m2ms):
            m2m.parent = bundle.obj
            m2m_resource = self.get_related_resource(m2m)

            pk_field = getattr(m2m_resource._meta, 'id_field', None)
            if pk_field is None:
                m2m.pk = index
            else:
                m2m.__class__.pk = link_property(pk_field)

            m2m_bundle = tastypie_bundle.Bundle(obj=m2m, request=bundle.request)
            self.m2m_resources.append(m2m_resource)
            if tastypie.__version__ >= (0, 9, 15):
                m2m_dehydrated.append(self.dehydrate_related(m2m_bundle, m2m_resource, for_list=for_list))
            else:
                m2m_dehydrated.append(self.dehydrate_related(m2m_bundle, m2m_resource))

        return m2m_dehydrated

    def hydrate(self, bundle):
        return [b.obj for b in self.hydrate_m2m(bundle)]

    @property
    def to_class(self):
        if not self._to_class_with_listresource:
            # Importing here to prevent import cycle
            from tastypie_mongoengine import resources
            base = super(EmbeddedListField, self).to_class
            # We create a new ad-hoc resource class here, mixed with MongoEngineListResource, pretending to be original class
            self._to_class_with_listresource = type(base.__name__, (base, resources.MongoEngineListResource), {
                '__module__': base.__module__,
                '_parent': self._resource,
                'attribute': self.attribute or self.instance_name,
            })
        return self._to_class_with_listresource


class ReferencedListField(TastypieMongoengineMixin, fields.ToManyField):
    """
    Represents a list of referenced objects. It must be used in conjunction
    with ReferenceField.
    """

    def __init__(self, of, attribute, **kwargs):
        help_text = kwargs.pop('help_text', None)

        super(ReferencedListField, self).__init__(to=of, attribute=attribute, **kwargs)

        self._help_text = help_text

    @property
    def help_text(self):
        if not self._help_text:
            self._help_text = "List of referenced documents (%s)." % (self.to_class(self.get_api_name())._meta.resource_name,)
        return self._help_text

    def build_schema(self):
        resource = self.to_class(self.get_api_name())
        return {
            'reference_uri': resource.get_resource_uri(),
            'reference_schema': resource._build_reverse_url('api_get_schema', kwargs={
                'api_name': self.get_api_name(),
                'resource_name': resource._meta.resource_name,
            }),
            'related_type': 'to_many',
        }

    def dehydrate(self, bundle, for_list=True):
        if not bundle.obj or not bundle.obj.pk:
            if not self.null:
                raise exceptions.ApiFieldError("The document %r does not have a primary key and can not be used in a ReferencedList context." % bundle.obj)

            return []

        the_m2ms = None

        if isinstance(self.attribute, basestring):
            the_m2ms = getattr(bundle.obj, self.attribute)
        elif callable(self.attribute):
            the_m2ms = self.attribute(bundle)

        if not the_m2ms:
            if not self.null:
                raise exceptions.ApiFieldError("The document %r has an empty attribute '%s' and does not allow a null value." % (bundle.obj, self.attribute))
            return []

        self.m2m_resources = []
        m2m_dehydrated = []

        # the_m2ms is a list, not a queryset
        for m2m in the_m2ms:
            m2m_resource = self.get_related_resource(m2m)
            m2m_bundle = tastypie_bundle.Bundle(obj=m2m, request=bundle.request)
            self.m2m_resources.append(m2m_resource)
            if tastypie.__version__ >= (0, 9, 15):
                m2m_dehydrated.append(self.dehydrate_related(m2m_bundle, m2m_resource, for_list=for_list))
            else:
                m2m_dehydrated.append(self.dehydrate_related(m2m_bundle, m2m_resource))

        return m2m_dehydrated

    def resource_from_data(self, fk_resource, data, request=None, related_obj=None, related_name=None):
        # We are ignoring any extra fields not present in resource
        # We delete them because otherwise resource_from_data fail
        # when using getattr and they are missing in resource
        for k in data.keys():
            if not hasattr(fk_resource, k):
                del data[k]

        return super(ReferencedListField, self).resource_from_data(fk_resource, data, request, related_obj, related_name)

########NEW FILE########
__FILENAME__ = paginator
import itertools

from django.conf import settings

from tastypie import exceptions, paginator

import bson
from bson import errors


class Paginator(paginator.Paginator):
    """
    Paginator which allows using MongoDB ObjectId as position
    from where to paginate (in positive or negative direction).
    """

    def get_limit(self):
        limit = getattr(settings, 'API_LIMIT_PER_PAGE', 20)

        if 'limit' in self.request_data:
            limit = self.request_data['limit']
        elif self.limit is not None:
            limit = self.limit

        try:
            limit = int(limit)
        except ValueError:
            raise exceptions.BadRequest("Invalid limit '%s' provided. Please provide an integer." % limit)

        return limit

    def get_offset(self):
        offset = self.offset

        if 'offset' in self.request_data:
            offset = self.request_data['offset']

        try:
            offset = bson.ObjectId(offset)
        except (TypeError, errors.InvalidId):
            try:
                offset = int(offset)
            except ValueError:
                raise exceptions.BadRequest("Invalid offset '%s' provided. Please provide an ObjectId or an integer." % offset)

        if isinstance(offset, int) and offset < 0:
            raise exceptions.BadRequest("Invalid integer offset '%s' provided. Please provide a non-negative integer." % offset)

        return offset

    def get_slice(self, limit, offset):
        if isinstance(offset, int):
            if limit < 0:
                raise exceptions.BadRequest("Invalid limit '%s' provided. Please provide a non-negative integer." % limit)
            return super(Paginator, self).get_slice(limit, offset)

        # TODO: Very very inefficient, optimize!

        if limit < 0:
            iterator = reversed(self.objects)
            limit = -limit
        else:
            iterator = self.objects.__iter__()

        if limit == 0:
            limit = None

        iterator = itertools.dropwhile(lambda obj: obj.pk != offset, iterator)
        iterator = itertools.islice(iterator, limit)

        return iterator

    def get_previous(self, limit, offset):
        if isinstance(offset, int):
            return super(Paginator, self).get_previous(limit, offset)

        # We do not support previous URI as the whole idea behind
        # using ObjectId-based offsets is that integer offsets can
        # become obsolete between requests
        return None

    def get_next(self, limit, offset, count):
        if isinstance(offset, int):
            return super(Paginator, self).get_next(limit, offset, count)

        # We do not support next URI as the whole idea behind using
        # ObjectId-based offsets is that integer offsets can become
        # obsolete between requests
        return None

########NEW FILE########
__FILENAME__ = resources
import itertools
import re
import sys

from django.conf import urls
from django.core import exceptions, urlresolvers
from django.db.models import base as models_base
from django.utils import datastructures

try:
    # Django 1.5+
    from django.db.models import constants
except ImportError:
    # Before Django 1.5
    from django.db.models.sql import constants

from tastypie import bundle as tastypie_bundle, exceptions as tastypie_exceptions, fields as tastypie_fields, http, resources, utils

import mongoengine
from mongoengine import fields as mongoengine_fields, queryset
try:
    from mongoengine.queryset import tranform as mongoengine_tranform
except ImportError:
    mongoengine_tranform = None

from tastypie_mongoengine import fields as tastypie_mongoengine_fields

# When Tastypie accesses query terms used by QuerySet it assumes the interface of Django ORM.
# We use a mock Query object to provide the same interface and return query terms by MongoEngine.
# MongoEngine code might not expose these query terms, so we fallback to hard-coded values.

QUERY_TERMS_ALL = getattr(mongoengine_tranform, 'MATCH_OPERATORS', (
    'ne', 'gt', 'gte', 'lt', 'lte', 'in', 'nin', 'mod', 'all', 'size', 'exists', 'not', 'within_distance', 'within_spherical_distance', 'within_box', 'within_polygon', 'near', 'near_sphere', 'contains', 'icontains', 'startswith', 'istartswith', 'endswith', 'iendswith', 'exact', 'iexact', 'match'
))


class Query(object):
    query_terms = dict([(query_term, None) for query_term in QUERY_TERMS_ALL])

if not hasattr(queryset.QuerySet, 'query'):
    queryset.QuerySet.query = Query()

CONTENT_TYPE_RE = re.compile(r'.*; type=([\w\d-]+);?')


class NOT_HYDRATED(object):
    pass


class ListQuerySet(datastructures.SortedDict):
    # Workaround for https://github.com/toastdriven/django-tastypie/pull/670
    query = Query()

    def _process_filter_value(self, value):
        # Sometimes value is passed as a list of one value
        # (if filter was converted from QueryDict, for example)
        if isinstance(value, (list, tuple)):
            assert len(value) == 1
            return value[0]
        else:
            return value

    def filter(self, **kwargs):
        result = self

        # pk optimization
        if 'pk' in kwargs:
            pk = unicode(self._process_filter_value(kwargs.pop('pk')))
            if pk in result:
                result = ListQuerySet([(unicode(pk), result[pk])])
            # Sometimes None is passed as a pk to not filter by pk
            elif pk is not None:
                result = ListQuerySet()

        for field, value in kwargs.iteritems():
            value = self._process_filter_value(value)
            if constants.LOOKUP_SEP in field:
                raise tastypie_exceptions.InvalidFilterError("Unsupported filter: (%s, %s)" % (field, value))

            try:
                result = ListQuerySet([(unicode(obj.pk), obj) for obj in result.itervalues() if getattr(obj, field) == value])
            except AttributeError as ex:
                raise tastypie_exceptions.InvalidFilterError(ex)

        return result

    def attrgetter(self, attr):
        def getter(obj):
            return self.resolve_attr(obj, attr)
        return getter

    def resolve_attr(self, obj, attr):
        for name in attr.split(constants.LOOKUP_SEP):
            while isinstance(obj, list):
                # Try to be a bit similar to MongoDB
                for o in obj:
                    if hasattr(o, name):
                        obj = o
                        break
                else:
                    obj = obj[0]
            obj = getattr(obj, name)
        return obj

    def order_by(self, *field_names):
        if not len(field_names):
            return self

        result = self

        for field in reversed(field_names):
            if field.startswith('-'):
                reverse = True
                field = field[1:]
            else:
                reverse = False

            try:
                result = [(unicode(obj.pk), obj) for obj in sorted(result, key=self.attrgetter(field), reverse=reverse)]
            except (AttributeError, IndexError) as ex:
                raise tastypie_exceptions.InvalidSortError(ex)

        return ListQuerySet(result)

    def __iter__(self):
        return self.itervalues()

    def __reversed__(self):
        for key in reversed(self.keyOrder):
            yield self[key]

    def __getitem__(self, key):
        # Tastypie access object_list[0], so we pretend to be
        # a list here (order is same as our iteration order)
        if isinstance(key, (int, long)):
            return itertools.islice(self, key, key + 1).next()
        # Tastypie also access sliced object_list in paginator
        elif isinstance(key, slice):
            return itertools.islice(self, key.start, key.stop, key.step)
        else:
            # We could convert silently to unicode here, but it is
            # better to check to find possible errors in program logic
            assert isinstance(key, unicode), key
            return super(ListQuerySet, self).__getitem__(key)


# Adapted from PEP 257
def trim(docstring):
    if not docstring:
        return ''
    # Convert tabs to spaces (following the normal Python rules)
    # and split into a list of lines:
    lines = docstring.expandtabs().splitlines()
    # Determine minimum indentation (first line doesn't count):
    indent = sys.maxint
    for line in lines[1:]:
        stripped = line.lstrip()
        if stripped:
            indent = min(indent, len(line) - len(stripped))
    # Remove indentation (first line is special):
    trimmed = [lines[0].strip()]
    if indent < sys.maxint:
        for line in lines[1:]:
            trimmed.append(line[indent:].rstrip())
    # Strip off trailing and leading blank lines:
    while trimmed and not trimmed[-1]:
        trimmed.pop()
    while trimmed and not trimmed[0]:
        trimmed.pop(0)
    # Return the first paragraph as a single string:
    return '\n'.join(trimmed).split('\n\n')[0]


class MongoEngineModelDeclarativeMetaclass(resources.ModelDeclarativeMetaclass):
    """
    This class has the same functionality as its supper ``ModelDeclarativeMetaclass``.
    Only thing it does differently is how it sets ``object_class`` and ``queryset`` attributes.

    This is an internal class and is not used by the end user of tastypie_mongoengine.
    """

    def __new__(cls, name, bases, attrs):
        meta = attrs.get('Meta')

        if meta:
            if hasattr(meta, 'queryset') and not hasattr(meta, 'object_class'):
                setattr(meta, 'object_class', meta.queryset._document)

            if hasattr(meta, 'object_class') and not hasattr(meta, 'queryset'):
                if hasattr(meta.object_class, 'objects'):
                    setattr(meta, 'queryset', meta.object_class.objects.all())
                elif issubclass(meta.object_class, mongoengine.EmbeddedDocument):
                    # Workaround for https://github.com/toastdriven/django-tastypie/pull/670
                    # We ignore queryset value later on, so we can set it here to empty one
                    setattr(meta, 'queryset', ListQuerySet())

        new_class = super(resources.ModelDeclarativeMetaclass, cls).__new__(cls, name, bases, attrs)
        include_fields = getattr(new_class._meta, 'fields', [])
        excludes = getattr(new_class._meta, 'excludes', [])

        field_names = new_class.base_fields.keys()

        for field_name in field_names:
            if field_name == 'resource_uri':
                if hasattr(new_class, '_parent'):
                    if new_class._parent._meta.object_class and issubclass(new_class._parent._meta.object_class, mongoengine.EmbeddedDocument):
                        # TODO: We do not support yet nested resources
                        # If parent is embedded document, then also this one do not have its own resource_uri
                        del(new_class.base_fields[field_name])
                elif new_class._meta.object_class and issubclass(new_class._meta.object_class, mongoengine.EmbeddedDocument):
                    # Embedded documents which are not in lists (do not have _parent) do not have their own resource_uri
                    del(new_class.base_fields[field_name])
            if field_name in new_class.declared_fields:
                continue
            if len(include_fields) and field_name not in include_fields:
                del(new_class.base_fields[field_name])
            if len(excludes) and field_name in excludes:
                del(new_class.base_fields[field_name])

        # Add in the new fields
        new_class.base_fields.update(new_class.get_fields(include_fields, excludes))

        if getattr(new_class._meta, 'include_absolute_url', True):
            if 'absolute_url' not in new_class.base_fields:
                new_class.base_fields['absolute_url'] = tastypie_fields.CharField(attribute='get_absolute_url', readonly=True)
        elif 'absolute_url' in new_class.base_fields and 'absolute_url' not in attrs:
            del(new_class.base_fields['absolute_url'])

        type_map = getattr(new_class._meta, 'polymorphic', {})

        if type_map and getattr(new_class._meta, 'include_resource_type', True):
            if 'resource_type' not in new_class.base_fields:
                new_class.base_fields['resource_type'] = tastypie_fields.CharField(readonly=True)
        elif 'resource_type' in new_class.base_fields and 'resource_type' not in attrs:
            del(new_class.base_fields['resource_type'])

        seen_types = set()
        for typ, resource in type_map.iteritems():
            if resource == 'self':
                type_map[typ] = new_class
                break
            # In the code for polymorphic resources we are assuming
            # that document classes are not duplicated among used resources
            # (that each resource is linked to its own document class)
            # So we are checking this assumption here
            if type_map[typ]._meta.object_class in seen_types:
                raise exceptions.ImproperlyConfigured("Used polymorphic resources should each use its own document class.")
            else:
                seen_types.add(type_map[typ]._meta.object_class)

        if new_class._meta.object_class:
            # In MongoEngine 0.7.6+ embedded documents do not have exceptions anymore,
            # but this prevents are from reusing existing Tastypie code

            exceptions_to_merge = [exc for exc in (queryset.DoesNotExist, queryset.MultipleObjectsReturned) if not hasattr(new_class._meta.object_class, exc.__name__)]
            module = new_class._meta.object_class.__module__
            for exc in exceptions_to_merge:
                name = exc.__name__
                parents = tuple(getattr(base, name) for base in new_class._meta.object_class._get_bases(bases) if hasattr(base, name)) or (exc,)
                # Create new exception and set to new_class
                exception = type(name, parents, {'__module__': module})
                setattr(new_class._meta.object_class, name, exception)

        return new_class


class MongoEngineResource(resources.ModelResource):
    """
    Adaptation of ``ModelResource`` to MongoEngine.
    """

    __metaclass__ = MongoEngineModelDeclarativeMetaclass

    def dispatch_subresource(self, request, subresource_name, **kwargs):
        field = self.fields[subresource_name]
        resource = field.to_class(self._meta.api_name)
        return resource.dispatch(request=request, **kwargs)

    def base_urls(self):
        base = super(MongoEngineResource, self).base_urls()

        embedded_urls = []
        embedded = (name for name, obj in self.fields.iteritems() if isinstance(obj, tastypie_mongoengine_fields.EmbeddedListField))

        for name in embedded:
            embedded_urls.extend((
                urls.url(
                    r"^(?P<resource_name>%s)/(?P<pk>\w[\w-]*)/(?P<subresource_name>%s)%s$" % (self._meta.resource_name, name, utils.trailing_slash()),
                    self.wrap_view('dispatch_subresource'),
                    {'request_type': 'list'},
                    name='api_dispatch_subresource_list',
                ),
                urls.url(
                    r"^(?P<resource_name>%s)/(?P<pk>\w[\w-]*)/(?P<subresource_name>%s)/(?P<subresource_pk>\w[\w-]*)%s$" % (self._meta.resource_name, name, utils.trailing_slash()),
                    self.wrap_view('dispatch_subresource'),
                    {'request_type': 'detail'},
                    name='api_dispatch_subresource_detail',
                ),
            ))

        return embedded_urls + base

    def _reset_collection(self):
        """
        Because MongoEngine creates collection connection when queryset object is initialized,
        we have to make sure that currently configured connection to database is really used.
        This happens for example in tests, where querysets are initialized as resource classes
        are imported, but then database connection is changed to test database.
        """

        self._meta.queryset._document._collection = None
        self._meta.queryset._collection_obj = self._meta.queryset._document._get_collection()
        if hasattr(self._meta.queryset, '_reset_already_indexed'):
            self._meta.queryset._reset_already_indexed()

    def get_object_list(self, request):
        """
        An ORM-specific implementation of ``get_object_list``.
        Returns a queryset that may have been limited by other overrides.
        """

        self._reset_collection()
        return self._meta.queryset.clone()

    def _get_object_type(self, request):
        match = CONTENT_TYPE_RE.match(request.META.get('CONTENT_TYPE', ''))
        if match:
            return match.group(1)
        elif 'type' in request.GET:
            return request.GET.get('type')
        else:
            return None

    def _wrap_polymorphic(self, resource, fun):
        object_class = self._meta.object_class
        qs = self._meta.queryset
        base_fields = self.base_fields
        fields = self.fields
        try:
            self._meta.object_class = resource._meta.object_class
            self._meta.queryset = resource._meta.queryset
            self.base_fields = resource.base_fields.copy()
            self.fields = resource.fields.copy()
            if getattr(self._meta, 'prefer_polymorphic_resource_uri', False):
                if resource.get_resource_uri():
                    self._meta.resource_name = resource._meta.resource_name
            if getattr(self._meta, 'include_resource_type', True):
                self.base_fields['resource_type'] = base_fields['resource_type']
                self.fields['resource_type'] = fields['resource_type']
            return fun()
        finally:
            self._meta.object_class = object_class
            self._meta.queryset = qs
            self.base_fields = base_fields
            self.fields = fields

    def _wrap_request(self, request, fun):
        type_map = getattr(self._meta, 'polymorphic', {})
        if not type_map:
            return fun()

        object_type = self._get_object_type(request)
        if not object_type:
            # Polymorphic resources are enabled, but
            # nothing is passed, so set it to a default
            try:
                object_type = self._get_type_from_class(type_map, self._meta.object_class)
            except KeyError:
                raise tastypie_exceptions.BadRequest("Invalid object type.")

        if object_type not in type_map:
            raise tastypie_exceptions.BadRequest("Invalid object type.")

        resource = type_map[object_type](self._meta.api_name)

        # Optimization
        if resource._meta.object_class is self._meta.object_class:
            return fun()

        return self._wrap_polymorphic(resource, fun)

    def dispatch(self, request_type, request, **kwargs):
        # We process specially only requests with payload
        if not request.body:
            assert request.method.lower() not in ('put', 'post', 'patch'), request.method
            return super(MongoEngineResource, self).dispatch(request_type, request, **kwargs)

        assert request.method.lower() in ('put', 'post', 'patch'), request.method

        return self._wrap_request(request, lambda: super(MongoEngineResource, self).dispatch(request_type, request, **kwargs))

    def get_schema(self, request, **kwargs):
        return self._wrap_request(request, lambda: super(MongoEngineResource, self).get_schema(request, **kwargs))

    def _get_resource_from_class(self, type_map, cls):
        for resource in type_map.itervalues():
            if resource._meta.object_class is cls:
                return resource
        raise KeyError(cls)

    def _get_type_from_class(self, type_map, cls):
        # As we are overriding self._meta.object_class we have to make sure
        # that we do not miss real match, so if self._meta.object_class
        # matches, we still check other items, otherwise we return immediately
        res = None
        for typ, resource in type_map.iteritems():
            if resource._meta.object_class is cls:
                if resource._meta.object_class is self._meta.object_class:
                    res = typ
                else:
                    return typ
        if res is not None:
            return res
        else:
            raise KeyError(cls)

    def dehydrate_resource_type(self, bundle):
        type_map = getattr(self._meta, 'polymorphic', {})
        if not type_map:
            return None

        return self._get_type_from_class(type_map, bundle.obj.__class__)

    def full_dehydrate(self, bundle, for_list=False):
        type_map = getattr(self._meta, 'polymorphic', {})
        if not type_map:
            return super(MongoEngineResource, self).full_dehydrate(bundle, for_list)

        # Optimization
        if self._meta.object_class is bundle.obj.__class__:
            return super(MongoEngineResource, self).full_dehydrate(bundle, for_list)

        resource = self._get_resource_from_class(type_map, bundle.obj.__class__)(self._meta.api_name)
        return self._wrap_polymorphic(resource, lambda: super(MongoEngineResource, self).full_dehydrate(bundle, for_list))

    def full_hydrate(self, bundle):
        # When updating objects, we want to force only updates of the same type, and object
        # should be completely replaced if type is changed, so we throw and exception here
        # to direct program logic flow (it is cached and replace instead of update is tried)
        if bundle.obj and self._meta.object_class is not bundle.obj.__class__:
            raise tastypie_exceptions.NotFound("A document instance matching the provided arguments could not be found.")

        bundle = super(MongoEngineResource, self).full_hydrate(bundle)

        # We redo check for required fields as Tastypie is not
        # reliable as it does checks in an inconsistent way
        # (https://github.com/toastdriven/django-tastypie/issues/491)
        for field_object in self.fields.itervalues():
            if field_object.readonly or getattr(field_object, '_primary_key', False):
                continue

            if not field_object.attribute:
                continue

            # Tastypie also skips setting value if it is None, but this means
            # updates to None are ignored: this is not good as it hides invalid
            # PUT/PATCH REST requests (setting value to None which should fail
            # validation (field required) is simply ignored and value is left
            # as it is)
            # (https://github.com/toastdriven/django-tastypie/issues/492)
            # We hydrate field again only if existing value is not None
            if getattr(bundle.obj, field_object.attribute, None) is not None:
                value = NOT_HYDRATED

                # Tastypie also ignores missing fields in PUT,
                # so we check for missing field here
                # (https://github.com/toastdriven/django-tastypie/issues/496)
                if field_object.instance_name not in bundle.data:
                    if field_object.has_default():
                        if callable(field_object.default):
                            value = field_object.default()
                        else:
                            value = field_object.default
                    # If it can be blank, we leave the field as it is, it was possibly already populated or it is not even necessary to be
                    elif field_object.blank:
                        pass
                    else:
                        value = None
                else:
                    value = field_object.hydrate(bundle)
                if value is None:
                    setattr(bundle.obj, field_object.attribute, None)

            if field_object.blank or field_object.null:
                continue

            # We are just trying to fix Tastypie here, for other "null" values
            # like [] and {} we leave to MongoEngine validate to catch them
            if getattr(bundle.obj, field_object.attribute, None) is None:
                raise tastypie_exceptions.ApiFieldError("The '%s' field has no data and doesn't allow a default or null value." % field_object.instance_name)

        return bundle

    def build_schema(self):
        data = super(MongoEngineResource, self).build_schema()

        for field_name, field_object in self.fields.items():
            # We process ListField specially here (and not use field's
            # build_schema) so that Tastypie's ListField can be used
            if isinstance(field_object, tastypie_fields.ListField):
                if getattr(field_object, 'field', None):
                    data['fields'][field_name]['content'] = {}

                    field_type = field_object.field.__class__.__name__.lower()
                    if field_type.endswith('field'):
                        field_type = field_type[:-5]
                    data['fields'][field_name]['content']['type'] = field_type

                    if field_object.field.__doc__:
                        data['fields'][field_name]['content']['help_text'] = trim(field_object.field.__doc__)

            if hasattr(field_object, 'build_schema'):
                data['fields'][field_name].update(field_object.build_schema())

        type_map = getattr(self._meta, 'polymorphic', {})
        if not type_map:
            return data

        data.update({
            'resource_types': type_map.keys(),
        })

        return data

    def obj_get(self, bundle, **kwargs):
        # MongoEngine exceptions are separate from Django exceptions, we combine them here
        try:
            return super(MongoEngineResource, self).obj_get(bundle=bundle, **kwargs)
        except self._meta.object_class.DoesNotExist as ex:
            exp = models_base.subclass_exception('DoesNotExist', (self._meta.object_class.DoesNotExist, exceptions.ObjectDoesNotExist), self._meta.object_class.DoesNotExist.__module__)
            raise exp(*ex.args)
        except queryset.DoesNotExist as ex:
            exp = models_base.subclass_exception('DoesNotExist', (queryset.DoesNotExist, exceptions.ObjectDoesNotExist), queryset.DoesNotExist.__module__)
            raise exp(*ex.args)
        except self._meta.object_class.MultipleObjectsReturned as ex:
            exp = models_base.subclass_exception('MultipleObjectsReturned', (self._meta.object_class.MultipleObjectsReturned, exceptions.MultipleObjectsReturned), self._meta.object_class.MultipleObjectsReturned.__module__)
            raise exp(*ex.args)
        except queryset.MultipleObjectsReturned as ex:
            exp = models_base.subclass_exception('MultipleObjectsReturned', (queryset.MultipleObjectsReturned, exceptions.MultipleObjectsReturned), queryset.MultipleObjectsReturned.__module__)
            raise exp(*ex.args)
        except mongoengine.ValidationError as ex:
            exp = models_base.subclass_exception('DoesNotExist', (queryset.DoesNotExist, exceptions.ObjectDoesNotExist), queryset.DoesNotExist.__module__)
            raise exp(*ex.args)

    def obj_create(self, bundle, **kwargs):
        self._reset_collection()
        return super(MongoEngineResource, self).obj_create(bundle, **kwargs)

    # TODO: Use skip_errors?
    def obj_update(self, bundle, skip_errors=False, **kwargs):
        self._reset_collection()

        if not bundle.obj or not getattr(bundle.obj, 'pk', None):
            try:
                bundle.obj = self.obj_get(bundle=bundle, **kwargs)
            except (queryset.DoesNotExist, exceptions.ObjectDoesNotExist):
                raise tastypie_exceptions.NotFound("A document instance matching the provided arguments could not be found.")

        self.authorized_update_detail(self.get_object_list(bundle.request), bundle)
        bundle = self.full_hydrate(bundle)
        return self.save(bundle, skip_errors=skip_errors)

    def obj_delete(self, bundle, **kwargs):
        self._reset_collection()

        # MongoEngine exceptions are separate from Django exceptions and Tastypie
        # expects Django exceptions, so we catch it here ourselves and raise NotFound
        try:
            return super(MongoEngineResource, self).obj_delete(bundle, **kwargs)
        except queryset.DoesNotExist:
            raise tastypie_exceptions.NotFound("A document instance matching the provided arguments could not be found.")

    def create_identifier(self, obj):
        return unicode(obj.pk)

    def save(self, bundle, skip_errors=False):
        try:
            return super(MongoEngineResource, self).save(bundle, skip_errors)
        except mongoengine.ValidationError as ex:
            raise exceptions.ValidationError(ex.message)

    def save_m2m(self, bundle):
        # Our related documents are not stored in a queryset, but a list,
        # so we have to manually build a list, set it, and save

        for field_name, field_object in self.fields.items():
            if not getattr(field_object, 'is_m2m', False):
                continue

            if not field_object.attribute:
                continue

            if field_object.readonly:
                continue

            related_objs = []

            for related_bundle in bundle.data[field_name]:
                related_bundle.obj.save()
                related_objs.append(related_bundle.obj)

            setattr(bundle.obj, field_object.attribute, related_objs)
            bundle.obj.save()

    @classmethod
    def api_field_from_mongo_field(cls, f, default=tastypie_fields.CharField):
        """
        Returns the field type that would likely be associated with each
        MongoEngine type.
        """

        result = default

        if isinstance(f, (mongoengine.ComplexDateTimeField, mongoengine.DateTimeField)):
            result = tastypie_fields.DateTimeField
        elif isinstance(f, mongoengine.BooleanField):
            result = tastypie_fields.BooleanField
        elif isinstance(f, mongoengine.FloatField):
            result = tastypie_fields.FloatField
        elif isinstance(f, mongoengine.DecimalField):
            result = tastypie_fields.DecimalField
        elif isinstance(f, mongoengine.IntField):
            result = tastypie_fields.IntegerField
        elif isinstance(f, (mongoengine.FileField, mongoengine.BinaryField)):
            result = tastypie_fields.FileField
        elif isinstance(f, mongoengine.DictField):
            result = tastypie_fields.DictField
        elif isinstance(f, mongoengine.ListField):
            result = tastypie_fields.ListField
        elif isinstance(f, mongoengine.GeoPointField):
            result = tastypie_fields.ListField
        elif isinstance(f, mongoengine.ObjectIdField):
            result = tastypie_mongoengine_fields.ObjectId

        return result

    @classmethod
    def api_field_options(cls, name, field, options):
        """
        Allows dynamic change of field options when creating resource
        fields from document fields automatically.
        """

        return options

    @classmethod
    def get_fields(cls, fields=None, excludes=None):
        """
        Given any explicit fields to include and fields to exclude, add
        additional fields based on the associated document.
        """

        final_fields = {}
        fields = fields or []
        excludes = excludes or []

        if not cls._meta.object_class:
            return final_fields

        for name, f in cls._meta.object_class._fields.iteritems():
            # If the field name is already present, skip
            if name in cls.base_fields:
                continue

            # If field is not present in explicit field listing, skip
            if fields and name not in fields:
                continue

            # If field is in exclude list, skip
            if excludes and name in excludes:
                continue

            # TODO: Might need it in the future
            # if cls.should_skip_field(f):
            #     continue

            api_field_class = cls.api_field_from_mongo_field(f)

            primary_key = f.primary_key or name == getattr(cls._meta, 'id_field', 'id')

            kwargs = {
                'attribute': name,
                'unique': f.unique or primary_key,
                'null': not f.required and not primary_key,
                'help_text': f.help_text,
            }

            # If field is not required, it does not matter if set default value,
            # so we do
            if not f.required:
                kwargs['default'] = f.default
            else:
                # MongoEngine does not really differ between user-specified default
                # and its default, so we try to guess
                if isinstance(f, mongoengine.ListField):
                    if not callable(f.default) or f.default() != []: # If not MongoEngine's default
                        kwargs['default'] = f.default
                elif isinstance(f, mongoengine.DictField):
                    if not callable(f.default) or f.default() != {}: # If not MongoEngine's default
                        kwargs['default'] = f.default
                else:
                    if f.default is not None: # If not MongoEngine's default
                        kwargs['default'] = f.default

            kwargs = cls.api_field_options(name, f, kwargs)

            final_fields[name] = api_field_class(**kwargs)
            final_fields[name].instance_name = name
            final_fields[name]._primary_key = primary_key

            # We store MongoEngine field so that schema output can show
            # to which content the list is limited to (if any)
            if isinstance(f, mongoengine.ListField):
                final_fields[name].field = f.field

        return final_fields

    def update_in_place(self, request, original_bundle, new_data):
        """
        Update the object in original_bundle in-place using new_data.
        """

        # TODO: Is this the place to use MongoDB atomic operations to update the document?

        from tastypie.utils import dict_strip_unicode_keys
        original_bundle.data.update(**dict_strip_unicode_keys(new_data))

        # Now we've got a bundle with the new data sitting in it and we're
        # we're basically in the same spot as a PUT request. So the rest of this
        # function is cribbed from put_detail.
        self.alter_deserialized_detail_data(request, original_bundle.data)

        # Removed request from kwargs, breaking obj_get filter, currently present
        # in tastypie. See https://github.com/toastdriven/django-tastypie/issues/824.
        kwargs = {
            self._meta.detail_uri_name: self.get_bundle_detail_data(original_bundle),
        }
        return self.obj_update(bundle=original_bundle, **kwargs)


class MongoEngineListResource(MongoEngineResource):
    """
    A MongoEngine resource used in conjunction with EmbeddedListField.
    """

    def __init__(self, api_name=None):
        super(MongoEngineListResource, self).__init__(api_name)

        self.instance = None
        self.parent = self._parent(api_name)

        # Validate the fields and set primary key if needed
        for field_name, field in self._meta.object_class._fields.iteritems():
            if field.primary_key:
                # Ensure only one primary key is set
                current_pk = getattr(self._meta, 'id_field', None)
                if current_pk and current_pk != field_name:
                    raise ValueError('Cannot override primary key field')

                # Set primary key
                if not current_pk:
                    self._meta.id_field = field_name

    def _safe_get(self, bundle, **kwargs):
        filters = self.remove_api_resource_names(kwargs)

        try:
            return self.parent.cached_obj_get(bundle=bundle, **filters)
        except (queryset.DoesNotExist, exceptions.ObjectDoesNotExist):
            raise tastypie_exceptions.ImmediateHttpResponse(response=http.HttpNotFound())

    def dispatch(self, request_type, request, **kwargs):
        subresource_pk = kwargs.pop('subresource_pk', None)

        bundle = self.build_bundle(request=request)
        self.instance = self._safe_get(bundle, **kwargs)

        # We use subresource pk as pk from now on
        kwargs['pk'] = subresource_pk

        return super(MongoEngineListResource, self).dispatch(request_type, request, **kwargs)

    def remove_api_resource_names(self, url_dict):
        kwargs_subset = super(MongoEngineListResource, self).remove_api_resource_names(url_dict)

        for key in ['subresource_name']:
            try:
                del(kwargs_subset[key])
            except KeyError:
                pass

        return kwargs_subset

    def get_object_list(self, request):
        if not self.instance:
            return ListQuerySet()

        pk_field = getattr(self._meta, 'id_field', None)

        if pk_field is not None:
            object_list = []
            for obj in getattr(self.instance, self.attribute):
                pk = getattr(obj, pk_field)
                obj.__class__.pk = tastypie_mongoengine_fields.link_property(pk_field)
                object_list.append((unicode(pk), obj))
            return ListQuerySet(object_list)

        else:
            def add_index(index, obj):
                obj.pk = index
                return obj

            return ListQuerySet([(unicode(index), add_index(index, obj)) for index, obj in enumerate(getattr(self.instance, self.attribute))])

    def obj_create(self, bundle, **kwargs):
        try:
            bundle.obj = self._meta.object_class()

            for key, value in kwargs.items():
                setattr(bundle.obj, key, value)

            bundle = self.full_hydrate(bundle)

            object_list = getattr(self.instance, self.attribute)
            pk_field = getattr(self._meta, 'id_field', None)

            if pk_field is None:
                bundle.obj.pk = len(object_list)
            else:
                bundle.obj.__class__.pk = tastypie_mongoengine_fields.link_property(pk_field)

            object_list.append(bundle.obj)

            self.save_related(bundle)

            self.instance.save()

            m2m_bundle = self.hydrate_m2m(bundle)
            self.save_m2m(m2m_bundle)
            return bundle
        except mongoengine.ValidationError as ex:
            raise exceptions.ValidationError(ex.message)

    def find_embedded_document(self, objects, pk_field, pk):
        # TODO: Would it be faster to traverse in reversed direction? Because probably last elements are fetched more often in practice?
        # TODO: Should we cache information about mappings between IDs and elements?
        for i, obj in enumerate(objects):
            if getattr(obj, pk_field) == pk:
                return i

        raise IndexError("Embedded document with primary key '%s' not found." % pk)

    # TODO: Use skip_errors?
    def obj_update(self, bundle, skip_errors=False, **kwargs):
        try:
            if not bundle.obj or not getattr(bundle.obj, 'pk', None):
                try:
                    bundle.obj = self.obj_get(bundle=bundle, **kwargs)
                except (queryset.DoesNotExist, exceptions.ObjectDoesNotExist):
                    raise tastypie_exceptions.NotFound("A document instance matching the provided arguments could not be found.")

            bundle = self.full_hydrate(bundle)

            object_list = getattr(self.instance, self.attribute)
            pk_field = getattr(self._meta, 'id_field', None)

            if pk_field is None:
                object_list[bundle.obj.pk] = bundle.obj
            else:
                object_list[self.find_embedded_document(object_list, pk_field, bundle.obj.pk)] = bundle.obj

            self.save_related(bundle)

            self.instance.save()

            m2m_bundle = self.hydrate_m2m(bundle)
            self.save_m2m(m2m_bundle)
            return bundle
        except mongoengine.ValidationError as ex:
            raise exceptions.ValidationError(ex.message)

    def obj_delete(self, bundle, **kwargs):
        obj = kwargs.pop('_obj', None)

        if not getattr(obj, 'pk', None):
            try:
                obj = self.obj_get(bundle=bundle, **kwargs)
            except (queryset.DoesNotExist, exceptions.ObjectDoesNotExist):
                raise tastypie_exceptions.NotFound("A document instance matching the provided arguments could not be found.")

        object_list = getattr(self.instance, self.attribute)
        pk_field = getattr(self._meta, 'id_field', None)

        if pk_field is None:
            object_list.pop(obj.pk)
        else:
            object_list.pop(self.find_embedded_document(object_list, pk_field, obj.pk))

        # Make sure to delete FileField files
        for fieldname, field in obj._fields.items():
            if isinstance(field, mongoengine_fields.FileField):
                obj[fieldname].delete()

        self.instance.save()

    def detail_uri_kwargs(self, bundle_or_obj):
        if isinstance(bundle_or_obj, tastypie_bundle.Bundle):
            obj = bundle_or_obj.obj
        else:
            obj = bundle_or_obj

        kwargs = {
            'resource_name': self.parent._meta.resource_name,
            'subresource_name': self.attribute,
            'subresource_pk': obj.pk,
        }

        if hasattr(obj, 'parent'):
            # pk could not exist in the case of nested resources, but we should not come here in this
            # case as we should remove resource_uri from fields in MongoEngineModelDeclarativeMetaclass
            # TODO: Support nested resources
            kwargs['pk'] = obj.parent.pk
        else:
            kwargs['pk'] = self.instance.pk

        if self._meta.api_name is not None:
            kwargs['api_name'] = self._meta.api_name

        return kwargs

    def get_resource_uri(self, bundle_or_obj=None, url_name='api_dispatch_subresource_list'):
        if bundle_or_obj is not None:
            url_name = 'api_dispatch_subresource_detail'

        try:
            return self._build_reverse_url(url_name, kwargs=self.resource_uri_kwargs(bundle_or_obj))
        except urlresolvers.NoReverseMatch:
            return ''

########NEW FILE########
__FILENAME__ = test_runner
import urlparse

from django.conf import settings
from django.test import client, simple, testcases
from django.utils import unittest

from mongoengine import connect, connection
from mongoengine.django import tests


class MongoEngineTestSuiteRunner(simple.DjangoTestSuiteRunner):
    """
    It is the same as in DjangoTestSuiteRunner, but without relational databases.

    It also supports filtering only wanted tests through ``TEST_RUNNER_FILTER``
    Django setting.
    """

    db_name = 'test_%s' % settings.MONGO_DATABASE_NAME

    def _filter_suite(self, suite):
        filters = getattr(settings, 'TEST_RUNNER_FILTER', None)

        if filters is None:
            # We do NOT filter if filters are not set
            return suite

        filtered = unittest.TestSuite()

        for test in suite:
            if isinstance(test, unittest.TestSuite):
                filtered.addTests(self._filter_suite(test))
            else:
                for f in filters:
                    if test.id().startswith(f):
                        filtered.addTest(test)

        return filtered

    def build_suite(self, test_labels, extra_tests=None, **kwargs):
        suite = super(MongoEngineTestSuiteRunner, self).build_suite(test_labels, extra_tests=None, **kwargs)
        suite = self._filter_suite(suite)
        return simple.reorder_suite(suite, (testcases.TestCase,))

    def setup_databases(self, **kwargs):
        connection.disconnect()
        connect(self.db_name, **getattr(settings, 'MONGO_DATABASE_OPTIONS', {}))

    def teardown_databases(self, old_config, **kwargs):
        connection.get_connection().drop_database(self.db_name)


class MongoEngineTestCase(tests.MongoTestCase):
    """
    A bugfixed version, see this `pull request`_.

    .. _pull request: https://github.com/hmarr/mongoengine/pull/506
    """

    def __init__(self, methodName='runtest'):
        # We skip MongoTestCase init
        super(tests.MongoTestCase, self).__init__(methodName)

    def _post_teardown(self):
        self.db = connection.get_db()
        super(MongoEngineTestCase, self)._post_teardown()


# We also patch Django so that it supports PATCH requests (used by Tastypie)
# Taken from https://code.djangoproject.com/attachment/ticket/17797/django-test-client-PATCH.patch

def requestfactory_patch(self, path, data=None, content_type=client.MULTIPART_CONTENT, **extra):
    """
    Construct a PATCH request.
    """

    data = data or {}
    patch_data = self._encode_data(data, content_type)

    parsed = urlparse.urlparse(path)
    request = {
        'CONTENT_LENGTH': len(patch_data),
        'CONTENT_TYPE': content_type,
        'PATH_INFO': self._get_path(parsed),
        'QUERY_STRING': parsed[4],
        'REQUEST_METHOD': 'PATCH',
        'wsgi.input': client.FakePayload(patch_data),
    }
    request.update(extra)
    return self.request(**request)


def client_patch(self, path, data=None, content_type=client.MULTIPART_CONTENT, follow=False, **extra):
    """
    Send a resource to the server using PATCH.
    """

    data = data or {}
    response = super(client.Client, self).patch(path, data=data, content_type=content_type, **extra)
    if follow:
        response = self._handle_redirects(response, **extra)
    return response

if not hasattr(client.RequestFactory, 'patch'):
    client.RequestFactory.patch = requestfactory_patch

if not hasattr(client.Client, 'patch'):
    client.Client.patch = client_patch

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_project.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import os
import sys

sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))


def runtests():
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_project.settings")

    from django.core.management import execute_from_command_line

    argv = [sys.argv[0], 'test', '--verbosity=2']
    execute_from_command_line(argv)
    sys.exit(0)

if __name__ == "__main__":
    runtests()

########NEW FILE########
__FILENAME__ = settings
# Django settings for test_project project

DEBUG = True

# We are not really using a relational database, but tests fail without
# defining it because flush command is being run, which expects it
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
    }
}

# Make this unique, and don't share it with anybody
SECRET_KEY = 'sq=uf!nqw=aibl+y1&5pp=)b7pc=c$4hnh$om*_c48r)^t!ob)'

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'test_project.urls'

AUTHENTICATION_BACKENDS = (
    'mongoengine.django.auth.MongoEngineBackend',
)

SESSION_ENGINE = 'mongoengine.django.sessions'

TEST_RUNNER = 'tastypie_mongoengine.test_runner.MongoEngineTestSuiteRunner'

INSTALLED_APPS = (
    'tastypie',
    'tastypie_mongoengine',
    'test_project.test_app',
)

MONGO_DATABASE_NAME = 'test_project'

import mongoengine
mongoengine.connect(MONGO_DATABASE_NAME)

if mongoengine.VERSION >= (0, 8, 0):
    AUTH_USER_MODEL = 'mongo_auth.MongoUser'
    INSTALLED_APPS = (
        'mongoengine.django.mongo_auth',
    ) + INSTALLED_APPS

########NEW FILE########
__FILENAME__ = resources
from tastypie import authorization as tastypie_authorization, fields as tastypie_fields

from tastypie_mongoengine import fields, paginator, resources

from test_project.test_app import documents


class StrangePersonResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.StrangePerson.objects.all()
        excludes = ('hidden',)


class OtherStrangePersonResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.StrangePerson.objects.all()
        excludes = ('hidden',)


class PersonResource(resources.MongoEngineResource):
    class Meta:
        # Ordering by id so that pagination is predictable
        queryset = documents.Person.objects.all().order_by('id')
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()
        ordering = ('name',)
        excludes = ('hidden',)
        paginator_class = paginator.Paginator

        polymorphic = {
            'person': 'self',
            'strangeperson': StrangePersonResource,
        }


class PersonObjectClassResource(resources.MongoEngineResource):
    class Meta:
        object_class = documents.Person
        allowed_methods = ('get', 'post')
        authorization = tastypie_authorization.Authorization()
        resource_name = 'personobjectclass'


class OnlySubtypePersonResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.Person.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()
        excludes = ('hidden',)

        polymorphic = {
            'strangeperson': StrangePersonResource,
        }


class EmbeddedStrangePersonResource(resources.MongoEngineResource):
    class Meta:
        object_class = documents.EmbeddedStrangePerson


class EmbeddedPersonResource(resources.MongoEngineResource):
    class Meta:
        object_class = documents.EmbeddedPerson
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()
        ordering = ('name',)
        excludes = ('hidden',)

        polymorphic = {
            'person': 'self',
            'strangeperson': EmbeddedStrangePersonResource,
        }


class IndividualResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.Individual.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()
        paginator_class = paginator.Paginator


class CompanyResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.Company.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()
        paginator_class = paginator.Paginator


class UnregisteredCompanyResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.UnregisteredCompany.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()
        paginator_class = paginator.Paginator


class ContactResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.Contact.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()

        prefer_polymorphic_resource_uri = True
        polymorphic = {
            'individual': IndividualResource,
            'company': CompanyResource,
            'unregisteredcompany': UnregisteredCompanyResource,
        }


class ContactGroupResource(resources.MongoEngineResource):
    contacts = fields.ReferencedListField(of='test_project.test_app.api.resources.ContactResource', attribute='contacts', null=True)

    class Meta:
        queryset = documents.ContactGroup.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class CustomerResource(resources.MongoEngineResource):
    person = fields.ReferenceField(to='test_project.test_app.api.resources.PersonResource', attribute='person', full=True)

    class Meta:
        queryset = documents.Customer.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class EmbeddedCommentResource(resources.MongoEngineResource):
    class Meta:
        object_class = documents.EmbeddedComment


class EmbeddedPostResource(resources.MongoEngineResource):
    comments = fields.EmbeddedListField(of='test_project.test_app.api.resources.EmbeddedCommentResource', attribute='comments', full=True, null=True)

    class Meta:
        object_class = documents.EmbeddedPost
        ordering = ('title', 'comments')


class BoardResource(resources.MongoEngineResource):
    posts = fields.EmbeddedListField(of='test_project.test_app.api.resources.EmbeddedPostResource', attribute='posts', full=True, null=True)

    class Meta:
        queryset = documents.Board.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class EmbeddedCommentWithIDResource(resources.MongoEngineResource):
    class Meta:
        object_class = documents.EmbeddedCommentWithID
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()
        paginator_class = paginator.Paginator


class DocumentWithIDResource(resources.MongoEngineResource):
    comments = fields.EmbeddedListField(of='test_project.test_app.api.resources.EmbeddedCommentWithIDResource', attribute='comments', full=True, null=True)

    class Meta:
        queryset = documents.DocumentWithID.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class EmbeddedListInEmbeddedDocTestResource(resources.MongoEngineResource):
    post = fields.EmbeddedDocumentField(embedded='test_project.test_app.api.resources.EmbeddedPostResource', attribute='post')

    class Meta:
        queryset = documents.EmbeddedListInEmbeddedDocTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class EmbeddedDocumentFieldTestResource(resources.MongoEngineResource):
    customer = fields.EmbeddedDocumentField(embedded='test_project.test_app.api.resources.EmbeddedPersonResource', attribute='customer', null=True)

    class Meta:
        queryset = documents.EmbeddedDocumentFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class DictFieldTestResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.DictFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class ListFieldTestResource(resources.MongoEngineResource):
    extra_list = tastypie_fields.ListField()

    class Meta:
        queryset = documents.ListFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class EmbeddedListFieldTestResource(resources.MongoEngineResource):
    embeddedlist = fields.EmbeddedListField(of='test_project.test_app.api.resources.EmbeddedPersonResource', attribute='embeddedlist', full=True, null=True)

    class Meta:
        queryset = documents.EmbeddedListFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()
        ordering = ('id', 'embeddedlist')


class EmbeddedListFieldNonFullTestResource(resources.MongoEngineResource):
    embeddedlist = fields.EmbeddedListField(of='test_project.test_app.api.resources.EmbeddedPersonResource', attribute='embeddedlist', full=False, null=True)

    class Meta:
        queryset = documents.EmbeddedListFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class ReferencedListFieldTestResource(resources.MongoEngineResource):
    referencedlist = fields.ReferencedListField(of='test_project.test_app.api.resources.PersonResource', attribute='referencedlist', full=True, null=True)

    class Meta:
        queryset = documents.ReferencedListFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class ReferencedListFieldNonFullTestResource(resources.MongoEngineResource):
    referencedlist = fields.ReferencedListField(of='test_project.test_app.api.resources.PersonResource', attribute='referencedlist', full=False, null=True)

    class Meta:
        queryset = documents.ReferencedListFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class BooleanMapTestResource(resources.MongoEngineResource):
    is_published_defined = tastypie_fields.BooleanField(default=False, null=False, attribute='is_published_defined')

    class Meta:
        queryset = documents.BooleanMapTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class EmbeddedListWithFlagFieldTestResource(resources.MongoEngineResource):
    embeddedlist = fields.EmbeddedListField(of='test_project.test_app.api.resources.EmbeddedPersonResource', attribute='embeddedlist', full=True, null=True)

    class Meta:
        queryset = documents.EmbeddedListWithFlagFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class AutoAllocationFieldTestResource(resources.MongoEngineResource):
    slug = tastypie_fields.CharField(readonly=True, attribute='slug')

    class Meta:
        queryset = documents.AutoAllocationFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class ExporterResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.Exporter.objects.all()
        resource_name = 'exporters'
        allowed_methods = ('get', 'post', 'put', 'delete')
        authorization = tastypie_authorization.Authorization()


class EmbeddedExporterListResource(resources.MongoEngineResource):
    exporter = fields.ReferenceField(to='test_project.test_app.api.resources.ExporterResource', attribute='exporter', full=True)

    class Meta:
        object_class = documents.PipeExporterEmbedded


class PipeResource(resources.MongoEngineResource):
    exporters = fields.EmbeddedListField(of='test_project.test_app.api.resources.EmbeddedExporterListResource', attribute='exporters', full=True, null=True)

    class Meta:
        queryset = documents.Pipe.objects.all()
        resource_name = 'pipes'
        allowed_methods = ('get', 'post', 'put', 'delete')
        authorization = tastypie_authorization.Authorization()


class BlankableEmbeddedResource(resources.MongoEngineResource):
    class Meta:
        object_class = documents.BlankableEmbedded


class BlankableParentResource(resources.MongoEngineResource):
    embedded = fields.EmbeddedDocumentField(embedded='test_project.test_app.api.resources.BlankableEmbeddedResource', attribute='embedded', blank=True)

    class Meta:
        queryset = documents.BlankableParent.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class TimezonedDateTimeResource(resources.MongoEngineResource):
    class Meta:
        object_class = documents.TimezonedDateTime


class ReadonlyParentResource(resources.MongoEngineResource):
    tzdt = fields.EmbeddedDocumentField(embedded='test_project.test_app.api.resources.TimezonedDateTimeResource', attribute='tzdt', readonly=True)

    class Meta:
        queryset = documents.ReadonlyParent.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()


class DatetimeFieldTestResource(resources.MongoEngineResource):
    class Meta:
        queryset = documents.DatetimeFieldTest.objects.all()
        allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
        authorization = tastypie_authorization.Authorization()

########NEW FILE########
__FILENAME__ = documents
import bson
import mongoengine
import datetime


class InheritableDocument(mongoengine.Document):
    meta = {
        'abstract': True,
        'allow_inheritance': True,
    }


class InheritableEmbeddedDocument(mongoengine.EmbeddedDocument):
    meta = {
        'abstract': True,
        'allow_inheritance': True,
    }


class Person(InheritableDocument):
    name = mongoengine.StringField(max_length=200, required=True, unique=True)
    optional = mongoengine.StringField(max_length=200, required=False)
    hidden = mongoengine.StringField(max_length=200, required=False)


class StrangePerson(Person):
    strange = mongoengine.StringField(max_length=100, required=True)


class Contact(InheritableDocument):
    phone = mongoengine.StringField(max_length=16, required=True)


class Individual(Contact):
    name = mongoengine.StringField(max_length=200, required=True)


class Company(Contact):
    corporate_name = mongoengine.StringField(max_length=200, required=True)


class UnregisteredCompany(Company):
    pass


class ContactGroup(InheritableDocument):
    contacts = mongoengine.ListField(mongoengine.ReferenceField(Contact, required=True))


class EmbeddedPerson(InheritableEmbeddedDocument):
    name = mongoengine.StringField(max_length=200, required=True)
    optional = mongoengine.StringField(max_length=200, required=False)
    hidden = mongoengine.StringField(max_length=200, required=False)


class EmbeddedStrangePerson(EmbeddedPerson):
    strange = mongoengine.StringField(max_length=100, required=True)


class Customer(InheritableDocument):
    person = mongoengine.ReferenceField(Person)
    employed = mongoengine.BooleanField(default=False)


class EmbeddedComment(InheritableEmbeddedDocument):
    content = mongoengine.StringField(max_length=200, required=True)


class EmbeddedPost(InheritableEmbeddedDocument):
    title = mongoengine.StringField(max_length=200, required=True)
    comments = mongoengine.ListField(mongoengine.EmbeddedDocumentField(EmbeddedComment))


class Board(InheritableDocument):
    posts = mongoengine.ListField(mongoengine.EmbeddedDocumentField(EmbeddedPost))


class EmbeddedCommentWithID(InheritableEmbeddedDocument):
    id = mongoengine.ObjectIdField(primary_key=True, default=lambda: bson.ObjectId())
    content = mongoengine.StringField(max_length=200, required=True)


class DocumentWithID(InheritableDocument):
    title = mongoengine.StringField(max_length=200, required=True)
    comments = mongoengine.ListField(mongoengine.EmbeddedDocumentField(EmbeddedCommentWithID))


class EmbeddedListInEmbeddedDocTest(InheritableDocument):
    post = mongoengine.EmbeddedDocumentField(EmbeddedPost)


class EmbeddedDocumentFieldTest(InheritableDocument):
    customer = mongoengine.EmbeddedDocumentField(EmbeddedPerson)


class DictFieldTest(InheritableDocument):
    dictionary = mongoengine.DictField(required=True)


class ListFieldTest(InheritableDocument):
    stringlist = mongoengine.ListField(mongoengine.StringField())
    intlist = mongoengine.ListField(mongoengine.IntField())
    anytype = mongoengine.ListField()


class EmbeddedListFieldTest(InheritableDocument):
    embeddedlist = mongoengine.ListField(mongoengine.EmbeddedDocumentField(EmbeddedPerson))


class ReferencedListFieldTest(InheritableDocument):
    referencedlist = mongoengine.ListField(mongoengine.ReferenceField(Person))


class BooleanMapTest(InheritableDocument):
    is_published_auto = mongoengine.BooleanField(default=False, required=True)
    is_published_defined = mongoengine.BooleanField(default=False, required=True)


class EmbeddedListWithFlagFieldTest(InheritableDocument):
    embeddedlist = mongoengine.ListField(mongoengine.EmbeddedDocumentField(EmbeddedPerson))
    is_published = mongoengine.BooleanField(default=False, required=True)


class AutoAllocationFieldTest(InheritableDocument):
    name = mongoengine.StringField(required=True)
    slug = mongoengine.StringField(required=True)

    def save(self, *args, **kwargs):
        from django.template.defaultfilters import slugify
        if not self.slug:
            self.slug = slugify(self.name)
        super(AutoAllocationFieldTest, self).save(*args, **kwargs)


class Exporter(InheritableDocument):
    name = mongoengine.StringField(required=True, unique=True)


class PipeExporterEmbedded(InheritableEmbeddedDocument):
    name = mongoengine.StringField(required=True)
    exporter = mongoengine.ReferenceField(Exporter, required=True)


class Pipe(InheritableDocument):
    name = mongoengine.StringField(required=True, unique=True)
    exporters = mongoengine.ListField(mongoengine.EmbeddedDocumentField(PipeExporterEmbedded))


class BlankableEmbedded(InheritableEmbeddedDocument):
    name = mongoengine.StringField(required=True, default='A blank name')
    description = mongoengine.StringField()


class BlankableParent(InheritableDocument):
    embedded = mongoengine.EmbeddedDocumentField(BlankableEmbedded, required=True, default=lambda: BlankableEmbedded())


class TimezonedDateTime(InheritableEmbeddedDocument):
    dt = mongoengine.DateTimeField(required=True)
    tz = mongoengine.StringField(required=True)


class ReadonlyParent(InheritableDocument):
    name = mongoengine.StringField(required=True)
    tzdt = mongoengine.EmbeddedDocumentField(TimezonedDateTime, required=True, default=lambda: TimezonedDateTime(dt=datetime.datetime(2012, 12, 12, 12, 12, 12), tz='UTC'))


class DatetimeFieldTest(InheritableDocument):
    datetime = mongoengine.DateTimeField(required=True)

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = test_basic
from __future__ import with_statement

import urlparse

from django.core import exceptions, urlresolvers
from django.test import client, utils
from django.utils import simplejson as json

import tastypie
from tastypie import authorization as tastypie_authorization

from tastypie_mongoengine import resources as tastypie_mongoengine_resources, test_runner

from test_project.test_app import documents
from test_project.test_app.api import resources


# TODO: Test set operations
# TODO: Test bulk operations
# TODO: Test ordering, filtering
# TODO: Use Tastypie's testcase class for tests?

@utils.override_settings(DEBUG=True)
class BasicTest(test_runner.MongoEngineTestCase):
    api_name = 'v1'
    c = client.Client()

    def resourceListURI(self, resource_name):
        return urlresolvers.reverse('api_dispatch_list', kwargs={'api_name': self.api_name, 'resource_name': resource_name})

    def resourcePK(self, resource_uri):
        match = urlresolvers.resolve(resource_uri)
        return match.kwargs['pk']

    def resourceDetailURI(self, resource_name, resource_pk):
        return urlresolvers.reverse('api_dispatch_detail', kwargs={'api_name': self.api_name, 'resource_name': resource_name, 'pk': resource_pk})

    def fullURItoAbsoluteURI(self, uri):
        scheme, netloc, path, query, fragment = urlparse.urlsplit(uri)
        return urlparse.urlunsplit((None, None, path, query, fragment))

    def test_basic(self):
        # Testing POST

        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 1"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        person1_uri = response['location']

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1')
        self.assertEqual(response['optional'], None)

        # Covered by Tastypie
        response = self.c.post(self.resourceListURI('person'), '{"name": null}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        # Covered by Tastypie
        response = self.c.post(self.resourceListURI('person'), '{}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        # Covered by Tastypie
        response = self.c.post(self.resourceListURI('person'), '{"optional": "Optional"}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        # Covered by MongoEngine validation
        response = self.c.post(self.resourceListURI('person'), '{"name": []}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        # Covered by MongoEngine validation
        response = self.c.post(self.resourceListURI('person'), '{"name": {}}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 2 null", "optional": null}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 2", "optional": "Optional"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        person2_uri = response['location']

        response = self.c.get(person2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 2')
        self.assertEqual(response['optional'], 'Optional')

        # Tastypie ignores additional field
        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 3", "additional": "Additional"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        # Referenced resources can be matched through fields if an unique field is used
        response = self.c.post(self.resourceListURI('customer'), '{"person": {"name": "Person 1"}}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        customer1_uri = response['location']

        response = self.c.get(customer1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['person']['name'], 'Person 1')
        self.assertEqual(response['person']['optional'], None)
        self.assertEqual(response['person']['resource_uri'], self.fullURItoAbsoluteURI(person1_uri))

        person1_id = response['person']['id']

        # Referenced resources can be even updated at the same time
        response = self.c.post(self.resourceListURI('customer'), '{"person": {"id": "%s", "name": "Person 1 UPDATED"}}' % person1_id, content_type='application/json')
        self.assertEqual(response.status_code, 201)

        customer2_uri = response['location']

        response = self.c.get(customer2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['person']['name'], 'Person 1 UPDATED')
        self.assertEqual(response['person']['optional'], None)
        self.assertEqual(response['person']['resource_uri'], self.fullURItoAbsoluteURI(person1_uri))
        self.assertEqual(response['employed'], False)

        response = self.c.post(self.resourceListURI('customer'), '{"person": "%s"}' % self.fullURItoAbsoluteURI(person1_uri), content_type='application/json')
        self.assertEqual(response.status_code, 201)

        customer3_uri = response['location']

        response = self.c.get(customer3_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['person']['name'], 'Person 1 UPDATED')
        self.assertEqual(response['person']['optional'], None)
        self.assertEqual(response['person']['resource_uri'], self.fullURItoAbsoluteURI(person1_uri))

        response = self.c.get(self.resourceListURI('person'))
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['objects']), 4)

        # Referenced resources can also be created automatically
        response = self.c.post(self.resourceListURI('customer'), '{"person": {"name": "Person does not YET exist"}}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        customer4_uri = response['location']

        response = self.c.get(customer4_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['person']['name'], 'Person does not YET exist')
        self.assertEqual(response['person']['optional'], None)

        person5_uri = response['person']['resource_uri']

        response = self.c.get(person5_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person does not YET exist')
        self.assertEqual(response['optional'], None)

        response = self.c.get(self.resourceListURI('person'))
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['objects']), 5)

        response = self.c.post(self.resourceListURI('embeddeddocumentfieldtest'), '{"customer": {"name": "Embedded person 1"}}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        embeddeddocumentfieldtest_uri = response['location']

        response = self.c.get(embeddeddocumentfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['customer']['name'], 'Embedded person 1')

        # Covered by MongoEngine validation
        response = self.c.post(self.resourceListURI('dictfieldtest'), '{"dictionary": {}}', content_type='application/json')
        self.assertContains(response, 'required and cannot be empty', status_code=400)

        # Covered by MongoEngine validation
        response = self.c.post(self.resourceListURI('dictfieldtest'), '{"dictionary": null}', content_type='application/json')
        self.assertContains(response, 'required and cannot be empty', status_code=400)

        # Covered by MongoEngine validation
        response = self.c.post(self.resourceListURI('dictfieldtest'), '{"dictionary": false}', content_type='application/json')
        self.assertContains(response, 'dictionaries may be used', status_code=400)

        response = self.c.post(self.resourceListURI('dictfieldtest'), '{"dictionary": {"a": "abc", "number": 34}}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        dictfieldtest_uri = response['location']

        response = self.c.get(dictfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['dictionary']['a'], 'abc')
        self.assertEqual(response['dictionary']['number'], 34)

        response = self.c.post(self.resourceListURI('listfieldtest'), '{"intlist": [1, 2, 3, 4], "stringlist": ["a", "b", "c"], "anytype": ["a", 1, null, 2]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        listfieldtest_uri = response['location']

        response = self.c.get(listfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['intlist'], [1, 2, 3, 4])
        self.assertEqual(response['stringlist'], ['a', 'b', 'c'])
        self.assertEqual(response['anytype'], ['a', 1, None, 2])

        # Field is not required
        response = self.c.post(self.resourceListURI('embeddedlistfieldtest'), '{"embeddedlist": []}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('embeddedlistfieldtest'), '{"embeddedlist": [{"name": "Embedded person 1"}, {"name": "Embedded person 2", "hidden": "Should be hidden"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        embeddedlistfieldtest_uri = response['location']

        response = self.c.get(embeddedlistfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['embeddedlist'][0]['name'], 'Embedded person 1')
        self.assertEqual(response['embeddedlist'][1]['name'], 'Embedded person 2')
        self.assertTrue('hidden' not in response['embeddedlist'][1])
        self.assertEqual(len(response['embeddedlist']), 2)

        embeddedlistfieldtest_object = documents.EmbeddedListFieldTest.objects.get(pk=self.resourcePK(self.fullURItoAbsoluteURI(embeddedlistfieldtest_uri)))
        self.assertEqual(embeddedlistfieldtest_object.embeddedlist[1].hidden, None)

        response = self.c.post(self.resourceListURI('embeddedlistfieldtest'), '{"embeddedlist": ["%s"]}' % self.fullURItoAbsoluteURI(person1_uri), content_type='application/json')
        self.assertContains(response, 'was not given a dictionary-alike data', status_code=400)

        response = self.c.post(self.resourceListURI('embeddedlistfieldnonfulltest'), '{"embeddedlist": [{"name": "Embedded person 1"}, {"name": "Embedded person 2", "hidden": "Should be hidden"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        embeddedlistfieldnonfulltest_uri = response['location']

        response = self.c.get(embeddedlistfieldnonfulltest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['embeddedlist']), 2)

        for i, person_uri in enumerate(response['embeddedlist']):
            person = self.c.get(person_uri)
            self.assertEqual(person.status_code, 200)
            person = json.loads(person.content)

            self.assertEqual(person['name'], 'Embedded person %d' % (i + 1))
            self.assertTrue('hidden' not in person)

        embeddedlistfieldtest_object = documents.EmbeddedListFieldTest.objects.get(pk=self.resourcePK(self.fullURItoAbsoluteURI(embeddedlistfieldnonfulltest_uri)))
        self.assertEqual(embeddedlistfieldtest_object.embeddedlist[1].hidden, None)

        # Testing PUT

        response = self.c.put(person1_uri, '{"name": "Person 1z"}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        # Covered by Tastypie
        response = self.c.put(person1_uri, '{"name": null}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        # Covered by Tastypie
        response = self.c.put(person1_uri, '{}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        # Covered by Tastypie
        response = self.c.put(person1_uri, '{"optional": "Optional ZZZ"}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        # Covered by MongoEngine validation
        response = self.c.put(person1_uri, '{"name": []}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        # Covered by MongoEngine validation
        response = self.c.put(person1_uri, '{"name": {}}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1z')

        response = self.c.put(customer2_uri, '{"person": "%s"}' % self.fullURItoAbsoluteURI(person2_uri), content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(customer2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['person']['name'], 'Person 2')
        self.assertEqual(response['person']['optional'], 'Optional')

        response = self.c.put(embeddeddocumentfieldtest_uri, '{"customer": null}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embeddeddocumentfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['customer'], None)

        response = self.c.put(embeddeddocumentfieldtest_uri, '{"customer": {"name": "Embedded person 1a"}}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embeddeddocumentfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['customer']['name'], 'Embedded person 1a')

        response = self.c.put(dictfieldtest_uri, '{"dictionary": {"a": 341, "number": "abcd"}}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(dictfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['dictionary']['number'], 'abcd')
        self.assertEqual(response['dictionary']['a'], 341)

        response = self.c.put(listfieldtest_uri, '{"intlist": [1, 2, 4], "stringlist": ["a", "b", "c", "d"], "anytype": [null, "1", 1]}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(listfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['intlist'], [1, 2, 4])
        self.assertEqual(response['stringlist'], ['a', 'b', 'c', 'd'])
        self.assertEqual(response['anytype'], [None, "1", 1])

        response = self.c.put(embeddedlistfieldtest_uri, '{"embeddedlist": [{"name": "Embedded person 1a"}, {"name": "Embedded person 2a"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embeddedlistfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['embeddedlist'][0]['name'], 'Embedded person 1a')
        self.assertEqual(response['embeddedlist'][1]['name'], 'Embedded person 2a')
        self.assertEqual(len(response['embeddedlist']), 2)

        response = self.c.put(embeddedlistfieldtest_uri, '{"embeddedlist": [{"name": "Embedded person 123"}, {}]}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        response = self.c.put(embeddedlistfieldnonfulltest_uri, '{"embeddedlist": [{"name": "Embedded person 1a"}, {"name": "Embedded person 2a"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embeddedlistfieldnonfulltest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['embeddedlist']), 2)

        for i, person_uri in enumerate(response['embeddedlist']):
            person = self.c.get(person_uri)
            self.assertEqual(person.status_code, 200)
            person = json.loads(person.content)

            self.assertEqual(person['name'], 'Embedded person %da' % (i + 1))

        # Testing PATCH

        response = self.c.patch(person1_uri, '{"name": "Person 1 PATCHED"}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        # Covered by Tastypie
        response = self.c.patch(person1_uri, '{"name": null}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        # Should not do anything, but succeed
        response = self.c.patch(person1_uri, '{}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        # Tastypie ignores additional field, should not do anything, but succeed
        response = self.c.patch(person1_uri, '{"additional": "Additional"}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        # Covered by Tastypie
        response = self.c.patch(person1_uri, '{"optional": "Optional PATCHED"}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        # Covered by MongoEngine validation
        response = self.c.patch(person1_uri, '{"name": []}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        # Covered by MongoEngine validation
        response = self.c.patch(person1_uri, '{"name": {}}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1 PATCHED')
        self.assertEqual(response['optional'], 'Optional PATCHED')

        response = self.c.patch(customer2_uri, '{"person": "%s"}' % self.fullURItoAbsoluteURI(person1_uri), content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(customer2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['person']['name'], 'Person 1 PATCHED')
        self.assertEqual(response['person']['optional'], 'Optional PATCHED')

        self.assertEqual(response['employed'], False)

        # There is a bug in Tastypie, so we test only on versions which have it fixed
        # https://github.com/toastdriven/django-tastypie/issues/501
        # https://github.com/toastdriven/django-tastypie/commit/e4de9377cb
        if tastypie.__version__ > (0, 9, 11):
            response = self.c.patch(customer2_uri, '{"employed": true}', content_type='application/json')
            self.assertEqual(response.status_code, 202)

            response = self.c.get(customer2_uri)
            self.assertEqual(response.status_code, 200)
            response = json.loads(response.content)

            self.assertEqual(response['employed'], True)

        response = self.c.patch(embeddeddocumentfieldtest_uri, '{"customer": {"name": "Embedded person PATCHED"}}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(embeddeddocumentfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['customer']['name'], 'Embedded person PATCHED')

        response = self.c.patch(dictfieldtest_uri, '{"dictionary": {"a": 42}}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(dictfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['dictionary']['a'], 42)
        self.assertTrue('number' not in response['dictionary'])

        response = self.c.patch(listfieldtest_uri, '{"intlist": [1, 2, 42]}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(listfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['intlist'], [1, 2, 42])
        self.assertEqual(response['stringlist'], ['a', 'b', 'c', 'd'])
        self.assertEqual(response['anytype'], [None, "1", 1])

        response = self.c.patch(embeddedlistfieldtest_uri, '{"embeddedlist": [{"name": "Embedded person PATCHED"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(embeddedlistfieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['embeddedlist'][0]['name'], 'Embedded person PATCHED')
        self.assertEqual(len(response['embeddedlist']), 1)

        # Testing DELETE

        response = self.c.delete(person1_uri)
        self.assertEqual(response.status_code, 204)

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 404)

    def test_objectclass(self):
        response = self.c.get(self.resourceListURI('personobjectclass'))

        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)
        self.assertEqual(len(response['objects']), 0)

        response = self.c.post(self.resourceListURI('personobjectclass'), '{"name": "Person 1"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        person1_uri = response['location']

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1')
        self.assertEqual(response['optional'], None)

    def test_schema(self):
        embeddeddocumentfieldtest_schema_uri = self.resourceListURI('embeddeddocumentfieldtest') + 'schema/'

        response = self.c.get(embeddeddocumentfieldtest_schema_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['fields']), 3)
        self.assertEqual(len(response['fields']['customer']['embedded']['fields']), 3)
        self.assertTrue('name' in response['fields']['customer']['embedded']['fields'])
        self.assertTrue('optional' in response['fields']['customer']['embedded']['fields'])
        self.assertTrue('resource_type' in response['fields']['customer']['embedded']['fields'])

        customer_schema_uri = self.resourceListURI('customer') + 'schema/'

        response = self.c.get(customer_schema_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['fields']), 4)
        self.assertEqual(response['fields']['person']['reference_uri'], self.resourceListURI('person'))

        listfieldtest_schema_uri = self.resourceListURI('listfieldtest') + 'schema/'

        response = self.c.get(listfieldtest_schema_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['fields']), 6)
        self.assertEqual(response['fields']['intlist']['content']['type'], 'int')
        self.assertEqual(response['fields']['stringlist']['content']['type'], 'string')
        self.assertTrue('content' not in response['fields']['anytype'])

        embeddedlistfieldtest_schema_uri = self.resourceListURI('embeddedlistfieldtest') + 'schema/'

        response = self.c.get(embeddedlistfieldtest_schema_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['fields']), 3)
        self.assertEqual(len(response['fields']['embeddedlist']['embedded']['fields']), 4)
        self.assertTrue('name' in response['fields']['embeddedlist']['embedded']['fields'])
        self.assertTrue('optional' in response['fields']['embeddedlist']['embedded']['fields'])
        self.assertTrue('resource_uri' in response['fields']['embeddedlist']['embedded']['fields'])
        self.assertTrue('resource_type' in response['fields']['embeddedlist']['embedded']['fields'])

        self.assertEqual(len(response['fields']['embeddedlist']['embedded']['resource_types']), 2)
        self.assertTrue('person' in response['fields']['embeddedlist']['embedded']['resource_types'])
        self.assertTrue('strangeperson' in response['fields']['embeddedlist']['embedded']['resource_types'])

        referencedlistfieldtest_schema_uri = self.resourceListURI('referencedlistfieldtest') + 'schema/'

        response = self.c.get(referencedlistfieldtest_schema_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['fields']), 3)
        self.assertTrue('reference_schema' in response['fields']['referencedlist'])
        self.assertTrue('reference_uri' in response['fields']['referencedlist'])

    def test_invalid(self):
        # Invalid ObjectId
        response = self.c.get(self.resourceListURI('customer') + 'foobar/')
        self.assertEqual(response.status_code, 404)

    def test_embeddedlist(self):
        # Testing POST

        response = self.c.post(self.resourceListURI('embeddedlistfieldtest'), '{"embeddedlist": [{"name": "Embedded person 1"}, {"name": "Embedded person 2", "optional": "Optional"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        mainresource_uri = response['location']

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['embeddedlist'][0]['name'], 'Embedded person 1')
        self.assertEqual(response['embeddedlist'][0]['optional'], None)
        self.assertEqual(response['embeddedlist'][1]['name'], 'Embedded person 2')
        self.assertEqual(response['embeddedlist'][1]['optional'], 'Optional')
        self.assertEqual(len(response['embeddedlist']), 2)

        embedded1_uri = self.fullURItoAbsoluteURI(mainresource_uri) + 'embeddedlist/0/'

        response = self.c.get(embedded1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 1')
        self.assertEqual(response['optional'], None)
        self.assertEqual(response['resource_uri'], embedded1_uri)

        embedded2_uri = self.fullURItoAbsoluteURI(mainresource_uri) + 'embeddedlist/1/'

        response = self.c.get(embedded2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 2')
        self.assertEqual(response['optional'], 'Optional')
        self.assertEqual(response['resource_uri'], embedded2_uri)

        embedded3_uri = self.fullURItoAbsoluteURI(mainresource_uri) + 'embeddedlist/2/'

        response = self.c.get(embedded3_uri)
        self.assertEqual(response.status_code, 404)

        embeddedresource_uri = self.fullURItoAbsoluteURI(mainresource_uri) + 'embeddedlist/'

        response = self.c.get(embeddedresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['name'], 'Embedded person 1')
        self.assertEqual(response['objects'][0]['optional'], None)
        self.assertEqual(response['objects'][0]['resource_uri'], embedded1_uri)
        self.assertEqual(response['objects'][1]['name'], 'Embedded person 2')
        self.assertEqual(response['objects'][1]['optional'], 'Optional')
        self.assertEqual(response['objects'][1]['resource_uri'], embedded2_uri)

        response = self.c.post(embeddedresource_uri, '{"name": "Embedded person 3"}', content_type='application/json')
        self.assertRedirects(response, embedded3_uri, status_code=201)

        response = self.c.get(embedded3_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 3')
        self.assertEqual(response['optional'], None)
        self.assertEqual(response['resource_uri'], embedded3_uri)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['embeddedlist']), 3)

        embedded4_uri = self.fullURItoAbsoluteURI(mainresource_uri) + 'embeddedlist/3/'

        response = self.c.post(embeddedresource_uri, '{"name": "Embedded person 4", "optional": 42}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        response = self.c.post(embeddedresource_uri, '{"name": "Embedded person 4", "optional": []}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        response = self.c.post(embeddedresource_uri, '{"name": "Embedded person 4", "optional": {}}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        response = self.c.get(embedded4_uri)
        self.assertEqual(response.status_code, 404)

        response = self.c.post(embeddedresource_uri, '{"name": "Embedded person 4", "optional": "Foobar"}', content_type='application/json')
        self.assertRedirects(response, embedded4_uri, status_code=201)

        response = self.c.get(embedded4_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 4')
        self.assertEqual(response['optional'], 'Foobar')
        self.assertEqual(response['resource_uri'], embedded4_uri)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['embeddedlist']), 4)

        # Testing PUT

        response = self.c.put(embedded4_uri, '{"name": "Embedded person 4a", "optional": "Foobar PUT"}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embedded4_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 4a')
        self.assertEqual(response['optional'], 'Foobar PUT')
        self.assertEqual(response['resource_uri'], embedded4_uri)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['embeddedlist'][3]['name'], 'Embedded person 4a')
        self.assertEqual(response['embeddedlist'][3]['optional'], 'Foobar PUT')
        self.assertEqual(len(response['embeddedlist']), 4)

        response = self.c.put(embedded4_uri, '{"name": "Embedded person 4a", "optional": []}', content_type='application/json')
        self.assertContains(response, 'only accepts string values', status_code=400)

        response = self.c.put(embedded4_uri, '{}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        response = self.c.put(embedded4_uri, '{"optional": "Optional"}', content_type='application/json')
        self.assertContains(response, 'field has no data', status_code=400)

        response = self.c.put(embedded4_uri, '{"name": "Embedded person 4 ZZZ"}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embedded4_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 4 ZZZ')
        self.assertEqual(response['optional'], None)
        self.assertEqual(response['resource_uri'], embedded4_uri)

        response = self.c.put(embedded1_uri, '{"name": "Embedded person 1 ZZZ"}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embedded1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 1 ZZZ')
        self.assertEqual(response['optional'], None)
        self.assertEqual(response['resource_uri'], embedded1_uri)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['embeddedlist']), 4)

        # Testing PATCH

        response = self.c.patch(embedded1_uri, '{"name": "Embedded person 1 PATCHED"}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(embedded1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 1 PATCHED')
        self.assertEqual(response['optional'], None)
        self.assertEqual(response['resource_uri'], embedded1_uri)

        # Testing DELETE

        response = self.c.delete(embedded4_uri)
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embedded4_uri)
        self.assertEqual(response.status_code, 404)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['embeddedlist']), 3)

        response = self.c.get(embedded2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 2')
        self.assertEqual(response['optional'], 'Optional')
        self.assertEqual(response['resource_uri'], embedded2_uri)

        response = self.c.delete(embedded2_uri)
        self.assertEqual(response.status_code, 204)

        response = self.c.get(embedded2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        # Content from embedded3_uri moves in place of embedded2_uri
        self.assertEqual(response['name'], 'Embedded person 3')
        self.assertEqual(response['optional'], None)
        self.assertEqual(response['resource_uri'], embedded2_uri)

        response = self.c.get(embedded3_uri)
        self.assertEqual(response.status_code, 404)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['embeddedlist']), 2)

    def test_referencedlist(self):
        response = self.c.get(self.resourceListURI('referencedlistfieldtest'))
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['objects']), 0)

        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 1"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        person1_uri = response['location']

        response = self.c.post(self.resourceListURI('referencedlistfieldtest'), '{"referencedlist": ["' + self.fullURItoAbsoluteURI(person1_uri) + '", {"name": "Person 2", "hidden": "Should be hidden"}, {"name": "Person 3", "optional": "Optional"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        mainresource_uri = response['location']

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['referencedlist']), 3)
        for i, person in enumerate(response['referencedlist']):
            self.assertEqual(person['resource_type'], 'person')
            self.assertEqual(person['name'], 'Person %d' % (i + 1))
            self.assertTrue('hidden' not in person)

        self.assertEqual(response['referencedlist'][2]['optional'], 'Optional')

        referencedlistfieldtest_object = documents.ReferencedListFieldTest.objects.get(pk=self.resourcePK(self.fullURItoAbsoluteURI(mainresource_uri)))
        self.assertEqual(referencedlistfieldtest_object.referencedlist[1].hidden, None)

        person2, person3 = response['referencedlist'][1:]

        response = self.c.put(person2['resource_uri'], '{"name": "Person 2", "optional": "Foobar PUT"}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(person2['resource_uri'])
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 2')
        self.assertEqual(response['optional'], 'Foobar PUT')

        response = self.c.put(mainresource_uri, '{"referencedlist": ["' + person2['resource_uri'] + '", "' + person3['resource_uri'] + '"]}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['referencedlist']), 2)
        for i, person in enumerate(response['referencedlist']):
            self.assertEqual(person['name'], 'Person %i' % (i + 2))

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1')

    def test_referencedlistnonfull(self):
        response = self.c.get(self.resourceListURI('referencedlistfieldnonfulltest'))
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['objects']), 0)

        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 1"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        person1_uri = response['location']

        response = self.c.post(self.resourceListURI('referencedlistfieldnonfulltest'), '{"referencedlist": ["' + self.fullURItoAbsoluteURI(person1_uri) + '", {"name": "Person 2", "hidden": "Should be hidden"}, {"name": "Person 3", "optional": "Optional"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        mainresource_uri = response['location']

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['referencedlist']), 3)
        for i, person_uri in enumerate(response['referencedlist']):
            person = self.c.get(person_uri)
            self.assertEqual(person.status_code, 200)
            person = json.loads(person.content)

            self.assertEqual(person['resource_type'], 'person')
            self.assertEqual(person['name'], 'Person %d' % (i + 1))
            self.assertTrue('hidden' not in person)

        referencedlistfieldtest_object = documents.ReferencedListFieldTest.objects.get(pk=self.resourcePK(self.fullURItoAbsoluteURI(mainresource_uri)))
        self.assertEqual(referencedlistfieldtest_object.referencedlist[1].hidden, None)

        person2_uri, person3_uri = response['referencedlist'][1:]

        response = self.c.put(person2_uri, '{"name": "Person 2", "optional": "Foobar PUT"}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(person2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 2')
        self.assertEqual(response['optional'], 'Foobar PUT')

        response = self.c.put(mainresource_uri, '{"referencedlist": ["' + person2_uri + '", "' + person3_uri + '"]}', content_type='application/json')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['referencedlist']), 2)
        for i, person_uri in enumerate(response['referencedlist']):
            person = self.c.get(person_uri)
            self.assertEqual(person.status_code, 200)
            person = json.loads(person.content)

            self.assertEqual(person['name'], 'Person %i' % (i + 2))

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1')

    def test_polymorphic_schema(self):
        person_schema_uri = self.resourceListURI('person') + 'schema/'

        response = self.c.get(person_schema_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['fields']), 5)
        self.assertTrue('resource_type' in response['fields'])
        self.assertTrue('strange' not in response['fields'])
        self.assertEqual(len(response['resource_types']), 2)
        self.assertTrue('person' in response['resource_types'])
        self.assertTrue('strangeperson' in response['resource_types'])

        response = self.c.get(person_schema_uri, {'type': 'strangeperson'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['fields']), 6)
        self.assertTrue('resource_type' in response['fields'])
        self.assertTrue('strange' in response['fields'])
        self.assertEqual(len(response['resource_types']), 2)
        self.assertTrue('person' in response['resource_types'])
        self.assertTrue('strangeperson' in response['resource_types'])

    def test_polymorphic(self):
        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 1"}', content_type='application/json; type=person')
        self.assertEqual(response.status_code, 201)

        # Tastypie ignores additional field
        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 1z", "strange": "Foobar"}', content_type='application/json; type=person')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 2", "strange": "Foobar"}', content_type='application/json; type=strangeperson')
        self.assertEqual(response.status_code, 201)

        # Field "name" is required
        response = self.c.post(self.resourceListURI('person'), '{"strange": "Foobar"}', content_type='application/json; type=strangeperson')
        self.assertContains(response, 'field has no data', status_code=400)

        # Field "strange" is required
        response = self.c.post(self.resourceListURI('person'), '{"name": "Person 2"}', content_type='application/json; type=strangeperson')
        self.assertContains(response, 'field has no data', status_code=400)

        response = self.c.get(self.resourceListURI('person'))
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['objects']), 3)
        self.assertEqual(response['objects'][0]['name'], 'Person 1')
        self.assertEqual(response['objects'][0]['resource_type'], 'person')
        self.assertEqual(response['objects'][1]['name'], 'Person 1z')
        self.assertEqual(response['objects'][1]['resource_type'], 'person')
        self.assertEqual(response['objects'][2]['name'], 'Person 2')
        self.assertEqual(response['objects'][2]['strange'], 'Foobar')
        self.assertEqual(response['objects'][2]['resource_type'], 'strangeperson')

        person1_uri = response['objects'][0]['resource_uri']
        person2_uri = response['objects'][2]['resource_uri']

        response = self.c.put(person1_uri, '{"name": "Person 1a"}', content_type='application/json; type=person')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1a')

        # Changing existing resource type (type->subtype)

        # Field "name" is required
        response = self.c.put(person1_uri, '{"strange": "something"}', content_type='application/json; type=strangeperson')
        self.assertContains(response, 'field has no data', status_code=400)

        # Field "strange" is required
        response = self.c.put(person1_uri, '{"name": "Person 1a"}', content_type='application/json; type=strangeperson')
        self.assertContains(response, 'field has no data', status_code=400)

        response = self.c.put(person1_uri, '{"name": "Person 1a", "strange": "something"}', content_type='application/json; type=strangeperson')
        # Object got replaced, so we get 201 with location, but we do not want a
        # new object, so redirect should match initial resource URL
        self.assertRedirects(response, person1_uri, status_code=201)

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1a')
        self.assertEqual(response['strange'], 'something')
        self.assertEqual(response['resource_type'], 'strangeperson')

        response = self.c.put(person2_uri, '{"name": "Person 2a", "strange": "FoobarXXX"}', content_type='application/json; type=strangeperson')
        self.assertEqual(response.status_code, 204)

        response = self.c.get(person2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 2a')
        self.assertEqual(response['strange'], 'FoobarXXX')

        # Changing resource type again (subtype->type)
        response = self.c.put(person1_uri, '{"name": "Person 1c"}', content_type='application/json; type=person')
        self.assertRedirects(response, person1_uri, status_code=201)

        response = self.c.get(person1_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 1c')
        self.assertEqual(response['resource_type'], 'person')

        response = self.c.put(person2_uri, '{"name": "Person 2c", "strange": "something"}', content_type='application/json; type=person')
        # Additional fields are ignored
        self.assertRedirects(response, person2_uri, status_code=201)

        response = self.c.get(person2_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Person 2c')
        self.assertEqual(response['resource_type'], 'person')

        # TODO: Test PATCH
        # TODO: Test DELETE

    def test_embeddedlist_polymorphic(self):
        # Testing POST

        response = self.c.post(self.resourceListURI('embeddedlistfieldtest'), '{"embeddedlist": [{"name": "Embedded person 1"}, {"name": "Embedded person 2", "optional": "Optional"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        mainresource_uri = response['location']

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['embeddedlist'][0]['name'], 'Embedded person 1')
        self.assertEqual(response['embeddedlist'][0]['optional'], None)
        self.assertEqual(response['embeddedlist'][0]['resource_type'], 'person')
        self.assertEqual(response['embeddedlist'][1]['name'], 'Embedded person 2')
        self.assertEqual(response['embeddedlist'][1]['optional'], 'Optional')
        self.assertEqual(response['embeddedlist'][0]['resource_type'], 'person')
        self.assertEqual(len(response['embeddedlist']), 2)

        embeddedresource_uri = self.fullURItoAbsoluteURI(mainresource_uri) + 'embeddedlist/'
        embedded3_uri = self.fullURItoAbsoluteURI(mainresource_uri) + 'embeddedlist/2/'

        response = self.c.post(embeddedresource_uri, '{"name": "Embedded person 3"}', content_type='application/json; type=strangeperson')
        self.assertContains(response, 'field has no data', status_code=400)

        response = self.c.post(embeddedresource_uri, '{"name": "Embedded person 3", "strange": "Strange"}', content_type='application/json; type=strangeperson')
        self.assertRedirects(response, embedded3_uri, status_code=201)

        response = self.c.get(embedded3_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'Embedded person 3')
        self.assertEqual(response['strange'], 'Strange')
        self.assertEqual(response['resource_type'], 'strangeperson')

        # TODO: Test PUT
        # TODO: Test PATCH
        # TODO: Test DELETE

    def test_limited_polymorphic(self):
        response = self.c.post(self.resourceListURI('onlysubtypeperson'), '{"name": "Person 1", "strange": "Strange"}', content_type='application/json; type=strangeperson')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('onlysubtypeperson'), '{"name": "Person 1"}', content_type='application/json; type=person')
        self.assertContains(response, 'Invalid object type', status_code=400)

        response = self.c.post(self.resourceListURI('onlysubtypeperson'), '{"name": "Person 1"}', content_type='application/json')
        self.assertContains(response, 'Invalid object type', status_code=400)

    def test_polymorphic_with_related_resource_names(self):
        response = self.c.post(self.resourceListURI('individual'), '{"name": "Individual 1", "phone": "000-000000"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)
        individual_uri = self.fullURItoAbsoluteURI(response['location'])

        response = self.c.post(self.resourceListURI('company'), '{"corporate_name": "Company 1", "phone": "000-000000"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)
        company_uri = self.fullURItoAbsoluteURI(response['location'])

        response = self.c.get(self.resourceListURI('contact'), content_type='application/json')
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['meta']['total_count'], 2)
        for obj in response['objects']:
            if obj['resource_type'] == 'individual':
                self.assertEqual(obj['resource_uri'], individual_uri)
            else:
                self.assertEqual(obj['resource_uri'], company_uri)

        response = self.c.post(self.resourceListURI('contactgroup'), '{"contacts": ["%s", "%s"]}' % (individual_uri, company_uri), content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.get(self.resourceListURI('contactgroup'), content_type='application/json')
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['meta']['total_count'], 1)
        self.assertIn(individual_uri, response['objects'][0]['contacts'])
        self.assertIn(company_uri, response['objects'][0]['contacts'])

        # Test fallback
        # Because the resource is not registered, it should be added on the MongoEngine layer
        unreg_company_resource = resources.UnregisteredCompanyResource()
        unreg_company_resource._reset_collection()
        unreg_company = unreg_company_resource._meta.object_class(corporate_name='Unreg company', phone='000-000000')
        unreg_company.save()

        response = self.c.get(self.resourceListURI('contact'), content_type='application/json')
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['meta']['total_count'], 3)

        unreg_company_obj = None
        for obj in response['objects']:
            if obj['resource_type'] == 'unregisteredcompany':
                unreg_company_obj = obj
                break

        self.assertEqual(unreg_company_obj['resource_uri'], self.resourceDetailURI('company', unreg_company.id))
        self.assertEqual(unreg_company_obj['resource_type'], 'unregisteredcompany')
        self.assertEqual(unreg_company_obj['corporate_name'], 'Unreg company')

    def test_polymorphic_duplicate_class(self):
        with self.assertRaises(exceptions.ImproperlyConfigured):
            class DuplicateSubtypePersonResource(tastypie_mongoengine_resources.MongoEngineResource):
                class Meta:
                    queryset = documents.Person.objects.all()
                    allowed_methods = ('get', 'post', 'put', 'patch', 'delete')
                    authorization = tastypie_authorization.Authorization()

                    polymorphic = {
                        'strangeperson': resources.StrangePersonResource,
                        'otherstrangeperson': resources.OtherStrangePersonResource,
                    }

    def test_mapping_boolean_field(self):
        self.assertEqual(resources.BooleanMapTestResource().is_published_auto.default, documents.BooleanMapTest()._fields['is_published_auto'].default)
        self.assertEqual(resources.BooleanMapTestResource().is_published_auto.null, not documents.BooleanMapTest()._fields['is_published_auto'].required)
        self.assertEqual(resources.BooleanMapTestResource().is_published_defined.default, documents.BooleanMapTest()._fields['is_published_defined'].default)
        self.assertEqual(resources.BooleanMapTestResource().is_published_defined.null, not documents.BooleanMapTest()._fields['is_published_defined'].required)
        self.assertEqual(resources.BooleanMapTestResource().is_published_auto.default, resources.BooleanMapTestResource().is_published_defined.default)
        self.assertEqual(resources.BooleanMapTestResource().is_published_auto.null, resources.BooleanMapTestResource().is_published_defined.null)

        response = self.c.post(self.resourceListURI('booleanmaptest'), '{}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('booleanmaptest'), '{"is_published_auto": true}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('booleanmaptest'), '{"is_published_defined": true}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('booleanmaptest'), '{"is_published_auto": true, "is_published_defined": true}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('booleanmaptest'), '{"is_published_auto": false}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('booleanmaptest'), '{"is_published_defined": false}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('booleanmaptest'), '{"is_published_auto": false, "is_published_defined": true}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.post(self.resourceListURI('booleanmaptest'), '{"is_published_auto": true, "is_published_defined": false}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

    def test_embeddedlist_with_flag(self):
        response = self.c.post(self.resourceListURI('embeddedlistwithflagfieldtest'), '{"embeddedlist": [{"name": "Embedded person 1"}, {"name": "Embedded person 2", "optional": "Optional"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        mainresource_uri = response['location']
        embeddedresource_uri = self.fullURItoAbsoluteURI(mainresource_uri) + 'embeddedlist/'

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['is_published'], False)

        response = self.c.post(embeddedresource_uri, '{"name": "Embedded person 1", "strange": "Strange"}', content_type='application/json; type=strangeperson')
        self.assertEqual(response.status_code, 201)

        response = self.c.patch(mainresource_uri, '{"is_published": true}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(mainresource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['is_published'], True)

    def test_nested_lists_field(self):
        posts = """
        {
            "posts": [
                {
                    "title": "Embedded post 1",
                    "comments": [
                        {"content": "Embedded comment 1.1"},
                        {"content": "Embedded comment 1.2"}
                    ]
                },
                {
                    "title": "Embedded post 2",
                    "comments": [
                        {"content": "Embedded comment 2.1"},
                        {"content": "Embedded comment 2.2"}
                    ]
                }
            ]
        }
        """

        response = self.c.post(self.resourceListURI('board'), posts, content_type='application/json')
        self.assertEqual(response.status_code, 201)

        board_uri = response['location']

        response = self.c.get(board_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['posts'][0]['comments'][0]['content'], 'Embedded comment 1.1')
        self.assertEqual(response['posts'][1]['comments'][0]['content'], 'Embedded comment 2.1')

        response = self.c.get(board_uri + 'posts/', {'order_by': 'title'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['title'], 'Embedded post 1')
        self.assertEqual(response['objects'][1]['title'], 'Embedded post 2')

        response = self.c.get(board_uri + 'posts/', {'order_by': '-title'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['title'], 'Embedded post 2')
        self.assertEqual(response['objects'][1]['title'], 'Embedded post 1')

        response = self.c.get(board_uri + 'posts/', {'order_by': 'comments__content'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['title'], 'Embedded post 1')
        self.assertEqual(response['objects'][1]['title'], 'Embedded post 2')

        response = self.c.get(board_uri + 'posts/', {'order_by': '-comments__content'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['title'], 'Embedded post 2')
        self.assertEqual(response['objects'][1]['title'], 'Embedded post 1')

    def test_ordering(self):
        response = self.c.post(self.resourceListURI('embeddedlistfieldtest'), '{"embeddedlist": [{"name": "Embedded person 1"}, {"name": "Embedded person 2", "optional": "Optional"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        mainresource1_uri = response['location']

        response = self.c.post(self.resourceListURI('embeddedlistfieldtest'), '{"embeddedlist": [{"name": "Embedded person 1a"}, {"name": "Embedded person 2a", "optional": "Optional"}]}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        mainresource2_uri = response['location']

        # MongoDB IDs are monotonic so this will sort it in the creation order
        response = self.c.get(self.resourceListURI('embeddedlistfieldtest'), {'order_by': 'id'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['resource_uri'], self.fullURItoAbsoluteURI(mainresource1_uri))
        self.assertEqual(response['objects'][1]['resource_uri'], self.fullURItoAbsoluteURI(mainresource2_uri))

        # MongoDB IDs are monotonic so this will sort it in reverse of the creation order
        response = self.c.get(self.resourceListURI('embeddedlistfieldtest'), {'order_by': '-id'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['resource_uri'], self.fullURItoAbsoluteURI(mainresource2_uri))
        self.assertEqual(response['objects'][1]['resource_uri'], self.fullURItoAbsoluteURI(mainresource1_uri))

        embeddedresource1_uri = self.fullURItoAbsoluteURI(mainresource1_uri) + 'embeddedlist/'
        embedded1_uri = self.fullURItoAbsoluteURI(mainresource1_uri) + 'embeddedlist/0/'
        embedded2_uri = self.fullURItoAbsoluteURI(mainresource1_uri) + 'embeddedlist/1/'

        response = self.c.get(embeddedresource1_uri, {'order_by': 'name'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['resource_uri'], embedded1_uri)
        self.assertEqual(response['objects'][1]['resource_uri'], embedded2_uri)

        response = self.c.get(embeddedresource1_uri, {'order_by': '-name'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['resource_uri'], embedded2_uri)
        self.assertEqual(response['objects'][1]['resource_uri'], embedded1_uri)

        response = self.c.get(self.resourceListURI('embeddedlistfieldtest'), {'order_by': 'embeddedlist__name'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['resource_uri'], self.fullURItoAbsoluteURI(mainresource1_uri))
        self.assertEqual(response['objects'][1]['resource_uri'], self.fullURItoAbsoluteURI(mainresource2_uri))

        response = self.c.get(self.resourceListURI('embeddedlistfieldtest'), {'order_by': '-embeddedlist__name'})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['objects'][0]['resource_uri'], self.fullURItoAbsoluteURI(mainresource2_uri))
        self.assertEqual(response['objects'][1]['resource_uri'], self.fullURItoAbsoluteURI(mainresource1_uri))

    def _test_pagination(self, uri, key, pattern):
        for i in range(100):
            response = self.c.post(uri, '{"%s": "%s"}' % (key, pattern % i), content_type='application/json')
            self.assertEqual(response.status_code, 201)

        response = self.c.get(uri, {'offset': '42', 'limit': 7})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['meta']['total_count'], 100)
        self.assertEqual(response['meta']['offset'], 42)
        self.assertEqual(response['meta']['limit'], 7)
        self.assertEqual(len(response['objects']), 7)

        for i, obj in enumerate(response['objects']):
            self.assertEqual(obj[key], pattern % (42 + i))

        offset = response['objects'][0]['id']

        response = self.c.get(uri, {'offset': offset, 'limit': 7})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['meta']['total_count'], 100)
        self.assertEqual(response['meta']['offset'], offset)
        self.assertEqual(response['meta']['limit'], 7)
        self.assertEqual(len(response['objects']), 7)

        for i, obj in enumerate(response['objects']):
            self.assertEqual(obj[key], pattern % (42 + i))

        response = self.c.get(uri, {'offset': offset, 'limit': -7})
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['meta']['total_count'], 100)
        self.assertEqual(response['meta']['offset'], offset)
        self.assertEqual(response['meta']['limit'], -7)
        self.assertEqual(len(response['objects']), 7)

        for i, obj in enumerate(response['objects']):
            self.assertEqual(obj[key], pattern % (42 - i))

    def test_pagination(self):
        self._test_pagination(self.resourceListURI('person'), 'name', 'Person %s')

    def test_embedded_in_embedded_doc(self):
        post = """
        {
            "post": {
                "title": "Embedded post",
                "comments": [
                    {"content": "Embedded comment 1"},
                    {"content": "Embedded comment 2"}
                ]
            }
        }
        """

        response = self.c.post(self.resourceListURI('embeddedlistinembeddeddoctest'), post, content_type='application/json')
        self.assertEqual(response.status_code, 201)

        post_uri = response['location']

        response = self.c.get(post_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(len(response['post']['comments']), 2)
        self.assertTrue('resource_uri' not in response['post'])
        self.assertTrue('resource_uri' not in response['post']['comments'][0])

    def test_field_auto_allocation(self):
        response = self.c.post(self.resourceListURI('autoallocationfieldtest'), '{"name": "Auto slug test !"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        resource_uri = response['location']

        response = self.c.get(resource_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['slug'], u'auto-slug-test')

    def test_embedded_document_custom_id(self):
        response = self.c.post(self.resourceListURI('documentwithid'), '{"title": "Main document"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        document_uri = response['location']

        response = self.c.get(document_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['title'], 'Main document')
        self.assertEqual(response['comments'], [])

        response = self.c.post(document_uri + 'comments/', '{"content": "Content"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        comment_uri = response['location']

        response = self.c.get(comment_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['content'], 'Content')

        response = self.c.patch(comment_uri, '{"content": "Content 2"}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(comment_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['content'], 'Content 2')

        response = self.c.get(document_uri + 'comments/abcd/')
        self.assertEqual(response.status_code, 404)

        response = self.c.patch(document_uri + 'comments/abcd/', '{"content": "Content 2"}', content_type='application/json')
        self.assertEqual(response.status_code, 404)

        response = self.c.delete(comment_uri)
        self.assertEqual(response.status_code, 204)

        self._test_pagination(document_uri + 'comments/', 'content', 'Comment %s')

    def test_embeddedlist_referencefield(self):
        response = self.c.post(self.resourceListURI('exporters'), '{"name": "exporter_1"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        exporter_uri = response['location']

        response = self.c.get(exporter_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'exporter_1')
        self.assertEqual(response['resource_uri'], self.fullURItoAbsoluteURI(exporter_uri))

        pipe_json = '{"name": "pipe_1", "exporters": [{"exporter": "%s", "name": "exporter_embedded"}]}' % response['resource_uri']
        response = self.c.post(self.resourceListURI('pipes'), pipe_json, content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.get(response['location'])
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'pipe_1')
        self.assertEqual(len(response['exporters']), 1)
        self.assertEqual(response['exporters'][0]['exporter']['name'], 'exporter_1')
        self.assertEqual(response['exporters'][0]['exporter']['resource_uri'], self.fullURItoAbsoluteURI(exporter_uri))
        self.assertEqual(response['exporters'][0]['name'], 'exporter_embedded')

        pipe_json = '{"name": "pipe_2", "exporters": [{"exporter": {"name": "exporter_1"}, "name": "exporter_embedded"}]}'
        response = self.c.post(self.resourceListURI('pipes'), pipe_json, content_type='application/json')
        self.assertEqual(response.status_code, 201)

        response = self.c.get(response['location'])
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['name'], 'pipe_2')
        self.assertEqual(len(response['exporters']), 1)
        self.assertEqual(response['exporters'][0]['exporter']['name'], 'exporter_1')
        self.assertEqual(response['exporters'][0]['exporter']['resource_uri'], self.fullURItoAbsoluteURI(exporter_uri))
        self.assertEqual(response['exporters'][0]['name'], 'exporter_embedded')

    def test_blankable_embedded(self):
        response = self.c.post(self.resourceListURI('blankableparent'), '{}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        document_uri = response['location']

        response = self.c.get(document_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['embedded']['name'], 'A blank name')
        self.assertEqual(response['embedded']['description'], None)

        response = self.c.patch(document_uri, '{"embedded": null}', content_type='application/json')

        # MongoEngine 0.8.2 broke handling of None values on fields with defaults defined and the following does not fail
        # https://github.com/MongoEngine/mongoengine/issues/381
        self.assertContains(response, 'Field is required', status_code=400)

    def test_readonly_embedded(self):
        response = self.c.post(self.resourceListURI('readonlyparent'), '{"name": "A readonly embedded test"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        document_uri = response['location']

        response = self.c.get(document_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['tzdt']['dt'], '2012-12-12T12:12:12')
        self.assertEqual(response['tzdt']['tz'], 'UTC')

        response = self.c.patch(document_uri, '{"tzdt": {"dt": "2012-12-12T12:00:00"}}', content_type='application/json')
        # Tastypie ignores readonly field, should not do anything, but succeed
        self.assertEqual(response.status_code, 202)

        response = self.c.get(document_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['tzdt']['dt'], '2012-12-12T12:12:12')
        self.assertEqual(response['tzdt']['tz'], 'UTC')

    def test_datetime(self):
        response = self.c.post(self.resourceListURI('datetimefieldtest'), '{"datetime": "2012-12-12T12:12:12"}', content_type='application/json')
        self.assertEqual(response.status_code, 201)

        datetimefieldtest_uri = response['location']

        response = self.c.get(datetimefieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['datetime'], '2012-12-12T12:12:12')

        response = self.c.patch(datetimefieldtest_uri, '{"datetime": "2012-12-12T12:00:00"}', content_type='application/json')
        self.assertEqual(response.status_code, 202)

        response = self.c.get(datetimefieldtest_uri)
        self.assertEqual(response.status_code, 200)
        response = json.loads(response.content)

        self.assertEqual(response['datetime'], '2012-12-12T12:00:00')

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url

from tastypie import api

from test_project.test_app.api import resources

v1_api = api.Api(api_name='v1')
v1_api.register(resources.PersonResource())
v1_api.register(resources.PersonObjectClassResource())
v1_api.register(resources.OnlySubtypePersonResource())
v1_api.register(resources.IndividualResource())
v1_api.register(resources.CompanyResource())
v1_api.register(resources.ContactResource())
v1_api.register(resources.ContactGroupResource())
v1_api.register(resources.CustomerResource())
v1_api.register(resources.BoardResource())
v1_api.register(resources.DocumentWithIDResource())
v1_api.register(resources.EmbeddedListInEmbeddedDocTestResource())
v1_api.register(resources.EmbeddedDocumentFieldTestResource())
v1_api.register(resources.DictFieldTestResource())
v1_api.register(resources.ListFieldTestResource())
v1_api.register(resources.EmbeddedListFieldTestResource())
v1_api.register(resources.EmbeddedListFieldNonFullTestResource())
v1_api.register(resources.ReferencedListFieldTestResource())
v1_api.register(resources.ReferencedListFieldNonFullTestResource())
v1_api.register(resources.BooleanMapTestResource())
v1_api.register(resources.EmbeddedListWithFlagFieldTestResource())
v1_api.register(resources.AutoAllocationFieldTestResource())
v1_api.register(resources.ExporterResource())
v1_api.register(resources.PipeResource())
v1_api.register(resources.BlankableParentResource())
v1_api.register(resources.ReadonlyParentResource())
v1_api.register(resources.DatetimeFieldTestResource())

urlpatterns = patterns(
    '',

    url(r'^api/', include(v1_api.urls)),
)

########NEW FILE########
