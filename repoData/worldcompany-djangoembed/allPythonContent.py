__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-oembed documentation build configuration file, created by
# sphinx-quickstart on Sat Feb 13 14:41:46 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'djangoembed'
copyright = u'2010, The World Company'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-oembeddoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-oembed.tex', u'django-oembed Documentation',
   u'The World Company', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from oembed.models import StoredProvider, StoredOEmbed


class StoredProviderAdmin(admin.ModelAdmin):
    list_display = ('wildcard_regex', 'endpoint_url', 'active', 'provides')
    list_filter = ('active', 'provides')

    actions = ['activate', 'deactivate']

    def activate(self, request, queryset):
        for item in queryset:
            item.active = True
            item.save()
    activate.short_description = "Activate selected Stored Providers"

    def deactivate(self, request, queryset):
        for item in queryset:
            item.active = False
            item.save()
    deactivate.short_description = "Deactivate selected Stored Providers"


class StoredOEmbedAdmin(admin.ModelAdmin):
    list_display = ('match', 'date_added')


admin.site.register(StoredProvider, StoredProviderAdmin)
admin.site.register(StoredOEmbed, StoredOEmbedAdmin)

########NEW FILE########
__FILENAME__ = constants
import re

from django.conf import settings


# the oembed consumer can work with different parsers!
OEMBED_TEXT_PARSER = getattr(settings, 'OEMBED_TEXT_PARSER', 'oembed.parsers.text.TextParser')
OEMBED_HTML_PARSER = getattr(settings, 'OEMBED_HTML_PARSER', 'oembed.parsers.html.HTMLParser')


# the oembed image processor supports different backends!
OEMBED_IMAGE_PROCESSOR = getattr(settings, 'OEMBED_IMAGE_PROCESSOR', 'oembed.image_processors.pil.PIL_Resizer')


# oembed-ed objects can specify a TTL, after which they should be re-fetched
# from the providing site.  these settings allow you to control both the
# minimum amount of time to store an oembed and a default in the event that
# the provider does not supply a TTL
DEFAULT_OEMBED_TTL = getattr(settings, 'DEFAULT_OEMBED_TTL', 604800) # 7 days
MIN_OEMBED_TTL = getattr(settings, 'MIN_OEMBED_TTL', 86400) # 1 day


# the oembed spec defines 4 resource types
RESOURCE_PHOTO = 'photo'
RESOURCE_VIDEO = 'video'
RESOURCE_RICH = 'rich'
RESOURCE_LINK = 'link'
RESOURCE_TYPES = (
    RESOURCE_PHOTO,
    RESOURCE_VIDEO,
    RESOURCE_RICH,
    RESOURCE_LINK,
)
RESOURCE_CHOICES = (
    (RESOURCE_PHOTO, 'Photo'),
    (RESOURCE_VIDEO, 'Video'),
    (RESOURCE_RICH, 'Rich'),
    (RESOURCE_LINK, 'Link'),
)


# url for matching inline urls, which is a fairly tricky business
URL_PATTERN = '(https?://[-A-Za-z0-9+&@#/%?=~_()|!:,.;]*[-A-Za-z0-9+&@#/%=~_|])'
URL_RE = re.compile(URL_PATTERN)
STANDALONE_URL_RE = re.compile('^\s*' + URL_PATTERN + '\s*$')


# oembed can parse HTML!
OEMBED_DEFAULT_PARSE_HTML = getattr(settings, 'OEMBED_DEFAULT_PARSE_HTML', True)
CONSUMER_URLIZE_ALL = getattr(settings, 'CONSUMER_URLIZE_ALL', True)


OEMBED_BLOCK_ELEMENTS = [
    'address', 'blockquote', 'center', 'dir', 'div', 'dl', 'fieldset', 'form', 
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'isindex', 'menu', 'noframes', 
    'noscript', 'ol', 'p', 'pre', 'table', 'ul', 'dd', 'dt', 'frameset', 'li', 
    'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'button', 'del', 'iframe',
    'ins', 'map', 'object', 'script', '[document]'
]


# some default sizes to use for scaling
OEMBED_ALLOWED_SIZES = getattr(settings, 'OEMBED_ALLOWED_SIZES', [(x, x) for x in xrange(100, 900, 100)])
OEMBED_THUMBNAIL_SIZE = getattr(settings, 'OEMBED_THUMBNAIL_SIZE', ((200, 200),))

SOCKET_TIMEOUT = getattr(settings, 'SOCKET_TIMEOUT', 5)


# regex for extracting domain names
DOMAIN_RE = re.compile('((https?://)[^/]+)*')

########NEW FILE########
__FILENAME__ = consumer
import re

import oembed
from oembed.constants import OEMBED_DEFAULT_PARSE_HTML, URL_RE
from oembed.exceptions import OEmbedException
from oembed.parsers import text_parser, html_parser


class OEmbedConsumer(object):
    def parse(self, text, *args, **kwargs):
        if OEMBED_DEFAULT_PARSE_HTML:
            return self.parse_html(text, *args, **kwargs)
        else:
            return self.parse_text(text, *args, **kwargs)
    
    def parse_html(self, text, *args, **kwargs):
        parser = html_parser()
        return parser.parse(text, *args, **kwargs)
    
    def parse_text(self, text, *args, **kwargs):
        parser = text_parser()
        return parser.parse(text, *args, **kwargs)
        
    def extract(self, text, *args, **kwargs):
        if OEMBED_DEFAULT_PARSE_HTML:
            return self.extract_oembeds_html(text, *args, **kwargs)
        else:
            return self.extract_oembeds(text, *args, **kwargs)
    
    def extract_oembeds(self, text, maxwidth=None, maxheight=None, resource_type=None):
        """
        Scans a block of text and extracts oembed data on any urls,
        returning it in a list of dictionaries
        """
        parser = text_parser()
        urls = parser.extract_urls(text)
        return self.handle_extracted_urls(urls, maxwidth, maxheight, resource_type)
    
    def extract_oembeds_html(self, text, maxwidth=None, maxheight=None, resource_type=None):
        parser = html_parser()
        urls = parser.extract_urls(text)
        return self.handle_extracted_urls(urls, maxwidth, maxheight, resource_type)
    
    def handle_extracted_urls(self, url_set, maxwidth=None, maxheight=None, resource_type=None):
        embeds = []
        
        for user_url in url_set:
            try:
                resource = oembed.site.embed(user_url, maxwidth=maxwidth, maxheight=maxheight)
            except OEmbedException:
                continue
            else:
                if not resource_type or resource.type == resource_type:
                    data = resource.get_data()
                    data['original_url'] = user_url
                    embeds.append(data)
        
        return embeds
    
    def strip(self, text, *args, **kwargs):
        """
        Try to maintain parity with what is extracted by extract since strip
        will most likely be used in conjunction with extract
        """
        if OEMBED_DEFAULT_PARSE_HTML:
            extracted = self.extract_oembeds_html(text, *args, **kwargs)
        else:
            extracted = self.extract_oembeds(text, *args, **kwargs)
        
        matches = [r['original_url'] for r in extracted]
        match_handler = lambda m: m.group() not in matches and m.group() or ''
        
        return re.sub(URL_RE, match_handler, text)

########NEW FILE########
__FILENAME__ = models
#     ,___,       
#     (6v6)      
#     (_^(_\     
#   ^^^"^" \\^^^^
#   ^^^^^^^^^^^^^

########NEW FILE########
__FILENAME__ = oembed_providers
import os
import re
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO
try: 
    import Image
except ImportError:
    from PIL import Image

from django.conf import settings
from django.contrib.sites.models import Site
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage

import oembed
from oembed.providers import BaseProvider
from oembed.resources import OEmbedResource
from oembed.utils import size_to_nearest, scale


class GoogleMapsProvider(BaseProvider):
    regex = r'^http://maps.google.com/maps\?([^\s]+)'
    provides = False
    resource_type = 'rich'
    
    MAP_SIZES = [(x, x) for x in xrange(100, 900, 100)]
    VALID_PARAMS = ['q', 'z']
    
    def request_resource(self, url, **kwargs):
        maxwidth = kwargs.get('maxwidth', None)
        maxheight = kwargs.get('maxheight', None)
        
        # calculate the appropriate width and height
        w, h = size_to_nearest(maxwidth, maxheight, self.MAP_SIZES, True)
        
        # prepare the dictionary of data to be returned as an oembed resource
        data = {
            'type': 'rich', 'provider_name': 'Google', 'version': '1.0',
            'width': w, 'height': h, 'title': '', 'author_name': '',
            'author_url': ''
        }
        
        url_params = re.match(self.regex, url).groups()[0]
        url_params = url_params.replace('&amp;', '&').split('&')
        
        map_params = ['output=embed']
        
        for param in url_params:
            k, v = param.split('=', 1)
            if k in self.VALID_PARAMS:
                map_params.append(param)
        
        data['html'] = '<iframe width="%d" height="%d" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="http://maps.google.com/maps?%s"></iframe>' % \
            (w, h, '&amp;'.join(map_params))
        
        return OEmbedResource.create(data)


class StaticMediaProvider(BaseProvider):
    media_url = settings.MEDIA_URL.strip('/')
    if not media_url.startswith('http'):
        all_domains = Site.objects.values_list('domain', flat=True)
        media_url = 'http://[^\s]*?(?:%s)/%s' % ('|'.join(all_domains), media_url)
    
    regex = re.compile(r'^%s/([^\s]+\.(jpg|gif|png))' % media_url, re.I)
    provides = False
    resource_type = 'photo'
    
    IMAGE_SIZES = [(x, x) for x in xrange(100, 900, 100)]
    
    def request_resource(self, url, **kwargs):
        maxwidth = kwargs.get('maxwidth', None)
        maxheight = kwargs.get('maxheight', None)
        
        # calculate the appropriate bounds for width and height
        w, h = size_to_nearest(maxwidth, maxheight, self.IMAGE_SIZES, True)

        # get the path, i.e. /media/img/kitties.jpg
        image_path = re.match(self.regex, url).groups()[0]
        
        # create the entire url as it would be on site, minus the filename
        base_url, ext = url.rsplit('.', 1)
                
        # create the file path minus the extension
        base_path, ext = image_path.rsplit('.', 1)
        
        append = '_%sx%s.%s' % (w, h, ext)
        
        new_path = '%s%s' % (base_path, append)
        
        if not default_storage.exists(new_path):
            # open the original to calculate its width and height
            source_file = default_storage.open(image_path)
            img = Image.open(source_file)

            # retrieve image format and dimensions
            format = img.format
            img_width, img_height = img.size

            # do the math-y parts
            new_width, new_height = scale(img_width, img_height, w, h)
            
            img = img.resize((new_width, new_height), Image.ANTIALIAS)

            img_buffer = StringIO()
            img.MAXBLOCK = 1024*1024
            img.save(img_buffer, format=format)

            source_file.close()
            default_storage.save(new_path, ContentFile(img_buffer.getvalue()))
        
        new_url = '%s%s' % (base_url, append)
        
        # get just the filename, i.e. test.jpg - used for generated the title
        # of the returned oembed resource
        image_filename = image_path.rsplit('/', 1)[-1]
        
        data = {'type': 'photo', 'provider_name': '', 'version': '1.0',
                'width': w, 'height': h, 'title': image_filename,
                'url': new_url, 'author_name': '', 'author_url': ''}
        
        return OEmbedResource.create(data)


oembed.site.register(GoogleMapsProvider)
oembed.site.register(StaticMediaProvider)

########NEW FILE########
__FILENAME__ = exceptions
class OEmbedException(Exception):
    pass

class OEmbedInvalidResource(OEmbedException):
    pass

class OEmbedMissingEndpoint(OEmbedException):
    pass

class OEmbedBadRequest(OEmbedException):
    pass

class OEmbedHTTPException(OEmbedException):
    pass

class AlreadyRegistered(OEmbedException):
    """Raised when a model is already registered with a site."""
    pass

class NotRegistered(OEmbedException):
    """Raised when a model is not registered with a site."""
    pass

########NEW FILE########
__FILENAME__ = fields
import re

from django.db import models
from django.db.models import signals, Max
from django.db.models.fields import TextField

import oembed
from oembed.constants import URL_RE
from oembed.exceptions import OEmbedMissingEndpoint
from oembed.models import AggregateMedia


class FieldRegistry(object):
    """
    FieldRegistry -> modified Borg pattern from Marty Alchin's Pro Django
    """
    _registry = {}
    
    @classmethod
    def add_field(cls, model, field):
        reg = cls._registry.setdefault(model, [])
        reg.append(field)
    
    @classmethod
    def get_fields(cls, model):
        return cls._registry.get(model, [])
    
    @classmethod
    def __contains__(cls, model):
        return model in cls._registry


class EmbeddedSignalCreator(object):
    def __init__(self, field):
        self.field = field
        self.name = '_%s' % self.field.name
    
    def contribute_to_class(self, cls, name):
        register_field(cls, self.field)


class EmbeddedMediaField(models.ManyToManyField):
    def __init__(self, media_type=None, to=None, **kwargs):
        if media_type and not isinstance(media_type, (basestring, list)):
            raise TypeError('media_type must be either a list or string')
        elif isinstance(media_type, basestring):
            media_type = [media_type]
        self.media_type = media_type
        
        super(EmbeddedMediaField, self).__init__(AggregateMedia, **kwargs)
    
    def contribute_to_class(self, cls, name):
        """
        I need a way to ensure that this signal gets created for all child
        models, and since model inheritance doesn't have a 'contrubite_to_class'
        style hook, I am creating a fake virtual field which will be added to
        all subclasses and handles creating the signal
        """
        super(EmbeddedMediaField, self).contribute_to_class(cls, name)
        register_field(cls, self)
        
        # add a virtual field that will create signals on any/all subclasses
        cls._meta.add_virtual_field(EmbeddedSignalCreator(self))


def register_field(cls, field):
    """
    Handles registering the fields with the FieldRegistry and creating a 
    post-save signal for the model.
    """
    FieldRegistry.add_field(cls, field)
    
    signals.post_save.connect(handle_save_embeds, sender=cls,
            dispatch_uid='%s.%s.%s' % \
            (cls._meta.app_label, cls._meta.module_name, field.name))
    

def handle_save_embeds(sender, instance, **kwargs):
    embedded_media_fields = FieldRegistry.get_fields(sender)
    if not embedded_media_fields:
        return
    
    urls = []
    for field in instance._meta.fields:
        if isinstance(field, TextField):
            urls.extend(re.findall(URL_RE, getattr(instance, field.name)))

    urls = set(urls)
    for embedded_field in embedded_media_fields:
        m2m = getattr(instance, embedded_field.name)
        m2m.clear()
        for url in urls:
            try:
                provider = oembed.site.provider_for_url(url)
            except OEmbedMissingEndpoint:
                pass
            else:
                if not embedded_field.media_type or \
                        provider.resource_type in embedded_field.media_type:
                    media_obj, created = AggregateMedia.objects.get_or_create(url=url)
                    m2m.add(media_obj)

try:
    from south.modelsinspector import add_introspection_rules
    add_introspection_rules([
        (
            [EmbeddedMediaField], # Class(es) these apply to
            [],         # Positional arguments (not used)
            {           # Keyword argument
                "media_type": ["media_type", {}],
            },
        ),
    ], ["^oembed\.fields\.EmbeddedMediaField"])

except ImportError:
    pass

########NEW FILE########
__FILENAME__ = pil
import os
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO
try: 
    import Image
except ImportError:
    from PIL import Image

from django.core.files.base import ContentFile
from django.core.files.storage import default_storage


class PIL_Resizer(object):
    def resize(self, image_field, new_width, new_height):
        img_path = image_field.name
        base_path, img_ext = os.path.splitext(image_field.name)
        base_url, img_ext = os.path.splitext(image_field.url)

        append = '_%sx%s%s' % (new_width, new_height, img_ext)

        new_url = base_url + append
        new_path = base_path + append

        if not default_storage.exists(new_path):
            # load a file-like object at the image path
            source_file = default_storage.open(img_path)

            # load up the image using PIL and retrieve format
            img = Image.open(source_file)
            format = img.format
            
            # perform resize
            img = img.resize((new_width, new_height), Image.ANTIALIAS)

            # create a file-like object to store resized data
            img_buffer = StringIO()
            img.MAXBLOCK = 1024*1024
            img.save(img_buffer, format=format)

            # save data
            default_storage.save(new_path, ContentFile(img_buffer.getvalue()))
        
        return (new_url, new_width, new_height)

########NEW FILE########
__FILENAME__ = listeners
from django.db.models.signals import post_save

import oembed
from oembed.models import StoredProvider

def provider_site_invalidate(sender, instance, created, **kwargs):
    oembed.site.invalidate_providers()

def start_listening():
    post_save.connect(provider_site_invalidate, sender=StoredProvider)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime

from south.db import db
from south.v2 import SchemaMigration

from django.conf import settings
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'StoredOEmbed'
        db.create_table('oembed_storedoembed', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('match', self.gf('django.db.models.fields.TextField')()),
            ('response_json', self.gf('django.db.models.fields.TextField')()),
            ('resource_type', self.gf('django.db.models.fields.CharField')(max_length=8)),
            ('date_added', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('date_expires', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('maxwidth', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('maxheight', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('object_id', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='related_storedoembed', null=True, to=orm['contenttypes.ContentType'])),
        ))
        db.send_create_signal('oembed', ['StoredOEmbed'])

        # Adding unique constraint on 'StoredOEmbed', fields ['match', 'maxwidth', 'maxheight']
        if 'mysql' not in settings.DATABASES['default']['ENGINE']:
            db.create_unique('oembed_storedoembed', ['match', 'maxwidth', 'maxheight'])

        # Adding model 'StoredProvider'
        db.create_table('oembed_storedprovider', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('endpoint_url', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('regex', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('wildcard_regex', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('resource_type', self.gf('django.db.models.fields.CharField')(max_length=8)),
            ('active', self.gf('django.db.models.fields.BooleanField')(default=False, blank=True)),
            ('provides', self.gf('django.db.models.fields.BooleanField')(default=False, blank=True)),
            ('scheme_url', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
        ))
        db.send_create_signal('oembed', ['StoredProvider'])

        # Adding model 'AggregateMedia'
        db.create_table('oembed_aggregatemedia', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('url', self.gf('django.db.models.fields.TextField')()),
            ('object_id', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='aggregate_media', null=True, to=orm['contenttypes.ContentType'])),
        ))
        db.send_create_signal('oembed', ['AggregateMedia'])


    def backwards(self, orm):
        
        # Deleting model 'StoredOEmbed'
        db.delete_table('oembed_storedoembed')

        # Removing unique constraint on 'StoredOEmbed', fields ['match', 'maxwidth', 'maxheight']
        if 'mysql' not in settings.DATABASES['default']['ENGINE']:
            db.delete_unique('oembed_storedoembed', ['match', 'maxwidth', 'maxheight'])

        # Deleting model 'StoredProvider'
        db.delete_table('oembed_storedprovider')

        # Deleting model 'AggregateMedia'
        db.delete_table('oembed_aggregatemedia')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'oembed.aggregatemedia': {
            'Meta': {'object_name': 'AggregateMedia'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'aggregate_media'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'url': ('django.db.models.fields.TextField', [], {})
        },
        'oembed.storedoembed': {
            'Meta': {'ordering': "('-date_added',)", 'unique_together': "(('match', 'maxwidth', 'maxheight'),)", 'object_name': 'StoredOEmbed'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'related_storedoembed'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'date_added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'date_expires': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'match': ('django.db.models.fields.TextField', [], {}),
            'maxheight': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'maxwidth': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'object_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'resource_type': ('django.db.models.fields.CharField', [], {'max_length': '8'}),
            'response_json': ('django.db.models.fields.TextField', [], {})
        },
        'oembed.storedprovider': {
            'Meta': {'ordering': "('endpoint_url', 'resource_type', 'wildcard_regex')", 'object_name': 'StoredProvider'},
            'active': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'endpoint_url': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'provides': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'regex': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'resource_type': ('django.db.models.fields.CharField', [], {'max_length': '8'}),
            'scheme_url': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'wildcard_regex': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        }
    }

    complete_apps = ['oembed']

########NEW FILE########
__FILENAME__ = models
from django import VERSION
from django.conf import settings
from django.contrib.contenttypes.generic import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.utils import simplejson

from oembed.constants import RESOURCE_CHOICES
from oembed.providers import HTTPProvider


if VERSION < (1, 2):
    db_engine = settings.DATABASE_ENGINE
else:
    db_engine = settings.DATABASES['default']['ENGINE']


class StoredOEmbed(models.Model):
    match = models.TextField()
    response_json = models.TextField()
    resource_type = models.CharField(choices=RESOURCE_CHOICES, editable=False, max_length=8)
    date_added = models.DateTimeField(auto_now_add=True)
    date_expires = models.DateTimeField(blank=True, null=True)
    maxwidth = models.IntegerField(blank=True, null=True)
    maxheight = models.IntegerField(blank=True, null=True)

    # generic bits
    object_id = models.IntegerField(blank=True, null=True)
    content_type = models.ForeignKey(ContentType, blank=True, null=True,
            related_name="related_%(class)s")
    content_object = GenericForeignKey()

    class Meta:
        ordering = ('-date_added',)
        verbose_name = 'stored OEmbed'
        verbose_name_plural = 'stored OEmbeds'
        if 'mysql' not in db_engine:
            unique_together = ('match', 'maxwidth', 'maxheight')

    def __unicode__(self):
        return self.match
    
    @property
    def response(self):
        return simplejson.loads(self.response_json)


class StoredProviderManager(models.Manager):
    def active(self):
        return self.filter(active=True)

class StoredProvider(models.Model, HTTPProvider):
    """
    Essentially, a stored proxy provider that mimics the interface of a python
    HTTPProvider - used for autodiscovery
    """
    endpoint_url = models.CharField(max_length=255)
    regex = models.CharField(max_length=255)
    wildcard_regex = models.CharField(max_length=255, blank=True,
        help_text='Wild-card version of regex')
    resource_type = models.CharField(choices=RESOURCE_CHOICES, max_length=8)
    active = models.BooleanField(default=False)
    provides = models.BooleanField(default=False, help_text='Provide upstream')
    scheme_url = models.CharField(max_length=255, blank=True)

    objects = StoredProviderManager()

    class Meta:
        ordering = ('endpoint_url', 'resource_type', 'wildcard_regex')

    def __unicode__(self):
        return self.wildcard_regex

    def save(self, *args, **kwargs):
        if not self.regex:
            # convert wildcard to non-greedy 'match anything' regex
            self.regex = self.wildcard_regex.replace('*', '.+?')
        super(StoredProvider, self).save(*args, **kwargs)

    @property
    def url_scheme(self):
        if self.provides and self.wildcard_regex:
            return self.wildcard_regex


class AggregateMediaDescriptor(property):
    def contribute_to_class(self, cls, name):
        self.name = name
        setattr(cls, self.name, self)
        
    def __get__(self, instance, cls=None):
        if instance.content_object:
            return instance.content_object
        try:
            import oembed
            resource = oembed.site.embed(instance.url)
            if resource.content_object:
                instance.content_object = resource.content_object
                instance.save()
                return instance.content_object
            else:
                stored_oembed = StoredOEmbed.objects.filter(
                        match=instance.url)[0]
                return stored_oembed
        except:
            pass

    def __set__(self, instance, value):
        raise NotImplementedError('%s is read-only' % self.name)


class AggregateMedia(models.Model):
    url = models.TextField()
    object_id = models.IntegerField(blank=True, null=True)
    content_type = models.ForeignKey(ContentType, blank=True, null=True,
            related_name="aggregate_media")
    content_object = GenericForeignKey()
    
    media = AggregateMediaDescriptor()
    
    def __unicode__(self):
        return self.url
    
    def get_absolute_url(self):
        if self.content_object and hasattr(self.content_object, 'get_absolute_url'):
            return self.content_object.get_absolute_url()
        return self.url


from oembed.listeners import start_listening
start_listening()

########NEW FILE########
__FILENAME__ = base
import os

from django.template import RequestContext, Context
from django.template.loader import render_to_string, select_template

from oembed.constants import CONSUMER_URLIZE_ALL
from oembed.utils import mock_request


class BaseParser(object):
    def render_oembed(self, oembed_resource, original_url, template_dir=None,
                      context=None):
        """
        Render the oembed resource and return as a string.
        
        Template directory will always fall back to 'oembed/[type].html', but
        a custom template dir can be passed in using the kwargs.
        
        Templates are given two context variables:
        - response: an OEmbedResource
        - original_url: the url that was passed to the consumer
        """
        provided_context = context or Context()
        context = RequestContext(context.get("request") or mock_request())
        context.update(provided_context)
        
        # templates are named for the resources they display, i.e. video.html
        template_name = '%s.html' % oembed_resource.type
        
        # set up template finder to fall back to the link template
        templates = [os.path.join('oembed', template_name), 'oembed/link.html']
        
        # if there's a custom template dir, look there first
        if template_dir:
            templates.insert(0, os.path.join('oembed', template_dir, template_name))
        
        template = select_template(templates)
        
        context.push()
        context['response'] = oembed_resource
        context['original_url'] = original_url
        rendered = template.render(context)
        context.pop()
        
        return rendered.strip() # rendering template may add whitespace
    
    def parse(self, text, maxwidth=None, maxheight=None, template_dir=None,
              context=None, urlize_all_links=CONSUMER_URLIZE_ALL):
        """
        Scans a block of text, replacing anything matching a provider pattern
        with an OEmbed html snippet, if possible.
        
        Templates should be stored at oembed/{format}.html, so for example:
            
            oembed/video.html
        
        An optional template_dir can be provided, allowing for
        
            oembed/[template_dir]/video.html
            
        These templates are passed a context variable, ``response``, which is
        an OEmbedResource, as well as the ``original_url``
        """
        context = context or Context()
        context['maxwidth'] = maxwidth
        context['maxheight'] = maxheight

        try:
            text = unicode(text)
        except UnicodeDecodeError:
            text = unicode(text.decode('utf-8'))
        
        return self.parse_data(text, maxwidth, maxheight, template_dir,
                               context, urlize_all_links)

    def parse_data(self, text, maxwidth, maxheight, template_dir, context,
                   urlize_all_links):
        """
        Implemented on all subclasses, this method contains the logic to
        process embeddable content in ``text``
        """
        raise NotImplementedError('Subclasses must define a parse_data method')
    
    def extract_urls(self, text):
        """
        Implemented on all subclasses, this method contains the logic to
        extract a list or set of urls from text
        """
        raise NotImplementedError('Subclasses must define a extract_urls method')

########NEW FILE########
__FILENAME__ = html
import re

from BeautifulSoup import BeautifulSoup # use BS to parse HTML (it's easy!)

import oembed
from oembed.constants import OEMBED_BLOCK_ELEMENTS, URL_RE, STANDALONE_URL_RE
from oembed.exceptions import OEmbedException
from oembed.parsers.base import BaseParser
from oembed.parsers.text import TextParser, TextBlockParser


class HTMLParser(BaseParser):
    """
    Use BeautifulSoup for easy html processing.
    """
    def parse_data(self, text, maxwidth, maxheight, template_dir, context,
                   urlize_all_links):                
        block_parser = TextBlockParser()
        original_template_dir = template_dir
        
        soup = BeautifulSoup(text)
        
        for user_url in soup.findAll(text=re.compile(URL_RE)):
            if not self.inside_a(user_url):
                if self.is_standalone(user_url):
                    template_dir = original_template_dir
                else:
                    template_dir = 'inline'
                
                replacement = block_parser.parse(
                    str(user_url),
                    maxwidth,
                    maxheight,
                    template_dir,
                    context,
                    urlize_all_links
                )
                user_url.replaceWith(replacement)
        
        return unicode(soup)
    
    def is_standalone(self, soupie):
        if re.match(STANDALONE_URL_RE, soupie):
            if soupie.parent.name in OEMBED_BLOCK_ELEMENTS:
                return True
        return False
    
    def inside_a(self, soupie):
        parent = soupie.parent
        while parent is not None:
            if parent.name == 'a':
                return True
            parent = parent.parent
        return False
    
    def extract_urls(self, text):
        block_parser = TextBlockParser()
        soup = BeautifulSoup(text)
        urls = set()
        url_list = []

        for user_url in soup.findAll(text=re.compile(URL_RE)):
            if not self.inside_a(user_url):
                block_urls = block_parser.extract_urls(unicode(user_url))
                
                for url in block_urls:
                    if url not in urls:
                        url_list.append(url)
                        urls.add(url)
        
        return url_list

########NEW FILE########
__FILENAME__ = text
import re

from django.utils.safestring import mark_safe

import oembed
from oembed.constants import URL_RE, STANDALONE_URL_RE
from oembed.exceptions import OEmbedException
from oembed.parsers.base import BaseParser


class TextBlockParser(BaseParser):
    def parse_data(self, text, maxwidth, maxheight, template_dir, context,
                   urlize_all_links):
        """
        Parses a block of text indiscriminately
        """
        # create a dictionary of user urls -> rendered responses
        replacements = {}
        user_urls = set(re.findall(URL_RE, text))
        
        for user_url in user_urls:
            try:
                resource = oembed.site.embed(user_url, maxwidth=maxwidth, maxheight=maxheight)
            except OEmbedException:
                if urlize_all_links:
                    replacements[user_url] = '<a href="%(LINK)s">%(LINK)s</a>' % {'LINK': user_url}
            else:
                context['minwidth'] = min(maxwidth, resource.width)
                context['minheight'] = min(maxheight, resource.height)
                
                replacement = self.render_oembed(
                    resource, 
                    user_url, 
                    template_dir=template_dir, 
                    context=context
                )
                replacements[user_url] = replacement.strip()
        
        # go through the text recording URLs that can be replaced
        # taking note of their start & end indexes
        user_urls = re.finditer(URL_RE, text)
        matches = []
        for match in user_urls:
            if match.group() in replacements:
                matches.append([match.start(), match.end(), match.group()])
        
        # replace the URLs in order, offsetting the indices each go
        for indx, (start, end, user_url) in enumerate(matches):
            replacement = replacements[user_url]
            difference = len(replacement) - len(user_url)
            
            # insert the replacement between two slices of text surrounding the
            # original url
            text = text[:start] + replacement + text[end:]
            
            # iterate through the rest of the matches offsetting their indices
            # based on the difference between replacement/original
            for j in xrange(indx + 1, len(matches)):
                matches[j][0] += difference
                matches[j][1] += difference
        return mark_safe(text)
    
    def extract_urls(self, text):
        urls = set()
        url_list = []
        for url in re.findall(URL_RE, text):
            if url not in urls:
                urls.add(url)
                url_list.append(url)
        
        return url_list


class TextParser(TextBlockParser):
    def parse_data(self, text, maxwidth, maxheight, template_dir, context, 
                   urlize_all_links):
        """
        Parses a block of text rendering links that occur on their own line
        normally but rendering inline links using a special template dir
        """
        block_parser = TextBlockParser()
        
        lines = text.splitlines()
        parsed = []
        
        for line in lines:
            if STANDALONE_URL_RE.match(line):
                user_url = line.strip()
                try:
                    resource = oembed.site.embed(user_url, maxwidth=maxwidth, maxheight=maxheight)
                    context['minwidth'] = min(maxwidth, resource.width)
                    context['minheight'] = min(maxheight, resource.height)
                except OEmbedException:
                    if urlize_all_links:
                        line = '<a href="%(LINK)s">%(LINK)s</a>' % {'LINK': user_url}
                else:
                    context['minwidth'] = min(maxwidth, resource.width)
                    context['minheight'] = min(maxheight, resource.height)
                    
                    line = self.render_oembed(
                        resource, 
                        user_url, 
                        template_dir=template_dir, 
                        context=context)
            else:
                line = block_parser.parse(line, maxwidth, maxheight, 'inline',
                                          context, urlize_all_links)
            
            parsed.append(line)
        
        return mark_safe('\n'.join(parsed))

########NEW FILE########
__FILENAME__ = providers
import datetime
import httplib2
import re
import time
from urllib import urlencode

try:
    import Image
except ImportError:
    from PIL import Image
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

from django.conf import settings
from django.contrib.sites.models import Site
from django.core.files import storage
from django.core.urlresolvers import get_resolver
from django.db.models.fields import DateTimeField, DateField
from django.db.models.fields.files import ImageField, ImageFieldFile
from django.template import RequestContext, Context
from django.template.loader import render_to_string, get_template
from django.utils import simplejson

from oembed.constants import OEMBED_ALLOWED_SIZES, OEMBED_THUMBNAIL_SIZE
from oembed.exceptions import OEmbedException, OEmbedHTTPException
from oembed.image_processors import image_processor
from oembed.resources import OEmbedResource
from oembed.utils import (fetch_url, get_domain, mock_request, cleaned_sites, 
    size_to_nearest, relative_to_full, scale)


resolver = get_resolver(None)


class BaseProvider(object):
    """
    Base class for OEmbed resources.
    """
    regex = None # regex this provider will match
    provides = True  # allow this provider to be accessed by third parties
    
    def request_resource(self, url, **kwargs):
        """
        Get an OEmbedResource from one of the providers configured in this 
        provider according to the resource url.
        
        Args:
            url: The url of the resource to get.
            format: Desired response format (json or xml).
            **kwargs: Optional parameters to pass in to the provider.
        
        Returns:
            OEmbedResource object.
            
        If no object returned, raises OEmbedException
        """
        raise NotImplementedError


class HTTPProvider(BaseProvider):
    """
    Provider class for HTTP providers, like YouTube - basically
    a proxy.
    """
    endpoint_url = ''
    provides = False # since this is generally a proxy to a pre-existing oembed
                     # provider, do not re-provide it
    
    # NOTE: these attributes are only required if provides = True
    # see http://oembed.com/ section 2.1 for how to define
    # but the gist is, this is a list of urls with wildcards
    # indicating what will match, instead of regex bits, i.e.
    # http://flickr.com/photos/*
    url_scheme = None
    resource_type = None # one of 'photo', 'video', 'rich' or 'link'
    
    def __init__(self):
        self._validate()
    
    def _validate(self):
        if self.provides and (not self.url_scheme or not self.resource_type):
            raise AttributeError(
                'If you want to provide %s up-stream, a url_scheme and ' \
                'resource_type must be specified' % self.__name__)
        if self.provides and self.resource_type not in ('photo', 'video', 'rich', 'link'):
            raise ValueError('resource_type must be one of "photo", "video", "rich" or "link"')
    
    def _fetch(self, url):
        """
        Fetches from a URL, respecting GZip encoding, etc.
        
        Returns an OEmbedResource instance
        """
        return fetch_url(url)
    
    def convert_to_resource(self, headers, raw_response, params):
        if 'content-type' not in headers:
            raise OEmbedException('Missing mime-type in response')
        
        content_type = headers['content-type'].split(';')[0]
        
        if content_type in ('text/javascript', 'application/json'):
            try:
                json_response = simplejson.loads(raw_response)
                resource = OEmbedResource.create(json_response)
            except ValueError:
                raise OEmbedException('Unable to parse response json')
        else:
            raise OEmbedException('Invalid mime-type - %s' % headers['content-type'])
        return resource
    
    def request_resource(self, url, **kwargs):
        """
        Request an OEmbedResource for a given url.  Some valid keyword args:
        - format
        - maxwidth
        - maxheight
        """
        params = kwargs
        
        params['url'] = url
        params['format'] = 'json'
        
        if '?' in self.endpoint_url:
            url_with_qs = '%s&%s' % (self.endpoint_url.rstrip('&'), urlencode(params))
        else:
            url_with_qs = "%s?%s" % (self.endpoint_url, urlencode(params))
        
        headers, raw_response = self._fetch(url_with_qs)
        resource = self.convert_to_resource(headers, raw_response, params)
        
        return resource


class DjangoProviderOptions(object):
    model = None         # required
    named_view = ''      # required: the name of this models' detail view
    fields_to_match = {} # mapping of regex_field -> model attr for lookups
    
    valid_sizes = OEMBED_ALLOWED_SIZES
    thumbnail_sizes = OEMBED_THUMBNAIL_SIZE
    image_processor = image_processor()
    force_fit = False
    
    year_part = 'year'
    month_part = 'month'
    day_part = 'day'

    context_varname = 'object'
    
    abstract = False
    
    def __init__(self, meta_options, provider_class):
        for k, v in meta_options.__dict__.items():
            if not k.startswith('_'):
                # because we are using properties, which are descriptors,
                # an AttributeError will be raised if we try to setattr()
                # to change a property (like image_field), so make changes
                # to the __dict__ instead
                self.__dict__[k] = v
        
        self.provider_class = provider_class
        
        if not self.abstract:
            self._validate()
            if not getattr(self, 'template_name', None):
                self.template_name = 'oembed/provider/%s_%s.html' % (
                    self.model._meta.app_label, self.model._meta.module_name
                )
    
    def _validate(self):
        if self.model is None:
            raise OEmbedException('Provider %s requires a model' % self.provider_class.__name__)
        if not self.named_view:
            raise OEmbedException('Provider %s requires a named_view' % self.provider_class.__name__)
    
    def _image_field(self):
        """
        Try to automatically detect an image field
        """
        for field in self.model._meta.fields:
            if isinstance(field, ImageField):
                return field.name
    image_field = property(_image_field)
    
    def _date_field(self):
        """
        Try to automatically detect an image field
        """
        for field in self.model._meta.fields:
            if isinstance(field, (DateTimeField, DateField)):
                return field.name
    date_field = property(_date_field)


class DjangoProviderMetaclass(type):
    def __new__(cls, name, bases, attrs):
        """
        Provides namespacing of Meta options
        """
        # these are any overrides defined on the incoming provider class
        meta = attrs.pop('Meta', None)
        
        provider_class = super(DjangoProviderMetaclass, cls).__new__(
            cls, name, bases, attrs)
        
        # see if the provider class is extending any class that has its own
        # set of overrides
        for b in bases:
            base_meta = getattr(b, '_meta', None)
            if not base_meta:
                continue
            
            for (k, v) in base_meta.__dict__.items():
                if not k.startswith('_') and k != 'abstract' and k not in meta.__dict__:
                    meta.__dict__[k] = v
        
        if meta:
            # instantiate the options class, passing in our provider
            _meta = DjangoProviderOptions(meta, provider_class)
            
            # bolt the options onto the new provider class
            provider_class._meta = _meta
        
        return provider_class


class DjangoProvider(BaseProvider):
    """
    Provider class for Django apps
    
    Examples:
    
    class PhotoProvider(DjangoProvider):
        class Meta:
            model = Photo
            named_view = 'photo_detail'
            fields_to_match = {'object_id': 'id'}
        
        def author_name(self, obj):
            return obj.user.username
        
        def title(self, obj):
            return obj.title
    
    class VideoProvider(DjangoDateBasedProvider):
        class Meta:
            model = Video
            named_view = 'video_detail'
            fields_to_match = {'slug': 'slug'}
        
            valid_sizes = ((400, 300), (600, 450)) # embed will automatically resize
            force_fit = True # don't scale dimensions, force fit
        
        def html(self, obj):
            return self.render_html(
                obj,
                context=Context({'width': self.width, 'height': self.height}), 
                context_varname='video')
        
        ...
    """
    __metaclass__ = DjangoProviderMetaclass
    
    resource_type = None # photo, link, video or rich
    
    def __init__(self):
        self._validate()
    
    def _validate(self):
        if self.resource_type not in ('photo', 'video', 'rich', 'link'):
            raise ValueError('resource_type must be one of "photo", "video", "rich" or "link"')
    
    def _build_regex(self):
        """
        Performs a reverse lookup on a named view and generates
        a list of regexes that match that object.  It generates
        regexes with the domain name included, using sites provided
        by the get_sites() method.
        
        >>> regex = provider.regex
        >>> regex.pattern
        'http://(www2.kusports.com|www2.ljworld.com|www.lawrence.com)/photos/(?P<year>\\d{4})/(?P<month>\\w{3})/(?P<day>\\d{1,2})/(?P<object_id>\\d+)/$'
        """
        # get the regexes from the urlconf
        url_patterns = resolver.reverse_dict.get(self._meta.named_view)
        
        try:
            regex = url_patterns[1]
        except TypeError:
            raise OEmbedException('Error looking up %s' % self._meta.named_view)
        
        # get a list of normalized domains
        cleaned_sites = self.get_cleaned_sites()
        
        site_regexes = []
        
        for site in self.get_sites():
            site_regexes.append(cleaned_sites[site.pk][0])
        
        # join the sites together with the regex 'or'
        sites = '|'.join(site_regexes)
        
        # create URL-matching regexes for sites
        regex = re.compile('(%s)/%s' % (sites, regex))
        
        return regex
    regex = property(_build_regex)
    
    def get_sites(self):
        """
        Return sites whose domains should be checked against
        """
        return Site.objects.all()
    
    def get_cleaned_sites(self):
        """
        Attribute-caches the sites/regexes returned by
        `oembed.utils.cleaned_sites`
        """
        if not getattr(self, '_clean_sites', None):
            self._clean_sites = cleaned_sites()
        return self._clean_sites
    
    def provider_from_url(self, url):
        """
        Given a URL for any of our sites, try and match it to one, returning
        the domain & name of the match.  If no match is found, return current.
        
        Returns a tuple of domain, site name -- used to determine 'provider'
        """
        domain = get_domain(url)
        site_tuples = self.get_cleaned_sites().values()
        for domain_re, name, normalized_domain in site_tuples:
            if re.match(domain_re, domain):
                return normalized_domain, name
        site = Site.objects.get_current()
        return site.domain, site.name
    
    def get_params(self, url):
        """
        Extract the named parameters from a url regex.  If the url regex does not contain
        named parameters, they will be keyed _0, _1, ...
        
        * Named parameters
        Regex:
        /photos/^(?P<year>\d{4})/(?P<month>\w{3})/(?P<day>\d{1,2})/(?P<object_id>\d+)/
        
        URL:
        http://www2.ljworld.com/photos/2009/oct/11/12345/
        
        Return Value:
        {u'day': '11', u'month': 'oct', u'object_id': '12345', u'year': '2009'}
        
        * Unnamed parameters
        Regex:
        /blah/([\w-]+)/(\d+)/
        
        URL:
        http://www.example.com/blah/hello/123/
        
        Return Value:
        {u'_0': 'hello', u'_1': '123'}
        """
        match = re.match(self.regex, url)
        if match is not None:
            params = match.groupdict()
            if not params:
                params = {}
                for i, group in enumerate(match.groups()[1:]):
                    params['_%s' % i] = group
            return params
        
        raise OEmbedException('No regex matched the url %s' % (url))
    
    def get_queryset(self):
        return self._meta.model._default_manager.all()
    
    def get_object(self, url):
        """
        Fields to match is a mapping of url params to fields, so for
        the photos example above, it would be:
        
        fields_to_match = { 'object_id': 'id' }
        
        This procedure parses out named params from a URL and then uses
        the fields_to_match dictionary to generate a query.
        """
        params = self.get_params(url)
        query = {}
        for key, value in self._meta.fields_to_match.iteritems():
            try:
                query[value] = params[key]
            except KeyError:
                raise OEmbedException('%s was not found in the urlpattern parameters.  Valid names are: %s' % (key, ', '.join(params.keys())))
        
        try:
            obj = self.get_queryset().get(**query)
        except self._meta.model.DoesNotExist:
            raise OEmbedException('Requested object not found')
        
        return obj
    
    def render_html(self, obj, context=None):
        """
        Generate the 'html' attribute of an oembed resource using a template.
        Sort of a corollary to the parser's render_oembed method.  By default,
        the current mapping will be passed in as the context.
        
        OEmbed templates are stored in:
        
        oembed/provider/[app_label]_[model].html
        
        -- or --
        
        oembed/provider/media_video.html
        """        
        provided_context = context or Context()
        context = RequestContext(mock_request())
        context.update(provided_context)
        
        context.push()
        context[self._meta.context_varname] = obj
        rendered = render_to_string(self._meta.template_name, context)
        context.pop()
        return rendered
    
    def map_attr(self, mapping, attr, obj):
        """
        A kind of cheesy method that allows for callables or attributes to
        be used interchangably
        """
        if attr not in mapping and hasattr(self, attr):
            if not callable(getattr(self, attr)):
                mapping[attr] = getattr(self, attr)
            else:
                mapping[attr] = getattr(self, attr)(obj)
    
    def get_image(self, obj):
        """
        Return an ImageFileField instance
        """
        if self._meta.image_field:
            return getattr(obj, self._meta.image_field)
    
    def resize(self, image_field, new_width=None, new_height=None):
        """
        Resize an image to the 'best fit' width & height, maintaining
        the scale of the image, so a 500x500 image sized to 300x400
        will actually be scaled to 300x300.
        
        Params:
        image: ImageFieldFile to be resized (i.e. model.image_field)
        new_width & new_height: desired maximums for resizing
        
        Returns:
        the url to the new image and the new width & height
        (http://path-to-new-image, 300, 300)
        """
        if isinstance(image_field, ImageFieldFile) and \
           image_field.field.width_field and \
           image_field.field.height_field:
            # use model fields
            current_width = getattr(image_field.instance, image_field.field.width_field)
            current_height = getattr(image_field.instance, image_field.field.height_field)
        else:
            # use PIL
            try:
                file_obj = storage.default_storage.open(image_field.name, 'rb')
                img_obj = Image.open(file_obj)
                current_width, current_height = img_obj.size
            except IOError:
                return (image_field.url, 0, 0) 
        
        # determine if resizing needs to be done (will not scale up)
        if current_width < new_width:
            if not new_height or current_height < new_height:
                return (image_field.url, current_width, current_height)
        
        # calculate ratios
        new_width, new_height = scale(current_width, current_height, new_width, new_height)
        
        # use the image_processor defined in the settings, or PIL by default
        return self._meta.image_processor.resize(image_field, new_width, new_height)
    
    def resize_photo(self, obj, mapping, maxwidth=None, maxheight=None):
        url, width, height = self.resize(
            self.get_image(obj), 
            *size_to_nearest(maxwidth, maxheight, self._meta.valid_sizes))
        mapping.update(url=url, width=width, height=height)
        
    def thumbnail(self, obj, mapping):
        url, width, height = self.resize(
            self.get_image(obj), 
            *size_to_nearest(allowed_sizes=self._meta.thumbnail_sizes))
        mapping.update(thumbnail_url=url, thumbnail_width=width, 
                       thumbnail_height=height)
    
    def preprocess(self, obj, mapping, **kwargs):
        """
        Pre-processing hook.  Called by map_to_dictionary()
        """
        pass
    
    def postprocess(self, obj, mapping, **kwargs):
        """
        Post-processing hook.  Called by map_to_dictionary()
        """
        pass
    
    def map_to_dictionary(self, url, obj, **kwargs):
        """
        Build a dictionary of metadata for the requested object.
        """
        maxwidth = kwargs.get('maxwidth', None)
        maxheight = kwargs.get('maxheight', None)
        
        provider_url, provider_name = self.provider_from_url(url)
        
        mapping = {
            'version': '1.0',
            'url': url,
            'provider_name': provider_name,
            'provider_url': provider_url,
            'type': self.resource_type
        }
        
        # a hook
        self.preprocess(obj, mapping, **kwargs)
        
        # resize image if we have a photo, otherwise use the given maximums
        if self.resource_type == 'photo' and self.get_image(obj):
            self.resize_photo(obj, mapping, maxwidth, maxheight)
        elif self.resource_type in ('video', 'rich', 'photo'):
            width, height = size_to_nearest(
                maxwidth,
                maxheight,
                self._meta.valid_sizes,
                self._meta.force_fit
            )
            mapping.update(width=width, height=height)
        
        # create a thumbnail
        if self.get_image(obj):
            self.thumbnail(obj, mapping)
        
        # map attributes to the mapping dictionary.  if the attribute is
        # a callable, it must have an argument signature of
        # (self, obj)
        for attr in ('title', 'author_name', 'author_url', 'html'):
            self.map_attr(mapping, attr, obj)
        
        # fix any urls
        if 'url' in mapping:
            mapping['url'] = relative_to_full(mapping['url'], url)
        
        if 'thumbnail_url' in mapping:
            mapping['thumbnail_url'] = relative_to_full(mapping['thumbnail_url'], url)
        
        if 'html' not in mapping and mapping['type'] in ('video', 'rich'):
            mapping['html'] = self.render_html(obj, context=Context(mapping))
        
        # a hook
        self.postprocess(obj, mapping, **kwargs)
        
        return mapping
    
    def request_resource(self, url, **kwargs):
        """
        Request an OEmbedResource for a given url.  Some valid keyword args:
        - format
        - maxwidth
        - maxheight
        """
        obj = self.get_object(url)
        
        mapping = self.map_to_dictionary(url, obj, **kwargs)
        
        resource = OEmbedResource.create(mapping)
        resource.content_object = obj
        
        return resource

class DjangoDateBasedProvider(DjangoProvider):
    """
    Provider for Django models that use date-based urls
    """
    def _validate(self):
        super(DjangoDateBasedProvider, self)._validate()
        if not self._meta.date_field:
            raise OEmbedException('date_field not found for %s' % self.__class__.__name__)
    
    def get_object(self, url, month_format='%b', day_format='%d'):
        """
        Parses the date from a url and uses it in the query.  For objects which
        are unique for date.
        """
        params = self.get_params(url)
        try:
            year = params[self._meta.year_part]
            month = params[self._meta.month_part]
            day = params[self._meta.day_part]
        except KeyError:
            try:
                # named lookups failed, so try to get the date using the first
                # three parameters
                year, month, day = params['_0'], params['_1'], params['_2']
            except KeyError:
                raise OEmbedException('Error extracting date from url parameters')
        
        try:
            tt = time.strptime('%s-%s-%s' % (year, month, day),
                               '%s-%s-%s' % ('%Y', month_format, day_format))
            date = datetime.date(*tt[:3])
        except ValueError:
            raise OEmbedException('Error parsing date from: %s' % url)

        # apply the date-specific lookups
        if isinstance(self._meta.model._meta.get_field(self._meta.date_field), DateTimeField):
            min_date = datetime.datetime.combine(date, datetime.time.min)
            max_date = datetime.datetime.combine(date, datetime.time.max)
            query = {'%s__range' % self._meta.date_field: (min_date, max_date)}
        else:
            query = {self._meta.date_field: date}
        
        # apply the regular search lookups
        for key, value in self._meta.fields_to_match.iteritems():
            try:
                query[value] = params[key]
            except KeyError:
                raise OEmbedException('%s was not found in the urlpattern parameters.  Valid names are: %s' % (key, ', '.join(params.keys())))
        
        try:
            obj = self.get_queryset().get(**query)
        except self._meta.model.DoesNotExist:
            raise OEmbedException('Requested object not found')
        
        return obj

########NEW FILE########
__FILENAME__ = resources
from django.utils import simplejson

from oembed.exceptions import OEmbedException

class OEmbedResource(object):
    """
    OEmbed resource, as well as a factory for creating resource instances
    from response json
    """
    _data = {}
    content_object = None
    
    def __getattr__(self, name):
        return self._data.get(name)
    
    def get_data(self):
        return self._data
        
    def load_data(self, data):
        self._data = data
    
    @property
    def json(self):
        return simplejson.dumps(self._data)
    
    @classmethod
    def create(cls, data):
        if not 'type' in data or not 'version' in data:
            raise OEmbedException('Missing required fields on OEmbed response.')

        data['width'] = data.get('width') and int(data['width']) or None
        data['height'] = data.get('height') and int(data['height']) or None
        
        filtered_data = dict([(k, v) for k, v in data.items() if v])
        
        resource = cls()
        resource.load_data(filtered_data)
        
        return resource

    @classmethod
    def create_json(cls, raw):
        data = simplejson.loads(raw)
        return cls.create(data)

########NEW FILE########
__FILENAME__ = sites
import datetime
import re

from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.db.models import signals
from django.utils import simplejson as json

from oembed.constants import DEFAULT_OEMBED_TTL, MIN_OEMBED_TTL, RESOURCE_TYPES
from oembed.exceptions import AlreadyRegistered, NotRegistered, OEmbedMissingEndpoint, OEmbedException
from oembed.models import StoredOEmbed, StoredProvider
from oembed.providers import BaseProvider, DjangoProvider
from oembed.resources import OEmbedResource
from oembed.utils import fetch_url, relative_to_full


class ProviderSite(object):
    def __init__(self):
        self.clear()
    
    def invalidate_providers(self):
        self._populated = False
    
    def clear(self):
        self._registry = {}
        self._registered_providers = []
        self.invalidate_providers()
    
    def register(self, provider_class):
        """
        Registers a provider with the site.
        """
        if not issubclass(provider_class, BaseProvider):
            raise TypeError('%s is not a subclass of BaseProvider' % provider_class.__name__)
        
        if provider_class in self._registered_providers:
            raise AlreadyRegistered('%s is already registered' % provider_class.__name__)
        
        if issubclass(provider_class, DjangoProvider):
            # set up signal handler for cache invalidation
            signals.post_save.connect(
                self.invalidate_stored_oembeds,
                sender=provider_class._meta.model
            )
        
        # don't build the regex yet - if not all urlconfs have been loaded
        # and processed at this point, the DjangoProvider instances will fail
        # when attempting to reverse urlpatterns that haven't been created.
        # Rather, the regex-list will be populated once, on-demand.
        self._registered_providers.append(provider_class)
        
        # flag for re-population
        self.invalidate_providers()
    
    def unregister(self, provider_class):
        """
        Unregisters a provider from the site.
        """
        if not issubclass(provider_class, BaseProvider):
            raise TypeError('%s must be a subclass of BaseProvider' % provider_class.__name__)
        
        if provider_class not in self._registered_providers:
            raise NotRegistered('%s is not registered' % provider_class.__name__)
        
        self._registered_providers.remove(provider_class)
        
        # flag for repopulation
        self.invalidate_providers()
    
    def populate(self):
        """
        Populate the internal registry's dictionary with the regexes for each
        provider instance
        """
        self._registry = {}
        
        for provider_class in self._registered_providers:
            instance = provider_class()
            self._registry[instance] = instance.regex
        
        for stored_provider in StoredProvider.objects.active():
            self._registry[stored_provider] = stored_provider.regex
        
        self._populated = True
    
    def ensure_populated(self):
        """
        Ensure not only that the internal registry of Python-class providers is
        populated, but also make sure the cached queryset of database-providers
        is up-to-date
        """
        if not self._populated:
            self.populate()
    
    def get_registry(self):
        """
        Return a dictionary of {provider_instance: regex}
        """
        self.ensure_populated()
        return self._registry

    def get_providers(self):
        """Provide a list of all oembed providers that are being used."""
        return self.get_registry().keys()
    
    def provider_for_url(self, url):
        """
        Find the right provider for a URL
        """
        for provider, regex in self.get_registry().items():
            if re.match(regex, url) is not None:
                return provider
        
        raise OEmbedMissingEndpoint('No endpoint matches URL: %s' % url)
    
    def invalidate_stored_oembeds(self, sender, instance, created, **kwargs):
        """
        A hook for django-based oembed providers to delete any stored oembeds
        """
        ctype = ContentType.objects.get_for_model(instance)
        StoredOEmbed.objects.filter(
            object_id=instance.pk,
            content_type=ctype).delete()
    
    def embed(self, url, **kwargs):
        """
        The heart of the matter
        """
        try:
            # first figure out the provider
            provider = self.provider_for_url(url)
        except OEmbedMissingEndpoint:
            raise
        else:
            try:
                # check the database for a cached response, because of certain
                # race conditions that exist with get_or_create(), do a filter
                # lookup and just grab the first item
                stored_match = StoredOEmbed.objects.filter(
                    match=url, 
                    maxwidth=kwargs.get('maxwidth', None), 
                    maxheight=kwargs.get('maxheight', None),
                    date_expires__gte=datetime.datetime.now())[0]
                return OEmbedResource.create_json(stored_match.response_json)
            except IndexError:
                # query the endpoint and cache response in db
                # prevent None from being passed in as a GET param
                params = dict([(k, v) for k, v in kwargs.items() if v])
                
                # request an oembed resource for the url
                resource = provider.request_resource(url, **params)
                
                try:
                    cache_age = int(resource.cache_age)
                    if cache_age < MIN_OEMBED_TTL:
                        cache_age = MIN_OEMBED_TTL
                except:
                    cache_age = DEFAULT_OEMBED_TTL
                
                date_expires = datetime.datetime.now() + datetime.timedelta(seconds=cache_age)
                
                stored_oembed, created = StoredOEmbed.objects.get_or_create(
                    match=url,
                    maxwidth=kwargs.get('maxwidth', None),
                    maxheight=kwargs.get('maxheight', None))
                
                stored_oembed.response_json = resource.json
                stored_oembed.resource_type = resource.type
                stored_oembed.date_expires = date_expires
                
                if resource.content_object:
                    stored_oembed.content_object = resource.content_object
                
                stored_oembed.save()
                return resource
    
    def autodiscover(self, url):
        """
        Load up StoredProviders from url if it is an oembed scheme
        """
        headers, response = fetch_url(url)
        if headers['content-type'].split(';')[0] in ('application/json', 'text/javascript'):
            provider_data = json.loads(response)
            return self.store_providers(provider_data)
    
    def store_providers(self, provider_data):
        """
        Iterate over the returned json and try to sort out any new providers
        """
        if not hasattr(provider_data, '__iter__'):
            raise OEmbedException('Autodiscovered response not iterable')
        
        provider_pks = []
        
        for provider in provider_data:
            if 'endpoint' not in provider or \
               'matches' not in provider:
                continue
            
            resource_type = provider.get('type')
            if resource_type not in RESOURCE_TYPES:
                continue
            
            stored_provider, created = StoredProvider.objects.get_or_create(
                wildcard_regex=provider['matches']
            )
            
            if created:
                stored_provider.endpoint_url = relative_to_full(    
                    provider['endpoint'],
                    provider['matches']
                )
                stored_provider.resource_type = resource_type
                stored_provider.save()
            
            provider_pks.append(stored_provider.pk)
        
        return StoredProvider.objects.filter(pk__in=provider_pks)     

# just like django admin
site = ProviderSite()

########NEW FILE########
__FILENAME__ = oembed_tags
from urllib import urlencode
from django import template
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse, NoReverseMatch
from django.template.defaultfilters import stringfilter
from django.utils.safestring import mark_safe

from oembed.consumer import OEmbedConsumer
from oembed.exceptions import OEmbedMissingEndpoint

import oembed

register = template.Library()

def oembed_filter(input, args=None):
    if args:
        dimensions = args.lower().split('x')
        if len(dimensions) != 2:
            raise template.TemplateSyntaxError("Usage: [width]x[height], e.g. 600x400")
        width, height = map(int, dimensions)
    else:
        width = height = None

    client = OEmbedConsumer()
    return mark_safe(client.parse(input, width, height))

register.filter('oembed', oembed_filter)

@register.filter
def extract_oembeds(text, args=None):
    """
    Extract oembed resources from a block of text.  Returns a list
    of dictionaries.

    Max width & height can be specified:
    {% for embed in block_of_text|extract_oembeds:"400x300" %}

    Resource type can be specified:
    {% for photo_embed in block_of_text|extract_oembeds:"photo" %}

    Or both:
    {% for embed in block_of_text|extract_oembeds:"400x300xphoto" %}
    """
    resource_type = width = height = None
    if args:
        dimensions = args.lower().split('x')
        if len(dimensions) in (3, 1):
            resource_type = dimensions.pop()

        if len(dimensions) == 2:
            width, height = map(lambda x: int(x), dimensions)

    client = OEmbedConsumer()
    return client.extract(text, width, height, resource_type)


@register.filter
def strip_oembeds(text, args=None):
    """
    Take a block of text and strip all the embeds from it, optionally taking
    a maxwidth, maxheight / resource_type
    
    Usage:
    {{ post.content|strip_embeds }}
    
    {{ post.content|strip_embeds:"600x600xphoto" }}
    
    {{ post.content|strip_embeds:"video" }}
    """
    resource_type = width = height = None
    if args:
        dimensions = args.lower().split('x')
        if len(dimensions) in (3, 1):
            resource_type = dimensions.pop()

        if len(dimensions) == 2:
            width, height = map(lambda x: int(x), dimensions)
    
    client = OEmbedConsumer()
    return mark_safe(client.strip(text, width, height, resource_type))


class OEmbedNode(template.Node):
    def __init__(self, nodelist, width, height, template_dir, var_name):
        self.nodelist = nodelist
        self.width = width
        self.height = height
        self.template_dir = template_dir
        self.var_name = var_name

    def render(self, context):
        kwargs = {}
        if self.width and self.height:
            kwargs['maxwidth'] = self.width
            kwargs['maxheight'] = self.height
            kwargs['template_dir'] = self.template_dir
            kwargs['context'] = context

        client = OEmbedConsumer()
        parsed = client.parse(self.nodelist.render(context), **kwargs)
        if self.var_name:
            context[self.var_name] = parsed
            return ''
        else:
            return parsed

def do_oembed(parser, token):
    """
    A node which parses everything between its two nodes, and replaces any links
    with OEmbed-provided objects, if possible.

    Supports two optional argument, which is the maximum width and height,
    specified like so:

    {% oembed 640x480 %}http://www.viddler.com/explore/SYSTM/videos/49/{% endoembed %}

    and or the name of a sub tempalte directory to render templates from:

    {% oembed 320x240 in "comments" %}http://www.viddler.com/explore/SYSTM/videos/49/{% endoembed %}

    or:

    {% oembed in "comments" %}http://www.viddler.com/explore/SYSTM/videos/49/{% endoembed %}

    either of those will render templates in oembed/comments/oembedtype.html

    Additionally, you can specify a context variable to drop the rendered text in:

    {% oembed 600x400 in "comments" as var_name %}...{% endoembed %}
    {% oembed as var_name %}...{% endoembed %}
    """
    args = token.split_contents()
    template_dir = None
    var_name = None
    if len(args) > 2:
        if len(args) == 3 and args[1] == 'in':
            template_dir = args[2]
        elif len(args) == 3 and args[1] == 'as':
            var_name = args[2]
        elif len(args) == 4 and args[2] == 'in':
            template_dir = args[3]
        elif len(args) == 4 and args[2] == 'as':
            var_name = args[3]
        elif len(args) == 6 and args[4] == 'as':
            template_dir = args[3]
            var_name = args[5]
        else:
            raise template.TemplateSyntaxError("OEmbed either takes a single " \
                "(optional) argument: WIDTHxHEIGHT, where WIDTH and HEIGHT " \
                "are positive integers, and or an optional 'in " \
                " \"template_dir\"' argument set.")
        if template_dir:
            if not (template_dir[0] == template_dir[-1] and template_dir[0] in ('"', "'")):
                raise template.TemplateSyntaxError("template_dir must be quoted")
            template_dir = template_dir[1:-1]

    if len(args) >= 2 and 'x' in args[1]:
        width, height = args[1].lower().split('x')
        if not width and height:
            raise template.TemplateSyntaxError("OEmbed's optional WIDTHxHEIGH" \
                "T argument requires WIDTH and HEIGHT to be positive integers.")
    else:
        width, height = None, None
    nodelist = parser.parse(('endoembed',))
    parser.delete_first_token()
    return OEmbedNode(nodelist, width, height, template_dir, var_name)

register.tag('oembed', do_oembed)


class OEmbedAutodiscoverNode(template.Node):
    def __init__(self, obj):
        self.obj = obj

    def render(self, context):
        obj = template.resolve_variable(self.obj, context)
        domain = Site.objects.get_current().domain
        try:
            url = 'http://%s%s' % (domain, obj.get_absolute_url())
            regex = oembed.site.provider_for_url(url)
            provider = 'http://%s%s' % (domain, reverse('oembed_json'))
            params = {'url': url, 'format': 'json'}
            return '<link rel="alternate" type="application/json+oembed" href="%s?%s" />' % (provider, urlencode(params))
        except OEmbedMissingEndpoint:
            return ''

def do_autodiscover(parser, token):
    """
    Generates a &lt;link&gt; tag with oembed autodiscovery bits for an object.

    {% oembed_autodiscover video %}
    """
    args = token.split_contents()
    if len(args) != 2:
        raise template.TemplateSyntaxError('%s takes an object as its parameter.' % args[0])
    else:
        obj = args[1]
    return OEmbedAutodiscoverNode(obj)

register.tag('oembed_autodiscover', do_autodiscover)


class OEmbedURLSchemeNode(template.Node):
    def render(self, context):
        try:
            site_profile = reverse('oembed_schema')
            current_site = Site.objects.get_current()
            return '<link rel="alternate" type="application/json+oembed+scheme" href="http://%s%s" title="%s OEmbed Scheme" />' % \
                (current_site.domain, site_profile, current_site.name)
        except NoReverseMatch:
            return ''

def do_url_scheme(parser, token):
    """
    Generates a &lt;link&gt; tag with oembed autodiscovery bits.

    {% oembed_url_scheme %}
    """
    args = token.split_contents()
    if len(args) != 1:
        raise template.TemplateSyntaxError('%s takes no parameters.' % args[0])
    return OEmbedURLSchemeNode()

register.tag('oembed_url_scheme', do_url_scheme)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from oembed.tests.models import Blog, Category

admin.site.register(Blog)
admin.site.register(Category)

########NEW FILE########
__FILENAME__ = models
from django.core.urlresolvers import reverse
from django.db import models
from django.template.defaultfilters import slugify

from oembed.fields import EmbeddedMediaField

class Blog(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField()
    content = models.TextField()
    author = models.CharField(max_length=255)
    pub_date = models.DateTimeField()

    def save(self, *args, **kwargs):
        self.slug = slugify(self.title)
        super(Blog, self).save(*args, **kwargs)

    def get_absolute_url(self):
        year = self.pub_date.year
        month = self.pub_date.strftime('%b').lower()
        day = self.pub_date.day
        return reverse('test_blog_detail', args=[year, month, day, self.slug])

class Category(models.Model):
    name = models.CharField(max_length=255)
    image = models.ImageField(upload_to='images')
    width = models.IntegerField(blank=True, null=True, editable=False)
    height = models.IntegerField(blank=True, null=True, editable=False)

    def get_absolute_url(self):
        return reverse('test_category_detail', args=[self.pk])

class Rich(models.Model):
    name = models.CharField(max_length=255)
    slug = models.SlugField()
    content = models.TextField()

    media = EmbeddedMediaField(['photo', 'video'], related_name='rich_media')
    photos = EmbeddedMediaField('photo', related_name='rich_photos')
    videos = EmbeddedMediaField('video', related_name='rich_videos')

    def get_absolute_url(self):
        return reverse('test_rich_detail', args=[self.slug])

########NEW FILE########
__FILENAME__ = oembed_providers
import oembed
from oembed.providers import DjangoDateBasedProvider, DjangoProvider
from oembed.utils import size_to_nearest

from oembed.tests.models import Blog, Category, Rich

class BlogProvider(DjangoDateBasedProvider):
    resource_type = 'link'
    
    class Meta:
        model = Blog
        named_view = 'test_blog_detail'
        fields_to_match = {'entry_slug': 'slug'}
        date_field = 'pub_date'

    def author_name(self, obj):
        return obj.author
    
    def title(self, obj):
        return obj.title

class CategoryProvider(DjangoProvider):
    resource_type = 'photo'
    
    class Meta:
        model = Category
        named_view = 'test_category_detail'
        fields_to_match = {'_0': 'pk'}
    
    def title(self, obj):
        return obj.name

class RichProvider(DjangoProvider):
    resource_type = 'rich'
    
    class Meta:
        model = Rich
        named_view = 'test_rich_detail'
        fields_to_match = {'_0': 'slug'}
    
    def title(self, obj):
        return obj.name

oembed.site.register(BlogProvider)
oembed.site.register(CategoryProvider)
oembed.site.register(RichProvider)

########NEW FILE########
__FILENAME__ = settings
import os

DEBUG = True

DATABASE_ENGINE = 'sqlite3'

SITE_ROOT = os.path.dirname(os.path.realpath(__file__))

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.admin',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'oembed.tests',
    'oembed',
]

DEFAULT_FILE_STORAGE = 'oembed.tests.storage.DummyMemoryStorage'

TEMPLATE_LOADERS = (
    'django.template.loaders.app_directories.load_template_source',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.core.context_processors.auth",
    "django.core.context_processors.media",
    "django.core.context_processors.request"
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'oembed.tests.urls'
SITE_ID = 1

MEDIA_ROOT = '%s/media/' % (SITE_ROOT)
MEDIA_URL = '/media/'

########NEW FILE########
__FILENAME__ = storage
import os
from urllib2 import urlparse
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

from django.conf import settings
from django.core.files import storage


class DummyMemoryStorage(storage.Storage):
    """
    A simple in-memory storage backend for testing image storage - copied from
    djutils (http://github.com/coleifer/djutils/)
    """
    _files = {} # bampf
    
    def delete(self, name):
        if name in self._files:
            del(self._files[name])
    
    def exists(self, name):
        return name in self._files
    
    def listdir(self, path):
        files = []
        if not path.endswith('/'):
            path += '/' # make sure ends in slash for string comp below
        for k in self._files:
            if k.startswith(path) and '/' not in k.replace(path, ''):
                files.append(k.replace(path, ''))
    
    def size(self, name):
        return len(self._files[name])
    
    def url(self, name):
        return urlparse.urljoin(settings.MEDIA_URL, name)
    
    def _open(self, name, mode):
        return StringIO(self._files.get(name, ''))
    
    def _save(self, name, content):
        content.seek(0)
        self._files[name] = content.read()
        return name
    
    def get_valid_name(self, name):
        return name
    
    def get_available_name(self, name):
        if name not in self._files:
            return name
        
        base_path, ext = os.path.splitext(name)
        counter = 1
        
        while 1:
            test = '%s_%s%s' % (base_path, counter, ext)
            if test not in self._files:
                return test
            counter += 1

########NEW FILE########
__FILENAME__ = base
import os
from urllib2 import urlparse
try: 
    import Image
except ImportError:
    from PIL import Image
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

from django.conf import settings
from django.core.files import storage
from django.core.files.base import ContentFile
from django.core.urlresolvers import reverse, NoReverseMatch
from django.test import TestCase
from django.utils import simplejson

import oembed
from oembed.providers import BaseProvider
from oembed.resources import OEmbedResource

from oembed.tests.settings import MEDIA_ROOT, MEDIA_URL, DEFAULT_FILE_STORAGE
from oembed.tests.storage import DummyMemoryStorage


class BaseOEmbedTestCase(TestCase):
    fixtures = ['oembed_testdata.json']
    urls = 'oembed.tests.urls'
    
    # third party providers (StoredProvider)
    flickr_url = 'http://www.flickr.com/photos/neilkrug/2554073003/'
    youtube_url = 'http://www.youtube.com/watch?v=nda_OSWeyn8'
    
    # django providers (DjangoProvider and DjangoDatebasedProvider)
    category_url = 'http://example.com/testapp/category/1/'
    blog_url = 'http://example.com/testapp/blog/2010/may/01/entry-1/'
    rich_url = 'http://example.com/testapp/rich/rich-one/'
    
    category_embed = '<img src="http://example.com/media/images/test_image1_800x600.jpg" alt="Category 1" ></img>'
    
    def setUp(self):
        "Set up test environment"
        # load up all the providers and register the test-only provider
        oembed.autodiscover()
        
        # refresh the attribute-cached time the db providers were last updated
        oembed.site._db_updated = None
        
        self.storage = DummyMemoryStorage()
        
        # monkeypatch default_storage
        self.orig_default_storage = storage.default_storage
        storage.default_storage = self.storage
        
        # swap media root & media url
        self.media_root, self.media_url = settings.MEDIA_ROOT, settings.MEDIA_URL
        settings.MEDIA_ROOT = MEDIA_ROOT
        settings.MEDIA_URL = MEDIA_URL

        # swap out template dirs
        self.template_dirs = settings.TEMPLATE_DIRS
        cur_dir = os.path.dirname(__file__)
        settings.TEMPLATE_DIRS = [os.path.join(os.path.dirname(cur_dir), 'templates')]
        
        # swap out file storage backend
        self.orig_file_storage = settings.DEFAULT_FILE_STORAGE
        settings.DEFAULT_FILE_STORAGE = DEFAULT_FILE_STORAGE

        # create 2 images for testing
        test_image = Image.new('CMYK', (1024, 768), (255, 255, 255, 255))
        self.test_img_buffer = StringIO()
        test_image.save(self.test_img_buffer, 'JPEG')
        
        self.test_img_file = ContentFile(self.test_img_buffer.getvalue())
        self.test_img_location = 'images/test_image1.jpg'
        storage.default_storage.save(self.test_img_location, self.test_img_file)

    def tearDown(self):
        settings.MEDIA_ROOT = self.media_root
        settings.MEDIA_URL = self.media_url
        settings.TEMPLATE_DIRS = self.template_dirs
        settings.DEFAULT_FILE_STORAGE = self.orig_file_storage
        storage.default_storage = self.orig_default_storage

    def _sort_by_pk(self, list_or_qs):
        # decorate, sort, undecorate using the pk of the items
        # in the list or queryset
        annotated = [(item.pk, item) for item in list_or_qs]
        annotated.sort()
        return map(lambda item_tuple: item_tuple[1], annotated)
    
    def assertQuerysetEqual(self, a, b):
        # assert list or queryset a is the same as list or queryset b
        return self.assertEqual(self._sort_by_pk(a), self._sort_by_pk(b))

########NEW FILE########
__FILENAME__ = consumer
import oembed

from oembed.tests.tests.base import BaseOEmbedTestCase
from oembed.consumer import OEmbedConsumer
from oembed.resources import OEmbedResource


class ConsumerTestCase(BaseOEmbedTestCase):
    def setUp(self):
        "Set up test environment"
        super(ConsumerTestCase, self).setUp()
        self.oembed_client = OEmbedConsumer()

    def test_parse_text(self):
        consumed = self.oembed_client.parse_text(self.category_url)
        self.assertEqual(consumed, self.category_embed)
    
    def test_parse_html(self):
        consumed = self.oembed_client.parse_html('<p>%s</p>' % self.category_url)
        self.assertEqual(consumed, '<p>%s</p>' % self.category_embed)
    
    def test_extract_oembeds(self):
        embeds = self.oembed_client.extract_oembeds(self.category_url)
        self.assertEqual(len(embeds), 1)
        self.assertEqual(embeds[0]['original_url'], self.category_url)
        
        embeds = self.oembed_client.extract_oembeds(self.category_url, resource_type='photo')
        self.assertEqual(len(embeds), 1)
        self.assertEqual(embeds[0]['original_url'], self.category_url)
        
        embeds = self.oembed_client.extract_oembeds(self.category_url, resource_type='video')
        self.assertEqual(len(embeds), 0)
    
    def test_extract_oembeds_html(self):
        embeds = self.oembed_client.extract_oembeds_html('<p>%s</p>' % self.category_url)
        self.assertEqual(len(embeds), 1)
        self.assertEqual(embeds[0]['original_url'], self.category_url)
        
        embeds = self.oembed_client.extract_oembeds_html('<p>%s</p>' % self.category_url, resource_type='photo')
        self.assertEqual(len(embeds), 1)
        self.assertEqual(embeds[0]['original_url'], self.category_url)
        
        embeds = self.oembed_client.extract_oembeds_html('<p>%s</p>' % self.category_url, resource_type='video')
        self.assertEqual(len(embeds), 0)
        
        embeds = self.oembed_client.extract_oembeds_html('<p><a href="%s">Some link</a></p>' % self.category_url)
        self.assertEqual(len(embeds), 0)
        
        embeds = self.oembed_client.extract_oembeds_html('<p><a href="/some-link/">%s</a></p>' % self.category_url)
        self.assertEqual(len(embeds), 0)
    
    def test_strip(self):
        test_string = 'testing [%s] [http://www.google.com]' % self.category_url
        expected = 'testing [] [http://www.google.com]'
        
        self.assertEqual(self.oembed_client.strip(test_string), expected)
        
        # with width & height
        self.assertEqual(self.oembed_client.strip(test_string, 600, 400), expected)
        
        # with resource_type
        self.assertEqual(self.oembed_client.strip(test_string, resource_type='photo'), expected)
        self.assertEqual(self.oembed_client.strip(test_string, resource_type='link'), test_string)
    
    def test_strip_html(self):
        test_string = '<a href="%(match)s">%(match)s</a> <p>%(no_match)s</p>' % \
            {'match': self.category_url, 'no_match': 'http://www.google.com'}
        expected = test_string
        
        self.assertEqual(self.oembed_client.strip(test_string), expected)
    
    def test_strip_html_failure(self):
        # show how strip can fail when handling html - it picks up the match
        # in the p tag then replaces it everywhere, including in the a tags
        test_string = '<a href="%(match)s">%(match)s</a> <p>%(match)s</p> <p>%(no_match)s</p>' % \
            {'match': self.category_url, 'no_match': 'http://www.google.com'}
        expected = test_string
        actual = '<a href=""></a> <p></p> <p>http://www.google.com</p>'
        
        self.assertEqual(self.oembed_client.strip(test_string), actual)

########NEW FILE########
__FILENAME__ = models
import datetime

import oembed
from oembed.exceptions import OEmbedMissingEndpoint
from oembed.models import StoredOEmbed, StoredProvider, AggregateMedia
from oembed.providers import DjangoProvider
from oembed.tests.tests.base import BaseOEmbedTestCase

from oembed.tests.models import Blog, Category, Rich


class ModelTestCase(BaseOEmbedTestCase):
    def test_stored_oembeds(self):
        video = oembed.site.embed(self.youtube_url)
        stored = StoredOEmbed.objects.get(match=self.youtube_url)
        self.assertEqual(stored.response, video.get_data())
    
        photo = oembed.site.embed(self.flickr_url)
        stored = StoredOEmbed.objects.get(match=self.flickr_url)
        self.assertEqual(stored.response, photo.get_data())
        
        # now create some on-the-fly
        link = oembed.site.embed(self.blog_url)
        stored = StoredOEmbed.objects.get(match=self.blog_url)
        self.assertEqual(stored.response, link.get_data())

        photo = oembed.site.embed(self.category_url)
        stored = StoredOEmbed.objects.get(match=self.category_url)
        self.assertEqual(stored.response, photo.get_data())
        
        rich = oembed.site.embed(self.rich_url)
        stored = StoredOEmbed.objects.get(match=self.rich_url)
        self.assertEqual(stored.response, rich.get_data())
    
    def test_stored_providers(self):
        active = StoredProvider.objects.get(pk=100)
        inactive = StoredProvider.objects.get(pk=101)
        
        active_qs = StoredProvider.objects.active()
        self.assertTrue(active in active_qs)
        self.assertFalse(inactive in active_qs)
        
        provider_list = oembed.site.get_providers()
        self.assertTrue(active in provider_list)
        self.assertFalse(inactive in provider_list)
        
        active.active = False
        active.save()
        provider_list = oembed.site.get_providers()
        self.assertFalse(active in provider_list)

    def test_media_aggregation(self):
        r = Rich(name='Test', slug='test', content='Hey check this out: %s' % self.youtube_url)
        r.save()

        am_queryset = AggregateMedia.objects.all()
        self.assertEqual(am_queryset.count(), 1)

        aggregated_object = am_queryset[0]
        self.assertEqual(aggregated_object.url, self.youtube_url)
        self.assertEqual(aggregated_object.media, StoredOEmbed.objects.get(match=self.youtube_url))

        self.assertQuerysetEqual(r.media.all(), am_queryset)
        self.assertQuerysetEqual(r.videos.all(), am_queryset)
        self.assertQuerysetEqual(r.photos.all(), [])

        r.content = 'Whoa i changed my mind, you should check this out: %s' % self.flickr_url
        r.save()

        am_queryset = AggregateMedia.objects.all()

        # the youtube one sticks around, but records from the rel table are killed
        self.assertEqual(am_queryset.count(), 2)

        # the flickr embed is there
        aggregated_object = am_queryset.get(url=self.flickr_url)

        # check that the flickr aggregated object GFKs to the StoredOEmbed
        self.assertEqual(aggregated_object.media, StoredOEmbed.objects.get(match=self.flickr_url))

        # the m2m fields should all be cleared out now
        self.assertQuerysetEqual(r.media.all(), am_queryset.filter(url=self.flickr_url))
        self.assertQuerysetEqual(r.videos.all(), [])
        self.assertQuerysetEqual(r.photos.all(), am_queryset.filter(url=self.flickr_url))

        r.content = 'Just text please'
        r.save()

        self.assertQuerysetEqual(r.media.all(), [])
        self.assertQuerysetEqual(r.videos.all(), [])
        self.assertQuerysetEqual(r.photos.all(), [])

    def test_internal_media_aggregation(self):
        category1 = Category.objects.get(pk=1)
        
        r = Rich(name='Container', slug='container', content='Check this out: %s' % self.category_url)
        r.save()

        am_queryset = AggregateMedia.objects.all()
        self.assertEqual(am_queryset.count(), 1)

        aggregated_object = am_queryset[0]
        self.assertEqual(aggregated_object.url, self.category_url)
        self.assertEqual(aggregated_object.media, category1) # gfk to actual category

        self.assertQuerysetEqual(r.media.all(), am_queryset)
        self.assertQuerysetEqual(r.videos.all(), [])
        self.assertQuerysetEqual(r.photos.all(), am_queryset)

########NEW FILE########
__FILENAME__ = parsers
import oembed

from oembed.tests.tests.base import BaseOEmbedTestCase
from oembed.parsers.text import TextParser, TextBlockParser
from oembed.parsers.html import HTMLParser


class TextBlockParserTestCase(BaseOEmbedTestCase):
    def setUp(self):
        self.parser = TextBlockParser()
        super(TextBlockParserTestCase, self).setUp()
    
    def test_basic_handling(self):
        parsed = self.parser.parse(self.category_url)
        self.assertEqual(parsed, self.category_embed)
    
    def test_inline_link_handling(self):
        parsed = self.parser.parse('Testing %s' % self.category_url)
        self.assertEqual(parsed, 'Testing %s' % self.category_embed)
    
    def test_block_handling(self):
        parsed = self.parser.parse('Testing %(url)s\n%(url)s' % ({'url': self.category_url}))
        self.assertEqual(parsed, 'Testing %(embed)s\n%(embed)s' % ({'embed': self.category_embed}))
    
    def test_urlization(self):
        test_string = 'Testing http://www.google.com'
        parsed = self.parser.parse(test_string, urlize_all_links=False)
        self.assertEqual(parsed, test_string)
        
        parsed = self.parser.parse(test_string, urlize_all_links=True)
        self.assertEqual(parsed, 'Testing <a href="http://www.google.com">http://www.google.com</a>')
    
    def test_extraction(self):
        extracted = self.parser.extract_urls('Testing %s wha?' % self.category_url)
        self.assertEqual(extracted, [self.category_url])
    
    def test_extraction_ordering(self):
        extracted = self.parser.extract_urls('''
            %s %s %s
            %s
        ''' % (self.category_url, self.blog_url, self.category_url, self.rich_url))
        
        self.assertEqual(extracted, [
            self.category_url,
            self.blog_url,
            self.rich_url,
        ])


class TextParserTestCase(BaseOEmbedTestCase):
    def setUp(self):
        self.parser = TextParser()
        super(TextParserTestCase, self).setUp()
    
    def test_basic_handling(self):
        parsed = self.parser.parse(self.category_url)
        self.assertEqual(parsed, self.category_embed)
    
    def test_inline_link_handling(self):
        parsed = self.parser.parse('Testing %s' % self.category_url)
        self.assertEqual(parsed, 'Testing <a href="http://example.com/testapp/category/1/">Category 1</a>')
    
    def test_block_handling(self):
        parsed = self.parser.parse('Testing %(url)s\n%(url)s' % ({'url': self.category_url}))
        self.assertEqual(parsed, 'Testing <a href="http://example.com/testapp/category/1/">Category 1</a>\n%s' % self.category_embed)

    def test_extraction(self):
        extracted = self.parser.extract_urls('Testing %s wha?' % self.category_url)
        self.assertEqual(extracted, [self.category_url])
    
    def test_extraction_ordering(self):
        extracted = self.parser.extract_urls('''
            %s %s %s
            
            %s
        ''' % (self.category_url, self.blog_url, self.category_url, self.rich_url))
        
        self.assertEqual(extracted, [
            self.category_url,
            self.blog_url,
            self.rich_url,
        ])


class HTMLParserTestCase(BaseOEmbedTestCase):
    def setUp(self):
        self.parser = HTMLParser()
        super(HTMLParserTestCase, self).setUp()
    
    def test_basic_handling(self):
        parsed = self.parser.parse('<p>%s</p>' % self.category_url)
        self.assertEqual(parsed, '<p>%s</p>' % self.category_embed)
    
    def test_inline_link_handling(self):
        parsed = self.parser.parse('<p>Testing %s</p>' % self.category_url)
        self.assertEqual(parsed, '<p>Testing <a href="http://example.com/testapp/category/1/">Category 1</a></p>')
    
    def test_block_handling(self):
        parsed = self.parser.parse('<p>Testing %(url)s</p><p>%(url)s</p>' % ({'url': self.category_url}))
        self.assertEqual(parsed, '<p>Testing <a href="http://example.com/testapp/category/1/">Category 1</a></p><p>%s</p>' % self.category_embed)
    
    def test_buried_link(self):
        parsed = self.parser.parse('<p>Testing <a href="%(url)s"><span>%(url)s</span></a></p>' % ({'url': self.category_url}))
        self.assertEqual(parsed, '<p>Testing <a href="http://example.com/testapp/category/1/"><span>http://example.com/testapp/category/1/</span></a></p>')
    
    def test_outside_of_markup(self):
        parsed = self.parser.parse('%s<p>Wow this is bad</p>' % self.category_url)
        self.assertEqual(parsed, '%s<p>Wow this is bad</p>' % self.category_embed)

    def test_extraction(self):
        extracted = self.parser.extract_urls('<p>Testing %s wha?</p>' % self.category_url)
        self.assertEqual(extracted, [self.category_url])
        
        extracted = self.parser.extract_urls('<p>Testing <a href="%(url)s">%(url)s</a> wha?</p>' % ({'url': self.category_url}))
        self.assertEqual(extracted, [])
    
    def test_extraction_ordering(self):
        extracted = self.parser.extract_urls('''
            <p>%s</p> <p>%s</p>
            <a href="/">%s</a><!--rich url-->
            <a href="%s">yo</a><!--rich url-->
            <p>%s</p>
        ''' % (self.category_url, self.blog_url, self.rich_url, self.rich_url, self.flickr_url))
        
        self.assertEqual(extracted, [
            self.category_url,
            self.blog_url,
            self.flickr_url,
        ])

########NEW FILE########
__FILENAME__ = providers
import datetime
import re

try: 
    import Image
except ImportError:
    from PIL import Image
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

from django.contrib.sites.models import Site

import oembed
from oembed.providers import DjangoProvider, DjangoDateBasedProvider, DjangoProviderOptions
from oembed.consumer import OEmbedConsumer
from oembed.constants import OEMBED_ALLOWED_SIZES

from oembed.tests.models import Blog
from oembed.tests.oembed_providers import BlogProvider
from oembed.tests.tests.base import BaseOEmbedTestCase

class ProviderTestCase(BaseOEmbedTestCase):
    def test_resource_options(self):
        self.assertTrue(isinstance(BlogProvider._meta, DjangoProviderOptions))
        
        ops = BlogProvider._meta
        self.assertEqual(ops.model, Blog)
        self.assertEqual(ops.date_field, 'pub_date')
        self.assertEqual(ops.fields_to_match, {'entry_slug': 'slug'})
        self.assertEqual(ops.named_view, 'test_blog_detail')
    
    def test_meta_queryset_behavior(self):
        provider = BlogProvider()
        
        obj = provider.get_object('http://example.com/testapp/blog/2010/may/01/entry-1/')
        blog_obj = Blog.objects.get(slug='entry-1')
        self.assertEqual(obj, blog_obj)
        
        new_obj = Blog.objects.create(
            title='new entry',
            author='new author',
            pub_date=datetime.datetime(2010, 1, 1),
        )
        oembed_obj = provider.get_object('http://example.com/testapp/blog/2010/jan/01/new-entry/')
        
        self.assertEqual(new_obj, oembed_obj)
    
    def test_resource_object(self):
        provider = BlogProvider()
        resource = provider.request_resource('http://example.com/testapp/blog/2010/may/01/entry-1/')
        
        blog_obj = Blog.objects.get(slug='entry-1')
        self.assertEqual(blog_obj, resource.content_object)
    
    def test_django_provider(self):
        resource = oembed.site.embed(self.category_url)
        
        category_data = resource.get_data()
        
        # provider data is pulled from the sites table
        self.assertEqual(category_data['provider_url'], 'http://example.com')
        self.assertEqual(category_data['provider_name'], 'example.com')
        
        # resource data is pulled from the provider
        self.assertEqual(category_data['type'], 'photo')
        self.assertEqual(category_data['title'], 'Category 1')
        
        max_width, max_height = max(OEMBED_ALLOWED_SIZES)
        
        # image data
        self.assertTrue(category_data['width'] <= max_width)
        self.assertTrue(category_data['height'] <= max_height)
        
        w, h = category_data['width'], category_data['height']
        image_name = 'images/test_image1_%sx%s.jpg' % (w, h)
        
        self.assertEqual(category_data['url'], 'http://example.com/media/%s' % image_name)
        
        # just double check to be sure it got saved here
        self.assertTrue(image_name in self.storage._files)
        
        img_buf = StringIO(self.storage._files[image_name])
        img = Image.open(img_buf)
        img_width, img_height = img.size
        self.assertTrue(img_width == w or img_height == h)

        tw, th = category_data['thumbnail_width'], category_data['thumbnail_height']
        thumbnail_name = 'images/test_image1_%sx%s.jpg' % (tw, th)
        
        self.assertEqual(category_data['thumbnail_url'], 'http://example.com/media/%s' % thumbnail_name)
        
        self.assertTrue(thumbnail_name in self.storage._files)
        
        img_buf = StringIO(self.storage._files[thumbnail_name])
        img = Image.open(img_buf)
        img_width, img_height = img.size
        self.assertTrue(img_width == tw or img_height == th)
    
    def test_django_provider_image_sizing(self):
        resource = oembed.site.embed(self.category_url, maxwidth=450)
        
        category_data = resource.get_data()
        
        # provider data is pulled from the sites table
        self.assertEqual(category_data['width'], 400)
        w, h = category_data['width'], category_data['height']
        
        self.assertEqual(category_data['url'], 'http://example.com/media/images/test_image1_%sx%s.jpg' % (w, h))

        # specify both
        resource = oembed.site.embed(self.category_url, maxwidth=450, maxheight=200)
        
        category_data = resource.get_data()
        
        self.assertEqual(category_data['height'], 200)
        w, h = category_data['width'], category_data['height']
        
        self.assertEqual(category_data['url'], 'http://example.com/media/images/test_image1_%sx%s.jpg' % (w, h))

    def test_django_provider_url_match(self):
        # even though the sites table has example.com having no www., the regex
        # constructed should be able to correctly match the url below
        resource = oembed.site.embed('http://www.example.com/testapp/category/2/')
        
        category_data = resource.get_data()
        self.assertEqual(category_data['title'], 'Category 2')
        
        # try a https
        resource = oembed.site.embed('https://www.example.com/testapp/category/2/')
        
        category_data = resource.get_data()
        self.assertEqual(category_data['title'], 'Category 2')
    
    def test_django_datebased_provider(self):
        resource = oembed.site.embed(self.blog_url)
        
        blog_data = resource.get_data()
        
        # provider data is pulled from the sites table
        self.assertEqual(blog_data['provider_url'], 'http://example.com')
        self.assertEqual(blog_data['provider_name'], 'example.com')
        
        # resource data
        self.assertEqual(blog_data['type'], 'link')
        self.assertEqual(blog_data['title'], 'Entry 1')
        self.assertEqual(blog_data['url'], 'http://example.com/testapp/blog/2010/may/01/entry-1/')
        self.assertEqual(blog_data['author_name'], 'Charles')
    
    def test_django_rich_provider(self):
        resource = oembed.site.embed(self.rich_url)
        
        rich_data = resource.get_data()
        
        max_width, max_height = max(OEMBED_ALLOWED_SIZES)
        
        # image data
        self.assertTrue(rich_data['width'] <= max_width)
        self.assertTrue(rich_data['height'] <= max_height)
        
        self.assertEqual(rich_data['title'], 'Rich One')
        self.assertEqual(rich_data['html'], '<h1>Rich One</h1><p>This is rich one<br />Awesome!</p>\n')
    
    def test_meta_inheritance(self):
        class BaseTestProvider(DjangoProvider):
            class Meta:
                abstract = True
                test_attr = 'basetestprovider'
                image_processor = 'someimageprocessor'
        
        class BaseDateBasedProvider(BaseTestProvider, DjangoDateBasedProvider):
            class Meta:
                abstract = True
                test_attr = 'basedatebasedprovider'
        
        class BlogProviderMixin(DjangoProvider):
            class Meta:
                abstract = True
                year_part = 'blog_year'
                month_part = 'blog_month'
                day_part = 'blog_day'
        
        class BaseBlogProvider(BaseDateBasedProvider):
            resource_type = 'rich'
            
            class Meta:
                abstract = True
                model = Blog
                test_attr = 'baseblogprovider'
        
        class SomeBlogProvider(BaseBlogProvider):
            class Meta:
                named_view = 'test_blog_detail'
                fields_to_match = {'blog_id': 'id'}
                test_attr = 'someblogprovider'
        
        class MixinBlogProvider(BlogProviderMixin, BaseBlogProvider):
            class Meta:
                named_view = 'test_blog_detail'
                fields_to_match = {'blog_id': 'id'}
                test_attr = 'mixinblogprovider'
        
        ops = BaseTestProvider._meta
        self.assertTrue(ops.abstract)
        self.assertEqual(ops.test_attr, 'basetestprovider')
        self.assertEqual(ops.image_processor, 'someimageprocessor')
        
        ops = BaseDateBasedProvider._meta
        self.assertTrue(ops.abstract)
        self.assertEqual(ops.test_attr, 'basedatebasedprovider')
        self.assertEqual(ops.image_processor, 'someimageprocessor')
        
        ops = BaseBlogProvider._meta
        self.assertTrue(ops.abstract)
        self.assertEqual(ops.test_attr, 'baseblogprovider')
        self.assertEqual(ops.image_processor, 'someimageprocessor')
        self.assertEqual(ops.model, Blog)
        
        ops = SomeBlogProvider._meta
        self.assertFalse(ops.abstract)
        self.assertEqual(ops.test_attr, 'someblogprovider')
        self.assertEqual(ops.image_processor, 'someimageprocessor')
        self.assertEqual(ops.model, Blog)
        self.assertEqual(ops.fields_to_match, {'blog_id': 'id'})
        
        ops = MixinBlogProvider._meta
        self.assertFalse(ops.abstract)
        self.assertEqual(ops.test_attr, 'mixinblogprovider')
        self.assertEqual(ops.image_processor, 'someimageprocessor')
        self.assertEqual(ops.model, Blog)
        self.assertEqual(ops.fields_to_match, {'blog_id': 'id'})
        self.assertEqual(ops.year_part, 'blog_year')
        self.assertEqual(ops.month_part, 'blog_month')
        self.assertEqual(ops.day_part, 'blog_day')

########NEW FILE########
__FILENAME__ = resources
import oembed

from oembed.tests.tests.base import BaseOEmbedTestCase
from oembed.resources import OEmbedResource


class ResourceTestCase(BaseOEmbedTestCase):
    def test_json_handling(self):
        resource = oembed.site.embed(self.category_url)

        json = resource.json
        another_resource = OEmbedResource.create_json(json)

        self.assertEqual(resource.get_data(), another_resource.get_data())

########NEW FILE########
__FILENAME__ = sites
from django.utils import simplejson

import oembed
from oembed.exceptions import AlreadyRegistered, NotRegistered, OEmbedMissingEndpoint
from oembed.models import StoredProvider, StoredOEmbed
from oembed.resources import OEmbedResource
from oembed.tests.oembed_providers import BlogProvider
from oembed.tests.tests.base import BaseOEmbedTestCase


class ProviderSiteTestCase(BaseOEmbedTestCase):
    def test_register(self):
        oembed.site.unregister(BlogProvider)
        self.assertRaises(NotRegistered, oembed.site.unregister, BlogProvider)
        
        oembed.site.register(BlogProvider)
        self.assertRaises(AlreadyRegistered, oembed.site.register, BlogProvider)
    
    def test_get_provider(self):
        oembed.site.unregister(BlogProvider)
        self.assertRaises(OEmbedMissingEndpoint, oembed.site.provider_for_url, self.blog_url)
        
        oembed.site.register(BlogProvider)
        provider = oembed.site.provider_for_url(self.blog_url)
        self.assertTrue(isinstance(provider, BlogProvider))
    
    def test_embed(self):
        oembed.site.unregister(BlogProvider)
        self.assertRaises(OEmbedMissingEndpoint, oembed.site.embed, self.blog_url)
        
        oembed.site.register(BlogProvider)
        resource = oembed.site.embed(self.blog_url)
        
        self.assertTrue(isinstance(resource, OEmbedResource))
    
    def test_object_caching(self):
        StoredOEmbed.objects.all().delete()
        
        for i in range(3):
            resource = oembed.site.embed(self.blog_url)
            self.assertEqual(StoredOEmbed.objects.count(), 1)
        
        for i in range(3):
            resource = oembed.site.embed(self.blog_url, maxwidth=400, maxheight=400)
            self.assertEqual(StoredOEmbed.objects.count(), 2)
        
        for i in range(3):
            resource = oembed.site.embed(self.blog_url, maxwidth=400)
            self.assertEqual(StoredOEmbed.objects.count(), 3)
    
    def test_autodiscovery(self):
        resp = self.client.get('/oembed/')
        json = simplejson.loads(resp.content)
        
        providers = oembed.site.store_providers(json)
        self.assertEqual(len(providers), 3)
        
        blog_provider, category_provider, rich_provider = providers
        
        self.assertEqual(blog_provider.wildcard_regex, 'http://example.com/testapp/blog/*/*/*/*/')
        self.assertEqual(blog_provider.regex, 'http://example.com/testapp/blog/.+?/.+?/.+?/.+?/')
        self.assertEqual(blog_provider.resource_type, 'link')
        self.assertEqual(blog_provider.endpoint_url, 'http://example.com/oembed/json/')
        
        self.assertEqual(category_provider.wildcard_regex, 'http://example.com/testapp/category/*/')
        self.assertEqual(category_provider.regex, 'http://example.com/testapp/category/.+?/')
        self.assertEqual(category_provider.resource_type, 'photo')
        self.assertEqual(category_provider.endpoint_url, 'http://example.com/oembed/json/')
        
        self.assertEqual(rich_provider.wildcard_regex, 'http://example.com/testapp/rich/*/')
        self.assertEqual(rich_provider.regex, 'http://example.com/testapp/rich/.+?/')
        self.assertEqual(rich_provider.resource_type, 'rich')
        self.assertEqual(rich_provider.endpoint_url, 'http://example.com/oembed/json/')

########NEW FILE########
__FILENAME__ = templatetags
from django.template import Context, Template

import oembed
from oembed.models import StoredOEmbed
from oembed.tests.models import Category

from oembed.tests.tests.base import BaseOEmbedTestCase

class OEmbedTemplateTagTestCase(BaseOEmbedTestCase):
    template_string = '{% load oembed_tags %}{% oembed %}XXX{% endoembed %}'
    
    def test_oembed_tag(self):
        t = Template(self.template_string.replace('XXX', self.category_url))
        c = Context()
        result = t.render(c)
        self.assertEqual(result, self.category_embed)
        
        t = Template(self.template_string.replace('XXX', 'http://www.google.com/'))
        c = Context()
        result = t.render(c)
        self.assertEqual('<a href="%(LINK)s">%(LINK)s</a>' % {'LINK': 'http://www.google.com/'}, result)
    
    def test_oembed_filter(self):
        t = Template('{% load oembed_tags %}{{ test_string|oembed }}')
        c = Context({'test_string': self.category_url})
        result = t.render(c)
        self.assertEqual(result, self.category_embed)
        
        c = Context({'test_string': 'http://www.google.com/'})
        result = t.render(c)
        self.assertEqual('<a href="%(LINK)s">%(LINK)s</a>' % {'LINK': 'http://www.google.com/'}, result)
        
    def test_extract_filter(self):
        t = Template('{% load oembed_tags %}{% for embed in test_string|extract_oembeds %}{{ embed.original_url }}{% endfor %}')
        c = Context({'test_string': self.category_url})
        result = t.render(c)
        self.assertEqual(result, self.category_url)
        
        t = Template('{% load oembed_tags %}{% for embed in test_string|extract_oembeds:"photo" %}{{ embed.original_url }}{% endfor %}')
        c = Context({'test_string': self.category_url + ' ' + self.blog_url})
        result = t.render(c)
        self.assertEqual(result, self.category_url)
        
        t = Template('{% load oembed_tags %}{% for embed in test_string|extract_oembeds:"link" %}{{ embed.original_url }}{% endfor %}')
        c = Context({'test_string': self.category_url + ' ' + self.blog_url})
        result = t.render(c)
        self.assertEqual(result, self.blog_url)
    
    def test_strip_filter(self):
        t = Template('{% load oembed_tags %}{{ test_string|strip_oembeds }}')
        c = Context({'test_string': 'testing [%s]' % self.category_url})
        result = t.render(c)
        self.assertEqual(result, 'testing []')
        
        t = Template('{% load oembed_tags %}{{ test_string|strip_oembeds:"photo" }}')
        c = Context({'test_string': 'testing [%s]' % self.category_url})
        result = t.render(c)
        self.assertEqual(result, 'testing []')
        
        t = Template('{% load oembed_tags %}{{ test_string|strip_oembeds:"link" }}')
        c = Context({'test_string': 'testing [%s]' % self.category_url})
        result = t.render(c)
        self.assertEqual(result, c['test_string'])
    
    def test_autodiscover(self):
        t = Template('{% load oembed_tags %}{% oembed_autodiscover obj %}')
        c = Context({'obj': Category.objects.get(pk=1)})
        result = t.render(c)
        self.assertEqual(result, '<link rel="alternate" type="application/json+oembed" href="http://example.com/oembed/json/?url=http%3A%2F%2Fexample.com%2Ftestapp%2Fcategory%2F1%2F&format=json" />')

    def test_scheme(self):
        t = Template('{% load oembed_tags %}{% oembed_url_scheme %}')
        c = Context()
        result = t.render(c)
        self.assertEqual(result, '<link rel="alternate" type="application/json+oembed+scheme" href="http://example.com/oembed/" title="example.com OEmbed Scheme" />')

########NEW FILE########
__FILENAME__ = utils
from django.contrib.sites.models import Site

from oembed.tests.tests.base import BaseOEmbedTestCase
from oembed.utils import size_to_nearest, relative_to_full, load_class, cleaned_sites, scale

class OEmbedUtilsTestCase(BaseOEmbedTestCase):
    def test_size_to_nearest(self):
        sizes = ((100, 100), (200, 200), (300, 300))

        self.assertEqual((300, 200), size_to_nearest(400, 200, sizes, False))
        self.assertEqual((100, 100), size_to_nearest(100, 100, sizes, False))
        self.assertEqual((200, 300), size_to_nearest(250, 500, sizes, False))
        
        # if force_fit is False then jump to the largest on None
        self.assertEqual((100, 300), size_to_nearest(150, None, sizes, False))
        self.assertEqual((300, 100), size_to_nearest(None, 150, sizes, False))

        # if force_fit is True then scale to the nearest size for the one
        # that is defined
        self.assertEqual((100, 100), size_to_nearest(150, None, sizes, True))
        self.assertEqual((100, 100), size_to_nearest(None, 150, sizes, True))
        self.assertEqual((200, 200), size_to_nearest(220, None, sizes, True))
        self.assertEqual((200, 200), size_to_nearest(None, 220, sizes, True))


        # if both dimensions are None use the largest possible
        self.assertEqual((300, 300), size_to_nearest(None, None, sizes, False))
        self.assertEqual((300, 300), size_to_nearest(None, None, sizes, True))

        # if a dimension is too small scale it up to the minimum
        self.assertEqual((100, 300), size_to_nearest(50, 300, sizes, False))
        self.assertEqual((100, 100), size_to_nearest(50, 300, sizes, True))
        self.assertEqual((100, 300), size_to_nearest(50, None, sizes, False))
        self.assertEqual((100, 100), size_to_nearest(50, None, sizes, True))

        # test when things are too large
        self.assertEqual((200, 200), size_to_nearest(400, 200, sizes, True))
        self.assertEqual((100, 100), size_to_nearest(100, 100, sizes, True))
        self.assertEqual((200, 200), size_to_nearest(250, 500, sizes, True))
        
        # test Nones around the edges
        self.assertEqual((100, 100), size_to_nearest(100, None, sizes, True))
        self.assertEqual((100, 100), size_to_nearest(None, 100, sizes, True))
        
    def test_size_to_nearest_defaults(self):
        self.assertEqual((800, 600), size_to_nearest(800, 600))
        self.assertEqual((800, 600), size_to_nearest(850, 650))

        self.assertEqual((800, 300), size_to_nearest(None, 350))
        self.assertEqual((400, 800), size_to_nearest(450, None))

        self.assertEqual((800, 300), size_to_nearest(None, 350))
        self.assertEqual((400, 800), size_to_nearest(450, None))
        
        self.assertEqual((200, 200), size_to_nearest(400, 250, force_fit=True))

    def test_relative_to_full(self):
        self.assertEqual('http://test.com/a/b/', relative_to_full('/a/b/', 'http://test.com'))
        self.assertEqual('http://test.com/a/b/', relative_to_full('/a/b/', 'http://test.com/c/d/?cruft'))
        self.assertEqual('http://test.com/a/b/', relative_to_full('http://test.com/a/b/', 'http://test.com'))
        self.assertEqual('http://blah.com/a/b/', relative_to_full('http://blah.com/a/b/', 'http://test.com'))
        self.assertEqual('/a/b/', relative_to_full('/a/b/', ''))
    
    def test_load_class(self):
        parser_class = load_class('oembed.parsers.html.HTMLParser')
        self.assertEqual(parser_class.__name__, 'HTMLParser')
        self.assertEqual(parser_class.__module__, 'oembed.parsers.html')
    
    def test_cleaned_sites(self):
        sites = Site.objects.all()
        cleaned = cleaned_sites()
        example = cleaned[1] # example site
        self.assertEquals(example[1], 'example.com')
        self.assertEquals(example[2], 'http://example.com')
        self.assertEquals(example[0], 'https?:\/\/(?:www[^\.]*\.)?example.com')
        
        www2_site = Site.objects.create(name='Test Site', domain='www2.testsite.com')
        mobile_site = Site.objects.create(name='Mobile Site', domain='m.testsite.com')
        
        cleaned = cleaned_sites()
        self.assertEquals(cleaned[www2_site.pk][1], 'Test Site')
        self.assertEquals(cleaned[www2_site.pk][2], 'http://www2.testsite.com')
        self.assertEquals(cleaned[www2_site.pk][0], 'https?:\/\/(?:www[^\.]*\.)?testsite.com')
        
        self.assertEquals(cleaned[mobile_site.pk][1], 'Mobile Site')
        self.assertEquals(cleaned[mobile_site.pk][2], 'http://m.testsite.com')
        self.assertEquals(cleaned[mobile_site.pk][0], 'https?:\/\/(?:www[^\.]*\.)?m.testsite.com')
    
    def test_scale(self):
        self.assertEqual(scale(640, 480, 320), (320, 240))
        self.assertEqual(scale(640, 480, 500, 240), (320, 240))
        self.assertEqual(scale(640, 480, 320, 500), (320, 240))
        self.assertEqual(scale(640, 480, 320, 240), (320, 240))
        
        self.assertEqual(scale(640, 480, 700), (640, 480))
        self.assertEqual(scale(640, 480, 700, 500), (640, 480))

########NEW FILE########
__FILENAME__ = views
from django.conf import settings
from django.core.urlresolvers import reverse
from django.utils import simplejson

import oembed
from oembed.models import StoredOEmbed, StoredProvider
from oembed.tests.tests.base import BaseOEmbedTestCase

class OEmbedViewTestCase(BaseOEmbedTestCase):
    def test_missing_endpoint(self):
        response = self.client.get('/oembed/json/?url=http://www.nothere.com/asdf/')
        self.assertEqual(response.status_code, 404)
    
    def test_bad_request(self):
        # no url provided raises bad request (400)
        response = self.client.get('/oembed/json/')
        self.assertEqual(response.status_code, 400)
    
    def test_basic_handling(self):
        response = self.client.get('/oembed/json/?url=%s' % self.category_url)
        self.assertEqual(response.status_code, 200)
        response_json = simplejson.loads(response.content)
        
        stored_oembed = StoredOEmbed.objects.get(match=self.category_url)
        self.assertEqual(response_json, stored_oembed.response)
        
    def test_stored_provider_signals(self):
        response = self.client.get('/oembed/json/?url=%s' % self.youtube_url)
        
        # Check some response details - this provider doesn't provide upstream
        self.assertEqual(response.status_code, 404)
        
        # re-register the youtube provider to provide upstream
        yt = StoredProvider.objects.get(endpoint_url='http://www.youtube.com/oembed')
        yt.provides = True
        yt.save()
        
        # now we should be able to get the youtube object through the endpoint
        response = self.client.get('/oembed/json/?url=%s' % self.youtube_url)
        self.assertEqual(response.status_code, 200)
        
        stored = StoredOEmbed.objects.get(match=self.youtube_url)
        self.assertEqual(simplejson.loads(response.content), stored.response)
    
    def test_oembed_schema(self):
        response = self.client.get('/oembed/')
        self.assertEqual(response.status_code, 200)
        
        json_data = simplejson.loads(response.content)
        self.assertEqual(json_data, [
            {
                "matches": "http://example.com/testapp/blog/*/*/*/*/",
                "endpoint": "/oembed/json/",
                "type": "link"
            },
            {
                "matches": "http://example.com/testapp/category/*/",
                "endpoint": "/oembed/json/",
                "type": "photo"
            },
            {
                "matches": "http://example.com/testapp/rich/*/",
                "endpoint": "/oembed/json/",
                "type": "rich"
            }
        ])
        
        stored_provider = StoredProvider.objects.get(pk=100)
        stored_provider.provides = True
        stored_provider.save()
        
        expected = {
            'matches': 'http://www.active.com/*',
            'endpoint': '/oembed/json/',
            'type': 'photo'
        }
        
        response = self.client.get('/oembed/')
        self.assertEqual(response.status_code, 200)
        
        json_data = simplejson.loads(response.content)
        self.assertTrue(expected in json_data)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.contrib import admin

admin.autodiscover()

def null_view(*args, **kwargs):
    pass

urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^oembed/', include('oembed.urls')),
    url(r'^testapp/blog/(?P<year>\d+)/(?P<month>\w+)/(?P<day>\d+)/(?P<entry_slug>[\w-]+)/$', null_view, name='test_blog_detail'),
    url(r'^testapp/rich/([a-z-]+)/$', null_view, name='test_rich_detail'),
    url(r'^testapp/category/(\d+)/$', null_view, name='test_category_detail'),
)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from django.conf.urls.defaults import *

urlpatterns = patterns('oembed.views',
    url(r'^$', 'oembed_schema', name='oembed_schema'),
    url(r'^json/$', 'json', name='oembed_json'),
    url(r'^consume/json/$', 'consume_json', name='oembed_consume_json'),
)

########NEW FILE########
__FILENAME__ = utils
import httplib2
import re

from django.conf import settings
from django.contrib.sites.models import Site
from django.http import HttpRequest
from django.utils.importlib import import_module

from oembed.constants import DOMAIN_RE, OEMBED_ALLOWED_SIZES, SOCKET_TIMEOUT
from oembed.exceptions import OEmbedHTTPException


def size_to_nearest(width=None, height=None, allowed_sizes=OEMBED_ALLOWED_SIZES,
                    force_fit=False):
    """
    Generate some dimensions for resizing an object.  This function DOES NOT handle
    scaling, it simply calculates maximums.  These values should then be passed to
    the resize() method which will scale it and return the scaled width & height.
    """
    minwidth, minheight = min(allowed_sizes)
    maxwidth, maxheight = max(allowed_sizes)

    if not width and not height:
        return maxwidth, maxheight

    if width:
        width = int(width) > minwidth and int(width) or minwidth
    elif force_fit:
        width = maxwidth

    if height:
        height = int(height) > minheight and int(height) or minheight
    elif force_fit:
        height = maxheight

    for size in sorted(allowed_sizes):
        if width and not height:
            if width >= size[0]:
                maxwidth = size[0]
                if force_fit:
                    maxheight = size[1]
            else:
                break
        elif height and not width:
            if height >= size[1]:
                maxheight = size[1]
                if force_fit:
                    maxwidth = size[0]
            else:
                break
        else:
            if force_fit:
                if (width >= size[0]) and (height >= size[1]):
                    maxwidth, maxheight = size
                else:
                    break
            else:
                if width >= size[0]:
                    maxwidth = size[0]
                if height >= size[1]:
                    maxheight = size[1]
    return maxwidth, maxheight

def scale(width, height, new_width, new_height=None):
    # determine if resizing needs to be done (will not scale up)
    if width < new_width:
        if not new_height or height < new_height:
            return (width, height)
    
    # calculate ratios
    width_percent = (new_width / float(width))
    if new_height:
        height_percent = (new_height / float(height))
    
    if not new_height or width_percent < height_percent:
        new_height = int((float(height) * float(width_percent)))
    else:
        new_width = int((float(width) * float(height_percent)))
    
    return (new_width, new_height)

def fetch_url(url, method='GET', user_agent='django-oembed', timeout=SOCKET_TIMEOUT):
    """
    Fetch response headers and data from a URL, raising a generic exception
    for any kind of failure.
    """
    sock = httplib2.Http(timeout=timeout)
    request_headers = {
        'User-Agent': user_agent,
        'Accept-Encoding': 'gzip'}
    try:
        headers, raw = sock.request(url, headers=request_headers, method=method)
    except:
        raise OEmbedHTTPException('Error fetching %s' % url)
    return headers, raw

def get_domain(url):
    match = re.search(DOMAIN_RE, url)
    if match:
        return match.group()
    return ''

def relative_to_full(url, example_url):
    """
    Given a url which may or may not be a relative url, convert it to a full
    url path given another full url as an example
    """
    if re.match('https?:\/\/', url):
        return url
    domain = get_domain(example_url)
    if domain:
        return '%s%s' % (domain, url)
    return url

def mock_request():
    """
    Generate a fake request object to allow oEmbeds to use context processors.
    """
    current_site = Site.objects.get_current()
    request = HttpRequest()
    request.META['SERVER_NAME'] = current_site.domain
    return request

def load_class(path):
    """
    dynamically load a class given a string of the format
    
    package.Class
    """
    package, klass = path.rsplit('.', 1)
    module = import_module(package)
    return getattr(module, klass)

def cleaned_sites():
    """
    Create a list of tuples mapping domains from the sites table to their
    site name.  The domains will be cleaned into regexes that may be
    more permissive than the site domain is in the db.
    
    [(domain_regex, domain_name, domain_string), ...]
    """
    mappings = {}
    for site in Site.objects.all():
        # match the site domain, breaking it into several pieces
        match = re.match(r'(https?://)?(www[^\.]*\.)?([^/]+)', site.domain)
        
        if match is not None:
            http, www, domain = match.groups()
            
            # if the protocol is specified, use it, otherwise accept 80/443
            http_re = http or r'https?:\/\/'
            
            # whether or not there's a www (or www2 :x) allow it in the match
            www_re = r'(?:www[^\.]*\.)?'
            
            # build a regex of the permissive http re, the www re, and the domain
            domain_re = http_re + www_re + domain
            
            # now build a pretty string representation of the domain
            http = http or r'http://'
            www = www or ''
            normalized = http + www + domain
            
            mappings[site.pk] = (domain_re, site.name, normalized)
    return mappings

########NEW FILE########
__FILENAME__ = views
import re

from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse, get_resolver
from django.http import HttpResponse, HttpResponseBadRequest, Http404
from django.template import defaultfilters, RequestContext
from django.utils import simplejson
from django.utils.encoding import smart_str

import oembed
from oembed.consumer import OEmbedConsumer
from oembed.exceptions import OEmbedException, OEmbedMissingEndpoint
from oembed.providers import DjangoProvider, HTTPProvider


resolver = get_resolver(None)


def json(request, *args, **kwargs):
    """
    The oembed endpoint, or the url to which requests for metadata are passed.
    Third parties will want to access this view with URLs for your site's
    content and be returned OEmbed metadata.
    """
    # coerce to dictionary
    params = dict(request.GET.items())
    
    callback = params.pop('callback', None)
    url = params.pop('url', None)
    
    if not url:
        return HttpResponseBadRequest('Required parameter missing: URL')
    
    try:
        provider = oembed.site.provider_for_url(url)
        if not provider.provides:
            raise OEmbedMissingEndpoint()
    except OEmbedMissingEndpoint:
        raise Http404('No provider found for %s' % url)
    
    query = dict([(smart_str(k), smart_str(v)) for k, v in params.items() if v])
    
    try:
        resource = oembed.site.embed(url, **query)
    except OEmbedException, e:
        raise Http404('Error embedding %s: %s' % (url, str(e)))

    response = HttpResponse(mimetype='application/json')
    json = resource.json
    
    if callback:
        response.write('%s(%s)' % (defaultfilters.force_escape(callback), json))
    else:
        response.write(json)
    
    return response


def consume_json(request):
    """
    Extract and return oembed content for given urls.

    Required GET params:
        urls - list of urls to consume

    Optional GET params:
        width - maxwidth attribute for oembed content
        height - maxheight attribute for oembed content
        template_dir - template_dir to use when rendering oembed

    Returns:
        list of dictionaries with oembed metadata and renderings, json encoded
    """
    client = OEmbedConsumer()
    
    urls = request.GET.getlist('urls')
    width = request.GET.get('width')
    height = request.GET.get('height')
    template_dir = request.GET.get('template_dir')

    output = {}
    ctx = RequestContext(request)

    for url in urls:
        try:
            provider = oembed.site.provider_for_url(url)
        except OEmbedMissingEndpoint:
            oembeds = None
            rendered = None
        else:
            oembeds = url
            rendered = client.parse_text(url, width, height, context=ctx, template_dir=template_dir)

        output[url] = {
            'oembeds': oembeds,
            'rendered': rendered,
        }

    return HttpResponse(simplejson.dumps(output), mimetype='application/json')

def oembed_schema(request):
    """
    A site profile detailing valid endpoints for a given domain.  Allows for
    better auto-discovery of embeddable content.

    OEmbed-able content lives at a URL that maps to a provider.
    """
    current_domain = Site.objects.get_current().domain
    url_schemes = [] # a list of dictionaries for all the urls we can match
    endpoint = reverse('oembed_json') # the public endpoint for our oembeds
    providers = oembed.site.get_providers()

    for provider in providers:
        # first make sure this provider class is exposed at the public endpoint
        if not provider.provides:
            continue
        
        match = None
        if isinstance(provider, DjangoProvider):
            # django providers define their regex_list by using urlreversing
            url_pattern = resolver.reverse_dict.get(provider._meta.named_view)

            # this regex replacement is set to be non-greedy, which results
            # in things like /news/*/*/*/*/ -- this is more explicit
            if url_pattern:
                regex = re.sub(r'%\(.+?\)s', '*', url_pattern[0][0][0])
                match = 'http://%s/%s' % (current_domain, regex)
        elif isinstance(provider, HTTPProvider):
            match = provider.url_scheme
        else:
            match = provider.regex

        if match:
            url_schemes.append({
                'type': provider.resource_type,
                'matches': match,
                'endpoint': endpoint
            })
    
    url_schemes.sort(key=lambda item: item['matches'])
    
    response = HttpResponse(mimetype='application/json')
    response.write(simplejson.dumps(url_schemes))
    return response

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import sys

from os.path import dirname, abspath

from django.conf import settings

if not settings.configured:
    settings.configure(
        DATABASE_ENGINE='sqlite3',
        ROOT_URLCONF='oembed.tests.urls',
        SITE_ID=1,
        INSTALLED_APPS=[
            'django.contrib.auth',
            'django.contrib.admin',
            'django.contrib.contenttypes',
            'django.contrib.sessions',
            'django.contrib.sites',
            'oembed.tests',
            'oembed',
        ]
    )

from django.test.simple import run_tests


def runtests(*test_args):
    if not test_args:
        test_args = ['oembed']
    parent = dirname(abspath(__file__))
    sys.path.insert(0, parent)
    failures = run_tests(test_args, verbosity=1, interactive=True)
    sys.exit(failures)


if __name__ == '__main__':
    runtests(*sys.argv[1:])

########NEW FILE########
