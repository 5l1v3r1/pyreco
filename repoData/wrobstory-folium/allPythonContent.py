__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Folium documentation build configuration file, created by
# sphinx-quickstart on Sun May 19 19:39:34 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Folium'
copyright = u'2013, Rob Story'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1.2'
# The full version, including alpha/beta/rc tags.
release = '0.1.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'f6'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Foliumdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Folium.tex', u'Folium Documentation',
   u'Rob Story', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'folium', u'Folium Documentation',
     [u'Rob Story'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Folium', u'Folium Documentation',
   u'Rob Story', 'Folium', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = antarctic_shelf
'''
Map the Antarctic Ice Shelf, with normal GeoJSON and TopoJSON

'''

import folium


geo_path = r'data/antarctic_ice_edge.json'
topo_path = r'data/antarctic_ice_shelf_topo.json'

ice_map = folium.Map(location=[-59.1759, -11.6016],
                     tiles='Mapbox Bright', zoom_start=2)
ice_map.geo_json(geo_path=geo_path)
ice_map.geo_json(geo_path=topo_path, topojson='objects.antarctic_ice_shelf')
ice_map.create_map()

########NEW FILE########
__FILENAME__ = base_map
# -*- coding: utf-8 -*-
'''Test of Folium basic map'''

import folium

#Standard OSM
map_osm = folium.Map(location=[45.5236, -122.6750])
map_osm.create_map(path='osm.html')

#Stamen Toner
stamen = folium.Map(location=[45.5236, -122.6750], tiles='Stamen Toner',
                    zoom_start=13)
stamen.create_map(path='stamen_toner.html')

########NEW FILE########
__FILENAME__ = choropleth_counties
'''
Choropleth maps of US counties.

GeoJSON via the US Census and Eric Celeste: http://eric.clst.org/Stuff/USGeoJSON

'''

import folium
import pandas as pd

county_data = r'us_county_data.csv'
county_geo = r'us_counties_20m_topo.json'

#Read into Dataframe, cast to string for consistency
df = pd.read_csv(county_data, na_values=[' '])
df['FIPS_Code'] = df['FIPS_Code'].astype(str)


def set_id(fips):
    '''Modify FIPS code to match GeoJSON property'''
    if fips == '0':
        return None
    elif len(fips) <= 4:
        return ''.join(['0500000US0', fips])
    else:
        return ''.join(['0500000US', fips])

#Apply set_id, drop NaN
df['GEO_ID'] = df['FIPS_Code'].apply(set_id)
df = df.dropna()

#Number of employed with auto scale
map_1 = folium.Map(location=[48, -102], zoom_start=3)
map_1.geo_json(geo_path=county_geo, data_out='data1.json', data=df,
               columns=['GEO_ID', 'Employed_2011'],
               key_on='feature.id',
               fill_color='YlOrRd', fill_opacity=0.7, line_opacity=0.3,
               topojson='objects.us_counties_20m')
map_1.create_map(path='map_1.html')

#Unemployment with custom defined scale
map_2 = folium.Map(location=[40, -99], zoom_start=4)
map_2.geo_json(geo_path=county_geo, data_out='data2.json', data=df,
               columns=['GEO_ID', 'Unemployment_rate_2011'],
               key_on='feature.id',
               threshold_scale=[0, 5, 7, 9, 11, 13],
               fill_color='YlGnBu', line_opacity=0.3,
               legend_name='Unemployment Rate 2011 (%)',
               topojson='objects.us_counties_20m')
map_2.create_map(path='map_2.html')

#Median Household income
map_3 = folium.Map(location=[40, -99], zoom_start=4)
map_3.geo_json(geo_path=county_geo, data_out='data3.json', data=df,
               columns=['GEO_ID', 'Median_Household_Income_2011'],
               key_on='feature.id',
               fill_color='PuRd', line_opacity=0.3,
               legend_name='Median Household Income 2011 ($)',
               topojson='objects.us_counties_20m')
map_3.create_map(path='map_3.html')

########NEW FILE########
__FILENAME__ = choropleth_states
'''
Choropleth map of US states

'''

import folium
import pandas as pd

state_geo = r'us-states.json'
state_unemployment = r'US_Unemployment_Oct2012.csv'

state_data = pd.read_csv(state_unemployment)

#Let Folium determine the scale
states = folium.Map(location=[48, -102], zoom_start=3)
states.geo_json(geo_path=state_geo, data=state_data,
                columns=['State', 'Unemployment'],
                key_on='feature.id',
                fill_color='YlGn', fill_opacity=0.7, line_opacity=0.2,
                legend_name='Unemployment Rate (%)')
states.create_map(path='us_state_map.html')

#Let's define our own scale and change the line opacity
states2 = folium.Map(location=[48, -102], zoom_start=3)
states2.geo_json(geo_path=state_geo, data=state_data,
                 columns=['State', 'Unemployment'],
                 threshold_scale=[5, 6, 7, 8, 9, 10],
                 key_on='feature.id',
                 fill_color='BuPu', fill_opacity=0.7, line_opacity=0.5,
                 legend_name='Unemployment Rate (%)',
                 reset=True)
states2.create_map(path='us_state_map_2.html')

########NEW FILE########
__FILENAME__ = folium_vincent_markers
# -*- coding: utf-8 -*-
'''Folium Vincent plotting'''

import pandas as pd
import vincent
import folium

NOAA_46041 = pd.read_csv(r'NOAA_46041.csv', index_col=3,
                         parse_dates=True)
NOAA_46050 = pd.read_csv(r'NOAA_46050_WS.csv', index_col=3,
                         parse_dates=True)
NOAA_46243 = pd.read_csv(r'NOAA_46243.csv', index_col=3,
                         parse_dates=True)

NOAA_46041 = NOAA_46041.dropna()

#Binned wind speeds for NOAA 46050
bins = range(0, 13, 1)
cuts = pd.cut(NOAA_46050['wind_speed_cwind (m/s)'], bins)
ws_binned = pd.value_counts(cuts).reindex(cuts.levels)

#NOAA 46401 Wave Period
vis1 = vincent.Line(NOAA_46041['dominant_wave_period (s)'],
                    width=400, height=200)
vis1.axis_titles(x='Time', y='Dominant Wave Period (s)')
vis1.to_json('vis1.json')

#NOAA 46050 Binned Wind Speed
vis2 = vincent.Bar(ws_binned, width=400, height=200)
vis2.axis_titles(x='Wind Speed (m/s)', y='# of Obs')
vis2.to_json('vis2.json')

#NOAA 46243 Wave Height
vis3 = vincent.Area(NOAA_46243['significant_wave_height (m)'],
                    width=400, height=200)
vis3.axis_titles(x='Time', y='Significant Wave Height (m)')
vis3.to_json('vis3.json')

#Map all buoys
buoy_map = folium.Map(location=[46.3014, -123.7390], zoom_start=7,
                      tiles='Stamen Terrain')
buoy_map.polygon_marker(location=[47.3489, -124.708], fill_color='#43d9de',
                        radius=12, popup=(vis1, 'vis1.json'))
buoy_map.polygon_marker(location=[44.639, -124.5339], fill_color='#43d9de',
                        radius=12, popup=(vis2, 'vis2.json'))
buoy_map.polygon_marker(location=[46.216, -124.1280], fill_color='#43d9de',
                        radius=12, popup=(vis3, 'vis3.json'))
buoy_map.create_map(path='NOAA_buoys.html')

########NEW FILE########
__FILENAME__ = line_example
# -*- coding: utf-8 -*-
'''Test of Folium polylines'''

import folium

# Coordinates are 15 points on the great circle from Boston to 
# San Francisco.
# Reference: http://williams.best.vwh.net/avform.htm#Intermediate
coordinates = [
    [  42.3581    ,  -71.0636    ],
    [  42.82995815,  -74.78991444],
    [  43.17929819,  -78.56603306],
    [  43.40320216,  -82.37774519],
    [  43.49975489,  -86.20965845],
    [  43.46811941,  -90.04569087],
    [  43.30857071,  -93.86961818],
    [  43.02248456,  -97.66563267],
    [  42.61228259, -101.41886832],
    [  42.08133868, -105.11585198],
    [  41.4338549 , -108.74485069],
    [  40.67471747, -112.29609954],
    [  39.8093434 , -115.76190821],
    [  38.84352776, -119.13665678],
    [  37.7833    , -122.4167    ]]


# Create the map and add the line
m = folium.Map(location=[41.9, -97.3], zoom_start=4)
m.line(coordinates, line_color='#FF0000', line_weight=5)

m.create_map(path='line_example.html')

########NEW FILE########
__FILENAME__ = markers
# -*- coding: utf-8 -*-
'''Test of Folium basic markers'''

import folium

#Simple Markers with Stamen Terrain
map_1 = folium.Map(location=[45.372, -121.6972], zoom_start=12,
                   tiles='Stamen Terrain')
map_1.simple_marker([45.3288, -121.6625], popup='Mt. Hood Meadows')
map_1.simple_marker([45.3311, -121.7113], popup='Timberline Lodge')
map_1.create_map(path='mthood.html')

#Circle Markers with Stamen Toner
map_2 = folium.Map(location=[45.5236, -122.6750], tiles='Stamen Toner',
                   zoom_start=13)
map_2.simple_marker(location=[45.5244, -122.6699], popup='The Waterfront')
map_2.circle_marker(location=[45.5215, -122.6261], radius=500,
                    popup='Laurelhurst Park', line_color='#3186cc',
                    fill_color='#3186cc')
map_2.create_map(path='portland.html')

#Lat/Lng popovers
map_3 = folium.Map(location=[46.1991, -122.1889], tiles='Stamen Terrain',
                   zoom_start=13)
map_3.lat_lng_popover()
map_3.create_map(path='sthelens.html')

#Click for marker
map_4 = folium.Map(location=[46.8527, -121.7649], tiles='Stamen Terrain',
                   zoom_start=13)
map_4.simple_marker(location=[46.8354, -121.7325], popup='Camp Muir')
map_4.click_for_marker(popup='Waypoint')
map_4.create_map(path='mtrainier.html')

#Polygon markers
map_5 = folium.Map(location=[45.5236, -122.6750], zoom_start=13)
map_5.polygon_marker(location=[45.5012, -122.6655], popup='Ross Island Bridge',
                     fill_color='#132b5e', num_sides=3, radius=10)
map_5.polygon_marker(location=[45.5132, -122.6708], popup='Hawthorne Bridge',
                     fill_color='#45647d', num_sides=4, radius=10)
map_5.polygon_marker(location=[45.5275, -122.6692], popup='Steel Bridge',
                     fill_color='#769d96', num_sides=6, radius=10)
map_5.polygon_marker(location=[45.5318, -122.6745], popup='Broadway Bridge',
                     fill_color='#769d96', num_sides=8, radius=10)
map_5.create_map(path='bridges.html')

########NEW FILE########
__FILENAME__ = folium
# -*- coding: utf-8 -*-
'''
Folium
-------

Make beautiful, interactive maps with Python and Leaflet.js

'''

from __future__ import print_function
from __future__ import division
import codecs
import json
import functools
from jinja2 import Environment, PackageLoader
from pkg_resources import resource_string, resource_filename
import utilities
from uuid import uuid4


ENV = Environment(loader=PackageLoader('folium', 'templates'))


def initialize_notebook():
    """Initialize the IPython notebook display elements"""
    try:
        from IPython.core.display import display, HTML
    except ImportError:
        print("IPython Notebook could not be loaded.")

    lib_css = ENV.get_template('ipynb_init_css.html')
    lib_js = ENV.get_template('ipynb_init_js.html')
    leaflet_dvf = ENV.get_template('leaflet-dvf.markers.min.js')

    display(HTML(lib_css.render()))
    display(HTML(lib_js.render({'leaflet_dvf': leaflet_dvf.render()})))

def iter_obj(type):
    '''Decorator to keep count of different map object types in self.mk_cnt'''
    def decorator(func):
        @functools.wraps(func)
        def wrapper(self, *args, **kwargs):
            self.mark_cnt[type] = self.mark_cnt.get(type, 0) + 1
            func_result = func(self, *args, **kwargs)
            return func_result
        return wrapper
    return decorator


class Map(object):
    '''Create a Map with Folium'''

    def __init__(self, location=None, width=960, height=500,
                 tiles='OpenStreetMap', API_key=None, max_zoom=18,
                 zoom_start=10, attr=None):
        '''Create a Map with Folium and Leaflet.js

        Generate a base map of given width and height with either default
        tilesets or a custom tileset URL. The following tilesets are built-in
        to Folium. Pass any of the following to the "tiles" keyword:
            -"OpenStreetMap"
            -"MapQuest Open"
            -"MapQuest Open Aerial"
            -"Mapbox Bright" (Limited levels of zoom for free tiles)
            -"Mapbox Control Room" (Limited levels of zoom for free tiles)
            -"Stamen Terrain"
            -"Stamen Toner"
            -"Cloudmade" (Must pass API key)
            -"Mapbox" (Must pass API key)
        You can pass a custom tileset to Folium by passing a Leaflet-style
        URL to the tiles parameter:
        http://{s}.yourtiles.com/{z}/{x}/{y}.png

        Parameters
        ----------
        location: tuple or list, default None
            Latitude and Longitude of Map (Northing, Easting).
        width: int, default 960
            Width of the map.
        height: int, default 500
            Height of the map.
        tiles: str, default 'OpenStreetMap'
            Map tileset to use. Can use defaults or pass a custom URL.
        API_key: str, default None
            API key for Cloudmade or Mapbox tiles.
        max_zoom: int, default 18
            Maximum zoom depth for the map.
        zoom_start: int, default 10
            Initial zoom level for the map.
        attr: string, default None
            Map tile attribution; only required if passing custom tile URL.

        Returns
        -------
        Folium Map Object

        Examples
        --------
        >>>map = folium.Map(location=[45.523, -122.675], width=750, height=500)
        >>>map = folium.Map(location=[45.523, -122.675],
                            tiles='Mapbox Control Room')
        >>>map = folium.Map(location=(45.523, -122.675), max_zoom=20,
                            tiles='Cloudmade', API_key='YourKey')
        >>>map = folium.Map(location=[45.523, -122.675], zoom_start=2,
                            tiles=('http://{s}.tiles.mapbox.com/v3/'
                                    'mapbox.control-room/{z}/{x}/{y}.png'),
                            attr='Mapbox attribution')

        '''

        #Inits
        self.map_path = None
        self.render_iframe = False
        self.map_type = 'base'
        self.map_id = '_'.join(['folium', uuid4().hex])

        #Mark counter, JSON, Plugins
        self.mark_cnt = {}
        self.json_data = {}
        self.plugins = {}

        #Location
        if not location:
            raise ValueError('You must pass a Lat/Lon location to initialize'
                             ' your map')
        self.location = location

        #Map Size Parameters
        self.width = width
        self.height = height
        self.map_size = {'width': width, 'height': height}
        self._size = ('style="width: {0}px; height: {1}px"'
                      .format(width, height))

        #Templates
        self.env = ENV
        self.template_vars = {'lat': location[0], 'lon': location[1],
                              'size': self._size, 'max_zoom': max_zoom,
                              'zoom_level': zoom_start,
                              'map_id': self.map_id}

        #Tiles
        self.tiles = ''.join(tiles.lower().strip().split())
        if self.tiles in ('cloudmade', 'mapbox') and not API_key:
            raise ValueError('You must pass an API key if using Cloudmade'
                             ' or non-default Mapbox tiles.')

        self.default_tiles = ['openstreetmap', 'mapboxcontrolroom',
                              'mapquestopen', 'mapquestopenaerial',
                              'mapboxbright', 'mapbox', 'cloudmade',
                              'stamenterrain', 'stamentoner']
        self.tile_types = {}
        for tile in self.default_tiles:
            self.tile_types[tile] = {'templ':
                                     self.env.get_template(tile + '_tiles.txt'),
                                     'attr':
                                     self.env.get_template(tile + '_att.txt')}

        if self.tiles in self.tile_types:
            self.template_vars['Tiles'] = (self.tile_types[self.tiles]['templ']
                                           .render(API_key=API_key))
            self.template_vars['attr'] = (self.tile_types[self.tiles]['attr']
                                          .render())
        else:
            self.template_vars['Tiles'] = tiles
            if not attr:
                raise ValueError('Custom tiles must'
                                 ' also be passed an attribution')
            self.template_vars['attr'] = unicode(attr, 'utf8')
            self.tile_types.update({'Custom': {'template': tiles, 'attr': attr}})

    @iter_obj('simple')
    def simple_marker(self, location=None, popup='Pop Text', popup_on=True):
        '''Create a simple stock Leaflet marker on the map, with optional
        popup text or Vincent visualization.

        Parameters
        ----------
        location: tuple or list, default None
            Latitude and Longitude of Marker (Northing, Easting)
        popup: string or tuple, default 'Pop Text'
            Input text or visualization for object. Can pass either text,
            or a tuple of the form (Vincent object, 'vis_path.json')
        popup_on: boolean, default True
            Pass false for no popup information on the marker

        Returns
        -------
        Marker names and HTML in obj.template_vars

        Example
        -------
        >>>map.simple_marker(location=[45.5, -122.3], popup='Portland, OR')
        >>>map.simple_marker(location=[45.5, -122.3], popup=(vis, 'vis.json'))

        '''
        count = self.mark_cnt['simple']

        mark_temp = self.env.get_template('simple_marker.js')

        #Get marker and popup
        marker = mark_temp.render({'marker': 'marker_' + str(count),
                                   'lat': location[0], 'lon': location[1]})

        popup_out = self._popup_render(popup=popup, mk_name='marker_',
                                       count=count,
                                       popup_on=popup_on)

        add_mark = 'map.addLayer(marker_{0})'.format(count)

        self.template_vars.setdefault('markers', []).append((marker,
                                                             popup_out,
                                                             add_mark))

    @iter_obj('line')
    def line(self, locations,
             line_color=None, line_opacity=None, line_weight=None):
        '''Add a line to the map with optional styles.

        Parameters
        ----------
        locations: list of points (latitude, longitude)
            Latitude and Longitude of line (Northing, Easting)
        line_color: string, default Leaflet's default ('#03f')
        line_opacity: float, default Leaflet's default (0.5)
        line_weight: float, default Leaflet's default (5)

        Note: If the optional styles are omitted, they will not be included
        in the HTML output and will obtain the Leaflet defaults listed above.

        Example
        -------
        >>>map.line(locations=[(45.5, -122.3), (42.3, -71.0)])
        >>>map.line(locations=[(45.5, -122.3), (42.3, -71.0)],
                    line_color='red', line_opacity=1.0)

        '''
        count = self.mark_cnt['line']

        line_temp = self.env.get_template('polyline.js')

        polyline_opts = {'color': line_color,
                'weight': line_weight,
                'opacity': line_opacity}

        varname = 'line_{}'.format(count)
        line_rendered = line_temp.render({'line': varname,
                                          'locations': locations,
                                          'options': polyline_opts})

        add_line = 'map.addLayer({});'.format(varname)

        self.template_vars.setdefault('lines', []).append((line_rendered,
                                                           add_line))


    @iter_obj('circle')
    def circle_marker(self, location=None, radius=500, popup='Pop Text',
                      popup_on=True, line_color='black', fill_color='black',
                      fill_opacity=0.6):
        '''Create a simple circle marker on the map, with optional popup text
        or Vincent visualization.

        Parameters
        ----------
        location: tuple or list, default None
            Latitude and Longitude of Marker (Northing, Easting)
        radius: int, default 500
            Circle radius, in pixels
        popup: string or tuple, default 'Pop Text'
            Input text or visualization for object. Can pass either text,
            or a tuple of the form (Vincent object, 'vis_path.json')
        popup_on: boolean, default True
            Pass false for no popup information on the marker
        line_color: string, default black
            Line color. Can pass hex value here as well.
        fill_color: string, default black
            Fill color. Can pass hex value here as well.
        fill_opacity: float, default 0.6
            Circle fill opacity

        Returns
        -------
        Circle names and HTML in obj.template_vars

        Example
        -------
        >>>map.circle_marker(location=[45.5, -122.3],
                             radius=1000, popup='Portland, OR')
        >>>map.circle_marker(location=[45.5, -122.3],
                             radius=1000, popup=(bar_chart, 'bar_data.json'))

        '''
        count = self.mark_cnt['circle']

        circle_temp = self.env.get_template('circle_marker.js')

        circle = circle_temp.render({'circle': 'circle_' + str(count),
                                     'radius': radius,
                                     'lat': location[0], 'lon': location[1],
                                     'line_color': line_color,
                                     'fill_color': fill_color,
                                     'fill_opacity': fill_opacity})

        popup_out = self._popup_render(popup=popup, mk_name='circle_',
                                       count=count,
                                       popup_on=popup_on)

        add_mark = 'map.addLayer(circle_{0})'.format(count)

        self.template_vars.setdefault('markers', []).append((circle,
                                                             popup_out,
                                                             add_mark))

    @iter_obj('polygon')
    def polygon_marker(self, location=None, line_color='black', line_opacity=1,
                       line_weight=2, fill_color='blue', fill_opacity=1,
                       num_sides=4, rotation=0, radius=15, popup='Pop Text',
                       popup_on=True):
        '''Custom markers using the Leaflet Data Vis Framework.


        Parameters
        ----------
        location: tuple or list, default None
            Latitude and Longitude of Marker (Northing, Easting)
        line_color: string, default 'black'
            Marker line color
        line_opacity: float, default 1
            Line opacity, scale 0-1
        line_weight: int, default 2
            Stroke weight in pixels
        fill_color: string, default 'blue'
            Marker fill color
        fill_opacity: float, default 1
            Marker fill opacity
        num_sides: int, default 4
            Number of polygon sides
        rotation: int, default 0
            Rotation angle in degrees
        radius: int, default 15
            Marker radius, in pixels
        popup: string or tuple, default 'Pop Text'
            Input text or visualization for object. Can pass either text,
            or a tuple of the form (Vincent object, 'vis_path.json')
        popup_on: boolean, default True
            Pass false for no popup information on the marker

        Returns
        -------
        Polygon marker names and HTML in obj.template_vars

        '''

        count = self.mark_cnt['polygon']

        poly_temp = self.env.get_template('poly_marker.js')

        polygon = poly_temp.render({'marker': 'polygon_' + str(count),
                                    'lat': location[0],
                                    'lon': location[1],
                                    'line_color': line_color,
                                    'line_opacity': line_opacity,
                                    'line_weight': line_weight,
                                    'fill_color': fill_color,
                                    'fill_opacity': fill_opacity,
                                    'num_sides': num_sides,
                                    'rotation': rotation,
                                    'radius': radius})

        popup_out = self._popup_render(popup=popup, mk_name='polygon_',
                                       count=count,
                                       popup_on=popup_on)

        add_mark = 'map.addLayer(polygon_{0})'.format(count)

        self.template_vars.setdefault('markers', []).append((polygon,
                                                             popup_out,
                                                             add_mark))
        #Update JS/CSS and other Plugin files
        js_temp = self.env.get_template('dvf_js_ref.txt').render()
        self.template_vars.update({'dvf_js': js_temp})

        polygon_js = resource_string('folium',
                                     'plugins/leaflet-dvf.markers.min.js')

        self.plugins.update({'leaflet-dvf.markers.min.js': polygon_js})

    def lat_lng_popover(self):
        '''Enable popovers to display Lat and Lon on each click'''

        latlng_temp = self.env.get_template('lat_lng_popover.js')
        self.template_vars.update({'lat_lng_pop': latlng_temp.render()})

    def click_for_marker(self, popup=None):
        '''Enable the addition of markers via clicking on the map. The marker
        popup defaults to Lat/Lon, but custom text can be passed via the
        popup parameter. Double click markers to remove them.

        Parameters
        ----------
        popup:
            Custom popup text

        Example
        -------
        >>>map.click_for_marker(popup='Your Custom Text')

        '''
        latlng = '"Latitude: " + lat + "<br>Longitude: " + lng '
        click_temp = self.env.get_template('click_for_marker.js')
        if popup:
            popup_txt = ''.join(['"', popup, '"'])
        else:
            popup_txt = latlng
        click_str = click_temp.render({'popup': popup_txt})
        self.template_vars.update({'click_pop': click_str})

    def _popup_render(self, popup=None, mk_name=None, count=None,
                      popup_on=True):
        '''Popup renderer: either text or Vincent/Vega.

        Parameters
        ----------
        popup: str or Vincent tuple, default None
            String for text popup, or tuple of (Vincent object, json_path)
        mk_name: str, default None
            Type of marker. Simple, Circle, etc.
        count: int, default None
            Count of marker
        popup_on: boolean, default True
            If False, no popup will be rendered
        '''
        if not popup_on:
            return 'var no_pop = null;'
        else:
            if isinstance(popup, str):
                popup_temp = self.env.get_template('simple_popup.js')
                return popup_temp.render({'pop_name': mk_name + str(count),
                                          'pop_txt': json.dumps(popup)})
            elif isinstance(popup, tuple):
                #Update template with JS libs
                vega_temp = self.env.get_template('vega_ref.txt').render()
                jquery_temp = self.env.get_template('jquery_ref.txt').render()
                d3_temp = self.env.get_template('d3_ref.txt').render()
                vega_parse = self.env.get_template('vega_parse.js').render()
                self.template_vars.update({'vega': vega_temp,
                                           'd3': d3_temp,
                                           'jquery': jquery_temp,
                                           'vega_parse': vega_parse})

                #Parameters for Vega template
                vega = popup[0]
                mark = ''.join([mk_name, str(count)])
                json_out = popup[1]
                div_id = popup[1].split('.')[0]
                width = vega.width
                height = vega.height
                if isinstance(vega.padding, dict):
                    width += vega.padding['left']+vega.padding['right']
                    height += vega.padding['top']+vega.padding['bottom']
                else:
                    width += 75
                    height += 50                    
                max_width = self.map_size['width']
                vega_id = '#' + div_id
                popup_temp = self.env.get_template('vega_marker.js')
                return popup_temp.render({'mark': mark, 'div_id': div_id,
                                          'width': width, 'height': height,
                                          'max_width': max_width,
                                          'json_out': json_out,
                                          'vega_id': vega_id})

    @iter_obj('geojson')
    def geo_json(self, geo_path=None, geo_str=None, data_out='data.json',
                 data=None, columns=None, key_on=None, threshold_scale=None,
                 fill_color='blue', fill_opacity=0.6, line_color='black',
                 line_weight=1, line_opacity=1, legend_name=None,
                 topojson=None, reset=False):
        '''Apply a GeoJSON overlay to the map.

        Plot a GeoJSON overlay on the base map. There is no requirement
        to bind data (passing just a GeoJSON plots a single-color overlay),
        but there is a data binding option to map your columnar data to
        different feature objects with a color scale.

        If data is passed as a Pandas dataframe, the "columns" and "key-on"
        keywords must be included, the first to indicate which DataFrame
        columns to use, the second to indicate the layer in the GeoJSON
        on which to key the data. The 'columns' keyword does not need to be
        passed for a Pandas series.

        Colors are generated from color brewer (http://colorbrewer2.org/)
        sequential palettes on a D3 threshold scale. The scale defaults to the
        following quantiles: [0, 0.5, 0.75, 0.85, 0.9]. A custom scale can be
        passed to `threshold_scale` of length <=6, in order to match the
        color brewer range.

        TopoJSONs can be passed as "geo_path", but the "topojson" keyword must
        also be passed with the reference to the topojson objects to convert.
        See the topojson.feature method in the TopoJSON API reference:
        https://github.com/mbostock/topojson/wiki/API-Reference


        Parameters
        ----------
        geo_path: string, default None
            URL or File path to your GeoJSON data
        geo_str: string, default None
            String of GeoJSON, alternative to geo_path
        data_out: string, default 'data.json'
            Path to write Pandas DataFrame/Series to JSON if binding data
        data: Pandas DataFrame or Series, default None
            Data to bind to the GeoJSON.
        columns: dict or tuple, default None
            If the data is a Pandas DataFrame, the columns of data to be bound.
            Must pass column 1 as the key, and column 2 the values.
        key_on: string, default None
            Variable in the GeoJSON file to bind the data to. Must always
            start with 'feature' and be in JavaScript objection notation.
            Ex: 'feature.id' or 'feature.properties.statename'.
        threshold_scale: list, default None
            Data range for D3 threshold scale. Defaults to the following range
            of quantiles: [0, 0.5, 0.75, 0.85, 0.9], rounded to the nearest
            order-of-magnitude integer. Ex: 270 rounds to 200, 5600 to 6000.
        fill_color: string, default 'blue'
            Area fill color. Can pass a hex code, color name, or if you are
            binding data, one of the following color brewer palettes:
            'BuGn', 'BuPu', 'GnBu', 'OrRd', 'PuBu', 'PuBuGn', 'PuRd', 'RdPu',
            'YlGn', 'YlGnBu', 'YlOrBr', and 'YlOrRd'.
        fill_opacity: float, default 0.6
            Area fill opacity, range 0-1.
        line_color: string, default 'black'
            GeoJSON geopath line color.
        line_weight: int, default 1
            GeoJSON geopath line weight.
        line_opacity: float, default 1
            GeoJSON geopath line opacity, range 0-1.
        legend_name: string, default None
            Title for data legend. If not passed, defaults to columns[1].
        topojson: string, default None
            If using a TopoJSON, passing "objects.yourfeature" to the topojson
            keyword argument will enable conversion to GeoJSON.
        reset: boolean, default False
            Remove all current geoJSON layers, start with new layer

        Output
        ------
        GeoJSON data layer in obj.template_vars

        Example
        -------
        >>>map.geo_json(geo_path='us-states.json', line_color='blue', line_weight=3)
        >>>map.geo_json(geo_path='geo.json', data=df, columns=['Data 1', 'Data 2'],
                        key_on='feature.properties.myvalue', fill_color='PuBu',
                        threshold_scale=[0, 20, 30, 40, 50, 60])
        >>>map.geo_json(geo_path='countries.json', topojson='objects.countries')
        '''

        if reset:
            reset_vars = ['json_paths', 'func_vars', 'color_scales', 'geo_styles',
                          'gjson_layers', 'map_legends', 'topo_convert']
            for var in reset_vars:
                self.template_vars.update({var: []})
            self.mark_cnt['geojson'] = 1

        def json_style(style_cnt, line_color, line_weight, line_opacity,
                       fill_color, fill_opacity, quant_fill):
            '''Generate JSON styling function from template'''
            style_temp = self.env.get_template('geojson_style.js')
            style = style_temp.render({'style': style_cnt,
                                       'line_color': line_color,
                                       'line_weight': line_weight,
                                       'line_opacity': line_opacity,
                                       'fill_color': fill_color,
                                       'fill_opacity': fill_opacity,
                                       'quantize_fill': quant_fill})
            return style

        #Set map type to geojson
        self.map_type = 'geojson'

        #Get JSON map layer template pieces, convert TopoJSON if necessary
        # geo_str is really a hack
        if geo_path:
            geo_path = ".defer(d3.json, '{0}')".format(geo_path)
        elif geo_str:
            geo_path = (".defer(function(callback)"
                        "{{callback(null, JSON.parse('{}'))}})").format(geo_str)

        if topojson is None:
            map_var = '_'.join(['gjson', str(self.mark_cnt['geojson'])])
            layer_var = map_var
        else:
            map_var = '_'.join(['tjson', str(self.mark_cnt['geojson'])])
            topo_obj = '.'.join([map_var, topojson])
            layer_var = '_'.join(['topo', str(self.mark_cnt['geojson'])])
            topo_templ = self.env.get_template('topo_func.js')
            topo_func = topo_templ.render({'map_var': layer_var,
                                           't_var': map_var,
                                           't_var_obj': topo_obj})
            topo_lib = self.env.get_template('topojson_ref.txt').render()
            self.template_vars.update({'topojson': topo_lib})
            self.template_vars.setdefault('topo_convert',
                                          []).append(topo_func)

        style_count = '_'.join(['style', str(self.mark_cnt['geojson'])])

        #Get Data binding pieces if available
        if data is not None:

            import pandas as pd

            #Create DataFrame with only the relevant columns
            if isinstance(data, pd.DataFrame):
                data = pd.concat([data[columns[0]], data[columns[1]]], axis=1)

            #Save data to JSON
            self.json_data[data_out] = utilities.transform_data(data)

            #Add data to queue
            d_path = ".defer(d3.json, '{0}')".format(data_out)
            self.template_vars.setdefault('json_paths', []).append(d_path)

            #Add data variable to makeMap function
            data_var = '_'.join(['data', str(self.mark_cnt['geojson'])])
            self.template_vars.setdefault('func_vars', []).append(data_var)

            #D3 Color scale
            series = data[columns[1]]
            domain = threshold_scale or utilities.split_six(series=series)
            if len(domain) > 253:
                raise ValueError('The threshold scale must be of length <= 253')
            if not utilities.color_brewer(fill_color):
                raise ValueError('Please pass a valid color brewer code to '
                                 'fill_local. See docstring for valid codes.')

            palette = utilities.color_brewer(fill_color, len(domain))
            d3range = palette[0: len(domain) + 1]
            tick_labels = utilities.legend_scaler(domain)

            color_temp = self.env.get_template('d3_threshold.js')
            d3scale = color_temp.render({'domain': domain,
                                         'range': d3range})
            self.template_vars.setdefault('color_scales', []).append(d3scale)

            #Create legend
            name = legend_name or columns[1]
            leg_templ = self.env.get_template('d3_map_legend.js')
            legend = leg_templ.render({'lin_max': int(domain[-1]*1.1),
                                       'tick_labels': tick_labels,
                                       'caption': name})
            self.template_vars.setdefault('map_legends', []).append(legend)

            #Style with color brewer colors
            matchColor = 'color(matchKey({0}, {1}))'.format(key_on, data_var)
            style = json_style(style_count, line_color, line_weight,
                               line_opacity, None, fill_opacity, matchColor)
        else:
            style = json_style(style_count, line_color, line_weight,
                               line_opacity, fill_color, fill_opacity, None)

        layer = ('gJson_layer_{0} = L.geoJson({1}, {{style: {2}}}).addTo(map)'
                 .format(self.mark_cnt['geojson'], layer_var, style_count))

        self.template_vars.setdefault('json_paths', []).append(geo_path)
        self.template_vars.setdefault('func_vars', []).append(map_var)
        self.template_vars.setdefault('geo_styles', []).append(style)
        self.template_vars.setdefault('gjson_layers', []).append(layer)

    def _build_map(self, html_templ=None, templ_type='string'):
        '''Build HTML/JS/CSS from Templates given current map type'''
        if html_templ is None:
            map_types = {'base': 'fol_template.html',
                         'geojson': 'geojson_template.html'}

            #Check current map type
            type_temp = map_types[self.map_type]

            html_templ = self.env.get_template(type_temp)
        else:
            if templ_type == 'string':
                html_templ = self.env.from_string(html_templ)

        self.HTML = html_templ.render(self.template_vars)

    def create_map(self, path='map.html', plugin_data_out=True, template=None):
        '''Write Map output to HTML and data output to JSON if available

        Parameters:
        -----------
        path: string, default 'map.html'
            Path for HTML output for map
        plugin_data_out: boolean, default True
            If using plugins such as awesome markers, write all plugin
            data such as JS/CSS/images to path
        template: string, default None
            Custom template to render

        '''
        self.map_path = path
        self._build_map(template)

        with codecs.open(path, 'w', 'utf-8') as f:
            f.write(self.HTML)

        if self.json_data:
            for path, data in self.json_data.iteritems():
                with open(path, 'w') as g:
                    json.dump(data, g)

        if self.plugins and plugin_data_out:
            for name, plugin in self.plugins.iteritems():
                with open(name, 'w') as f:
                    f.write(plugin)

    def _repr_html_(self):
        """Build the HTML representation for IPython."""
        map_types = {'base': 'ipynb_repr.html',
                     'geojson': 'ipynb_iframe.html'}

        #Check current map type
        type_temp = map_types[self.map_type]
        if self.render_iframe:
            type_temp = 'ipynb_iframe.html'
        templ = self.env.get_template(type_temp)
        self._build_map(html_templ=templ, templ_type='temp')
        if self.map_type == 'geojson' or self.render_iframe:
            if not self.map_path:
                raise ValueError('Use create_map to set the path!')
            return templ.render(path=self.map_path, width=self.width,
                                height=self.height)
        return self.HTML

    def display(self):
        """Display the visualization inline in the IPython notebook.

        This is deprecated, use the following instead::

            from IPython.display import display
            display(viz)
        """
        from IPython.core.display import display, HTML
        display(HTML(self._repr_html_()))

########NEW FILE########
__FILENAME__ = utilities
# -*- coding: utf-8 -*-
'''
Utilities
-------

Utility module for Folium helper functions.

'''

from __future__ import print_function
from __future__ import division
import math
from jinja2 import Environment, PackageLoader, Template

try:
    import pandas as pd
except ImportError:
    pd = None

try:
    import numpy as np
except ImportError:
    np = None


def get_templates():
    '''Get Jinja templates'''
    return Environment(loader=PackageLoader('folium', 'templates'))

def legend_scaler(legend_values, max_labels=10.0):
    '''
    Downsamples the number of legend values so that there isn't a collision
    of text on the legend colorbar (within reason). The colorbar seems to 
    support ~10 entries as a maximum
    '''
    import math

    if len(legend_values)<max_labels:
        legend_ticks = legend_values
    else:
        spacer = int(math.ceil(len(legend_values)/max_labels))
        legend_ticks = []
        for i in legend_values[::spacer]:
            legend_ticks += [i]
            legend_ticks += ['']*(spacer-1)
    return legend_ticks


def linear_gradient(hexList, nColors):
    """Given a list of hexcode values, will return a list of length
    nColors where the colors are linearly interpolated between the
    (r, g, b) tuples that are given.

    Example:
    linear_gradient([(0, 0, 0), (255, 0, 0), (255, 255, 0)], 100)
    """
    def _scale(start, finish, length, i):
        """Return the value correct value of a number that is inbetween start
        and finish, for use in a loop of length *length*"""
        base=16

        fraction = float(i) / (length - 1)
        raynge = int(finish, base) - int(start, base)
        thex = hex(int(int(start, base) + fraction * raynge)).split('x')[-1]
        if len(thex)!=2:
            thex ='0' + thex
        return thex


    allColors = []
    # separate (r, g, b) pairs
    for start, end in zip(hexList[:-1], hexList[1:]):
        # linearly intepolate between pair of hex ###### values and add to list
        nInterpolate = 765 
        for index in range(nInterpolate):
            r = _scale(start[1:3], end[1:3], nInterpolate, index)
            g = _scale(start[3:5], end[3:5], nInterpolate, index)
            b = _scale(start[5:7], end[5:7], nInterpolate, index)
            allColors.append(''.join(['#',r,g,b]))

    # pick only nColors colors from the total list
    result = []
    for counter in range(nColors):
        fraction = float(counter) / (nColors - 1)
        index = int(fraction * (len(allColors) - 1)) 
        result.append(allColors[index])
    return result


def color_brewer(color_code, n=6):
    '''Generate a colorbrewer color scheme of length 'len', type 'scheme.
    Live examples can be seen at http://colorbrewer2.org/'''
    maximum_n = 253

    scheme_info = {'BuGn': 'Sequential',
                   'BuPu': 'Sequential',
                   'GnBu': 'Sequential',
                   'OrRd': 'Sequential',
                   'PuBu': 'Sequential',
                   'PuBuGn': 'Sequential',
                   'PuRd': 'Sequential',
                   'RdPu': 'Sequential',
                   'YlGn': 'Sequential',
                   'YlGnBu': 'Sequential',
                   'YlOrBr': 'Sequential',
                   'YlOrRd': 'Sequential',
                   'BrBg': 'Diverging',
                   'PiYG': 'Diverging',
                   'PRGn': 'Diverging',
                   'PuOr': 'Diverging',
                   'RdBu': 'Diverging',
                   'RdGy': 'Diverging',
                   'RdYlBu': 'Diverging',
                   'RdYlGn': 'Diverging',
                   'Spectral': 'Diverging',
                   'Accent': 'Qualitative', 
                   'Dark2': 'Qualitative',
                   'Paired': 'Qualitative',
                   'Pastel1': 'Qualitative',
                   'Pastel2': 'Qualitative',
                   'Set1': 'Qualitative',
                   'Set2': 'Qualitative',
                   'Set3': 'Qualitative',
                   }

    schemes = {'BuGn': ['#EDF8FB', '#CCECE6', '#CCECE6', '#66C2A4', '#41AE76',
                        '#238B45', '#005824'],
               'BuPu': ['#EDF8FB', '#BFD3E6', '#9EBCDA', '#8C96C6', '#8C6BB1',
                        '#88419D', '#6E016B'],
               'GnBu': ['#F0F9E8', '#CCEBC5', '#A8DDB5', '#7BCCC4', '#4EB3D3',
                        '#2B8CBE', '#08589E'],
               'OrRd': ['#FEF0D9', '#FDD49E', '#FDBB84', '#FC8D59', '#EF6548',
                        '#D7301F', '#990000'],
               'PuBu': ['#F1EEF6', '#D0D1E6', '#A6BDDB', '#74A9CF', '#3690C0',
                        '#0570B0', '#034E7B'],
               'PuBuGn': ['#F6EFF7', '#D0D1E6', '#A6BDDB', '#67A9CF', '#3690C0',
                          '#02818A', '#016450'],
               'PuRd': ['#F1EEF6', '#D4B9DA', '#C994C7', '#DF65B0', '#E7298A',
                        '#CE1256', '#91003F'],
               'RdPu': ['#FEEBE2', '#FCC5C0', '#FA9FB5', '#F768A1', '#DD3497',
                        '#AE017E', '#7A0177'],
               'YlGn': ['#FFFFCC', '#D9F0A3', '#ADDD8E', '#78C679', '#41AB5D',
                        '#238443', '#005A32'],
               'YlGnBu': ['#FFFFCC', '#C7E9B4', '#7FCDBB', '#41B6C4', '#1D91C0',
                          '#225EA8', '#0C2C84'],
               'YlOrBr': ['#FFFFD4', '#FEE391', '#FEC44F', '#FE9929', '#EC7014',
                          '#CC4C02', '#8C2D04'],
               'YlOrRd': ['#FFFFB2', '#FED976', '#FEB24C', '#FD8D3C', '#FC4E2A',
                          '#E31A1C', '#B10026'],
               'BrBg': ['#8c510a', '#d8b365', '#f6e8c3', '#c7eae5', '#5ab4ac', '#01665e'],
               'PiYG': ['#c51b7d', '#e9a3c9', '#fde0ef', '#e6f5d0', '#a1d76a', '#4d9221'],
               'PRGn': ['#762a83', '#af8dc3', '#e7d4e8', '#d9f0d3', '#7fbf7b', '#1b7837'],
               'PuOr': ['#b35806', '#f1a340', '#fee0b6', '#d8daeb', '#998ec3', '#542788'],
               'RdBu': ['#b2182b', '#ef8a62', '#fddbc7', '#d1e5f0', '#67a9cf', '#2166ac'],
               'RdGy': ['#b2182b', '#ef8a62', '#fddbc7', '#e0e0e0', '#999999', '#4d4d4d'],
               'RdYlBu': ['#d73027', '#fc8d59', '#fee090', '#e0f3f8', '#91bfdb', '#4575b4'],
               'RdYlGn': ['#d73027', '#fc8d59', '#fee08b', '#d9ef8b', '#91cf60', '#1a9850'],
               'Spectral': ['#d53e4f' '#fc8d59' '#fee08b' '#e6f598' '#99d594' '#3288bd'],
               'Accent': ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f'],
               'Dark2': ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02'],
               'Paired': ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c'],
               'Pastel1': ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc'],
               'Pastel2': ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae'],
               'Set1': ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33'],
               'Set2': ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f'],
               'Set3': ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462'],
               }

    #Raise an error if the n requested is greater than the maximum
    if n > maximum_n:
        raise ValueError("The maximum number of colors in a ColorBrewer sequential color series is 253")

    #Only if n is greater than six do we interpolate values
    if n > 6:
        if color_code not in schemes:
            color_scheme= None
        else:
            #Check to make sure that it is not a qualitative scheme
            if scheme_info[color_code]=='Qualitative':
                raise ValueError("Expanded color support is not available for Qualitative schemes, restrict number of colors to 6")
            else:
                color_scheme = linear_gradient(schemes.get(color_code), n)
    else:
        color_scheme = schemes.get(color_code, None)
    return color_scheme



def transform_data(data):
    '''Transform Pandas DataFrame into JSON format

    Parameters
    ----------
    data: DataFrame or Series
        Pandas DataFrame or Series

    Returns
    -------
    JSON compatible dict

    Example
    -------
    >>>transform_data(df)

    '''

    if pd is None:
        raise ImportError("The Pandas package is required for this functionality")

    if np is None:
        raise ImportError("The NumPy package is required for this functionality")

    def type_check(value):
        '''Type check values for JSON serialization. Native Python JSON
        serialization will not recognize some Numpy data types properly,
        so they must be explictly converted.'''
        if pd.isnull(value):
            return None
        elif (isinstance(value, pd.tslib.Timestamp) or
              isinstance(value, pd.Period)):
            return time.mktime(value.timetuple())
        elif isinstance(value, (int, np.integer)):
            return int(value)
        elif isinstance(value, (float, np.float_)):
            return float(value)
        elif isinstance(value, str):
            return str(value)
        else:
            return value

    if isinstance(data, pd.Series):
        json_data = [{type_check(x): type_check(y) for x, y in data.iteritems()}]
    elif isinstance(data, pd.DataFrame):
        json_data = [{type_check(y): type_check(z) for x, y, z in data.itertuples()}]

    return json_data


def split_six(series=None):
    '''Given a Pandas Series, get a domain of values from zero to the 90% quantile
    rounded to the nearest order-of-magnitude integer. For example, 2100 is rounded
    to 2000, 2790 to 3000.

    Parameters
    ----------
    series: Pandas series, default None

    Returns
    -------
    list

    '''

    if pd is None:
        raise ImportError("The Pandas package is required for this functionality")
    if np is None:
        raise ImportError("The NumPy package is required for this functionality")

    def base(x):
        if x > 0:
            base = pow(10, math.floor(math.log10(x)))
            return round(x/base)*base
        else:
            return 0

    quants = [0, 50, 75, 85, 90]
    # Some weirdness in series quantiles a la 0.13
    arr = series.values
    return [base(np.percentile(arr, x)) for x in quants]

########NEW FILE########
__FILENAME__ = folium_tests
# -*- coding: utf-8 -*-
'''
Folium Tests
-------

'''
import json
import pandas as pd
import nose.tools as nt
import jinja2
from jinja2 import Environment, PackageLoader
import folium
import vincent


def setup_data():
    '''Import economic data for testing'''
    with open('us-counties.json', 'r') as f:
        get_id = json.load(f)

    county_codes = [x['id'] for x in get_id['features']]
    county_df = pd.DataFrame({'FIPS_Code': county_codes}, dtype=str)

    #Read into Dataframe, cast to string for consistency
    df = pd.read_csv('us_county_data.csv', na_values=[' '])
    df['FIPS_Code'] = df['FIPS_Code'].astype(str)

    #Perform an inner join, pad NA's with data from nearest county
    merged = pd.merge(df, county_df, on='FIPS_Code', how='inner')
    return merged.fillna(method='pad')


def test_get_templates():
    '''Test template getting'''

    env = folium.utilities.get_templates()
    nt.assert_is_instance(env, jinja2.environment.Environment)


class testFolium(object):
    '''Test class for the Folium library'''

    def setup(self):
        '''Setup Folium Map'''

        self.map = folium.Map(location=[45.5236, -122.6750], width=900,
                              height=400, max_zoom=20, zoom_start=4)
        self.env = Environment(loader=PackageLoader('folium', 'templates'))

    def test_init(self):
        '''Test map initialization'''

        assert self.map.map_type == 'base'
        assert self.map.mark_cnt == {}
        assert self.map.location == [45.5236, -122.6750]
        assert self.map.map_size == {'width': 900, 'height': 400}

        nt.assert_raises(ValueError, callableObj=folium.Map)

        tmpl = {'Tiles': u'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                'attr': (u'Map data (c) <a href="http://openstreetmap.org">'
                         'OpenStreetMap</a> contributors'),
                'lat': 45.5236, 'lon': -122.675, 'max_zoom': 20,
                'size': 'style="width: 900px; height: 400px"',
                'zoom_level': 4}

        assert self.map.template_vars == tmpl

    def test_cloudmade(self):
        '''Test cloudmade tiles and the API key'''

        nt.assert_raises(ValueError, callableObj=folium.Map,
                         location=[45.5236, -122.6750], tiles='cloudmade')

        map = folium.Map(location=[45.5236, -122.6750], tiles='cloudmade',
                         API_key='###')
        assert map.template_vars['Tiles'] == (u'http://{s}.tile.cloudmade.com'
                                              '/###/997/256/{z}/{x}/{y}.png')

    def test_builtin_tile(self):
        '''Test custom maptiles'''

        default_tiles = ['OpenStreetMap', 'Stamen Terrain', 'Stamen Toner']
        for tiles in default_tiles:
            map = folium.Map(location=[45.5236, -122.6750], tiles=tiles)
            tiles = ''.join(tiles.lower().strip().split())
            url = map.tile_types[tiles]['templ'].render()
            attr = map.tile_types[tiles]['attr'].render()

            assert map.template_vars['Tiles'] == url
            assert map.template_vars['attr'] == attr

    def test_custom_tile(self):
        '''Test custom tile URLs'''

        url = u'http://{s}.custom_tiles.org/{z}/{x}/{y}.png'
        attr = 'Attribution for custom tiles'

        nt.assert_raises(ValueError, callableObj=folium.Map,
                         location=[45.5236, -122.6750], tiles=url)

        map = folium.Map(location=[45.52, -122.67], tiles=url, attr=attr)
        assert map.template_vars['Tiles'] == url
        assert map.template_vars['attr'] == attr

    def test_simple_marker(self):
        '''Test simple marker addition'''

        mark_templ = self.env.get_template('simple_marker.js')
        popup_templ = self.env.get_template('simple_popup.js')

        #Single Simple marker
        self.map.simple_marker(location=[45.50, -122.7])
        mark_1 = mark_templ.render({'marker': 'marker_1', 'lat': 45.50,
                                    'lon': -122.7})
        popup_1 = popup_templ.render({'pop_name': 'marker_1',
                                      'pop_txt': 'Pop Text'})
        assert self.map.template_vars['markers'][0][0] == mark_1
        assert self.map.template_vars['markers'][0][1] == popup_1

        #Test Simple marker addition
        self.map.simple_marker(location=[45.60, -122.8], popup='Hi')
        mark_2 = mark_templ.render({'marker': 'marker_2', 'lat': 45.60,
                                    'lon': -122.8})
        popup_2 = popup_templ.render({'pop_name': 'marker_2',
                                      'pop_txt': 'Hi'})
        assert self.map.mark_cnt['simple'] == 2
        assert self.map.template_vars['markers'][1][0] == mark_2
        assert self.map.template_vars['markers'][1][1] == popup_2

        #Test no popup
        self.map.simple_marker(location=[45.60, -122.8], popup_on=False)
        assert self.map.template_vars['markers'][2][1] == 'var no_pop = null;'

    def test_circle_marker(self):
        '''Test circle marker additions'''

        circ_templ = self.env.get_template('circle_marker.js')

        #Single Circle marker
        self.map.circle_marker(location=[45.60, -122.8], popup='Hi')
        circle_1 = circ_templ.render({'circle': 'circle_1', 'lat': 45.60,
                                      'lon': -122.8, 'radius': 500,
                                      'line_color': 'black',
                                      'fill_color': 'black',
                                      'fill_opacity': 0.6})
        assert self.map.template_vars['markers'][0][0] == circle_1

        #Second circle marker
        self.map.circle_marker(location=[45.70, -122.9], popup='Hi')
        circle_2 = circ_templ.render({'circle': 'circle_2', 'lat': 45.70,
                                      'lon': -122.9, 'radius': 500,
                                      'line_color': 'black',
                                      'fill_color': 'black',
                                      'fill_opacity': 0.6})
        assert self.map.template_vars['markers'][1][0] == circle_2

    def test_poly_marker(self):
        '''Test polygon marker'''

        poly_temp = self.env.get_template('poly_marker.js')

        polygon = poly_temp.render({'marker': 'polygon_1',
                                    'lat': 45.5,
                                    'lon': -122.5,
                                    'line_color': 'black',
                                    'line_opacity': 1,
                                    'line_weight': 2,
                                    'fill_color': 'blue',
                                    'fill_opacity': 1,
                                    'num_sides': 4,
                                    'rotation': 0,
                                    'radius': 15})

        self.map.polygon_marker(location=[45.5, -122.5])
        assert self.map.template_vars['markers'][0][0] == polygon

    def test_latlng_pop(self):
        '''Test lat/lon popovers'''

        self.map.lat_lng_popover()
        pop_templ = self.env.get_template('lat_lng_popover.js').render()
        assert self.map.template_vars['lat_lng_pop'] == pop_templ

    def test_click_for_marker(self):
        '''Test click for marker functionality'''

        #lat/lng popover
        self.map.click_for_marker()
        click_templ = self.env.get_template('click_for_marker.js')
        click = click_templ.render({'popup': ('"Latitude: " + lat + "<br>'
                                              'Longitude: " + lng ')})
        assert self.map.template_vars['click_pop'] == click

        #Custom popover
        self.map.click_for_marker(popup='Test')
        click_templ = self.env.get_template('click_for_marker.js')
        click = click_templ.render({'popup': '"Test"'})
        assert self.map.template_vars['click_pop'] == click

    def test_vega_popup(self):
        '''Test vega popups'''

        vis = vincent.Bar()

        self.map.simple_marker(location=[45.60, -122.8], popup=(vis, 'vis.json'))
        popup_temp = self.env.get_template('vega_marker.js')
        vega = popup_temp.render({'mark': 'marker_1', 'div_id': 'vis',
                                  'width': 675, 'height': 350,
                                  'max_width': 900,
                                  'json_out': 'vis.json',
                                  'vega_id': '#vis'})
        assert self.map.template_vars['markers'][0][1] == vega

    def test_geo_json(self):
        '''Test geojson  method'''

        path = 'us-counties.json'
        geo_path = ".defer(d3.json, '{0}')".format(path)

        #No data binding
        self.map.geo_json(geo_path=path)
        geo_path = ".defer(d3.json, '{0}')".format(path)
        map_var = 'gjson_1'
        layer_var = 'gjson_1'
        style_temp = self.env.get_template('geojson_style.js')
        style = style_temp.render({'style': 'style_1',
                                   'line_color': 'black',
                                   'line_weight': 1,
                                   'line_opacity': 1,
                                   'fill_color': 'blue',
                                   'fill_opacity': 0.6})
        layer = ('gJson_layer_{0} = L.geoJson({1}, {{style: {2}}}).addTo(map)'
                 .format(1, layer_var, 'style_1'))

        templ = self.map.template_vars
        assert self.map.map_type == 'geojson'
        assert templ['func_vars'][0] == map_var
        assert templ['geo_styles'][0] == style
        assert templ['gjson_layers'][0] == layer
        assert templ['json_paths'][0] == geo_path

        #Data binding incorrect color value error
        data = setup_data()
        nt.assert_raises(ValueError, self.map.geo_json,
                         path, data=data,
                         columns=['FIPS_Code', 'Unemployed_2011'],
                         key_on='feature.id', fill_color='blue')

        #Data binding threshold_scale too long
        data = setup_data()
        nt.assert_raises(ValueError, self.map.geo_json,
                         path, data=data,
                         columns=['FIPS_Code', 'Unemployed_2011'],
                         key_on='feature.id',
                         threshold_scale=[1, 2, 3, 4, 5, 6, 7],
                         fill_color='YlGnBu')

        #With DataFrame data binding, default threshold scale
        self.map.geo_json(geo_path=path, data=data,
                          columns=['FIPS_Code', 'Unemployed_2011'],
                          key_on='feature.id', fill_color='YlGnBu',
                          reset=True)
        geo_path = ".defer(d3.json, '{0}')".format(path)
        data_path = ".defer(d3.json, '{0}')".format('data.json')
        map_var = 'gjson_1'
        layer_var = 'gjson_1'
        data_var = 'data_1'

        domain = [4.0, 1000.0, 3000.0, 5000.0, 9000.0]
        palette = folium.utilities.color_brewer('YlGnBu')
        d3range = palette[0: len(domain) + 1]
        color_temp = self.env.get_template('d3_threshold.js')
        scale = color_temp.render({'domain': domain,
                                   'range': d3range})

        style_temp = self.env.get_template('geojson_style.js')
        color = 'matchKey(feature.id, data_1)'
        style = style_temp.render({'style': 'style_1',
                                   'line_color': 'black',
                                   'line_weight': 1,
                                   'line_opacity': 1,
                                   'quantize_fill': color,
                                   'fill_opacity': 0.6})

        layer = ('gJson_layer_{0} = L.geoJson({1}, {{style: {2}}}).addTo(map)'
                 .format(1, layer_var, 'style_1'))

        templ = self.map.template_vars
        assert templ['func_vars'] == [data_var, map_var]
        assert templ['geo_styles'][0] == style
        assert templ['gjson_layers'][0] == layer
        assert templ['json_paths'] == [data_path, geo_path]
        assert templ['color_scales'][0] == scale

        #Adding TopoJSON as additional layer
        path_2 = 'or_counties_topo.json'
        self.map.geo_json(geo_path=path_2, topojson='objects.or_counties_geo')
        geo_path_2 = ".defer(d3.json, '{0}')".format(path_2)
        map_var_2 = 'tjson_2'
        layer_var_2 = 'topo_2'
        topo_func = ('topo_2 = topojson.feature(tjson_2,'
                     ' tjson_2.objects.or_counties_geo);')
        layer_2 = ('gJson_layer_{0} = L.geoJson({1}, {{style: {2}}}).addTo(map)'
                   .format(2, layer_var_2, 'style_2'))

        templ = self.map.template_vars
        assert templ['func_vars'] == [data_var, map_var, map_var_2]
        assert templ['gjson_layers'][1] == layer_2
        assert templ['json_paths'] == [data_path, geo_path, geo_path_2]
        assert templ['topo_convert'][0] == topo_func

    def test_map_build(self):
        '''Test map build'''

        #Standard map
        self.map._build_map()
        html_templ = self.env.get_template('fol_template.html')

        tmpl = {'Tiles': u'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                'attr': (u'Map data (c) <a href="http://openstreetmap.org">'
                'OpenStreetMap</a> contributors'),
                'lat': 45.5236, 'lon': -122.675, 'max_zoom': 20,
                'size': 'style="width: 900px; height: 400px"',
                'zoom_level': 4}
        HTML = html_templ.render(tmpl)

        assert self.map.HTML == HTML

########NEW FILE########
