__FILENAME__ = completions
from __future__ import absolute_import, unicode_literals, print_function, division

import sublime
import sublime_plugin

    

class SublimeREPLCompletions(sublime_plugin.EventListener):
    def on_query_completions(self, view, prefix, locations):
        try:
            from .sublimerepl import manager
        except ValueError:
            from sublimerepl import manager
            
        if not view.settings().get("repl"):
            return True

        rv = manager.repl_view(view)
        if not rv:
            return []

        repl = rv.repl
        if not repl.autocomplete_available():
            return []

        line = view.line(locations[0])

        start = max(line.begin(), rv._output_end)
        end = line.end()

        whole_line = view.substr(sublime.Region(start, end))
        pos_in_line = locations[0] - start
        whole_prefix = whole_line[:pos_in_line]

        completions = repl.autocomplete_completions(
            whole_line=whole_line,
            pos_in_line=pos_in_line,
            prefix=prefix,
            whole_prefix=whole_prefix,
            locations=locations)
        return completions, sublime.INHIBIT_WORD_COMPLETIONS | sublime.INHIBIT_EXPLICIT_COMPLETIONS

########NEW FILE########
__FILENAME__ = ipy_repl
import os
import sys
import json
import socket
import threading

activate_this = os.environ.get("SUBLIMEREPL_ACTIVATE_THIS", None)

# turn off pager
os.environ['TERM'] = 'emacs'

if activate_this:
    with open(activate_this, "r") as f:
        exec(f.read(), {"__file__": activate_this})

try:
    import IPython
    IPYTHON = True
except ImportError:
    IPYTHON = False

if not IPYTHON:
    # for virtualenvs w/o IPython
    import code
    code.InteractiveConsole().interact()

from IPython.config.loader import Config

editor = "subl -w"

cfg = Config()
cfg.InteractiveShell.use_readline = False
cfg.InteractiveShell.autoindent = False
cfg.InteractiveShell.colors = "NoColor"
cfg.InteractiveShell.editor = os.environ.get("SUBLIMEREPL_EDITOR", editor)

try:
    # IPython 1.0.0
    from IPython.terminal.console.app import ZMQTerminalIPythonApp

    def kernel_client(zmq_shell):
        return zmq_shell.kernel_client
except ImportError:
    # Older IPythons
    from IPython.frontend.terminal.console.app import ZMQTerminalIPythonApp

    def kernel_client(zmq_shell):
        return zmq_shell.kernel_manager


embedded_shell = ZMQTerminalIPythonApp(config=cfg, user_ns={})
embedded_shell.initialize()

if os.name == "nt":
    # OMG what a fugly hack
    import IPython.utils.io as io
    io.stdout = io.IOStream(sys.__stdout__, fallback=io.devnull)
    io.stderr = io.IOStream(sys.__stderr__, fallback=io.devnull)
    embedded_shell.shell.show_banner()  # ... my eyes, oh my eyes..


ac_port = int(os.environ.get("SUBLIMEREPL_AC_PORT", "0"))
ac_ip = os.environ.get("SUBLIMEREPL_AC_IP", "127.0.0.1")
if ac_port:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ac_ip, ac_port))


def read_netstring(s):
    size = 0
    while True:
        ch = s.recv(1)
        if ch == b':':
            break
        size = size * 10 + int(ch)
    msg = b""
    while size != 0:
        msg += s.recv(size)
        size -= len(msg)
    ch = s.recv(1)
    assert ch == b','
    return msg


def send_netstring(sock, msg):
    payload = b"".join([str(len(msg)).encode("ascii"), b':', msg.encode("utf-8"), b','])
    sock.sendall(payload)


def complete(zmq_shell, req):
    kc = kernel_client(zmq_shell)
    msg_id = kc.shell_channel.complete(**req)
    msg = kc.shell_channel.get_msg(timeout=10)
    if msg['parent_header']['msg_id'] == msg_id:
        return msg["content"]["matches"]
    return []


def handle():
    while True:
        msg = read_netstring(s).decode("utf-8")
        try:
            req = json.loads(msg)
            completions = complete(embedded_shell, req)
            result = (req["text"], completions)
            res = json.dumps(result)
            send_netstring(s, res)
        except Exception:
            send_netstring(s, "[]")

if ac_port:
    t = threading.Thread(target=handle)
    t.start()

embedded_shell.start()

if ac_port:
    s.close()

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# SublimeREPL documentation build configuration file, created by
# sphinx-quickstart on Sun Feb 26 16:38:41 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'SublimeREPL'
copyright = '2012, Wojciech Bederski'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0.30'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'SublimeREPLdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'SublimeREPL.tex', 'SublimeREPL Documentation',
   'Wojciech Bederski', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'sublimerepl', 'SublimeREPL Documentation',
     ['Wojciech Bederski'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'SublimeREPL', 'SublimeREPL Documentation',
   'Wojciech Bederski', 'SublimeREPL', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = lang_integration
from __future__ import absolute_import, unicode_literals, print_function, division
import sublime
import sublime_plugin

import re
import os
import glob
import os.path
import socket
from functools import partial
from contextlib import closing

SETTINGS_FILE = "SublimeREPL.sublime-settings"

class ClojureAutoTelnetRepl(sublime_plugin.WindowCommand):
    def is_running(self, port_str):
        """Check if port is open on localhost"""
        port = int(port_str)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        res = s.connect_ex(("127.0.0.1", port))
        s.close()
        return res == 0

    def choices(self):
        choices = []
        for folder in self.window.folders():
            proj_file = os.path.join(folder, "project.clj")
            try:
                with open(proj_file) as f:
                    data = f.read()
                    port_match = re.search(":repl-port\s+(\d{1,})", data)
                    if not port_match:
                        continue
                    port = port_match.group(1)
                    description = proj_file
                    desc_match = re.search(r':description\s+"([^"]+)"', data)
                    if desc_match:
                        description = desc_match.group(1)
                    if self.is_running(port):
                        description += " (active)"
                    else:
                        description += " (not responding)"
                    choices.append([description, port])
            except IOError as e:
                pass  # just ignore it, no file or no access

        return choices + [["Custom telnet", "Pick your own telnet port number to Lein REPL"]]

    def run(self):
        choices = self.choices()
        if len(choices) == 1: #only custom telnet action
            self.on_done(choices, 0)
        else:
            on_done = partial(self.on_done, choices)
            self.window.show_quick_panel(self.choices(), on_done)

    def on_done(self, choices, index):
        if index == -1:
            return
        if index == len(choices) - 1:
            self.window.show_input_panel("Enter port number", "",
                                         self.open_telnet_repl,
                                         None, None)
            return
        self.open_telnet_repl(choices[index][1])

    def open_telnet_repl(self, port_str):
        try:
            port = int(port_str)
        except ValueError:
            return
        self.window.run_command("repl_open", {"type":"telnet", "encoding":"utf8", "host":"localhost", "port":port,
                                "external_id":"clojure", "syntax":"Packages/Clojure/Clojure.tmLanguage"})


def scan_for_virtualenvs(venv_paths):
    bin_dir = "Scripts" if os.name == "nt" else "bin"
    found_dirs = set()
    for venv_path in venv_paths:
        p = os.path.expanduser(venv_path)
        pattern = os.path.join(p, "*", bin_dir, "activate_this.py")
        found_dirs.update(list(map(os.path.dirname, glob.glob(pattern))))
    return sorted(found_dirs)


class PythonVirtualenvRepl(sublime_plugin.WindowCommand):
    def _scan(self):
        venv_paths = sublime.load_settings(SETTINGS_FILE).get("python_virtualenv_paths", [])
        return scan_for_virtualenvs(venv_paths)

    def run_virtualenv(self, choices, index):
        if index == -1:
            return
        (name, directory) = choices[index]
        activate_file = os.path.join(directory, "activate_this.py")
        python_executable = os.path.join(directory, "python")
        path_separator = ":"
        if os.name == "nt":
            python_executable += ".exe"  # ;-)
            path_separator = ";"

        self.window.run_command("repl_open",
            {
                "encoding":"utf8",
                "type": "subprocess",
                "autocomplete_server": True,
                "extend_env": {
                    "PATH": directory + path_separator + "{PATH}",
                    "SUBLIMEREPL_ACTIVATE_THIS": activate_file,
                    "PYTHONIOENCODING": "utf-8"
                },
                "cmd": [python_executable, "-u", "${packages}/SublimeREPL/config/Python/ipy_repl.py"],
                "cwd": "$file_path",
                "encoding": "utf8",
                "syntax": "Packages/Python/Python.tmLanguage",
                "external_id": "python"
             })

    def run(self):
        choices = self._scan()
        nice_choices = [[path.split(os.path.sep)[-2], path] for path in choices]
        self.window.show_quick_panel(nice_choices, partial(self.run_virtualenv, nice_choices))


VENV_SCAN_CODE = """
import os
import glob
import os.path

venv_paths = channel.receive()
bin_dir = "Scripts" if os.name == "nt" else "bin"
found_dirs = set()
for venv_path in venv_paths:
    p = os.path.expanduser(venv_path)
    pattern = os.path.join(p, "*", bin_dir, "activate_this.py")
    found_dirs.update(map(os.path.dirname, glob.glob(pattern)))

channel.send(found_dirs)
channel.close()

"""

class ExecnetVirtualenvRepl(sublime_plugin.WindowCommand):
    def run(self):
        self.window.show_input_panel("SSH connection (eg. user@host)", "", self.on_ssh_select, None, None)

    def on_ssh_select(self, host_string):
        import execnet
        venv_paths = sublime.load_settings(SETTINGS_FILE).get("python_virtualenv_paths", [])
        try:
            gw = execnet.makegateway("ssh=" + host_string)
            ch = gw.remote_exec(VENV_SCAN_CODE)
        except Exception as e:
            sublime.error_message(repr(e))
            return

        with closing(ch):
            ch.send(venv_paths)
            directories = ch.receive(60)
        gw.exit()

        choices = [[host_string + ":" + path.split(os.path.sep)[-2], path] for path in sorted(directories)]
        nice_choices = [["w/o venv", "n/a"]] + choices
        self.window.show_quick_panel(nice_choices, partial(self.run_virtualenv, host_string, nice_choices))

    def run_virtualenv(self, host_string, nice_choices, index):
        if index == -1:
            return
        if index == 0:
            connection_string = "ssh={host}".format(host=host_string)
            ps1 = "({host}@) >>> ".format(host=host_string)
            activate_file = ""
        else:
            (name, directory) = nice_choices[index]
            activate_file = os.path.join(directory, "activate_this.py")
            python_file = os.path.join(directory, "python")
            ps1 = "({name}) >>> ".format(name=name, host=host_string)
            connection_string = "ssh={host}//env:PATH={dir}//python={python}".format(
                host=host_string,
                dir=directory,
                python=python_file
            )

        self.window.run_command("repl_open",
                 {
                  "type": "execnet_repl",
                  "encoding": "utf8",
                  "syntax": "Packages/Python/Python.tmLanguage",
                  "connection_string": connection_string,
                  "activate_file": activate_file,
                  "ps1": ps1
                 })






########NEW FILE########
__FILENAME__ = PyDbLite
"""PyDbLite.py for Python 3

BSD licence

Author : Pierre Quentel (pierre.quentel@gmail.com)

In-memory database management, with selection by list comprehension 
or generator expression

Fields are untyped : they can store anything that can be pickled.
Selected records are returned as dictionaries. Each record is 
identified by a unique id and has a version number incremented
at every record update, to detect concurrent access

Syntax :
    from PyDbLite import Base
    db = Base('dummy')
    # create new base with field names
    db.create('name','age','size')
    # existing base
    db.open()
    # insert new record
    db.insert(name='homer',age=23,size=1.84)
    # records are dictionaries with a unique integer key __id__
    # simple selection by field value
    records = db(name="homer")
    # complex selection by list comprehension
    res = [ r for r in db if 30 > r['age'] >= 18 and r['size'] < 2 ]
    # or generator expression
    for r in (r for r in db if r['name'] in ('homer','marge') ):
    # delete a record or a list of records
    db.delete(one_record)
    db.delete(list_of_records)
    # delete a record by its id
    del db[rec_id]
    # direct access by id
    record = db[rec_id] # the record such that record['__id__'] == rec_id
    # create an index on a field
    db.create_index('age')
    # update
    db.update(record,age=24)
    # add and drop fields
    db.add_field('new_field',default=0)
    db.drop_field('name')
    # save changes on disk
    db.commit()

version 1.0 : first port from Python2 to Python3
"""

version = "1.0"

import os
import pickle
import bisect
    
class Index:
    """Class used for indexing a base on a field
    The instance of Index is an attribute the Base instance"""

    def __init__(self,db,field):
        self.db = db # database object (instance of Base)
        self.field = field # field name

    def __iter__(self):
        return self
    
    def __next__(self):
        return iter(self.db.indices[self.field]).__next__()

    def keys(self):
        return self.db.indices[self.field].keys()

    def __getitem__(self,key):
        """Lookup by key : return the list of records where
        field value is equal to this key, or an empty list"""
        ids = self.db.indices[self.field].get(key,[])
        return [ self.db.records[_id] for _id in ids ]

    def __contains__(self,key):
        return key in self.db.indices[self.field]

class Tester:

    def __init__(self,db,key):
        self.db = db
        self.key = key
        self.records = db.records.values()

    def __eq__(self,other):
        if len(self.records)==len(self.db.records):
            # use db indices if applicable
            self.records = eval ("self.db(%s=other)" %self.key)
        else:
            self.records = [r for r in self.records if r[self.key]==other]
        return self

    def __ne__(self,other):
        self.records = [r for r in self.records if r[self.key]!=other]
        return self

    def __lt__(self,other):
        recs = []
        for r in self.records:
            try:
                if r[self.key]<other:
                    recs.append(r)
            except TypeError:
                continue
        self.records = recs
        return self

    def __le__(self,other):
        recs = []
        for r in self.records:
            try:
                if r[self.key]<=other:
                    recs.append(r)
            except TypeError:
                continue
        self.records = recs
        return self

    def __gt__(self,other):
        recs = []
        for r in self.records:
            try:
                if r[self.key]>other:
                    recs.append(r)
            except TypeError:
                continue
        self.records = recs
        return self
        
    def __ge__(self,other):
        recs = []
        for r in self.records:
            try:
                if r[self.key]>=other:
                    recs.append(r)
            except TypeError:
                continue
        self.records = recs
        return self

    def __and__(self,other_tester):
        ids1 = dict([(id(r),r) for r in self.records])
        ids2 = dict([(id(r),r) for r in other_tester.records])
        ids = set(ids1.keys()) & set(ids2.keys())
        res = Tester(self.db,self.key)
        res.records = [ids1[_id] for _id in ids]
        return res

    def __or__(self,other_tester):
        ids = dict([(id(r),r) for r in self.records])
        ids.update(dict([(id(r),r) for r in other_tester.records]))
        res = Tester(self.db,self.key)
        res.records = ids.values()
        return res

    def extract(self,*fields):
        return [ [r[f] for f in fields] for r in self.records ]

    def __len__(self):
        return len(self.records)

    def __iter__(self):
        return iter(self.records)

class Base:

    def __init__(self,basename,protocol=pickle.HIGHEST_PROTOCOL):
        """protocol as defined in pickle / pickle
        Defaults to the highest protocol available
        For maximum compatibility use protocol = 0"""
        self.name = basename
        self.protocol = protocol

    def create(self,*fields,**kw):
        """Create a new base with specified field names
        A keyword argument mode can be specified ; it is used if a file
        with the base name already exists
        - if mode = 'open' : open the existing base, ignore the fields
        - if mode = 'override' : erase the existing base and create a
        new one with the specified fields"""
        self.mode = mode = kw.get("mode",None)
        if os.path.exists(self.name):
            if not os.path.isfile(self.name):
                raise IOError("%s exists and is not a file" %self.name)
            elif mode is None:
                raise IOError("Base %s already exists" %self.name)
            elif mode == "open":
                return self.open()
            elif mode == "override":
                os.remove(self.name)
        self.fields = list(fields)
        self.records = {}
        self.next_id = 0
        self.indices = {}
        self.commit()
        return self

    def create_index(self,*fields):
        """Create an index on the specified field names
        
        An index on a field is a mapping between the values taken by the field
        and the sorted list of the ids of the records whose field is equal to 
        this value
        
        For each indexed field, an attribute of self is created, an instance 
        of the class Index (see above). Its name it the field name, with the
        prefix _ to avoid name conflicts
        """
        reset = False
        for f in fields:
            if not f in self.fields:
                raise NameError("%s is not a field name %s" %(f,self.fields))
            # initialize the indices
            if self.mode == "open" and f in self.indices:
                continue
            reset = True
            self.indices[f] = {}
            for _id,record in self.records.items():
                # use bisect to quickly insert the id in the list
                bisect.insort(self.indices[f].setdefault(record[f],[]),
                    _id)
            # create a new attribute of self, used to find the records
            # by this index
            setattr(self,'_'+f,Index(self,f))
        if reset:
            self.commit()

    def delete_index(self,*fields):
        """Delete the index on the specified fields"""
        for f in fields:
            if not f in self.indices:
                raise ValueError("No index on field %s" %f)
        for f in fields:
            del self.indices[f]
        self.commit()

    def open(self):
        """Open an existing database and load its content into memory"""
        # guess protocol
        _in = open(self.name,'rb') # binary mode
        self.fields = pickle.load(_in)
        self.next_id = pickle.load(_in)
        self.records = pickle.load(_in)
        self.indices = pickle.load(_in)
        for f in self.indices.keys():
            setattr(self,'_'+f,Index(self,f))
        _in.close()
        self.mode = "open"
        return self

    def commit(self):
        """Write the database to a file"""
        out = open(self.name,'wb')
        pickle.dump(self.fields,out,self.protocol)
        pickle.dump(self.next_id,out,self.protocol)
        pickle.dump(self.records,out,self.protocol)
        pickle.dump(self.indices,out,self.protocol)
        out.close()

    def insert(self,*args,**kw):
        """Insert a record in the database
        Parameters can be positional or keyword arguments. If positional
        they must be in the same order as in the create() method
        If some of the fields are missing the value is set to None
        Returns the record identifier
        """
        if args:
            kw = dict([(f,arg) for f,arg in zip(self.fields,args)])
        # initialize all fields to None
        record = dict([(f,None) for f in self.fields])
        # raise exception if unknown field
        for key in kw:
            if not key in self.fields:
                raise NameError("Invalid field name : %s" %key)
        # set keys and values
        for (k,v) in kw.items():
            record[k]=v
        # add the key __id__ : record identifier
        record['__id__'] = self.next_id
        # add the key __version__ : version number
        record['__version__'] = 0
        # create an entry in the dictionary self.records, indexed by __id__
        self.records[self.next_id] = record
        # update index
        for ix in self.indices.keys():
            bisect.insort(self.indices[ix].setdefault(record[ix],[]),
                self.next_id)
        # increment the next __id__
        self.next_id += 1
        return record['__id__']

    def delete(self,removed):
        """Remove a single record, or the records in an iterable
        Before starting deletion, test if all records are in the base
        and don't have twice the same __id__
        Return the number of deleted items
        """
        if isinstance(removed,dict):
            # remove a single record
            removed = [removed]
        else:
            # convert iterable into a list (to be able to sort it)
            removed = [ r for r in removed ]
        if not removed:
            return 0
        _ids = [ r['__id__'] for r in removed ]
        _ids.sort()
        keys = set(self.records.keys())
        # check if the records are in the base
        if not set(_ids).issubset(keys):
            missing = list(set(_ids).difference(keys))
            raise IndexError('Delete aborted. Records with these ids' \
                ' not found in the base : %s' %str(missing))
        # raise exception if duplicate ids
        for i in range(len(_ids)-1):
            if _ids[i] == _ids[i+1]:
                raise IndexError("Delete aborted. Duplicate id : %s" %_ids[i])
        deleted = len(removed)
        while removed:
            r = removed.pop()
            _id = r['__id__']
            # remove id from indices
            for indx in self.indices.keys():
                pos = bisect.bisect(self.indices[indx][r[indx]],_id)-1
                del self.indices[indx][r[indx]][pos]
                if not self.indices[indx][r[indx]]:
                    del self.indices[indx][r[indx]]
            # remove record from self.records
            del self.records[_id]
        return deleted

    def update(self,records,**kw):
        """Update one record of a list of records 
        with new keys and values and update indices"""
        # ignore unknown fields
        kw = dict([(k,v) for (k,v) in kw.items() if k in self.fields])
        if isinstance(records,dict):
            records = [ records ]
        # update indices
        for indx in set(self.indices.keys()) & set (kw.keys()):
            for record in records:
                if record[indx] == kw[indx]:
                    continue
                _id = record["__id__"]
                # remove id for the old value
                old_pos = bisect.bisect(self.indices[indx][record[indx]],_id)-1
                del self.indices[indx][record[indx]][old_pos]
                if not self.indices[indx][record[indx]]:
                    del self.indices[indx][record[indx]]
                # insert new value
                bisect.insort(self.indices[indx].setdefault(kw[indx],[]),_id)
        for record in records:
            # update record values
            record.update(kw)
            # increment version number
            record["__version__"] += 1

    def add_field(self,field,default=None):
        if field in self.fields + ["__id__","__version__"]:
            raise ValueError("Field %s already defined" %field)
        for r in self:
            r[field] = default
        self.fields.append(field)
        self.commit()
    
    def drop_field(self,field):
        if field in ["__id__","__version__"]:
            raise ValueError("Can't delete field %s" %field)
        self.fields.remove(field)
        for r in self:
            del r[field]
        if field in self.indices:
            del self.indices[field]
        self.commit()

    def __call__(self,*args,**kw):
        """Selection by field values
        db(key=value) returns the list of records where r[key] = value"""
        if args and kw:
            raise SyntaxError("Can't specify positional AND keyword arguments")
        if args:
            if len(args)>1:
                raise SyntaxError("Only one field can be specified")
            elif args[0] not in self.fields:
                raise ValueError("%s is not a field" %args[0])
            else:
                return Tester(self,args[0])
        if not kw:
            return self.records.values() # db() returns all the values
        # indices and non-indices
        keys = kw.keys()
        ixs = set(keys) & set(self.indices.keys())
        no_ix = set(keys) - ixs
        if ixs:
            # fast selection on indices
            ix = ixs.pop()
            res = set(self.indices[ix].get(kw[ix],[]))
            if not res:
                return []
            while ixs:
                ix = ixs.pop()
                res = res & set(self.indices[ix].get(kw[ix],[]))
        else:
            # if no index, initialize result with test on first field
            field = no_ix.pop()
            res = set([r["__id__"] for r in self if r[field] == kw[field] ])
        # selection on non-index fields
        for field in no_ix:
            res = res & set([ _id for _id in res 
                if self.records[_id][field] == kw[field] ])
        return [ self[_id] for _id in res ]
    
    def __getitem__(self,key):
        # direct access by record id
        if key < 0:
            key = len(self)+key
        return self.records[key]
    
    def __len__(self):
        return len(self.records)

    def __delitem__(self,record_id):
        """Delete by record id"""
        self.delete(self[record_id])
        
    def __contains__(self,record_id):
        return record_id in self.records

    def __iter__(self):
        """Iteration on records"""
        return self.records.values().__iter__()

if __name__ == '__main__':
    with open('PyDbLite_test.py') as fh:
        exec(fh.read())
########NEW FILE########
__FILENAME__ = autocomplete_server
# -*- coding: utf-8 -*-

import json
import socket
import threading
import sublime

def read_netstring(s):
    size = 0
    while True:
        byte = s.recv(1)
        if byte == b':':
            break
        size = size * 10 + int(byte)
    msg = b""
    while size != 0:
        msg += s.recv(size)
        size -= len(msg)
    byte = s.recv(1)
    assert byte == b','
    return msg.decode("utf-8")

def send_netstring(s, msg):
    payload = "".join([str(len(msg)), ':', msg, ',']).encode("utf-8")
    s.sendall(payload)


class AutocompleteServer(object):
    def __init__(self, repl, server_ip="127.0.0.1"):
        self._repl = repl
        self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._cli_sock = None
        self._server_ip = server_ip

    def start(self):
        self._sock.bind((self._server_ip, 0))
        threading.Thread(target=self._wait).start()

    def _wait(self):
        self._sock.listen(1)
        s, address = self._sock.accept()
        self._cli_sock = s

    def port(self):
        return self._sock.getsockname()[1]

    def connected(self):
        return bool(self._cli_sock)

    def complete(self, whole_line, pos_in_line, prefix, whole_prefix, locations):
        req = json.dumps({"text": "", "line": whole_line, "cursor_pos": pos_in_line})
        send_netstring(self._cli_sock, req)
        self._cli_sock.settimeout(4)
        msg = read_netstring(self._cli_sock)
        self._cli_sock.settimeout(None)
        res = json.loads(msg)
        if not res:
            return []
        return [(x, x) for x in res[1]]

########NEW FILE########
__FILENAME__ = execnet_repl
# encoding: utf-8
from . import repl
from queue import Queue
import sys
import execnet

REMOTE_CODE = """
from __future__ import with_statement
from __future__ import division
from __future__ import absolute_import
#if '{activate_file}':
#    execfile('{activate_file}', dict(__file__='{activate_file}'))

import code
import sys
import time
import contextlib
import threading
try:
    from Queue import Queue
except ImportError:
    from queue import Queue  # py3

class ChannelOut(object):
    def write(self, data):
        channel.send(data)
    def flush(self):
        pass

@contextlib.contextmanager
def redirect_stdio():
    orig = (sys.stdout, sys.stderr)
    sys.stdout = sys.stderr = ChannelOut()
    yield
    (sys.stdout, sys.stderr) = orig

class InterceptingConsole(code.InteractiveConsole):
    PS1 = "{ps1}"
    PS2 = "... "
    def __init__(self):
        code.InteractiveConsole.__init__(self)
        self.input = Queue()
        self.output = channel
        self.output.send(self.PS1)

    def write(self, data):
        self.output.send(data)

    def push(self, line):
        with redirect_stdio():
            more = code.InteractiveConsole.push(self, line)
        self.output.send(self.PS2 if more else self.PS1)
        return more

    def run(self):
        while True:
            line = self.input.get()
            if line is None:
                break
            self.push(line)


ic = InterceptingConsole()
_thread = threading.Thread(target=ic.run)
_thread.start()

channel.setcallback(ic.input.put, endmarker=None)

while not channel.isclosed():
    time.sleep(1.0)
"""


class ExecnetRepl(repl.Repl):
    TYPE = "execnet_repl"

    def __init__(self, encoding, connection_string=None, activate_file="", ps1=">>> "):
        super(ExecnetRepl, self).__init__(encoding, "python", "\n", False)
        self._connections_string = connection_string
        self._ps1 = ps1
        self._gw = execnet.makegateway(connection_string)
        remote_code = REMOTE_CODE.format(ps1=ps1, activate_file=activate_file)
        self._channel = self._gw.remote_exec(remote_code)
        self.output = Queue()
        self._channel.setcallback(self.output.put, endmarker=None)
        self._alive = True
        self._killed = False

    def name(self):
        return "execnet " + self._ps1.split()[0]

    def is_alive(self):
        return self._alive

    def write_bytes(self, bytes):
        if self._channel.isclosed():
            self._alive = False
        else:
            self._channel.send(bytes)

    def read_bytes(self):
        bytes = self.output.get()
        if bytes is None:
            self._gw.exit()
        else:
            return bytes

    def kill(self):
        self._killed = True
        self._channel.close()
        self._gw.exit()

########NEW FILE########
__FILENAME__ = killableprocess
# killableprocess - subprocesses which can be reliably killed
#
# Parts of this module are copied from the subprocess.py file contained
# in the Python distribution.
#
# Copyright (c) 2003-2004 by Peter Astrand <astrand@lysator.liu.se>
#
# Additions and modifications written by Benjamin Smedberg
# <benjamin@smedbergs.us> are Copyright (c) 2006 by the Mozilla Foundation
# <http://www.mozilla.org/>
#
# More Modifications
# Copyright (c) 2006-2007 by Mike Taylor <bear@code-bear.com>
# Copyright (c) 2007-2008 by Mikeal Rogers <mikeal@mozilla.com>
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of the
# author not be used in advertising or publicity pertaining to
# distribution of the software without specific, written prior
# permission.
#
# THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""killableprocess - Subprocesses which can be reliably killed

This module is a subclass of the builtin "subprocess" module. It allows
processes that launch subprocesses to be reliably killed on Windows (via the Popen.kill() method.

It also adds a timeout argument to Wait() for a limited period of time before
forcefully killing the process.

Note: On Windows, this module requires Windows 2000 or higher (no support for
Windows 95, 98, or NT 4.0). It also requires ctypes, which is bundled with
Python 2.5+ or available from http://python.net/crew/theller/ctypes/
"""

import subprocess
import sys
import os
import time
import datetime
import types

try:
    from subprocess import CalledProcessError
except ImportError:
    # Python 2.4 doesn't implement CalledProcessError
    class CalledProcessError(Exception):
        """This exception is raised when a process run by check_call() returns
        a non-zero exit status. The exit status will be stored in the
        returncode attribute."""
        def __init__(self, returncode, cmd):
            self.returncode = returncode
            self.cmd = cmd
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

mswindows = (sys.platform == "win32")
py2 = (sys.version_info[0] == 2)

if mswindows:
    from . import winprocess
else:
    import signal

def call(*args, **kwargs):
    waitargs = {}
    if "timeout" in kwargs:
        waitargs["timeout"] = kwargs.pop("timeout")

    return Popen(*args, **kwargs).wait(**waitargs)

def check_call(*args, **kwargs):
    """Call a program with an optional timeout. If the program has a non-zero
    exit status, raises a CalledProcessError."""

    retcode = call(*args, **kwargs)
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = args[0]
        raise CalledProcessError(retcode, cmd)

if not mswindows:
    def DoNothing(*args):
        pass

class Popen(subprocess.Popen):
    kill_called = False
    if mswindows:
        if py2:
            def _execute_child(self, args, executable, preexec_fn, close_fds,
                           cwd, env, universal_newlines, startupinfo,
                           creationflags, shell,
                           p2cread, p2cwrite,
                           c2pread, c2pwrite,
                           errread, errwrite):
                return self._execute_child_compat(args, executable, preexec_fn, close_fds,
                           cwd, env, universal_newlines, startupinfo,
                           creationflags, shell,
                           p2cread, p2cwrite,
                           c2pread, c2pwrite,
                           errread, errwrite)
        else:
            def _execute_child(self, args, executable, preexec_fn, close_fds,
                               pass_fds,
                               cwd, env,
                               startupinfo,
                               creationflags, shell,
                               p2cread, p2cwrite,
                               c2pread, c2pwrite,
                               errread, errwrite,
                               unused_restore_signals, unused_start_new_session):
                return self._execute_child_compat(args, executable, preexec_fn, close_fds,
                           cwd, env, True, startupinfo,
                           creationflags, shell,
                           p2cread, p2cwrite,
                           c2pread, c2pwrite,
                           errread, errwrite)


    if mswindows:
        def _execute_child_compat(self, args, executable, preexec_fn, close_fds,
                           cwd, env, universal_newlines, startupinfo,
                           creationflags, shell,
                           p2cread, p2cwrite,
                           c2pread, c2pwrite,
                           errread, errwrite):
            if not isinstance(args, str):
                args = subprocess.list2cmdline(args)

            # Always or in the create new process group
            creationflags |= winprocess.CREATE_NEW_PROCESS_GROUP

            if startupinfo is None:
                startupinfo = winprocess.STARTUPINFO()

            if None not in (p2cread, c2pwrite, errwrite):
                startupinfo.dwFlags |= winprocess.STARTF_USESTDHANDLES

                startupinfo.hStdInput = int(p2cread)
                startupinfo.hStdOutput = int(c2pwrite)
                startupinfo.hStdError = int(errwrite)
            if shell:
                startupinfo.dwFlags |= winprocess.STARTF_USESHOWWINDOW
                startupinfo.wShowWindow = winprocess.SW_HIDE
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                args = comspec + " /c " + args

            # determine if we can create create a job
            canCreateJob = winprocess.CanCreateJobObject()

            # set process creation flags
            creationflags |= winprocess.CREATE_SUSPENDED
            creationflags |= winprocess.CREATE_UNICODE_ENVIRONMENT
            if canCreateJob:
                creationflags |= winprocess.CREATE_BREAKAWAY_FROM_JOB

            # create the process
            hp, ht, pid, tid = winprocess.CreateProcess(
                executable, args,
                None, None, # No special security
                1, # Must inherit handles!
                creationflags,
                winprocess.EnvironmentBlock(env),
                cwd, startupinfo)
            self._child_created = True
            self._handle = int(hp)
            self._thread = ht
            self.pid = pid
            self.tid = tid
            
            if canCreateJob:
                # We create a new job for this process, so that we can kill
                # the process and any sub-processes
                self._job = winprocess.CreateJobObject()
                winprocess.AssignProcessToJobObject(self._job, int(hp))
            else:
                self._job = None

            winprocess.ResumeThread(int(ht))
            ht.Close()

            if p2cread is not None and p2cread != -1:
                p2cread.Close()
            if c2pwrite is not None and c2pwrite != -1:
                c2pwrite.Close()
            if errwrite is not None and errwrite != -1:
                errwrite.Close()
            time.sleep(.1)

    def kill(self, group=True):
        """Kill the process. If group=True, all sub-processes will also be killed."""
        self.kill_called = True
        if mswindows:
            if group and self._job:
                winprocess.TerminateJobObject(self._job, 127)
            else:
                try:
                    winprocess.TerminateProcess(self._handle, 127)
                except:
                    # TODO: better error handling here
                    pass
            self.returncode = 127
        else:
            if group:
                try:
                    os.killpg(self.pid, signal.SIGKILL)
                except: pass
            else:
                os.kill(self.pid, signal.SIGKILL)
            super(Popen, self).kill()
            self.returncode = -9

    def wait(self, timeout=None, group=True):
        """Wait for the process to terminate. Returns returncode attribute.
        If timeout seconds are reached and the process has not terminated,
        it will be forcefully killed. If timeout is -1, wait will not
        time out."""

        if timeout is not None:
            # timeout is now in milliseconds
            timeout = timeout * 1000

        if self.returncode is not None:
            return self.returncode

        starttime = datetime.datetime.now()

        if mswindows:
            if timeout is None:
                timeout = -1
            rc = winprocess.WaitForSingleObject(self._handle, timeout)

            if rc != winprocess.WAIT_TIMEOUT:
                def check():
                    now = datetime.datetime.now()
                    diff = now - starttime
                    if (diff.seconds * 1000 * 1000 + diff.microseconds) < (timeout * 1000):
                        if self._job:
                            if (winprocess.QueryInformationJobObject(self._job, 8)['BasicInfo']['ActiveProcesses'] > 0):
                                return True
                        else:
                            return True
                    return False
                while check():
                    time.sleep(.5)

            now = datetime.datetime.now()
            diff = now - starttime
            if (diff.seconds * 1000 * 1000 + diff.microseconds) > (timeout * 1000):
                self.kill(group)
            else:
                self.returncode = winprocess.GetExitCodeProcess(self._handle)
        else:
            if (sys.platform == 'linux2') or (sys.platform in ('sunos5', 'solaris')):
                def group_wait(timeout):
                    try:
                        os.waitpid(self.pid, 0)
                    except OSError as e:
                        pass # If wait has already been called on this pid, bad things happen
                    return self.returncode
            elif sys.platform == 'darwin':
                def group_wait(timeout):
                    try:
                        count = 0
                        if timeout is None and self.kill_called:
                            timeout = 10 # Have to set some kind of timeout or else this could go on forever
                        if timeout is None:
                            while 1:
                                os.killpg(self.pid, signal.SIG_DFL)
                        while ((count * 2) <= timeout):
                            os.killpg(self.pid, signal.SIG_DFL)
                            # count is increased by 500ms for every 0.5s of sleep
                            time.sleep(.5); count += 500
                    except OSError:
                        return self.returncode

            if timeout is None:
                if group is True:
                    return group_wait(timeout)
                else:
                    subprocess.Popen.wait(self)
                    return self.returncode

            returncode = False

            now = datetime.datetime.now()
            diff = now - starttime
            while (diff.seconds * 1000 * 1000 + diff.microseconds) < (timeout * 1000) and ( returncode is False ):
                if group is True:
                    return group_wait(timeout)
                else:
                    if subprocess.poll() is not None:
                        returncode = self.returncode
                time.sleep(.5)
                now = datetime.datetime.now()
                diff = now - starttime
            return self.returncode

        return self.returncode
    # We get random maxint errors from subprocesses __del__
    __del__ = lambda self: None

def setpgid_preexec_fn():
    os.setpgid(0, 0)

def runCommand(cmd, **kwargs):
    if sys.platform != "win32":
        return Popen(cmd, preexec_fn=setpgid_preexec_fn, **kwargs)
    else:
        return Popen(cmd, **kwargs)

########NEW FILE########
__FILENAME__ = qijo
from ctypes import c_void_p, POINTER, sizeof, Structure, windll, WinError, WINFUNCTYPE, addressof, c_size_t, c_ulong
from ctypes.wintypes import BOOL, BYTE, DWORD, HANDLE, LARGE_INTEGER

LPVOID = c_void_p
LPDWORD = POINTER(DWORD)
SIZE_T = c_size_t
ULONG_PTR = POINTER(c_ulong)

# A ULONGLONG is a 64-bit unsigned integer.
# Thus there are 8 bytes in a ULONGLONG.
# XXX why not import c_ulonglong ?
ULONGLONG = BYTE * 8

class IO_COUNTERS(Structure):
    # The IO_COUNTERS struct is 6 ULONGLONGs.
    # TODO: Replace with non-dummy fields.
    _fields_ = [('dummy', ULONGLONG * 6)]

class JOBOBJECT_BASIC_ACCOUNTING_INFORMATION(Structure):
    _fields_ = [('TotalUserTime', LARGE_INTEGER),
                ('TotalKernelTime', LARGE_INTEGER),
                ('ThisPeriodTotalUserTime', LARGE_INTEGER),
                ('ThisPeriodTotalKernelTime', LARGE_INTEGER),
                ('TotalPageFaultCount', DWORD),
                ('TotalProcesses', DWORD),
                ('ActiveProcesses', DWORD),
                ('TotalTerminatedProcesses', DWORD)]

class JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION(Structure):
    _fields_ = [('BasicInfo', JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
                ('IoInfo', IO_COUNTERS)]

# see http://msdn.microsoft.com/en-us/library/ms684147%28VS.85%29.aspx
class JOBOBJECT_BASIC_LIMIT_INFORMATION(Structure):
    _fields_ = [('PerProcessUserTimeLimit', LARGE_INTEGER),
                ('PerJobUserTimeLimit', LARGE_INTEGER),
                ('LimitFlags', DWORD),
                ('MinimumWorkingSetSize', SIZE_T),
                ('MaximumWorkingSetSize', SIZE_T),
                ('ActiveProcessLimit', DWORD),
                ('Affinity', ULONG_PTR),
                ('PriorityClass', DWORD),
                ('SchedulingClass', DWORD)
                ]

# see http://msdn.microsoft.com/en-us/library/ms684156%28VS.85%29.aspx
class JOBOBJECT_EXTENDED_LIMIT_INFORMATION(Structure):
    _fields_ = [('BasicLimitInformation', JOBOBJECT_BASIC_LIMIT_INFORMATION),
                ('IoInfo', IO_COUNTERS),
                ('ProcessMemoryLimit', SIZE_T),
                ('JobMemoryLimit', SIZE_T),
                ('PeakProcessMemoryUsed', SIZE_T),
                ('PeakJobMemoryUsed', SIZE_T)]

# XXX Magical numbers like 8 should be documented
JobObjectBasicAndIoAccountingInformation = 8

# ...like magical number 9 comes from
# http://community.flexerasoftware.com/archive/index.php?t-181670.html
# I wish I had a more canonical source
JobObjectExtendedLimitInformation = 9

class JobObjectInfo(object):
    mapping = { 'JobObjectBasicAndIoAccountingInformation': 8,
                'JobObjectExtendedLimitInformation': 9
                }
    structures = { 8: JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION,
                   9: JOBOBJECT_EXTENDED_LIMIT_INFORMATION
                   }
    def __init__(self, _class):
        if isinstance(_class, str):
            assert _class in self.mapping, 'Class should be one of %s; you gave %s' % (self.mapping, _class)
            _class = self.mapping[_class]
        assert _class in self.structures, 'Class should be one of %s; you gave %s' % (self.structures, _class)
        self.code = _class
        self.info = self.structures[_class]()
    

QueryInformationJobObjectProto = WINFUNCTYPE(
    BOOL,        # Return type
    HANDLE,      # hJob
    DWORD,       # JobObjectInfoClass
    LPVOID,      # lpJobObjectInfo
    DWORD,       # cbJobObjectInfoLength
    LPDWORD      # lpReturnLength
    )

QueryInformationJobObjectFlags = (
    (1, 'hJob'),
    (1, 'JobObjectInfoClass'),
    (1, 'lpJobObjectInfo'),
    (1, 'cbJobObjectInfoLength'),
    (1, 'lpReturnLength', None)
    )

_QueryInformationJobObject = QueryInformationJobObjectProto(
    ('QueryInformationJobObject', windll.kernel32),
    QueryInformationJobObjectFlags
    )

class SubscriptableReadOnlyStruct(object):
    def __init__(self, struct):
        self._struct = struct

    def _delegate(self, name):
        result = getattr(self._struct, name)
        if isinstance(result, Structure):
            return SubscriptableReadOnlyStruct(result)
        return result

    def __getitem__(self, name):
        match = [fname for fname, ftype in self._struct._fields_
                 if fname == name]
        if match:
            return self._delegate(name)
        raise KeyError(name)

    def __getattr__(self, name):
        return self._delegate(name)

def QueryInformationJobObject(hJob, JobObjectInfoClass):
    jobinfo = JobObjectInfo(JobObjectInfoClass)
    result = _QueryInformationJobObject(
        hJob=hJob,
        JobObjectInfoClass=jobinfo.code,
        lpJobObjectInfo=addressof(jobinfo.info),
        cbJobObjectInfoLength=sizeof(jobinfo.info)
        )
    if not result:
        raise WinError()
    return SubscriptableReadOnlyStruct(jobinfo.info)

def test_qijo():
    from .killableprocess import Popen

    popen = Popen('c:\\windows\\notepad.exe')

    try:
        result = QueryInformationJobObject(0, 8)
        raise AssertionError('throw should occur')
    except WindowsError as e:
        pass

    try:
        result = QueryInformationJobObject(0, 1)
        raise AssertionError('throw should occur')
    except NotImplementedError as e:
        pass

    result = QueryInformationJobObject(popen._job, 8)
    if result['BasicInfo']['ActiveProcesses'] != 1:
        raise AssertionError('expected ActiveProcesses to be 1')
    popen.kill()

    result = QueryInformationJobObject(popen._job, 8)
    if result.BasicInfo.ActiveProcesses != 0:
        raise AssertionError('expected ActiveProcesses to be 0')

########NEW FILE########
__FILENAME__ = winprocess
# A module to expose various thread/process/job related structures and
# methods from kernel32
#
# The MIT License
#
# Copyright (c) 2003-2004 by Peter Astrand <astrand@lysator.liu.se>
#
# Additions and modifications written by Benjamin Smedberg
# <benjamin@smedbergs.us> are Copyright (c) 2006 by the Mozilla Foundation
# <http://www.mozilla.org/>
#
# More Modifications
# Copyright (c) 2006-2007 by Mike Taylor <bear@code-bear.com>
# Copyright (c) 2007-2008 by Mikeal Rogers <mikeal@mozilla.com>
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of the
# author not be used in advertising or publicity pertaining to
# distribution of the software without specific, written prior
# permission.
#
# THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

from ctypes import c_void_p, POINTER, sizeof, Structure, windll, WinError, WINFUNCTYPE
from ctypes.wintypes import BOOL, BYTE, DWORD, HANDLE, LPCWSTR, LPWSTR, UINT, WORD
from .qijo import QueryInformationJobObject

LPVOID = c_void_p
LPBYTE = POINTER(BYTE)
LPDWORD = POINTER(DWORD)
LPBOOL = POINTER(BOOL)

def ErrCheckBool(result, func, args):
    """errcheck function for Windows functions that return a BOOL True
    on success"""
    if not result:
        raise WinError()
    return args


# AutoHANDLE

class AutoHANDLE(HANDLE):
    """Subclass of HANDLE which will call CloseHandle() on deletion."""
    
    CloseHandleProto = WINFUNCTYPE(BOOL, HANDLE)
    CloseHandle = CloseHandleProto(("CloseHandle", windll.kernel32))
    CloseHandle.errcheck = ErrCheckBool
    
    def Close(self):
        if self.value and self.value != HANDLE(-1).value:
            self.CloseHandle(self)
            self.value = 0
    
    def __del__(self):
        self.Close()

    def __int__(self):
        return self.value

def ErrCheckHandle(result, func, args):
    """errcheck function for Windows functions that return a HANDLE."""
    if not result:
        raise WinError()
    return AutoHANDLE(result)

# PROCESS_INFORMATION structure

class PROCESS_INFORMATION(Structure):
    _fields_ = [("hProcess", HANDLE),
                ("hThread", HANDLE),
                ("dwProcessID", DWORD),
                ("dwThreadID", DWORD)]

    def __init__(self):
        Structure.__init__(self)
        
        self.cb = sizeof(self)

LPPROCESS_INFORMATION = POINTER(PROCESS_INFORMATION)

# STARTUPINFO structure

class STARTUPINFO(Structure):
    _fields_ = [("cb", DWORD),
                ("lpReserved", LPWSTR),
                ("lpDesktop", LPWSTR),
                ("lpTitle", LPWSTR),
                ("dwX", DWORD),
                ("dwY", DWORD),
                ("dwXSize", DWORD),
                ("dwYSize", DWORD),
                ("dwXCountChars", DWORD),
                ("dwYCountChars", DWORD),
                ("dwFillAttribute", DWORD),
                ("dwFlags", DWORD),
                ("wShowWindow", WORD),
                ("cbReserved2", WORD),
                ("lpReserved2", LPBYTE),
                ("hStdInput", HANDLE),
                ("hStdOutput", HANDLE),
                ("hStdError", HANDLE)
                ]
LPSTARTUPINFO = POINTER(STARTUPINFO)

SW_HIDE                 = 0

STARTF_USESHOWWINDOW    = 0x01
STARTF_USESIZE          = 0x02
STARTF_USEPOSITION      = 0x04
STARTF_USECOUNTCHARS    = 0x08
STARTF_USEFILLATTRIBUTE = 0x10
STARTF_RUNFULLSCREEN    = 0x20
STARTF_FORCEONFEEDBACK  = 0x40
STARTF_FORCEOFFFEEDBACK = 0x80
STARTF_USESTDHANDLES    = 0x100

# EnvironmentBlock

class EnvironmentBlock:
    """An object which can be passed as the lpEnv parameter of CreateProcess.
    It is initialized with a dictionary."""

    def __init__(self, dict):
        if not dict:
            self._as_parameter_ = None
        else:
            values = ["%s=%s" % (key, value)
                      for (key, value) in dict.items()]
            values.append("")
            self._as_parameter_ = LPCWSTR("\0".join(values))
        
# CreateProcess()

CreateProcessProto = WINFUNCTYPE(BOOL,                  # Return type
                                 LPCWSTR,               # lpApplicationName
                                 LPWSTR,                # lpCommandLine
                                 LPVOID,                # lpProcessAttributes
                                 LPVOID,                # lpThreadAttributes
                                 BOOL,                  # bInheritHandles
                                 DWORD,                 # dwCreationFlags
                                 LPVOID,                # lpEnvironment
                                 LPCWSTR,               # lpCurrentDirectory
                                 LPSTARTUPINFO,         # lpStartupInfo
                                 LPPROCESS_INFORMATION  # lpProcessInformation
                                 )

CreateProcessFlags = ((1, "lpApplicationName", None),
                      (1, "lpCommandLine"),
                      (1, "lpProcessAttributes", None),
                      (1, "lpThreadAttributes", None),
                      (1, "bInheritHandles", True),
                      (1, "dwCreationFlags", 0),
                      (1, "lpEnvironment", None),
                      (1, "lpCurrentDirectory", None),
                      (1, "lpStartupInfo"),
                      (2, "lpProcessInformation"))

def ErrCheckCreateProcess(result, func, args):
    ErrCheckBool(result, func, args)
    # return a tuple (hProcess, hThread, dwProcessID, dwThreadID)
    pi = args[9]
    return AutoHANDLE(pi.hProcess), AutoHANDLE(pi.hThread), pi.dwProcessID, pi.dwThreadID

CreateProcess = CreateProcessProto(("CreateProcessW", windll.kernel32),
                                   CreateProcessFlags)
CreateProcess.errcheck = ErrCheckCreateProcess

# flags for CreateProcess
CREATE_BREAKAWAY_FROM_JOB = 0x01000000
CREATE_DEFAULT_ERROR_MODE = 0x04000000
CREATE_NEW_CONSOLE = 0x00000010
CREATE_NEW_PROCESS_GROUP = 0x00000200
CREATE_NO_WINDOW = 0x08000000
CREATE_SUSPENDED = 0x00000004
CREATE_UNICODE_ENVIRONMENT = 0x00000400

# flags for job limit information
# see http://msdn.microsoft.com/en-us/library/ms684147%28VS.85%29.aspx
JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x00000800
JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x00001000

# XXX these flags should be documented
DEBUG_ONLY_THIS_PROCESS = 0x00000002
DEBUG_PROCESS = 0x00000001
DETACHED_PROCESS = 0x00000008

# CreateJobObject()

CreateJobObjectProto = WINFUNCTYPE(HANDLE,             # Return type
                                   LPVOID,             # lpJobAttributes
                                   LPCWSTR             # lpName
                                   )

CreateJobObjectFlags = ((1, "lpJobAttributes", None),
                        (1, "lpName", None))

CreateJobObject = CreateJobObjectProto(("CreateJobObjectW", windll.kernel32),
                                       CreateJobObjectFlags)
CreateJobObject.errcheck = ErrCheckHandle

# AssignProcessToJobObject()

AssignProcessToJobObjectProto = WINFUNCTYPE(BOOL,      # Return type
                                            HANDLE,    # hJob
                                            HANDLE     # hProcess
                                            )
AssignProcessToJobObjectFlags = ((1, "hJob"),
                                 (1, "hProcess"))
AssignProcessToJobObject = AssignProcessToJobObjectProto(
    ("AssignProcessToJobObject", windll.kernel32),
    AssignProcessToJobObjectFlags)
AssignProcessToJobObject.errcheck = ErrCheckBool

# GetCurrentProcess()
# because os.getPid() is way too easy
GetCurrentProcessProto = WINFUNCTYPE(HANDLE    # Return type
                                     )
GetCurrentProcessFlags = ()
GetCurrentProcess = GetCurrentProcessProto(
    ("GetCurrentProcess", windll.kernel32),
    GetCurrentProcessFlags)
GetCurrentProcess.errcheck = ErrCheckHandle

# IsProcessInJob()
try:
    IsProcessInJobProto = WINFUNCTYPE(BOOL,     # Return type
                                      HANDLE,   # Process Handle
                                      HANDLE,   # Job Handle
                                      LPBOOL      # Result
                                      )
    IsProcessInJobFlags = ((1, "ProcessHandle"),
                           (1, "JobHandle", HANDLE(0)),
                           (2, "Result"))
    IsProcessInJob = IsProcessInJobProto(
        ("IsProcessInJob", windll.kernel32),
        IsProcessInJobFlags)
    IsProcessInJob.errcheck = ErrCheckBool 
except AttributeError:
    # windows 2k doesn't have this API
    def IsProcessInJob(process):
        return False


# ResumeThread()

def ErrCheckResumeThread(result, func, args):
    if result == -1:
        raise WinError()

    return args

ResumeThreadProto = WINFUNCTYPE(DWORD,      # Return type
                                HANDLE      # hThread
                                )
ResumeThreadFlags = ((1, "hThread"),)
ResumeThread = ResumeThreadProto(("ResumeThread", windll.kernel32),
                                 ResumeThreadFlags)
ResumeThread.errcheck = ErrCheckResumeThread

# TerminateProcess()

TerminateProcessProto = WINFUNCTYPE(BOOL,   # Return type
                                    HANDLE, # hProcess
                                    UINT    # uExitCode
                                    )
TerminateProcessFlags = ((1, "hProcess"),
                         (1, "uExitCode", 127))
TerminateProcess = TerminateProcessProto(
    ("TerminateProcess", windll.kernel32),
    TerminateProcessFlags)
TerminateProcess.errcheck = ErrCheckBool

# TerminateJobObject()

TerminateJobObjectProto = WINFUNCTYPE(BOOL,   # Return type
                                      HANDLE, # hJob
                                      UINT    # uExitCode
                                      )
TerminateJobObjectFlags = ((1, "hJob"),
                           (1, "uExitCode", 127))
TerminateJobObject = TerminateJobObjectProto(
    ("TerminateJobObject", windll.kernel32),
    TerminateJobObjectFlags)
TerminateJobObject.errcheck = ErrCheckBool

# WaitForSingleObject()

WaitForSingleObjectProto = WINFUNCTYPE(DWORD,  # Return type
                                       HANDLE, # hHandle
                                       DWORD,  # dwMilliseconds
                                       )
WaitForSingleObjectFlags = ((1, "hHandle"),
                            (1, "dwMilliseconds", -1))
WaitForSingleObject = WaitForSingleObjectProto(
    ("WaitForSingleObject", windll.kernel32),
    WaitForSingleObjectFlags)

INFINITE = -1
WAIT_TIMEOUT = 0x0102
WAIT_OBJECT_0 = 0x0
WAIT_ABANDONED = 0x0080

# GetExitCodeProcess()

GetExitCodeProcessProto = WINFUNCTYPE(BOOL,    # Return type
                                      HANDLE,  # hProcess
                                      LPDWORD, # lpExitCode
                                      )
GetExitCodeProcessFlags = ((1, "hProcess"),
                           (2, "lpExitCode"))
GetExitCodeProcess = GetExitCodeProcessProto(
    ("GetExitCodeProcess", windll.kernel32),
    GetExitCodeProcessFlags)
GetExitCodeProcess.errcheck = ErrCheckBool

def CanCreateJobObject():
    currentProc = GetCurrentProcess()
    if IsProcessInJob(currentProc):
        jobinfo = QueryInformationJobObject(HANDLE(0), 'JobObjectExtendedLimitInformation')
        limitflags = jobinfo['BasicLimitInformation']['LimitFlags']
        return bool(limitflags & JOB_OBJECT_LIMIT_BREAKAWAY_OK) or bool(limitflags & JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)
    else:
        return True

### testing functions

def parent():
    print('Starting parent')
    currentProc = GetCurrentProcess()
    if IsProcessInJob(currentProc):
        print("You should not be in a job object to test")
        sys.exit(1)
    assert CanCreateJobObject()
    print('File: %s' % __file__)
    command = [sys.executable, __file__, '-child']
    print('Running command: %s' % command)
    process = Popen(command)
    process.kill()
    code = process.returncode
    print('Child code: %s' % code)
    assert code == 127
        
def child():
    print('Starting child')
    currentProc = GetCurrentProcess()
    injob = IsProcessInJob(currentProc)
    print("Is in a job?: %s" % injob)
    can_create = CanCreateJobObject()
    print('Can create job?: %s' % can_create)
    process = Popen('c:\\windows\\notepad.exe')
    assert process._job
    jobinfo = QueryInformationJobObject(process._job, 'JobObjectExtendedLimitInformation')
    print('Job info: %s' % jobinfo)
    limitflags = jobinfo['BasicLimitInformation']['LimitFlags']
    print('LimitFlags: %s' % limitflags)
    process.kill()

########NEW FILE########
__FILENAME__ = powershell_repl
# -*- coding: utf-8 -*-
# Copyright (c) 2011, Wojciech Bederski (wuub.net)
# All rights reserved.
# See LICENSE.txt for details.
import os
import re
from . import subprocess_repl

# PowerShell in interactive mode shows no prompt, so we must hold it by hand.
# Every command prepended with other command, which will output only one character ('.')
# When user command leads to no output (for example, 'cd ..'), we get only this character,
# and then we send command to show prompt explicitly.
# No output at all means, that PowerShell needs more input (multiline mode).
# In this case we proceeds sending user input without modifications.

class PowershellRepl(subprocess_repl.SubprocessRepl):
    TYPE = "powershell"
    PREPENDER = b"."

    def __init__(self, encoding, **kwds):
        if not encoding:
            # Detect encoding
            chcp = os.popen('chcp')
            chcp_encoding = re.match(r'[^\d]+(\d+)', chcp.read())
            if not chcp_encoding:
                raise LookupError("Can't detect encoding from chcp")
            encoding = "cp" + chcp_encoding.groups()[0]
            print(encoding)

        super(PowershellRepl, self).__init__(encoding, **kwds)

        # Using this to detect whether PowerShell returns some output or it needs more input
        # PowerShell in interactive mode doesn't show prompt, so we must hold it by hand
        # It's a hack and, for example, we can send 'Write-Host "" -NoNewLine' with no output, but in outhr cases it may work well
        self.got_output = True
        self.multiline = False

        self.prompt()

    def read_bytes(self):
        # this is windows specific problem, that you cannot tell if there
        # are more bytes ready, so we read only 1 at a times

        result = super(PowershellRepl, self).read_bytes()

        # Consumes output (it must be equal to PREPENDER)
        if result and not self.got_output:
            self.got_output = True
            self.multiline = False
            self.prompt()
            # Don't return PREPENDER, read another input
            return self.read_bytes()

        return result

    def write_bytes(self, bytes):
        # Drop flag on new input
        self.got_output = False
        if not self.multiline:
            # Turn multiline mode on, it will be turned off, when PowerShell returns some output
            self.multiline = True
            self.prepend()
        self.do_write(bytes)

    def do_write(self, bytes):
        super(PowershellRepl, self).write_bytes(bytes)

    def prompt(self):
        """ Sends command to get prompt """
        self.do_write(b'Write-Host ("PS " + (gl).Path + "> ") -NoNewline\n')

    def prepend(self):
        """ Command to prepend every output with special mark to detect multiline mode """
        self.do_write(b'Write-Host "' + PowershellRepl.PREPENDER + b'" -NoNewLine; ')

########NEW FILE########
__FILENAME__ = repl
# -*- coding: utf-8 -*-
# Copyright (c) 2011, Wojciech Bederski (wuub.net)
# All rights reserved.
# See LICENSE.txt for details.

from uuid import uuid4
from codecs import getincrementaldecoder, getencoder


class NoReplError(LookupError):
    """Looking for Repl subclass failed"""
    pass

class Repl(object):
    """Class that represents a process that is being executed.
       For example this can be python, bash or a telnet session"""

    TYPE = "<base>"

    @classmethod
    def subclass(cls, type):
        """Returns subclass of Repl of given type eq. SubprocessRepl"""
        todo = [cls]
        seen = set()
        while True:
            if not todo:
                raise NoReplError
            cur = todo.pop()
            if cur in seen:
                continue
            if cur.TYPE == type:
                return cur
            todo.extend(cur.__subclasses__())

    def __init__(self, encoding, external_id=None, cmd_postfix="\n", suppress_echo=False,
                 additional_scopes=None, apiv2=False):
        self.id = uuid4().hex
        self._encoding = encoding
        self.decoder = getincrementaldecoder(self._encoding)()
        self.encoder = getencoder(encoding)
        self.external_id = external_id
        self.cmd_postfix = cmd_postfix
        self.suppress_echo = suppress_echo
        self.additional_scopes = additional_scopes or []
        self.apiv2 = apiv2

    def autocomplete_available(self):
        return False

    def autocomplete_completions(self, whole_line, pos_in_line, prefix, whole_prefix, locations):
        raise NotImplementedError

    def allow_restarts(self):
        """Override if for some reason restart logic should not be
           used for this REPL"""
        return True

    def close(self):
        if self.is_alive():
            self.kill()

    def name(self):
        """Returns name of this repl that should be used as a filename"""
        return NotImplementedError

    def is_alive(self):
        """ Returns true if the undelying process is stil working"""
        raise NotImplementedError

    def write_bytes(self, bytes):
        raise NotImplementedError

    def read_bytes(self):
        """Reads at lest one byte of Repl output. Returns None if output died.
           Can block!!!"""
        raise NotImplementedError

    def kill(self):
        """Kills the underlying repl"""
        raise NotImplementedError

    def write(self, command):
        """Encodes and evaluates a given command"""
        (bytes, how_many) = self.encoder(command)
        return self.write_bytes(bytes)

    def reset_decoder(self):
        self.decoder = getincrementaldecoder(self._encoding)()

    def read(self):
        """Reads at least one decoded char of output"""
        while True:
            bs = self.read_bytes()
            if not bs:
                return None
            try:
                output = self.decoder.decode(bs)
            except Exception as e:
                output = "■"
                self.reset_decoder()
            if output:
                return output

########NEW FILE########
__FILENAME__ = sublimehaskell_repl
import re
import os
import sublime

from .subprocess_repl import SubprocessRepl

def get_settings():
    return sublime.load_settings("SublimeHaskell.sublime-settings")

def get_setting(key, default=None):
    "This should be used only from main thread"
    # Get setting
    return get_settings().get(key, default)

def ghci_package_db():
    dev = get_setting('use_cabal_dev')
    box = get_setting('cabal_dev_sandbox')
    if dev and box:
        package_conf = (filter(lambda x: re.match('packages-(.*)\.conf', x), os.listdir(box)) + [None])[0]
        if package_conf:
            return os.path.join(box, package_conf)
    return None

def ghci_append_package_db(cmd):
    package_conf = ghci_package_db()
    if package_conf:
        cmd.extend(['-package-db', package_conf])
    return cmd

def ghci_get_min_whitespace_prefix(lines):
    line_spaces = [len(line) - len(line.lstrip()) for line in lines]
    if not line_spaces:
        return 0
    min_spaces = min(line_spaces)
    return min_spaces

def ghci_inject_let(lines):
    fixed_lines = [line for line in lines if not line.isspace()]

    letprefix =   "let "
    spaceprefix = "    "

    # matches eg. "func x y z ="
    # must start lowercase at start of line
    # remaining chars must be upper or lowercase letters, numbers, _ or '
    if fixed_lines and (not fixed_lines[0].startswith("let ")) and re.search("\A([a-z](\w|['_])*[ ]).*[=][ ]", lines[0]):
        fixed_lines[0] = letprefix + fixed_lines[0]
        fixed_lines[1:] = [spaceprefix + line for line in fixed_lines[1:]]

    return fixed_lines

def ghci_remove_whitespace(lines):
    # remove lines that are completely whitespace
    lines = [line for line in lines if not line.isspace()]

    # remove extra whitespace for more flexible block execution
    min_spaces = ghci_get_min_whitespace_prefix(lines)

    # remove the minimum number of spaces over all lines from each
    fixed_lines = [line[min_spaces:] for line in lines]
    return fixed_lines

def ghci_wrap_multiline_syntax(lines):
    # wrap in mutli-line syntax if more than one line
    if len(lines) <= 1:
        return lines
    fixed_lines = [":{" + os.linesep] + lines + [os.linesep + ":}" + os.linesep]
    return fixed_lines

class SublimeHaskellRepl(SubprocessRepl):
    TYPE = "sublime_haskell"

    def __init__(self, encoding, cmd=None, **kwds):
        super(SublimeHaskellRepl, self).__init__(encoding, cmd=ghci_append_package_db(cmd), **kwds)

    def write(self, command):
        setting_multiline = get_setting('format_multiline', True)
        setting_trimwhitespace = get_setting('format_trim_whitespace', True)
        setting_injectlet = get_setting('format_inject_let', True)

        new_cmd = ""
        if command.isspace() or (not setting_multiline and not setting_trimwhitespace):
            new_cmd = command
        else:
            lines = command.splitlines(True)
            if setting_trimwhitespace:
                lines = ghci_remove_whitespace(lines)
            if setting_injectlet:
                lines = ghci_inject_let(lines)
            if setting_multiline:
                lines = ghci_wrap_multiline_syntax(lines)
            new_cmd = "".join(lines)
        return super(SublimeHaskellRepl, self).write(new_cmd)

########NEW FILE########
__FILENAME__ = sublimepython_repl
# encoding: utf-8
import code
import contextlib
from .repl import Repl
try:
    from queue import Queue
except ImportError:
    from Queue import Queue
import sys
import threading
import sublime


class QueueOut(object):
    def __init__(self, queue):
        self.queue = queue

    def write(self, data):
        self.queue.put(data)


@contextlib.contextmanager
def redirect_stdio(queue):
    orig = (sys.stdout, sys.stderr)
    sys.stdout = sys.stderr = QueueOut(queue)
    yield
    (sys.stdout, sys.stderr) = orig


class SublimeLocals(dict):
    def __init__(self, *args, **kwds):
        import pydoc
        super(SublimeLocals, self).__init__(*args, **kwds)
        self['sublime'] = sublime
        self['__name__'] = "__main__"
        self['view'] = None
        self['window'] = None
        self['help'] = pydoc.help

    def __getitem__(self, key):
        if key == 'window':
            return sublime.active_window()
        if key == 'view':
            return sublime.active_window().active_view()
        return super(SublimeLocals, self).__getitem__(key)


class InterceptingConsole(code.InteractiveConsole):
    PS1 = ">>> "
    PS2 = "... "

    def __init__(self, encoding):
        code.InteractiveConsole.__init__(self, locals=SublimeLocals())
        self.input = Queue()
        self.output = Queue()
        self.output.put(self.PS1)
        self._encoding = encoding

    def write(self, data):
        self.output.put(data)

    def push(self, line):
        with redirect_stdio(self.output):
            more = code.InteractiveConsole.push(self, line.decode(self._encoding))
        self.output.put(self.PS2 if more else self.PS1)
        return more

    def run(self):
        while True:
            line = self.input.get()
            if line is None:
                break
            self.push(line)


class SublimePythonRepl(Repl):
    TYPE = "sublime_python"

    def __init__(self, encoding):
        super(SublimePythonRepl, self).__init__(encoding, "python", "\n", False)
        self._console = InterceptingConsole(encoding)
        self._thread = threading.Thread(target=self._console.run)
        self._thread.start()

    def name(self):
        return "sublime"

    def is_alive(self):
        return True

    def write_bytes(self, bytes):
        self._console.input.put(bytes)

    def read_bytes(self):
        return self._console.output.get().encode(self._encoding)

    def kill(self):
        self._console.input.put(None)

########NEW FILE########
__FILENAME__ = sublimeutop_repl
# encoding: utf-8
from __future__ import absolute_import, print_function, division

try:
    from queue import Queue
except ImportError:
    from Queue import Queue
from .subprocess_repl import SubprocessRepl

class SublimeUTopRepl(SubprocessRepl):
    TYPE = "sublime_utop"

    def __init__(self, encoding, **kwds):
        super(SublimeUTopRepl, self).__init__(encoding, apiv2=True, **kwds)

        # Buffer for reassembling stanzas arrived from utop.
        self._buffer = b''

        # Phrase pending input with mapping of utop-lines to
        # SublimeREPL-view-lines.
        self._phrase = []
        self._phrase_line_begins = []

        # Completion state.
        self._completions = None
        self._completion_prefix = ""
        self._completion_queue = Queue()

    def autocomplete_available(self):
        return True

    def autocomplete_completions(self, whole_line, pos_in_line,
                                 prefix, whole_prefix, locations):
        self._completion_prefix = prefix
        self.write_command('complete', '', [whole_prefix])

        # This would block the UI. When REPL works correctly,
        # this blocks for less than 100ms.
        return [(x, x) for x in self._completion_queue.get(timeout=500)]

    #
    # USER INTERACTION LEVEL
    #
    # User interaction consists of visible artifacts (prompt, etc)
    # and input in form of complete expressions. History is handled
    # by SublimeREPL.
    #

    def compose_highlights(self, a, b):
        highlights = []

        # Highlight each fragment of line which lies in [a;b).
        for (line, loc) in zip(self._phrase, self._phrase_line_begins):
            # Does this line have any highlight?
            if a < len(line):
                # Yeah, does it end here?
                if b <= len(line):
                    # Highlight the requested area and return.
                    highlights.append((loc + a, loc + b))
                    break
                else:
                    # Highlight till the end of line.
                    highlights.append((loc + a, loc + len(line)))

            # Shift the highlight region left by len(line) and
            # continue.
            a -= len(line) + 1
            b -= len(line) + 1
            # Always start from beginning of line for next lines.
            if a < 0:
                a = 0

        return [('highlight', x) for x in highlights]

    def read(self):
        stanza = self.read_stanza()
        if stanza is None:
            return None

        key, value = stanza
        if key == 'accept':
            packet = []

            if value != "":
                a, b = map(int, value.split(','))
                packet.extend(self.compose_highlights(a, b))

            # We've finished this phrase.
            self._phrase = []
            self._phrase_line_begins = []

            # Erase prompt. Accept is the first stanza we receive in
            # reply to input; immediately after it may follow stdout/stderr
            # and prompt stanzas in any order. To avoid garbled text,
            # we need to erase prompt before continuing.
            packet.append(('prompt', ''))
            packet.append(('output', '\n'))
            return packet

        elif key == 'stdout':
            return [('output', value + '\n')]
        elif key == 'stderr':
            return [('output', '! ' + value + '\n')]

        elif key == 'prompt':
            return [('prompt', '# ')]
        elif key == 'continue':
            return [('prompt', '\n  ')]

        # Full completion reply is completion-start..completion*..completion-end.
        # Names are fully qualified, i.e. Thread.
        elif key == 'completion-start':
            self._completions = []
            return []
        elif key == 'completion':
            self._completions.append(value)
            return []
        elif key == 'completion-stop':
            self._completion_queue.put(self._completions)
            self._completions = None
            return []

        # Word completion reply is just completion-word stanza.
        # Names are partial, i.e. ead ([Thr]ead).
        elif key == 'completion-word':
            self._completion_queue.put([self._completion_prefix + value])
            return []

        # Stuff we don't care about: phrase-terminator.
        # Stuff we never receive: history-*.
        else:
            return []

    def write(self, expression, location=None):
        # If the phrase is incomplete, utop will not remember it, so
        # we need to account for it here. Also, Shift+Enter will add a literal
        # newline, which would otherwise break protocol.
        for line in expression.split('\n'):
            self._phrase.append(line)
            if location is not None:
                self._phrase_line_begins.append(location)
                location += len(line) + 1

        self.write_command('input', 'allow-incomplete', self._phrase)

    #
    # COMMAND LEVEL
    #
    # A command is a collection of stanzas: one begin stanza,
    # zero or more data stanzas, and one end stanza.
    #

    def write_command(self, command, options, data):
        self.write_stanza(command, options)
        for datum in data:
            self.write_stanza('data', datum)
        self.write_stanza('end')

    #
    # STANZA LEVEL
    #
    # A stanza is a statement of form "key:value\n".
    # Decoding and encoding is done on the stanza level.
    #

    def read_stanza(self):
        while True:
            try:
                stanza_end = self._buffer.index(b'\n')
                stanza = self.decoder.decode(self._buffer[:stanza_end])
                self._buffer = self._buffer[stanza_end+1:]

                colon = stanza.index(':')
                return stanza[:colon], stanza[colon+1:]
            except ValueError:
                bytes = self.read_bytes()
                if not bytes:
                    return None
                else:
                    self._buffer += bytes

    def write_stanza(self, key, value=''):
        (bytes, _) = self.encoder(key + ':' + value + '\n')
        self.write_bytes(bytes)

########NEW FILE########
__FILENAME__ = subprocess_repl
# -*- coding: utf-8 -*-
# Copyright (c) 2011, Wojciech Bederski (wuub.net)
# All rights reserved.
# See LICENSE.txt for details.
from __future__ import absolute_import, unicode_literals, print_function, division

import subprocess
import os
import sys
from .repl import Repl
import signal
from sublime import load_settings, error_message
from .autocomplete_server import AutocompleteServer
from .killableprocess import Popen

PY3 = sys.version_info[0] == 3

if os.name == 'posix':
    POSIX = True
    import fcntl
    import select
else:
    POSIX = False


class Unsupported(Exception):
    def __init__(self, msgs):
        super(Unsupported, self).__init__()
        self.msgs = msgs

    def __repr__(self):
        return "\n".join(self.msgs)


def win_find_executable(executable, env):
    """Explicetely looks for executable in env["PATH"]"""
    if os.path.dirname(executable):
        return executable # executable is already absolute filepath
    path = env.get("PATH", "")
    pathext = env.get("PATHEXT") or ".EXE"
    dirs = path.split(os.path.pathsep)
    (base, ext) = os.path.splitext(executable)
    if ext:
        extensions = [ext]
    else:
        extensions = pathext.split(os.path.pathsep)
    for directory in dirs:
        for extension in extensions:
            filepath = os.path.join(directory, base + extension)
            if os.path.exists(filepath):
                return filepath
    return None


class SubprocessRepl(Repl):
    TYPE = "subprocess"

    def __init__(self, encoding, cmd=None, env=None, cwd=None, extend_env=None, soft_quit="", autocomplete_server=False, **kwds):
        super(SubprocessRepl, self).__init__(encoding, **kwds)
        settings = load_settings('SublimeREPL.sublime-settings')

        if cmd[0] == "[unsupported]":
            raise Unsupported(cmd[1:])

        self._autocomplete_server = None
        if autocomplete_server:
            self._autocomplete_server = AutocompleteServer(self, settings.get("autocomplete_server_ip"))
            self._autocomplete_server.start()

        env = self.env(env, extend_env, settings)
        env[b"SUBLIMEREPL_AC_PORT"] = str(self.autocomplete_server_port()).encode("utf-8")
        env[b"SUBLIMEREPL_AC_IP"] = settings.get("autocomplete_server_ip").encode("utf-8")

        if PY3:
            strings_env = {}
            for k, v in env.items():
                strings_env[k.decode("utf-8")] = v.decode("utf-8")
            env = strings_env

        self._cmd = self.cmd(cmd, env)
        self._soft_quit = soft_quit
        self._killed = False
        self.popen = Popen(
                        self._cmd,
                        startupinfo=self.startupinfo(settings),
                        creationflags=self.creationflags(settings),
                        bufsize=1,
                        cwd=self.cwd(cwd, settings),
                        env=env,
                        stderr=subprocess.STDOUT,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE)

        if POSIX:
            flags = fcntl.fcntl(self.popen.stdout, fcntl.F_GETFL)
            fcntl.fcntl(self.popen.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)

    def autocomplete_server_port(self):
        if not self._autocomplete_server:
            return None
        return self._autocomplete_server.port()

    def autocomplete_available(self):
        if not self._autocomplete_server:
            return False
        return self._autocomplete_server.connected()

    def autocomplete_completions(self, whole_line, pos_in_line, prefix, whole_prefix, locations):
        return self._autocomplete_server.complete(
            whole_line=whole_line,
            pos_in_line=pos_in_line,
            prefix=prefix,
            whole_prefix=whole_prefix,
            locations=locations,
        )

    def cmd(self, cmd, env):
        """On Linux and OSX just returns cmd, on windows it has to find
           executable in env because of this: http://bugs.python.org/issue8557"""
        if os.name != "nt":
            return cmd
        if isinstance(cmd, str):
            _cmd = [cmd]
        else:
            _cmd = cmd
        executable = win_find_executable(_cmd[0], env)
        if executable:
            _cmd[0] = executable
        return _cmd

    def cwd(self, cwd, settings):
        if cwd and os.path.exists(cwd):
            return cwd
        return None

    def getenv(self, settings):
        """Tries to get most appropriate environent, on windows
           it's os.environ.copy, but on other system's we'll
           try get values from login shell"""

        getenv_command = settings.get("getenv_command")
        if getenv_command and POSIX:
            try:
                output = subprocess.check_output(getenv_command)
                lines = output.decode("utf-8", errors="replace").splitlines()
                env = dict(line.split('=', 1)  for line in lines)
                return env
            except:
                import traceback
                traceback.print_exc()
                error_message(
                    "SublimeREPL: obtaining sane environment failed in getenv()\n"
                    "Check console and 'getenv_command' setting \n"
                    "WARN: Falling back to SublimeText environment")

        # Fallback to environ.copy() if not on POSIX or sane getenv failed
        return os.environ.copy()

    def env(self, env, extend_env, settings):
        updated_env = env if env else self.getenv(settings)
        default_extend_env = settings.get("default_extend_env")
        if default_extend_env:
            updated_env.update(self.interpolate_extend_env(updated_env, default_extend_env))
        if extend_env:
            updated_env.update(self.interpolate_extend_env(updated_env, extend_env))

        bytes_env = {}
        for k, v in list(updated_env.items()):
            try:
                enc_k = self.encoder(str(k))[0]
                enc_v = self.encoder(str(v))[0]
            except UnicodeDecodeError:
                continue #f*** it, we'll do it live
            else:
                bytes_env[enc_k] = enc_v
        return bytes_env

    def interpolate_extend_env(self, env, extend_env):
        """Interpolates (subst) values in extend_env.
           Mostly for path manipulation"""
        new_env = {}
        for key, val in list(extend_env.items()):
            new_env[key] = str(val).format(**env)
        return new_env

    def startupinfo(self, settings):
        startupinfo = None
        if os.name == 'nt':
            from .killableprocess import STARTUPINFO, STARTF_USESHOWWINDOW
            startupinfo = STARTUPINFO()
            startupinfo.dwFlags |= STARTF_USESHOWWINDOW
            startupinfo.wShowWindow |= 1 # SW_SHOWNORMAL
        return startupinfo

    def creationflags(self, settings):
        creationflags = 0
        if os.name == "nt":
            creationflags = 0x8000000 # CREATE_NO_WINDOW
        return creationflags

    def name(self):
        if self.external_id:
            return self.external_id
        if isinstance(self._cmd, str):
            return self._cmd
        return " ".join([str(x) for x in self._cmd])

    def is_alive(self):
        return self.popen.poll() is None

    def read_bytes(self):
        out = self.popen.stdout
        if POSIX:
            while True:
                i, _, _ = select.select([out], [], [])
                if i:
                    return out.read(4096)
        else:
            # this is windows specific problem, that you cannot tell if there
            # are more bytes ready, so we read only 1 at a times

            while True:
                byte = self.popen.stdout.read(1)
                if byte == b'\r':
                    # f'in HACK, for \r\n -> \n translation on windows
                    # I tried universal_endlines but it was pain and misery! :'(
                    continue
                return byte



    def write_bytes(self, bytes):
        si = self.popen.stdin
        si.write(bytes)
        si.flush()

    def kill(self):
        self._killed = True
        self.write(self._soft_quit)
        self.popen.kill()

    def available_signals(self):
        signals = {}
        for k, v in list(signal.__dict__.items()):
            if not k.startswith("SIG"):
                continue
            signals[k] = v
        return signals

    def send_signal(self, sig):
        if sig == signal.SIGTERM:
            self._killed = True
        if self.is_alive():
            self.popen.send_signal(sig)


########NEW FILE########
__FILENAME__ = telnet_repl
# -*- coding: utf-8 -*-
# Copyright (c) 2011, Wojciech Bederski (wuub.net)
# All rights reserved.
# See LICENSE.txt for details.

import telnetlib
from . import repl

class TelnetRepl(repl.Repl):
    TYPE = "telnet"

    def __init__(self, encoding, host="localhost", port=23, **kwds):
        """Create new TelnetRepl with the following initial values:
        encoding: one of python accepted encoding used to encode commands and decode responses
        external_id: external, persisten name of this repl used to find it later
        host: telnet host to connect to
        port: telnet port to connect to
        cmd_postfix: some REPLS require you to end a command with a postfix to begin execution,
          think ';' or '.', you can force repl to add it automatically"""
        super(TelnetRepl, self).__init__(encoding, **kwds)
        self._telnet = telnetlib.Telnet()
        #convert to int for user's sake, we don't care if it's an float or string
        # as long as it can be turned into an INT
        self._telnet.open(host, int(port))
        self._alive = True
        self._killed = False

    def name(self):
        return "%s:%s" % (self._telnet.host, self._telnet.port)

    def is_alive(self):
        return self._alive

    def read_bytes(self):
        return self._telnet.read_some()

    def write_bytes(self, bytes):
        self._telnet.write(bytes)

    def kill(self):
        self._killed = True
        self._telnet.close()
        self._alive = False

########NEW FILE########
__FILENAME__ = run_existing_command
from __future__ import absolute_import, unicode_literals, print_function, division

import os
import os.path
import sys
import json
import sublime
import sublime_plugin

SUBLIMEREPL_DIR = None
SUBLIMEREPL_USER_DIR = None

def plugin_loaded():
    global SUBLIMEREPL_DIR
    global SUBLIMEREPL_USER_DIR
    SUBLIMEREPL_DIR = "Packages/SublimeREPL"
    SUBLIMEREPL_USER_DIR = os.path.join(sublime.packages_path(), "User", "SublimeREPL")

PY2 = False
if sys.version_info[0] == 2:
    SUBLIMEREPL_DIR = os.getcwdu()
    SUBLIMEREPL_USER_DIR = os.path.join(sublime.packages_path(), "User", "SublimeREPL")
    PY2 = True

# yes, CommandCommmand :) 
class RunExistingWindowCommandCommand(sublime_plugin.WindowCommand):
    def run(self, id, file):
        """Find and run existing command with id in specified file. 
        SUBLIMEREPL_USER_DIR is consulted first, and then SUBLIMEREPL_DIR""" 
        for prefix in (SUBLIMEREPL_USER_DIR, SUBLIMEREPL_DIR):
            path = os.path.join(prefix, file)
            json_cmd = self._find_cmd(id, path)
            if json_cmd:
                break
        if not json_cmd:
            return
        args = json_cmd["args"] if "args" in json_cmd else None
        self.window.run_command(json_cmd["command"], args)
    
    def _find_cmd(self, id, file):
        return self._find_cmd_in_file(id, file)
                
    def _find_cmd_in_file(self, id, file):
        try:
            if PY2 or os.path.isfile(file):
                with open(file) as f:
                    bytes = f.read()
            else:
                bytes = sublime.load_resource(file)
        except (IOError, ValueError):
            return None
        else:
            data = json.loads(bytes)
            return self._find_cmd_in_json(id, data)

    def _find_cmd_in_json(self, id, json_object):
        if isinstance(json_object, list):
            for elem in json_object:
                cmd = self._find_cmd_in_json(id, elem)
                if cmd:
                    return cmd
        elif isinstance(json_object, dict):
            if "id" in json_object and json_object["id"] == id:
                return json_object
            elif "children" in json_object:
                return self._find_cmd_in_json(id, json_object["children"])
        return None
########NEW FILE########
__FILENAME__ = sublimerepl
# -*- coding: utf-8 -*-
# Copyright (c) 2011, Wojciech Bederski (wuub.net)
# All rights reserved.
# See LICENSE.txt for details.
from __future__ import absolute_import, unicode_literals, print_function, division

import re
import os
import sys
import os.path
import threading
import traceback
from datetime import datetime

import sublime
import sublime_plugin

try:
    import queue
    from . import sublimerepl_build_system_hack
    from . import repls
    from .repllibs import PyDbLite
    unicode_type = str
    PY2 = False
except ImportError:
    import sublimerepl_build_system_hack
    import repls
    from repllibs import PyDbLite
    import Queue as queue
    unicode_type = unicode
    PY2 = True

PLATFORM = sublime.platform().lower()
SETTINGS_FILE = 'SublimeREPL.sublime-settings'
SUBLIME2 = sublime.version() < '3000'

RESTART_MSG = """
#############
## RESTART ##
#############
"""

class ReplInsertTextCommand(sublime_plugin.TextCommand):
    def run(self, edit, pos, text):
        self.view.set_read_only(False)  # make sure view is writable
        self.view.insert(edit, int(pos), text)


class ReplEraseTextCommand(sublime_plugin.TextCommand):
    def run(self, edit, start, end):
        self.view.set_read_only(False)  # make sure view is writable
        self.view.erase(edit, sublime.Region(int(start), int(end)))


class ReplPass(sublime_plugin.TextCommand):
    def run(self, edit):
        pass


class ReplReader(threading.Thread):
    def __init__(self, repl):
        super(ReplReader, self).__init__()
        self.repl = repl
        self.daemon = True
        self.queue = queue.Queue()

    def run(self):
        r = self.repl
        q = self.queue
        while True:
            result = r.read()
            q.put(result)
            if result is None:
                break


class HistoryMatchList(object):
    def __init__(self, command_prefix, commands):
        self._command_prefix = command_prefix
        self._commands = commands
        self._cur = len(commands)  # no '-1' on purpose

    def current_command(self):
        if not self._commands:
            return ""
        return self._commands[self._cur]

    def prev_command(self):
        self._cur = max(0, self._cur - 1)
        return self.current_command()

    def next_command(self):
        self._cur = min(len(self._commands) - 1, self._cur + 1)
        return self.current_command()


class History(object):
    def __init__(self):
        self._last = None

    def push(self, command):
        cmd = command.rstrip()
        if not cmd or cmd == self._last:
            return
        self.append(cmd)
        self._last = cmd

    def append(self, cmd):
        raise NotImplementedError()

    def match(self, command_prefix):
        raise NotImplementedError()


class MemHistory(History):
    def __init__(self):
        super(MemHistory, self).__init__()
        self._stack = []

    def append(self, cmd):
        self._stack.append(cmd)

    def match(self, command_prefix):
        matching_commands = []
        for cmd in self._stack:
            if cmd.startswith(command_prefix):
                matching_commands.append(cmd)
        return HistoryMatchList(command_prefix, matching_commands)


class PersistentHistory(MemHistory):
    def __init__(self, external_id):
        super(PersistentHistory, self).__init__()
        path = os.path.join(sublime.packages_path(), "User", ".SublimeREPLHistory")
        if not os.path.isdir(path):
            os.makedirs(path)
        filepath = os.path.join(path, external_id + ".db")
        self._db = PyDbLite.Base(filepath)
        self._external_id = external_id
        self._db.create("external_id", "command", "ts", mode="open")

    def append(self, cmd):
        self._db.insert(external_id=self._external_id, command=cmd, ts=datetime.now())
        self._db.commit()

    def match(self, command_prefix):
        retults = [cmd for cmd in self._db if cmd["command"].startswith(command_prefix)]
        return HistoryMatchList(command_prefix, [x["command"] for x in retults])


class ReplView(object):
    def __init__(self, view, repl, syntax, repl_restart_args):
        self.repl = repl
        self._view = view
        self._window = view.window()
        self._repl_launch_args = repl_restart_args
        # list of callable(repl) to handle view close events
        self.call_on_close = []

        if syntax:
            view.set_syntax_file(syntax)
        self._output_end = view.size()
        self._prompt_size = 0

        self._repl_reader = ReplReader(repl)
        self._repl_reader.start()

        settings = sublime.load_settings(SETTINGS_FILE)

        view.settings().set("repl_external_id", repl.external_id)
        view.settings().set("repl_id", repl.id)
        view.settings().set("repl", True)
        view.settings().set("repl_sublime2", SUBLIME2)
        if repl.allow_restarts():
            view.settings().set("repl_restart_args", repl_restart_args)

        rv_settings = settings.get("repl_view_settings", {})
        for setting, value in list(rv_settings.items()):
            view.settings().set(setting, value)

        view.settings().set("history_arrows", settings.get("history_arrows", True))

        # for hysterical rasins ;)
        persistent_history_enabled = settings.get("persistent_history_enabled") or settings.get("presistent_history_enabled")
        if self.external_id and persistent_history_enabled:
            self._history = PersistentHistory(self.external_id)
        else:
            self._history = MemHistory()
        self._history_match = None

        self._filter_color_codes = settings.get("filter_ascii_color_codes")

        # optionally move view to a different group
        # find current position of this replview
        (group, index) = self._window.get_view_index(view)

        # get the view that was focussed before the repl was opened.
        # we'll have to focus this one briefly to make sure it's in the
        # foreground again after moving the replview away
        oldview = self._window.views_in_group(group)[max(0, index - 1)]

        target = settings.get("open_repl_in_group")

        # either the target group is specified by index
        if isinstance(target, int):
            if 0 <= target < self._window.num_groups() and target != group:
                self._window.set_view_index(view, target, len(self._window.views_in_group(target)))
                self._window.focus_view(oldview)
                self._window.focus_view(view)
        ## or, if simply set to true, move it to the next group from the currently active one
        elif target and group + 1 < self._window.num_groups():
            self._window.set_view_index(view, group + 1, len(self._window.views_in_group(group + 1)))
            self._window.focus_view(oldview)
            self._window.focus_view(view)

        # begin refreshing attached view
        self.update_view_loop()

    @property
    def external_id(self):
        return self.repl.external_id

    def on_backspace(self):
        if self.delta < 0:
            self._view.run_command("left_delete")

    def on_ctrl_backspace(self):
        if self.delta < 0:
            self._view.run_command("delete_word", {"forward": False, "sub_words": True})

    def on_super_backspace(self):
        if self.delta < 0:
            for i in range(abs(self.delta)):
                self._view.run_command("left_delete")  # Hack to delete to BOL

    def on_left(self):
        if self.delta != 0:
            self._window.run_command("move", {"by": "characters", "forward": False, "extend": False})

    def on_shift_left(self):
        if self.delta != 0:
            self._window.run_command("move", {"by": "characters", "forward": False, "extend": True})

    def on_home(self):
        if self.delta > 0:
            self._window.run_command("move_to", {"to": "bol", "extend": False})
        else:
            for i in range(abs(self.delta)):
                self._window.run_command("move", {"by": "characters", "forward": False, "extend": False})

    def on_shift_home(self):
        if self.delta > 0:
            self._window.run_command("move_to", {"to": "bol", "extend": True})
        else:
            for i in range(abs(self.delta)):
                self._window.run_command("move", {"by": "characters", "forward": False, "extend": True})

    def on_selection_modified(self):
        self._view.set_read_only(self.delta > 0)

    def on_close(self):
        self.repl.close()
        for fun in self.call_on_close:
            fun(self)

    def clear(self, edit):
        self.escape(edit)
        self._view.erase(edit, self.output_region)
        self._output_end = self._view.sel()[0].begin()

    def escape(self, edit):
        self._view.set_read_only(False)
        self._view.erase(edit, self.input_region)
        self._view.show(self.input_region)

    def enter(self):
        v = self._view
        if v.sel()[0].begin() != v.size():
            v.sel().clear()
            v.sel().add(sublime.Region(v.size()))

        l = self._output_end

        self.push_history(self.user_input)  # don't include cmd_postfix in history
        v.run_command("insert", {"characters": self.repl.cmd_postfix})
        command = self.user_input
        self.adjust_end()

        if self.repl.apiv2:
            self.repl.write(command, location=l)
        else:
            self.repl.write(command)

    def previous_command(self, edit):
        self._view.set_read_only(False)
        self.ensure_history_match()
        self.replace_current_input(edit, self._history_match.prev_command())
        self._view.show(self.input_region)

    def next_command(self, edit):
        self._view.set_read_only(False)
        self.ensure_history_match()
        self.replace_current_input(edit, self._history_match.next_command())
        self._view.show(self.input_region)

    def update_view(self, view):
        """If projects were switched, a view could be a new instance"""
        if self._view is not view:
            self._view = view

    def adjust_end(self):
        if self.repl.suppress_echo:
            v = self._view
            vsize = v.size()
            self._output_end = min(vsize, self._output_end)
            v.run_command("repl_erase_text", {"start": self._output_end, "end": vsize})
        else:
            self._output_end = self._view.size()

    def write(self, unistr):
        """Writes output from Repl into this view."""
        # remove color codes
        if self._filter_color_codes:
            unistr = re.sub(r'\033\[\d*(;\d*)?\w', '', unistr)
            unistr = re.sub(r'.\x08', '', unistr)

        # string is assumed to be already correctly encoded
        self._view.run_command("repl_insert_text", {"pos": self._output_end - self._prompt_size, "text": unistr})
        self._output_end += len(unistr)
        self._view.show(self.input_region)

    def write_prompt(self, unistr):
        """Writes prompt from REPL into this view. Prompt is treated like
           regular output, except output is inserted before the prompt."""
        self._prompt_size = 0
        self.write(unistr)
        self._prompt_size = len(unistr)

    def append_input_text(self, text, edit=None):
        if edit:
            self._view.insert(edit, self._view.size(), text)
        else:
            self._view.run_command("repl_insert_text", {"pos": self._view.size(), "text": text})

    def handle_repl_output(self):
        """Returns new data from Repl and bool indicating if Repl is still
           working"""
        try:
            while True:
                packet = self._repl_reader.queue.get_nowait()
                if packet is None:
                    return False

                self.handle_repl_packet(packet)

        except queue.Empty:
            return True

    def handle_repl_packet(self, packet):
        if self.repl.apiv2:
            for opcode, data in packet:
                if opcode == 'output':
                    self.write(data)
                elif opcode == 'prompt':
                    self.write_prompt(data)
                elif opcode == 'highlight':
                    a, b = data
                    regions = self._view.get_regions('sublimerepl')
                    regions.append(sublime.Region(a, b))
                    self._view.add_regions('sublimerepl', regions, 'invalid',
                                           '', sublime.DRAW_EMPTY | sublime.DRAW_OUTLINED)
                else:
                    print('SublimeREPL: unknown REPL opcode: ' + opcode)
        else:
            self.write(packet)

    def update_view_loop(self):
        is_still_working = self.handle_repl_output()
        if is_still_working:
            sublime.set_timeout(self.update_view_loop, 100)
        else:
            self.write("\n***Repl Killed***\n""" if self.repl._killed else "\n***Repl Closed***\n""")
            self._view.set_read_only(True)
            if sublime.load_settings(SETTINGS_FILE).get("view_auto_close"):
                window = self._view.window()
                if window is not None:
                    window.focus_view(self._view)
                    window.run_command("close")

    def push_history(self, command):
        self._history.push(command)
        self._history_match = None

    def ensure_history_match(self):
        user_input = self.user_input
        if self._history_match is not None:
            if user_input != self._history_match.current_command():
                # user did something! reset
                self._history_match = None
        if self._history_match is None:
            self._history_match = self._history.match(user_input)

    def replace_current_input(self, edit, cmd):
        if cmd:
            self._view.replace(edit, self.input_region, cmd)
            self._view.sel().clear()
            self._view.sel().add(sublime.Region(self._view.size()))

    def run(self, edit, code):
        self.replace_current_input(edit, code)
        self.enter()
        self._view.show(self.input_region)
        self._window.focus_view(self._view)

    @property
    def view(self):
        return self._view

    @property
    def input_region(self):
        return sublime.Region(self._output_end, self._view.size())

    @property
    def output_region(self):
        return sublime.Region(0, self._output_end - 2)

    @property
    def user_input(self):
        """Returns text entered by the user"""
        return self._view.substr(self.input_region)

    @property
    def delta(self):
        """Return a repl_view and number of characters from current selection
        to then begging of user_input (otherwise known as _output_end)"""
        return self._output_end - self._view.sel()[0].begin()

    def allow_deletion(self):
        # returns true if all selections falls in user input
        # and can be safetly deleted
        output_end = self._output_end
        for sel in self._view.sel():
            if sel.begin() == sel.end() and sel.begin() == output_end:
                # special case, when single selecion
                # is at the very beggining of prompt
                return False
            # i don' really know if end() is always after begin()
            if sel.begin() < output_end or sel.end() < output_end:
                return False
        return True


class ReplManager(object):

    def __init__(self):
        self.repl_views = {}

    def repl_view(self, view):
        repl_id = view.settings().get("repl_id")
        if repl_id not in self.repl_views:
            return None
        rv = self.repl_views[repl_id]
        rv.update_view(view)
        return rv

    def find_repl(self, external_id):
        """Yields rvews matching external_id taken from source.[external_id] scope
           Match is done on external_id value of repl and additional_scopes"""
        for rv in self.repl_views.values():
            if not (rv.repl and rv.repl.is_alive()):
                continue  # dead repl, skip
            rvid = rv.external_id
            additional_scopes = rv.repl.additional_scopes
            if rvid == external_id or external_id in additional_scopes:
                yield rv

    def open(self, window, encoding, type, syntax=None, view_id=None, **kwds):
        repl_restart_args = {
            'encoding': encoding,
            'type': type,
            'syntax': syntax,
        }
        repl_restart_args.update(kwds)
        try:
            kwds = ReplManager.translate(window, kwds)
            encoding = ReplManager.translate(window, encoding)
            r = repls.Repl.subclass(type)(encoding, **kwds)
            found = None
            for view in window.views():
                if view.id() == view_id:
                    found = view
                    break
            view = found or window.new_file()

            rv = ReplView(view, r, syntax, repl_restart_args)
            rv.call_on_close.append(self._delete_repl)
            self.repl_views[r.id] = rv
            view.set_scratch(True)
            view.set_name("*REPL* [%s]" % (r.name(),))
            return rv
        except Exception as e:
            traceback.print_exc()
            sublime.error_message(repr(e))

    def restart(self, view, edit):
        repl_restart_args = view.settings().get("repl_restart_args")
        if not repl_restart_args:
            sublime.message_dialog("No restart parameters found")
            return False
        rv = self.repl_view(view)
        if rv:
            if rv.repl and rv.repl.is_alive() and not sublime.ok_cancel_dialog("Still running. Really restart?"):
                return False
            rv.on_close()  # yes on_close, delete rv from

        view.insert(edit, view.size(), RESTART_MSG)
        repl_restart_args["view_id"] = view.id()
        self.open(view.window(), **repl_restart_args)
        return True

    def _delete_repl(self, repl_view):
        repl_id = repl_view.repl.id
        if repl_id not in self.repl_views:
            return None
        del self.repl_views[repl_id]

    @staticmethod
    def translate(window, obj, subst=None):
        if subst is None:
            subst = ReplManager._subst_for_translate(window)
        if isinstance(obj, dict):
            return ReplManager._translate_dict(window, obj, subst)
        if isinstance(obj, unicode_type):  # PY2
            return ReplManager._translate_string(window, obj, subst)
        if isinstance(obj, list):
            return ReplManager._translate_list(window, obj, subst)
        return obj

    @staticmethod
    def _subst_for_translate(window):
        """ Return all available substitutions"""
        import locale
        res = {
            "packages": sublime.packages_path(),
            "installed_packages": sublime.installed_packages_path()
        }
        if window.folders():
            res["folder"] = window.folders()[0]
        res["editor"] = "subl -w"
        res["win_cmd_encoding"] = "utf8"
        if sublime.platform() == "windows":
            res["win_cmd_encoding"] = locale.getdefaultlocale()[1]
            res["editor"] = '"%s"' % (sys.executable,)
        av = window.active_view()
        if av is None:
            return res
        filename = av.file_name()
        if not filename:
            return res
        filename = os.path.abspath(filename)
        res["file"] = filename
        res["file_path"] = os.path.dirname(filename)
        res["file_basename"] = os.path.basename(filename)
        if 'folder' not in res:
            res["folder"] = res["file_path"]

        if sublime.load_settings(SETTINGS_FILE).get("use_build_system_hack", False):
            project_settings = sublimerepl_build_system_hack.get_project_settings(window)
            res.update(project_settings)

        return res

    @staticmethod
    def _translate_string(window, string, subst=None):
        from string import Template
        if subst is None:
            subst = ReplManager._subst_for_translate(window)

        # see #200, on older OSX (10.6.8) system wide python won't accept
        # dict(unicode -> unicode) as **argument.
        # It's best to just str() keys, since they are ascii anyway
        if PY2:
            subst = dict((str(key), val) for key, val in subst.items())

        return Template(string).safe_substitute(**subst)

    @staticmethod
    def _translate_list(window, list, subst=None):
        if subst is None:
            subst = ReplManager._subst_for_translate(window)
        return [ReplManager.translate(window, x, subst) for x in list]

    @staticmethod
    def _translate_dict(window, dictionary, subst=None):
        if subst is None:
            subst = ReplManager._subst_for_translate(window)
        if PLATFORM in dictionary:
            return ReplManager.translate(window, dictionary[PLATFORM], subst)
        for k, v in list(dictionary.items()):
            dictionary[k] = ReplManager.translate(window, v, subst)
        return dictionary

manager = ReplManager()

# Window Commands #########################################


# Opens a new REPL
class ReplOpenCommand(sublime_plugin.WindowCommand):
    def run(self, encoding, type, syntax=None, view_id=None, **kwds):
        manager.open(self.window, encoding, type, syntax, view_id, **kwds)


class ReplRestartCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        manager.restart(self.view, edit)

    def is_visible(self):
        if not self.view:
            return False
        return bool(self.view.settings().get("repl_restart_args", None))

    def is_enabled(self):
        return self.is_visible()

# REPL Comands ############################################


# Submits the Command to the REPL
class ReplEnterCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.enter()


class ReplClearCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.clear(edit)


# Resets Repl Command Line
class ReplEscapeCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.escape(edit)


def repl_view_delta(sublime_view):
    """Return a repl_view and number of characters from current selection
    to then beggingin of user_input (otherwise known as _output_end)"""
    rv = manager.repl_view(sublime_view)
    if not rv:
        return None, -1
    delta = rv._output_end - sublime_view.sel()[0].begin()
    return rv, delta


class ReplBackspaceCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.on_backspace()


class ReplCtrlBackspaceCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.on_ctrl_backspace()


class ReplSuperBackspaceCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.on_super_backspace()


class ReplLeftCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.on_left()


class ReplShiftLeftCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.on_shift_left()


class ReplHomeCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.on_home()


class ReplShiftHomeCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.on_shift_home()


class ReplViewPreviousCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.previous_command(edit)


class ReplViewNextCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.next_command(edit)


class ReplKillCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        rv = manager.repl_view(self.view)
        if rv:
            rv.repl.kill()

    def is_visible(self):
        rv = manager.repl_view(self.view)
        return bool(rv)

    def is_enabled(self):
        return self.is_visible()


class SublimeReplListener(sublime_plugin.EventListener):
    def on_selection_modified(self, view):
        rv = manager.repl_view(view)
        if rv:
            rv.on_selection_modified()

    def on_close(self, view):
        rv = manager.repl_view(view)
        if rv:
            rv.on_close()

    def on_text_command(self, view, command_name, args):
        rv = manager.repl_view(view)
        if not rv:
            return None

        if command_name == 'left_delete':
            # stop backspace on ST3 w/o breaking brackets
            if not rv.allow_deletion():
                return 'repl_pass', {}

        if command_name == 'delete_word' and not args.get('forward'):
            # stop ctrl+backspace on ST3 w/o breaking brackets
            if not rv.allow_deletion():
                return 'repl_pass', {}

        return None

class SubprocessReplSendSignal(sublime_plugin.TextCommand):
    def run(self, edit, signal=None):
        rv = manager.repl_view(self.view)
        subrepl = rv.repl
        signals = subrepl.available_signals()
        sorted_names = sorted(signals.keys())
        if signal in signals:
            #signal given by name
            self.safe_send_signal(subrepl, signals[signal])
            return
        if signal in list(signals.values()):
            #signal given by code (correct one!)
            self.safe_send_signal(subrepl, signal)
            return

        # no or incorrect signal given
        def signal_selected(num):
            if num == -1:
                return
            signame = sorted_names[num]
            sigcode = signals[signame]
            self.safe_send_signal(subrepl, sigcode)
        self.view.window().show_quick_panel(sorted_names, signal_selected)

    def safe_send_signal(self, subrepl, sigcode):
        try:
            subrepl.send_signal(sigcode)
        except Exception as e:
            sublime.error_message(str(e))

    def is_visible(self):
        rv = manager.repl_view(self.view)
        return bool(rv) and hasattr(rv.repl, "send_signal")

    def is_enabled(self):
        return self.is_visible()

    def description(self):
        return "Send SIGNAL"

########NEW FILE########
__FILENAME__ = sublimerepl_build_system_hack
from __future__ import absolute_import, unicode_literals, print_function, division

import sublime_plugin
try:
    import queue
except ImportError:
    import Queue as queue

RESULTS = None
HACK_BUILD_SYSTEM = "Packages/SublimeREPL/sublimerepl_build_system_hack.sublime-build"
AUTOMATIC_BUILD_SYSTEM = ""


class SublimereplBuildSystemHackCommand(sublime_plugin.WindowCommand):
    def run(self, cmd):
        RESULTS.put(cmd)


def get_project_settings(window):
    global RESULTS
    try:
        RESULTS = queue.Queue()  # in case of garbage on RESULTS
        window.run_command("set_build_system", {"file": HACK_BUILD_SYSTEM})
        window.run_command("build")
    finally:
        window.run_command("set_build_system", {"file": AUTOMATIC_BUILD_SYSTEM})
    return RESULTS.get(timeout=1.0)

########NEW FILE########
__FILENAME__ = text_transfer
from __future__ import absolute_import, unicode_literals, print_function, division

import re
import sublime_plugin
import sublime
from collections import defaultdict
import tempfile
import binascii

try:
    from .sublimerepl import manager, SETTINGS_FILE
except (ImportError, ValueError):
    from sublimerepl import manager, SETTINGS_FILE


def default_sender(repl, text, view=None, repl_view=None):
    if repl.apiv2:
        repl.write(text, location=repl_view.view.size() - len(text))
    else:
        repl.write(text)

    if view is None or not sublime.load_settings(SETTINGS_FILE).get('focus_view_on_transfer'):
        return
    active_window = sublime.active_window()
    active_view = active_window.active_view()
    target_view = repl_view.view
    if target_view == active_view:
        return  #
    active_group = sublime.active_window().active_group()
    if target_view in active_window.views_in_group(active_group):
        return  # same group, dont switch
    active_window.focus_view(target_view)
    active_window.focus_view(view)


"""Senders is a dict of functions used to transfer text to repl as a repl
   specific load_file action"""
SENDERS = defaultdict(lambda: default_sender)


def sender(external_id,):
    def wrap(func):
        SENDERS[external_id] = func
    return wrap


@sender("coffee")
def coffee(repl, text, view=None, repl_view=None):
    """
        use CoffeeScript multiline hack
        http://coffeescript.org/documentation/docs/repl.html
    """
    default_sender(repl, text.replace("\n", u'\uFF00') + "\n", view, repl_view)

@sender("python")
def python_sender(repl, text, view=None, repl_view=None):
    text_wo_encoding = re.sub(
        pattern=r"#.*coding[:=]\s*([-\w.]+)",
        repl="# <SublimeREPL: encoding comment removed>",
        string=text,
        count=1)
    code = binascii.hexlify(text_wo_encoding.encode("utf-8"))
    execute = ''.join([
        'from binascii import unhexlify as __un; exec(compile(__un("',
        str(code.decode('ascii')),
        '").decode("utf-8"), "<string>", "exec"))\n'
    ])
    return default_sender(repl, execute, view, repl_view)


@sender("ruby")
def ruby_sender(repl, text, view=None, repl_view=None):
    code = binascii.b2a_base64(text.encode("utf-8"))
    payload = "begin require 'base64'; eval(Base64.decode64('%s'), binding=TOPLEVEL_BINDING) end\n" % (code.decode("ascii"),)
    return default_sender(repl, payload, view, repl_view)


# custom clojure sender that makes sure that all selections are
# evaluated in the namespace declared by the file they are in
@sender("clojure")
def clojure_sender(repl, text, view, repl_view=None):
    # call (load-string) instead of just writing the string so
    # that syntax errors are caught and thrown back immediately.
    # also, escape backslashes and double-quotes
    text = '(load-string "' + text.strip().replace('\\', r'\\').replace('"', r'\"') + '")'

    # find the first non-commented statement from the start of the file
    namespacedecl = view.find(r"^[^;]*?\(", 0)

    # if it's a namespace declaration, go search for the namespace name
    if namespacedecl and view.scope_name(namespacedecl.end()-1).startswith("source.clojure meta.function.namespace.clojure"):
        namespacedecl = view.extract_scope(namespacedecl.end()-1)

        # we're looking for the first symbol within the declaration that
        # looks like a namespace and isn't metadata, a comment, etc.
        pos = namespacedecl.begin() + 3
        while pos < namespacedecl.end():
            # see http://clojure.org/reader for a description of valid
            # namespace names. the inital } or whitespace make sure we're
            # not matching on keywords etc.
            namespace = view.find(r"[\}\s][A-Za-z\_!\?\*\+\-][\w!\?\*\+\-:]*(\.[\w!\?\*\+\-:]+)*", pos)

            if not namespace:
                # couldn't find the namespace name within the declaration. suspicious.
                break
            elif view.scope_name(namespace.begin() + 1).startswith("source.clojure meta.function.namespace.clojure entity.name.namespace.clojure"):
                # looks alright, we've got our namespace!
                # switch to namespace before executing command

                # we could do this explicitly by calling (ns), (in-ns) etc:
                # text = "(ns " + view.substr(namespace)[1:] + ") " + text
                # but this would not only result in an extra return value
                # printed to the user, the repl would also remain in that
                # namespace after execution, so instead we do the same thing
                # that swank-clojure does:
                text = "(binding [*ns* (or (find-ns '" + view.substr(namespace)[1:] + ") (find-ns 'user))] " + text + ')'
                # i.e. we temporarily switch to the namespace if it has already
                # been created, otherwise we execute it in 'user. the most
                # elegant option for this would probably be:
                # text = "(binding [*ns* (create-ns '" + view.substr(namespace)[1:] + ")] " + text + ')'
                # but this can lead to problems because of newly created
                # namespaces not automatically referring to clojure.core
                # (see https://groups.google.com/forum/?fromgroups=#!topic/clojure/Th-Bqq68hfo)
                break
            else:
                # false alarm (metadata or a comment), keep looking
                pos = namespace.end()
    return default_sender(repl, text + repl.cmd_postfix, view, repl_view)

class ReplViewWrite(sublime_plugin.TextCommand):
    def run(self, edit, external_id, text):
        for rv in manager.find_repl(external_id):
            rv.append_input_text(text)
            break  # send to first repl found
        else:
            sublime.error_message("Cannot find REPL for '{0}'".format(external_id))


class ReplSend(sublime_plugin.TextCommand):
    def run(self, edit, external_id, text, with_auto_postfix=True):
        for rv in manager.find_repl(external_id):
            if with_auto_postfix:
                text += rv.repl.cmd_postfix
            if sublime.load_settings(SETTINGS_FILE).get('show_transferred_text'):
                rv.append_input_text(text)
                rv.adjust_end()
            SENDERS[external_id](rv.repl, text, self.view, rv)
            break
        else:
            sublime.error_message("Cannot find REPL for '{}'".format(external_id))


class ReplTransferCurrent(sublime_plugin.TextCommand):
    def run(self, edit, scope="selection", action="send"):
        text = ""
        if scope == "selection":
            text = self.selected_text()
        elif scope == "lines":
            text = self.selected_lines()
        elif scope == "function":
            text = self.selected_functions()
        elif scope == "block":
            text = self.selected_blocks()
        elif scope == "file":
            text = self.selected_file()
        cmd = "repl_" + action
        self.view.window().run_command(cmd, {"external_id": self.repl_external_id(), "text": text})

    def repl_external_id(self):
        return self.view.scope_name(0).split(" ")[0].split(".", 1)[1]

    def selected_text(self):
        v = self.view
        parts = [v.substr(region) for region in v.sel()]
        return "".join(parts)

    def selected_blocks(self):
        # TODO: Clojure only for now
        v = self.view
        strs = []
        old_sel = list(v.sel())
        v.run_command("expand_selection", {"to": "brackets"})
        v.run_command("expand_selection", {"to": "brackets"})
        for s in v.sel():
            strs.append(v.substr(s))
        v.sel().clear()
        for s in old_sel:
            v.sel().add(s)
        return "\n\n".join(strs)

    def selected_lines(self):
        v = self.view
        parts = []
        for sel in v.sel():
            for line in v.lines(sel):
                parts.append(v.substr(line))
        return "\n".join(parts)

    def selected_file(self):
        v = self.view
        return v.substr(sublime.Region(0, v.size()))

########NEW FILE########
