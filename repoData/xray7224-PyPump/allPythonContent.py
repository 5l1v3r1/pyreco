__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PyPump documentation build configuration file, created by
# sphinx-quickstart on Mon May 27 12:57:47 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import time
import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# Versions/Release
version = "0.6"
release = "0.6-dev"

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PyPump'
copyright = u'{year}, Jessica Tallon'.format(year=time.strftime("%Y"))

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

sys.path.append(os.path.abspath("themes"))

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'kr'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ["themes"]

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'PyPumpdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'PyPump.tex', u'PyPump Documentation',
   u'Jessica Tallon', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pypump', u'PyPump Documentation',
     [u'Jessica Tallon'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'PyPump', u'PyPump Documentation',
   u'Jessica Tallon', 'PyPump', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = pypump-post-note
#!/usr/bin/env python
##
#   Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
##

import os
import json
import argparse

from pypump import PyPump, Client

class App(object):

    client_name = 'pypump-post-note'
    pump = None
    config_file = os.path.join(os.environ['HOME'],'.config',
                               client_name, 'config.json')
    config = dict()

    def __init__(self):
        """ Init app and log in to our pump.io account """

        # Set up argparse
        self.parser = argparse.ArgumentParser(description='Post a note to the pump.io network')
        self.parser.add_argument('-u', '--user', dest='webfinger', required=True, help='user@example.com')
        self.parser.add_argument('-t', '--title', dest='note_title', default=None, help='Note title')
        self.parser.add_argument('-n', '--note', dest='note_content', required=True, help='Note content')
        self.args = self.parser.parse_args()

        self.read_config()

        # Try to login to our pump.io account using account credentials
        # from config, if our webfinger is not found in config we will
        # have to authorize the app with our account.
        webfinger = self.args.webfinger

        client=Client(
            webfinger=webfinger,
            type='native',
            name=self.client_name,
            key=self.config.get(webfinger, {}).get('key'),
            secret=self.config.get(webfinger, {}).get('secret')
        )

        self.pump = PyPump(
            client=client,
            token=self.config.get(webfinger, {}).get('token'),
            secret=self.config.get(webfinger, {}).get('token_secret'),
            verifier_callback=self.verifier
        )

        # Add account credentials to config in case we didnt have it already
        self.config[webfinger] = {
            'key' : self.pump.get_registration()[0],
            'secret' : self.pump.get_registration()[1],
            'token' : self.pump.get_token()[0],
            'token_secret' : self.pump.get_token()[1],
        }

        self.write_config()

    def verifier(self, url):
        """ Will ask user to click link to accept app and write code """
        webbrowser.open(url)
        print('A browser should have opened up with a link to allow us to access')
        print('your account, follow the instructions on the link and paste the verifier')
        print('Code into here to give us access, if the browser didn\'t open, the link is:')
        print(url)
        print()
        return input('Verifier: ').lstrip(" ").rstrip(" ")

    def write_config(self):
        """ Write config to file """
        if not os.path.exists(os.path.dirname(self.config_file)):
            os.makedirs(os.path.dirname(self.config_file))
        with open(self.config_file, 'w') as f:
            f.write(json.dumps(self.config))
            f.close()
    
    def read_config(self):
        """ Read config from file """
        try:
            with open(self.config_file, 'r') as f:
                self.config = json.loads(f.read())
                f.close()
        except IOError:
            return False
        return True

    def post_note(self):
        """ Post note and return the URL of the posted note """
        if self.args.note_title:
            note_title = self.args.note_title
        else:
            note_title = None
        note_content = self.args.note_content
        mynote = self.pump.Note(display_name=note_title, content = note_content)
        mynote.to = self.pump.me.followers
        mynote.cc = self.pump.Public
        mynote.send()

        return mynote.id or None

if __name__ == '__main__':
    app = App()
    url = app.post_note()

    if url:
        print('Note posted')
    else:
        print('Note could not be posted')

########NEW FILE########
__FILENAME__ = client
##
#   Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
#   This program is free software: you can redistribute it and/or modify 
#   it under the terms of the GNU General Public License as published by 
#   the Free Software Foundation, either version 3 of the License, or 
#   (at your option) any later version. 
# 
#   This program is distributed in the hope that it will be useful, 
#   but WITHOUT ANY WARRANTY; without even the implied warranty of 
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
#   GNU General Public License for more details. 
# 
#   You should have received a copy of the GNU General Public License 
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
##

from __future__ import absolute_import

import json
import logging

import requests

_log = logging.getLogger(__name__)

class ClientException(Exception):
    
    def __init__(self, message, context=None, *args, **kwargs):
        if context is not None:
            message = "{0} (context: {1})".format(message, context)
        
        super(ClientException, self).__init__(message, *args, **kwargs)

class Client(object):
    """This represents a client/application which is using the Pump API

    Attributes / init args::
    - webfinger: webfinger id of this user, ie "mary@example.org"
      This is probably your username @ the domain of the pump instance
      you're using.
    - type: whether this is a "web" or "native" client.  Unless you're
      using pypump as part of a web service, you should choose "native".
    - name: The name of this client, ie your application's name.  For
      example, if you were using PyPump to write CoolCommunicator, you
      would put "CoolCommunicator" here.
    - contacts: Who wrote this application?  List of email addresses
      of those who authored this client.
    - redirect: a list of URIs as callbacks for the authorization
      server
    - logo: URI of your application's logo.

    Additionally, the following init args should only be supplied if
    you've already registered this client with the server.  If not,
    these will be filled in during the `self.register()` step::
    - key: If This is the token (the `client_id`) we got back that
      identifies our client, assuming we've already registered our
      client.
    - secret: This is your secret token that authorizes you to connect
      to the pump instance (the `client_secret`).
    - expirey: When our token expires (`espires_at`)

    Note that the above three are not the same as the oauth
    permissions verifying the user has access to post, this is related
    to permissions and identification of the client software to post.
    For the premission related to the access of the account, see
    PyPump.key and PyPump.secret.
    """

    ENDPOINT = "api/client/register"

    def __init__(self, webfinger, type, name=None, contacts=None, redirect=None,
                 logo=None, key=None, secret=None, expirey=None):

        self.webfinger = webfinger
        self.name = name 
        self.type = type
        self.logo = logo
        self.contacts = contacts or []
        self.redirect = redirect or []

        self.key = key
        self.secret = secret
        self.expirey = expirey

        self._pump = None

    @property
    def server(self):
        return self.webfinger.split("@", 1)[1]
    
    @property
    def nickname(self):
        return self.webfinger.split("@", 1)[0]

    def set_pump(self, pump):
        self._pump = pump

    @property
    def context(self):
        """ Provides request context """
        type = "client_associate" if self.key is None else "client_update"
        data = {
            "type": type, 
            "application_type": self.type,
        }

        # is this an update?
        if self.key:
            data["client_id"] = self.key
            data["client_secret"] = self.secret

        # Add optional params
        if self.name:
            data["application_name"] = self.name

        if self.logo:
            data["logo_url"] = self.logo

        if self.contacts:
            # space seporated list
            data["contacts"] = " ".join(self.contacts)

        if self.redirect:
            data["redirect_uri"] = " ".join(self.redirect)

        # Convert to JSON  and send
        return json.dumps(data)

    def request(self, server=None):
        """ Sends the request """
        request = {
                "headers": {"Content-Type": "application/json"},
                "data": self.context,
                }
        
        url = "{proto}://{server}/{endpoint}".format(
            proto=self._pump.protocol,
            server = server or self.server,
            endpoint = self.ENDPOINT
        )
        
        response = self._pump._requester(requests.post, url, **request)
        
        try:
            server_data = response.json()
        except ValueError:
            raise ClientException(response.content)

        if "error" in server_data:
            raise ClientException(server_data["error"], self.context)

        _log.debug("Client registration recieved: %(id)s %(secret)s %(expire)s", {
                "id": server_data["client_id"],
                "secret": server_data["client_secret"],
                "expire": server_data["expires_at"]
                })
        
        return server_data

    def register(self, server=None):
        """ Reigsters the client with the Pump API retriving the id and secret """
        if (self.key or self.secret):
            return self.update()
 
        server_data = self.request(server)

        self.key = server_data["client_id"]
        self.secret = server_data["client_secret"]
        self.expirey = server_data["expires_at"]

    def update(self):
        """ Updates the information the Pump server has about the client """
        error = ""

        if self.key is None:
            error = "To update a client you need to provide a key"
        if self.secret is None:
            error = "To update a client you need to provide the secret"

        if error:
            raise ClientException(error)

        self.request()
        return True

    def __repr__(self):
        if self.key:
            return "<Client {0} ({1})>".format(self.server, self.key)
        return "<Client {0}>".format(self.server)

    def __str__(self):
        return repr(self)


########NEW FILE########
__FILENAME__ = DoesNotExist
##
#   Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
##

class DoesNotExist(Exception):
    pass


########NEW FILE########
__FILENAME__ = ImmutableException
##
#   Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
##

class ImmutableException(Exception):

    message = "You can't set %s on %s, the object is immutable."

    def __init__(self, item, obj, *args, **kwargs):
        message = self.message % (item, obj)
        super(ImmutableException, self).__init__(message, *args, **kwargs)

########NEW FILE########
__FILENAME__ = PumpException
##
#   Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
##

class PumpException(Exception):
    """ This is used when the remote server gives an error """
    pass

########NEW FILE########
__FILENAME__ = ServerError
##
#   Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
##

import json

class ServerError(Exception):
    
    def __init__(self, data, *args, **kwargs):
        data = json.loads(data)
        super(ServerError, self).__init__(data["error"], *args, **kwargs)

########NEW FILE########
__FILENAME__ = StoreException
##
#   Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
##


class StoreException(Exception):
    """ Raised when error occurs in store """
    pass

class ValidationError(StoreException):
    """ Raised when validation on a field fails """
    pass

########NEW FILE########
__FILENAME__ = activity
##
# Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>.
##

from dateutil.parser import parse
from pypump.models import AbstractModel

import pypump.models.activity
import six
import logging

_log = logging.getLogger(__name__)

class Mapper(object):
    """ Handles mapping of json attributes to models """

    # TODO probably better to move this into the models,
    # {"json_attr":("model_attr", "datatype"), .. } or similar
    literals = ["content", "display_name", "id", "objectType",
                "object_type", "summary", "url", "preferred_username",
                "verb", "username", "total_items", "liked",]
    dates = ["updated", "published", "deleted", "received"]
    objects = ["generator", "actor", "obj", "author", "in_reply_to", "location"]
    lists = ["to", "cc", "bcc", "bto","object_types"]
    #feeds = ["likes", "shares", "replies"]

    def __init__(self, pypump=None, *args, **kwargs):
        self._pump = pypump

    def parse_map(self, obj, mapping=None, ignore_attr=None, *args, **kwargs):
        """ Parses a dictionary of (model_attr, json_attr) items """
        mapping = mapping or obj._mapping
        ignore_attr = ignore_attr or obj._ignore_attr

        if "data" in kwargs:
            for k, v in mapping.items():
                if v in kwargs["data"] and k not in ignore_attr:
                    self.add_attr(obj, k, kwargs["data"][v], from_json=True)
                #elif k not in ignore_attr:
                    #_log.debug("Setting attribute %r to None" % k)
                    #self.set_none(obj, k)
        else:
            for k, v in mapping.items():
                if k in kwargs and k not in ignore_attr:
                    self.add_attr(obj, k, kwargs[k])

    def add_attr(self, obj, key, data, from_json=False):
        if key in self.objects:
            self.set_object(obj, key, data, from_json)
        elif key in self.dates:
            self.set_date(obj, key, data, from_json)
        elif key in self.lists:
            self.set_list(obj, key, data, from_json)
        elif key in self.literals:
            self.set_literal(obj, key, data, from_json)
        else:
            _log.debug("Ignoring unknown attribute %r", key)

    def set_none(self, obj, key):
        setattr(obj, key, None)

    def set_literal(self, obj, key, data, from_json):
        setattr(obj, key, data)

    def get_object(self, data):
        try:
            # Look for suitable PyPump model based on objectType
            obj_type = data.get("objectType").capitalize()
            obj = getattr(self._pump, obj_type)
            obj = obj().unserialize(data)
            _log.debug("Created PyPump model %r" % obj.__class__)
            return obj
        except AttributeError as e:
            _log.debug("Exception: %s" % e)
            try:
                # Look for suitable activityobject model based on objectType
                obj = getattr(pypump.models.activity, data.get("objectType").capitalize())
                obj = obj(pypump=self._pump, data=data)
                _log.debug("Created activity.* model: %r" % obj.__class__)
                return obj
            except AttributeError as e:
                # Fall back to ActivityObject
                _log.debug("Exception: %s" % e)
                obj = ActivityObject(pypump=self._pump, data=data)
                _log.debug("Created ActivityObject: %r" % obj)
                return obj

    def set_object(self, obj, key, data, from_json):
        if from_json:
            setattr(obj, key, self.get_object(data))

    def set_date(self, obj, key, data, from_json):
        if from_json:
            setattr(obj, key, parse(data))

    def set_list(self, obj, key, data, from_json):
        if from_json:
            tmplist = []
            for i in data:
                if isinstance(i, six.string_types):
                    tmplist.append(i)
                else:
                    tmplist.append(self.get_object(i))
            setattr(obj, key, tmplist)


class ActivityObject(AbstractModel):
    """ Super class for activity objects,
        this class is used when we can't find a matching object type
    """
    _ignore_attr = []

    # Map of (model_attr, json_attr) pairs
    # TODO include attribute type here, see TODO in Mapper
    _mapping = {
        "attachments": "attachments",
        "author": "author",
        "content": "content",
        "display_name": "displayName",
        "downstream_duplicates": "downstreamDuplicates",
        "id": "id",
        "image": "image",
        "in_reply_to": "inReplyTo",
        "likes": "likes",
        "links": "links",
        "objectType": "objectType",
        "published": "published",
        "replies": "replies",
        "shares": "shares",
        "summary": "summary",
        "updated": "updated",
        "upstream_duplicates": "upstreamDuplicates",
        "url": "url",
        "deleted" : "deleted"
    }

    
    # We set these to None for now to remove the AbstractModel read-only properties so we can set our own attributes
    #TYPE = None
    objectType = None

    def __repr__(self):
        return "<{type}: {id}>".format(type=self.objectType, id=self.id)

    def __str__(self):
        return str(self.__repr__())

    def __init__(self, *args, **kwargs):
        super(ActivityObject, self).__init__(*args, **kwargs)
        Mapper(*args, **kwargs).parse_map(self,
                           mapping=ActivityObject._mapping,
                           ignore_attr=ActivityObject._ignore_attr,
                           *args,
                           **kwargs)


class Application(ActivityObject):
    _ignore_attr = ["likes", "replies", "shares"]
    _mapping = {}

    def __init__(self, *args, **kwargs):
        super(Application, self).__init__(*args, **kwargs)
        Mapper(*args, **kwargs).parse_map(self, *args, **kwargs)


class Activity(AbstractModel):
    _ignore_attr = []
    _mapping = {
        "verb":"verb",
        "generator":"generator",
        "updated":"updated",
        "url":"url",
        "published":"published",
        "received":"received",
        "content":"content",
        "id":"id",
        "to":"to",
        "cc":"cc",
        "actor":"actor",
        "obj":"object"
    }

    def __init__(self, *args, **kwargs):
        super(Activity, self).__init__(*args, **kwargs)
    
    def __repr__(self):
        return '<Activity: {webfinger} {verb}ed {model}>'.format(
            webfinger=self.actor.id.replace("acct:", ""),
            verb=self.verb.rstrip("e"), # english: e + ed = ed
            model=self.obj.objectType
        )

    def unserialize(self, data):
        """ From JSON -> Activity object """

        if "author" not in data["object"]:
            # add author if not set (true for posted objects in inbox/major)
            data["object"]["author"] = data["actor"]

        Mapper(pypump=self._pump).parse_map(self, data=data)
        self.add_links(data)

        return self


########NEW FILE########
__FILENAME__ = collection
##
# Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>.
##
import logging

from pypump.models import AbstractModel
from pypump.models.feed import Feed
from pypump.models.activity import Mapper

_log = logging.getLogger(__name__)

class Collection(AbstractModel):

    _members = None
    _ignore_attr = ["dummyattr", ]
    _mapping = {
        "id": "id",
        "display_name": "displayName",
        "content": "content",
        "author": "author",
        "published": "published",
        "updated": "updated",
        "url": "url"
    }

    def __init__(self, id=None, *args, **kwargs):
        super(Collection, self).__init__(*args, **kwargs)

        self.id = id

    @property
    def members(self):
        self._members = self._members or Feed(self.links["members"], pypump=self._pump)
        return self._members

    @property
    def ENDPOINT(self):
        return self.id

    def add(self, obj):
        """ Adds a member to the collection """
        activity = {
            "verb": "add",
            "object": {
                "objectType": obj.objectType,
                "id": obj.id
            },
            "target":{
                "objectType": "collection",
                "id": self.id
            }
        }

        self._post_activity(activity)

    def remove(self, obj):
        """ Removes a member from the collection """
        activity = {
            "verb": "remove",
            "object": {
                "objectType": obj.objectType,
                "id": obj.id
            },
            "target":{
                "objectType": "collection",
                "id": self.id
            }
        }

        self._post_activity(activity)

    def delete(self):
        """ Deletes the collection """
        self._pump.request(self.id, method="DELETE")

    def __str__(self):
        return self.display_name or self.id

    def __repr__(self):
        return "<{type}: {id}>".format(type=self.TYPE, id=self.id)

    def unserialize(self, data):
        Mapper(pypump=self._pump).parse_map(self, data=data)
        self.add_links(data)
        return self


class Public(object):
    ENDPOINT = "http://activityschema.org/collection/public"

    def __init__(self):
        self.id = self.ENDPOINT
        self.objectType = 'collection'


########NEW FILE########
__FILENAME__ = comment
##
# Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>.
##

from dateutil.parser import parse
from pypump.models import (AbstractModel, Commentable, Likeable, Shareable, 
                           Deleteable)
from pypump.models.activity import Mapper

class Comment(AbstractModel, Likeable, Shareable, Deleteable, Commentable):

    _ignore_attr = []
    _mapping = {
        "id": "id",
        "url": "url",
        "content": "content",
        "published": "published",
        "updated": "updated",
        "deleted": "deleted",
        "liked" : "liked",
        "author" : "author",
        "in_reply_to" : "inReplyTo"
    }

    @property
    def ENDPOINT(self):
        return "/api/user/{username}/feed".format(
            username=self._pump.client.nickname
            )

    id = None
    url = None
    content = None
    published = None
    updated = None
    deleted = None
    liked = None
    author = None
    in_reply_to = None

    def __init__(self, content=None, id=None, in_reply_to=None, published=None, updated=None,
                 deleted=None, liked=None, author=None, url=None, *args, **kwargs):

        super(Comment, self).__init__(*args, **kwargs)

        self.id = id
        self.url = url
        self.content = content
        self.published = published
        self.updated = updated
        self.deleted = deleted
        self.liked = liked
        self.author = author
        self.in_reply_to = in_reply_to

    def __repr__(self):
        return "<{type} by {webfinger}>".format(
            type=self.TYPE,
            webfinger=getattr(self.author,'webfinger', 'unknown')
            )

    def send(self):
        activity = {
            "verb":"post",
            "object":{
                "objectType":self.objectType,
                "content":self.content,
                "inReplyTo":{
                    "id":self.in_reply_to.id,
                    "objectType":self.in_reply_to.objectType,
                },
            },
        }

        return self._post_activity(activity)

    def unserialize(self, data):
        """ from JSON -> Comment """
        Mapper(pypump=self._pump).parse_map(self, data=data)
        self.add_links(data)
        return self
        

########NEW FILE########
__FILENAME__ = feed
##
# Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>.
##

import logging
import six

from pypump.models import AbstractModel
from pypump.models.activity import Mapper

_log = logging.getLogger(__name__)

class ItemList(object):
    """ A feed's list of items """

    previous_id = None

    def __init__(self, feed, count=None, start=None, stop=None):
        self.feed = feed
        self.start = start
        self.stop = stop
        self.cache = list()
        self.count = count
        self.itercounter = 0

    def __iter__(self):
        return self

    def _should_stop(self, data):
        if not data:
            return True

        if type(self.stop) == int:
            if type(self.start) == int:
                # feed[start_int:stop_int]
                if self.stop and self.itercounter >= (self.stop - self.start):
                    return True
            elif self.start is not None:
                # feed[start_id:count_int]
                if self.itercounter >= self.stop:
                    return True
            elif self.start is None:
                if self.itercounter >= self.stop:
                    return True

        elif self.stop is not None:
            # feed[:stop_id]
            if self.stop == data["id"]:
                return True

    def _build_cache(self):
        if not self.previous_id:
            if type(self.start) == int:
                response = self.feed._request(count=self.count, offset=self.start)
            elif self.start is not None:
                response = self.feed._request(count=self.count, before=self.start)
            else:
                response = self.feed._request(count=self.count)
        elif "next" in self.feed.links:
            url = self.feed.links["next"]
            response = self.feed._request(count=self.count, feed_url=url)
        else:
            response = None
        
        self.cache = response["items"] if response else None

    def __next__(self):
        if not self.cache:
            self._build_cache()
        data = self.cache.pop(0) if self.cache else None

        if self._should_stop(data):
            raise StopIteration

        if not data.get("objectType"): # object without an objectType, grr
            data["objectType"] = self.feed.object_types[0].capitalize()
        obj = Mapper(pypump=self.feed._pump).get_object(data)
        self.previous_id = obj.id
        self.itercounter +=1
        return obj

    def next(self):
        return self.__next__()


class Feed(AbstractModel):
    id = None
    display_name = None
    total_items = None
    object_types = None
    url = None
    _parent = None
    _ENDPOINT = None

    @property
    def ENDPOINT(self):
        if self._ENDPOINT is None:
            raise NotImplementedError("Definition of the ENDPOINT must be done by subclass")
        return self._ENDPOINT

    @property
    def items(self):
        return ItemList(self)

    def __init__(self, feed_url=None, *args, **kwargs):
        super(Feed, self).__init__(*args, **kwargs)

        self._ENDPOINT = feed_url
        self.id = self.ENDPOINT

        tmp = self.total_items or list(self[:1]) # we do a request on init to get some info

    def __repr__(self):
        return "<Feed: {type}>".format(
            type = self.TYPE,
        )

    def __str__(self):
        return "{name}".format(name=self.display_name or self.TYPE)

    def __iter__(self):
        return ItemList(self)

    def __getitem__(self, key):
        if isinstance(key, slice):
            return self.__getslice__(key)
        if type(key) is not int:
            raise TypeError('index must be integer')
        item = ItemList(self, count=1, start=key, stop=key+1)
        try:
            return item.next()
        except StopIteration:
            raise IndexError

    def __getslice__(self, s, e=None):
        if type(s) is not slice:
            s = slice(s,e)

        return ItemList(self, start=s.start, stop=s.stop)

    def _request(self, offset=None, count=None, since=None, before=None, feed_url=None):
        params = dict()
        for i in ["count", "offset", "since", "before"]:
            if eval(i):
                params[i] = eval(i)

        url = feed_url or self.ENDPOINT

        _log.debug("feed._request: url: %s, params: %s", url, params)
        data = self._pump.request(url, params=params)
        self.unserialize(data)
        return data

    def _subfeed(self, feedname):
        endpoint = self.ENDPOINT
        if not endpoint.endswith("/"):
            endpoint += "/"
        return endpoint + feedname

    def unserialize(self, data):
        ignore_attr = ["dummyattr",]
        mapping = {
            "display_name": "displayName",
            "total_items": "totalItems",
            "object_types": "objectTypes",
            "url": "url",
            "author": "author"
        }

        Mapper(pypump=self._pump).parse_map(self, mapping=mapping, ignore_attr=ignore_attr, data=data)
        self.links = {} # we need to delete old links or else we get infinite feeds
        self.add_links(data)


class Followers(Feed):
    """ Person's followers """

class Following(Feed):
    """ People followed by Person """

class Favorites(Feed):
    """ Person's favorites """

class Inbox(Feed):
    """ Person's inbox """
    _ENDPOINT = None
    _direct = None
    _minor = None
    _major = None

    def __init__(self, feed_url=None, *args, **kwargs):
        super(Inbox, self).__init__(feed_url, *args, **kwargs)
        if feed_url is not None:
            self._ENDPOINT = feed_url

    @property
    def ENDPOINT(self):
        return self._ENDPOINT

    @property
    def direct(self):
        endpoint = self._subfeed("direct")
        if "direct" in self.id or "major" in self.id or "minor" in self.id:
            return self
        self._direct = self._direct or self.__class__(endpoint, pypump=self._pump)
        return self._direct

    @property
    def major(self):
        endpoint = self._subfeed("major")
        if "major" in self.id or "minor" in self.id:
            return self
        self._major = self._major or self.__class__(endpoint, pypump=self._pump)
        return self._major

    @property
    def minor(self):
        endpoint = self._subfeed("minor")
        if "minor" in self.id or "major" in self.id:
            return self
        self._minor = self._minor or self.__class__(endpoint, pypump=self._pump)
        return self._minor


class Outbox(Feed):
    """ Person's outbox """
    _ENDPOINT = None
    _major = None
    _minor = None

    def __init__(self, feed_url=None, *args, **kwargs):
        super(Outbox, self).__init__(feed_url, *args, **kwargs)
        if feed_url is not None:
            self._ENDPOINT = feed_url

    @property
    def ENDPOINT(self):
        return self._ENDPOINT

    @property
    def major(self):
        endpoint = self._subfeed("major")
        if "major" in self.id or "minor" in self.id:
            return self
        self._major = self._major or self.__class__(endpoint, pypump=self._pump)
        return self._major

    @property
    def minor(self):
        endpoint = self._subfeed("minor")
        if "major" in self.id or "minor" in self.id:
            return self
        self._minor = self._minor or self.__class__(endpoint, pypump=self._pump)
        return self._minor


class Lists(Feed):
    _membertype="person"

    @property
    def membertype(self):
        return self._membertype

    @property
    def ENDPOINT(self):
        # offset and count doesnt work properly, see https://github.com/e14n/pump.io/issues/794
        return self._ENDPOINT

    def create(self, display_name, content=None):
        """ Creates a new list """
        activity = {
            "verb":"create",
            "object":{
                "objectType":"collection",
                "objectTypes":[self.membertype],
                "displayName":display_name,
                "content":content
            }
        }
        self._post_activity(activity, unserialize=False)

    def __getitem__(self, key):
        if isinstance(key, six.string_types):
            lists = list(self)
            for i in lists:
                if i.display_name == key:
                    return i
        else:
            return super(Lists, self).__getitem__(key)


########NEW FILE########
__FILENAME__ = image
##
# Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>.
##

import logging
import mimetypes
import os

from dateutil.parser import parse

from pypump.models import (AbstractModel, Postable, Likeable, Commentable,
                           Deleteable, Shareable)
from pypump.models.activity import Mapper

_log = logging.getLogger(__name__)

class ImageContainer(object):
    """ Container to hold about a specific image """
    def __init__(self, url, width, height):
        self.url = url
        self.width = width
        self.height = height

    def __repr__(self):
        return "<Image {width}x{height}".format(
            width=self.width,
            height=self.height
        )

class Image(AbstractModel, Postable, Likeable, Shareable, Commentable, Deleteable):

    _ignore_attr = []
    _mapping = {
        "id": "id",
        "url": "url",
        "display_name": "displayName",
        "summary": "summary",
        "content": "content",
        "author": "author",
        "published": "published",
        "updated": "updated",
        "deleted": "deleted",
    }

    id = None
    url = None
    display_name = None
    summary = None
    content = None
    author = None
    published = None
    updated = None
    deleted = None

    @property
    def ENDPOINT(self):
        return "/api/user/{username}/feed".format(self._pump.client.nickname)

    def __init__(self, id=None, url=None, display_name=None, content=None, 
                 author=None, published=None, updated=None, *args, **kwargs):

        super(Image, self).__init__(*args, **kwargs)

        self.id = id
        self.display_name = display_name
        self.content = content
        self.author = author
        self.url = url
        self.published = published
        self.updated = updated

    def __repr__(self):
        if self.author is None:
            return "<{type}>".format(type=self.TYPE)

        return "<{type} by {webfinger}>".format(
            type=self.TYPE,
            webfinger=self.author.webfinger)

    def from_file(self, filename):
        """ Uploads an image from a filename """
        mimetype = mimetypes.guess_type(filename)[0] or "application/octal-stream"
        headers = {
            "Content-Type": mimetype,
            "Content-Length": os.path.getsize(filename),
        }
        
        # upload image file
        image = self._pump.request(
                "/api/user/{0}/uploads".format(self._pump.client.nickname),
                method="POST",
                data=open(filename, "rb").read(),
                headers=headers,
                )

        # now send it to the feed
        data = {
            "verb": "post",
            "object": image,
        }
        data.update(self.serialize())

        if not self.content and not self.display_name:
            self._post_activity(data)
        else:
            self._post_activity(data, unserialize=False)

            # update image with display_name and content
            if self.content:
                image['content'] = self.content
            if self.display_name:
                image['displayName'] = self.display_name
            data = {
                "verb": "update",
                "object": image,
            }
            self._post_activity(data)

        return self

    def unserialize(self, data):

        if "fullImage" in data:
            full_image = data["fullImage"]
            self.original = ImageContainer(
                url=full_image["url"],
                height=full_image.get("height"),
                width=full_image.get("width")
            )
            
        if "image" in data:
            save_point = "original" if not hasattr(self, "original") else "thumbnail"
            thumbnail = data["image"]
            setattr(self, save_point, ImageContainer(
                url=thumbnail["url"],
                height=thumbnail.get("height"),
                width=thumbnail.get("width")
            ))
        Mapper(pypump=self._pump).parse_map(self, data=data)
        self.add_links(data)

        return self

########NEW FILE########
__FILENAME__ = note
##
# Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>.
##

from datetime import datetime
from dateutil.parser import parse

from pypump.models import (AbstractModel, Postable, Likeable, Shareable, 
                           Commentable, Deleteable)
from pypump.models.activity import Mapper

class Note(AbstractModel, Postable, Likeable, Shareable, Commentable, Deleteable):

    _ignore_attr = []
    _mapping = {
        "id": "id",
        "url": "url",
        "display_name": "displayName",
        "content": "content",
        "published": "published",
        "updated": "updated",
        "deleted": "deleted",
        "liked": "liked",
        "author": "author"
    }
    
    @property
    def ENDPOINT(self):
        return "/api/user/{username}/feed".format(
            username=self._pump.client.nickname
            )

    id = None
    url = None
    display_name = None
    content = None
    published = None # When this was published
    updated = None # last time this was updated
    deleted = None # has the note been deleted
    liked = None
    author = None

    def __init__(self, content=None, id=None, published=None, updated=None, 
                 deleted=False, liked=None, author=None, display_name=None, url=None,
                 *args, **kwargs):

        super(Note, self).__init__(*args, **kwargs)

        self.id = id
        self.url = url
        self.display_name = display_name
        self.content = content
        self.published = published
        self.updated = updated
        self.deleted = deleted
        self.liked = liked
        self.author = author

    def serialize(self):
        """ Convers the post to JSON """
        data = super(Note, self).serialize()
        data.update({
            "verb":"post",
            "object":{
                "objectType":self.objectType,
                "content":self.content,
            }
        })
        if self.display_name:
            data["object"]["displayName"] = self.display_name

        return data

    def __repr__(self):
        return "<{type} by {name}>".format(
            type=self.TYPE,
            name=getattr(self.author, 'webfinger', 'unknown')
            )
   
    def unserialize(self, data):
        """ Goes from JSON -> Note object """
        Mapper(pypump=self._pump).parse_map(self, data=data)
        self.add_links(data)
        return self

########NEW FILE########
__FILENAME__ = person
##
# Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>.
##

import six

from datetime import datetime
from dateutil.parser import parse

from pypump.models import AbstractModel
from pypump.exception import PyPumpException
from pypump.models.feed import (Followers, Following, Lists,
                                Favorites, Inbox, Outbox)
from pypump.models.activity import Mapper

class Person(AbstractModel):

    _ignore_attr = []
    _mapping = {
        "id": "id",
        "url": "url",
        "username": "preferredUsername",
        "display_name": "displayName",
        "summary": "summary",
        "updated": "updated",
        "published":"published",
        "location":"location",
    }

    TYPE = "person"
    ENDPOINT = "/api/user/{username}/feed"

    id = None
    username = None
    display_name = None
    url = None # url to profile
    updated = None # Last time this was updated
    published = None # when they joined (I think?)
    location = None # place item
    summary = None # lil bit about them =]    
    image = None # Image items

    _inbox = None
    _outbox = None
    _followers = None
    _following = None
    _favorites = None
    _lists = None

    @property
    def outbox(self):
        self._outbox = self._outbox or Outbox(self.links['activity-outbox'],pypump=self._pump)
        return self._outbox

    @property
    def followers(self):
        self._followers = self._followers or Followers(self.links['followers'],pypump=self._pump)
        return self._followers

    @property
    def following(self):
        self._following = self._following or Following(self.links['following'],pypump=self._pump)
        return self._following

    @property
    def favorites(self):
        self._favorites = self._favorites or Favorites(self.links['favorites'],pypump=self._pump)
        return self._favorites

    @property
    def lists(self):
        self._lists = self._lists or Lists(self.links['lists'],pypump=self._pump)
        return self._lists

    @property
    def inbox(self):
        if not self.isme:
            raise PyPumpException("You can't read other people's inboxes")
        self._inbox = self._inbox or Inbox(self.links['activity-inbox'], pypump=self._pump)
        return self._inbox

    @property
    def webfinger(self):
        return self.id.replace("acct:", "")

    def __init__(self, webfinger=None, id=None, username=None, url=None, summary=None, 
                 display_name=None, image=None, 
                 published=None, updated=None, location=None,
                 *args, **kwargs):
        """
        id - the ID of the person. e.g. acct:Username@server.example
        username - persons username
        url - url to profile
        summary - summary of the user
        display_name - what the user want's to show up (default: username)
        image - image of the user (default: No image/None)
        published - when the user joined pump (default: None)
        updated - when the user last updated their profile (default: published)
        location - where the user resides (default: No location/None)
        """
        super(Person, self).__init__(*args, **kwargs)

        # okay we need to check if the webfinger is being used
        if isinstance(webfinger, six.string_types):
            # first clean up
            webfinger = webfinger.strip(" ")
            # okay now we need to look if it's on our servers or not.
            if "@" in webfinger:
                self.username, self.server = webfinger.split("@")
            else:
                # they probably just gave a username, the assumption is it's on our server!
                self.username, self.server = webfinger, self._pump.client.server

            self.add_link('self', "{0}://{1}/api/user/{2}/profile".format(
                self._pump.protocol, self.server, self.username)
            )
            data = self._pump.request(self.links['self'])
            self.unserialize(data)

        self.username = username or self.username
        self.url = url or self.url
        self.summary = summary or self.summary
        self.image = image or self.image
        self.display_name = display_name or self.display_name
        self.published = published or self.published
        self.updated = updated or self.updated
        self.isme = (self.username == self._pump.client.nickname and self.server == self._pump.client.server)

    def follow(self): 
        """ Follow person """
        activity = {
            "verb":"follow",
            "object":{
                "id":self.id,
                "objectType":self.objectType,
            }
        }

        self._post_activity(activity)

    def unfollow(self):
        """ Unfollow person """
        activity = {
            "verb":"stop-following",
            "object":{
                "id":self.id,
                "objectType":self.objectType,
            }
        }

        self._post_activity(activity)

    def update(self):
        """ Updates person object"""
        activity = {
            "verb":"update",
            "object":{
                "id": self.id,
                "objectType": self.objectType,
                "displayName": self.display_name,
                "summary": self.summary,
            }
        }

        self._post_activity(activity)

    def __repr__(self):
        return "<Person: {person}>".format(person=self.id.replace("acct:", ""))

    def __str__(self):
        return self.display_name or self.username or self.webfinger

    def unserialize(self, data):
        """ Goes from JSON -> Person object """

        Mapper(pypump=self._pump).parse_map(self, data=data)
        self.server = self.id.replace("acct:", "").split("@")[-1]
        self.isme = "acct:%s@%s" % (self._pump.client.nickname, self._pump.client.server) == self.id
        self.add_links(data)

        return self

########NEW FILE########
__FILENAME__ = place
##
# Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
# 
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>.
##

from pypump.models import AbstractModel

class Place(AbstractModel):

    name = None
    longitude = None
    latitude = None

    def __init__(self, name=None, longitude=None, latitude=None, *args, **kwargs):
        super(Place, self).__init__(*args, **kwargs)
        self.name = name
        self.longitude = longitude
        self.latitude = latitude

    def __repr__(self):
        return "<{type} {name}>".format(type=self.TYPE, name=self.name)

    def unserialize(self, data):
        self.name = data.get("displayName", None)        
        if ("lon" in data and "lat" in data):
            self.longitude = float(data["lon"])
            self.latitude = float(data["lat"])
        
        elif "position" in data:
            position = data["position"][:-1]
            if position[1:].find("+") != -1:
                latitude = position.lstrip("+").split("+", 1)[0]
                self.latitude = float(latitude)

                self.longitude = float(position[1:].split("+", 1)[1])
            else:
                latitude = position.lstrip("+").split("-", 1)[0]
                self.latitude = float(latitude)

                self.longitude = float(position[1:].split("-", 1)[1])               

        else:
            self.longitude = None
            self.latitude = None

        return self

########NEW FILE########
__FILENAME__ = pypump
# -*- coding: utf-8 -*-

##
#   Copyright (C) 2013 Jessica T. (Tsyesika) <xray7224@googlemail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
##

from __future__ import absolute_import

import json
import logging

import requests
import six

from six.moves.urllib import parse
from requests_oauthlib import OAuth1

from pypump.store import JSONStore
from pypump.client import Client
from pypump.exception import PyPumpException

# load models
from pypump.models.note import Note
from pypump.models.comment import Comment
from pypump.models.person import Person
from pypump.models.image import Image
from pypump.models.place import Place
from pypump.models.activity import Activity

from pypump.models.collection import Collection, Public

_log = logging.getLogger(__name__)

class PyPump(object):
    """Main class to interface with PyPump.

    This class keeps everything together and is responsible for making
    requests to the server on it's own behalf and on the bahalf of the
    other clients as well as handling the OAuth requests.

    Attributes / init args::
    - client: an instance of `pypump.Client()`
    - verifier_callback: If this is our first time registering the
      client, this function will be called with a single argument, the
      url one can post to for completing verification.
    - store: this is the store instance to save any data persistantly.
    - verifier_callback: the URI that is used for redirecting a user
      after they authenticate this client... assuming this is
      happening over the web.  If not, the callback is "oob", or "out
      of band".
    - verify_requests: If this is set to False PyPump won't check SSL/TLS
      certificates.
    - retries: number of times to retry if a request fails
    - timeout: how long to give on a timeout for an http request, in
      seconds
    """

    PARAM_VERIFER = six.b("oauth_verifier")
    PARAM_TOKEN = six.b("oauth_token")
    PARAM_TOKEN_SECRET = six.b("oauth_token_secret")

    URL_CLIENT_REGISTRATION = "/api/client/register"

    store_class = JSONStore

    def __init__(self, client, verifier_callback, store=None, callback="oob",
                 verify_requests=True, retries=1, timeout=30):
        """
        This is the main pump instance, this handles the oauth,
        this also holds the models.
        """
        self._me = None
        self.protocol = "https"

        self.retries = retries
        self.timeout = timeout

        self._server_cache = {}
        self._server_tokens = {}
        self.verify_requests = verify_requests
        self.callback = callback
        self.client = client
        self.verifier_callback = verifier_callback
        self._server_cache[self.client.server] = self.client

        # Setup store object
        if store is None:
            self.store = self.create_store()
        else:
            self.store = store

        # Setup variables for client
        self.client.set_pump(self)
        if "client-key" in self.store:
            self.client.key = self.store["client-key"]

        if "client-secret" in self.store:
            self.client.secret = self.store["client-secret"]

        if "client-expirey" in self.store:
            self.client.expirey = self.store["client-expirey"]


        if not self.client.key:
            self.client.register()
            # Save the info back to the store

            self.store["client-key"] = self.client.key
            self.store["client-secret"] = self.client.secret
            self.store["client-expirey"] = self.client.expirey

        self.populate_models()

        if "oauth-request-token" not in self.store and "oauth-access-token" not in self.store:
            # we Need to make a new oauth request
            self.oauth_request()

    @property
    def me(self):
        if self._me is not None:
            return self._me

        self._me = self.Person("{username}@{server}".format(
            username = self.client.nickname,
            server = self.client.server
        ))
        return self._me

    def create_store(self):
        """ Creates store object """
        if self.store_class is not None:
            return self.store_class.load(self.client.webfinger, self)

        raise NotImplementedError("You need to specify PyPump.store_class or override PyPump.create_store method.")

    def populate_models(self):
        def factory(pypump, model):
            return lambda *args, **kwargs: model(
                pypump=kwargs.pop("pypump", pypump),
                *args,
                **kwargs)

        self.Note = factory(self, Note)
        self.Collection = factory(self, Collection)
        self.Comment = factory(self, Comment)
        self.Image = factory(self, Image)
        self.Person = factory(self, Person)
        self.Place = factory(self, Place)
        self.Public = Public()
        self.Activity = factory(self, Activity)

    def build_url(self, endpoint):
        """ Returns a fully qualified URL """
        server = None
        if "://" in endpoint:
            #looks like an url, let's break it down
            server, endpoint = self.deconstruct_url(endpoint)

        endpoint = endpoint.lstrip("/")
        url = "{proto}://{server}/{endpoint}".format(
                proto=self.protocol,
                server=self.client.server if server is None else server,
                endpoint=endpoint
                )
        return url

    def deconstruct_url(self, url):
        """ Breaks down URL and returns server and endpoint """
        url = url.split("://", 1)[-1]
        server, endpoint = url.split("/", 1)
        return (server, endpoint)

    def _add_client(self, url, key=None, secret=None):
        """ Creates Client object with key and secret for server
        and adds it to _server_cache if it doesnt already exist """

        if "://" in url:
            server, endpoint = self.deconstruct_url(url)
        else:
            server = url

        if server not in self._server_cache:
            if not (key and secret):
                client = Client(
                    webfinger=self.client.webfinger,
                    name=self.client.name,
                    type=self.client.type
                )
                client.set_pump(self)
                client.register(server)
            else:
                client = Client(
                        webfinger=self.client.webfinger,
                        key=key,
                        secret=secret,
                        type=self.client.type,
                        name=self.client.name,
                        )
                client.set_pump(self)

            self._server_cache[server] = client

    def request(self, endpoint, method="GET", data="",
                raw=False, params=None, retries=None, client=None,
                headers=None, timeout=None, **kwargs):
        """ Make request to endpoint with OAuth
        method = GET (default), POST or PUT
        attempts = this is how many times it'll try re-attempting
        """

        retries = self.retries if retries is None else retries
        timeout = self.timeout if timeout is None else timeout

        # check client has been setup
        if client is None:
            client = self.setup_oauth_client(endpoint)

        params = {} if params is None else params

        if data and isinstance(data, dict):
            data = json.dumps(data)

        if not raw:
            url = self.build_url(endpoint)
        else:
            url = endpoint

        headers = headers or {"Content-Type": "application/json"}

        for attempt in range(retries):
            if method == "POST":
                request = {
                        "auth": client,
                        "headers": headers,
                        "params": params,
                        "data": data,
                        "timeout": timeout,
                        }

                request.update(kwargs)
                response = self._requester(
                    fnc=requests.post,
                    endpoint=endpoint,
                    raw=raw,
                    **request
                )

            elif method == "GET":
                request = {
                        "params": params,
                        "auth": client,
                        "headers": headers,
                        "timeout": timeout,
                        }

                request.update(kwargs)
                response = self._requester(
                    fnc=requests.get,
                    endpoint=endpoint,
                    raw=raw,
                    **request
                )

            elif method == "DELETE":
                request = {
                        "params": params,
                        "auth": client,
                        "headers": headers,
                        "timeout": timeout,
                        }

                request.update(kwargs)
                response = self._requester(
                    fnc=requests.delete,
                    endpoint=endpoint,
                    raw=raw,
                    **request
                )

            if response.status_code == 200:
                # huray!
                return response.json()

            if response.status_code == 400:
                # can't do much
                try:
                    try:
                        data = response.json()
                        error = data["error"]
                    except ValueError:
                        error = response.content

                    if not error:
                        raise IndexError # yesss i know.
                except IndexError:
                    error = "400 - Bad request."
                raise PyPumpException(error)

            if response.ok:
                return response

        error = "Request Failed to {url} (response: {data} | status: {status})"
        error = error.format(
                url=url,
                data=response.content,
                status=response.status_code
                )

        raise PyPumpException(error)

    def _requester(self, fnc, endpoint, raw=False, **kwargs):
        if not raw:
            url = self.build_url(endpoint)
        else:
            url = endpoint

        kwargs["verify"] = self.verify_requests

        try:
            response = fnc(url, **kwargs)
            return response
        except requests.exceptions.ConnectionError:
            if self.protocol == "http" or raw:
                raise # shoot this seems real.
            else:
                self.set_http()
                url = self.build_url(endpoint)
                self.set_https()
                raw = True
                return self._requester(fnc, url, raw, **kwargs)

    def set_https(self):
        """ Enforces protocol to be https """
        self.protocol = "https"

    def set_http(self):
        """ Sets protocol to be http """
        self.protocol = "http"

    ##
    # OAuth specific stuff
    ##
    def oauth_request(self):
        """ Makes a oauth connection """
        # get tokens from server and make a dict of them.
        self._server_tokens = self.request_token()

        self.store["oauth-request-token"] = self._server_tokens["token"]
        self.store["oauth-request-secret"] = self._server_tokens["token_secret"]

        # now we need the user to authorize me to use their pump.io account
        result = self.verifier_callback(self.construct_oauth_url())
        if result is not None:
            self.verifier(result)

    def construct_oauth_url(self):
        """ Constructs verifier OAuth URL """
        return self.build_url("oauth/authorize?oauth_token={token}".format(
                protocol=self.protocol,
                server=self.client.server,
                token=self.store["oauth-request-token"].decode("utf-8")
                ))

    def verifier(self, verifier):
        """ Called once verifier has been retrived """
        self.request_access(verifier)

    def setup_oauth_client(self, url=None):
        """ Sets up client for requests to pump """
        if url and "://" in url:
            server, endpoint = self.deconstruct_url(url)
        else:
            server = self.client.server

        if server not in self._server_cache:
            self._add_client(server)

        if server == self.client.server:
            self.oauth = OAuth1(
                    client_key=self.store["client-key"],
                    client_secret=self.store["client-secret"],
                    resource_owner_key=self.store["oauth-access-token"],
                    resource_owner_secret=self.store["oauth-access-secret"]
                    )
            return self.oauth
        else:
            return OAuth1(
                client_key=self._server_cache[server].key,
                client_secret=self._server_cache[server].secret,
            )

    def request_token(self):
        """ Gets OAuth request token """
        client = OAuth1(
                client_key=self._server_cache[self.client.server].key,
                client_secret=self._server_cache[self.client.server].secret,
                callback_uri=self.callback
                )

        request = {"auth": client}
        response = self._requester(
            requests.post,
            "oauth/request_token",
            **request
        )

        data = parse.parse_qs(response.content)
        data = {
            'token': data[self.PARAM_TOKEN][0],
            'token_secret': data[self.PARAM_TOKEN_SECRET][0]
            }

        return data

    def request_access(self, verifier):
        """ Get OAuth access token so we can make requests """
        client = OAuth1(
                client_key=self._server_cache[self.client.server].key,
                client_secret=self._server_cache[self.client.server].secret,
                resource_owner_key=self.store["oauth-request-token"],
                resource_owner_secret=self.store["oauth-request-secret"],
                verifier=verifier
                )

        request = {"auth": client}
        response = self._requester(
            requests.post,
            "oauth/access_token",
            **request
        )

        data = parse.parse_qs(response.content)

        self.store["oauth-access-token"] = data[self.PARAM_TOKEN][0]
        self.store["oauth-access-secret"] = data[self.PARAM_TOKEN_SECRET][0]
        self._server_tokens = {} # clean up code.

class WebPump(PyPump):
    """
        This is a PyPump class which is aimed at mainly web developers.
        Allowing you to avoid the callbacks making the oauth portion of
        PyPump instanciation blocking.

        After initialisation you will be able to do `PyPump.verifier_url`
        allowing you to get the url to direct your user to. That method
        will return None if the oauth handshake was successful and no
        verifier callback needs to be done.

        Once you have the verifier instanciate this class again and
        call the verifier method alike what you do using the PyPump class
    """

    url = None

    def __init__(self, *args, **kwargs):
        """
            This is exactly the same as PyPump.__init__ apart from
            verifier_callback is no longer an option for kwargs and
            if specified will be ignored.
        """
        kwargs["verifier_callback"] = self._callback_verifier
        super(WebPump, self).__init__(*args, **kwargs)
        self.url = self.construct_oauth_url()

    def _callback_verifier(self, url):
        """ This is used to catch the url and store it at `self.url` """
        self.url = url

    @property
    def logged_in(self):
        """ Return boolean if is logged in """
        if "oauth-access-token" not in self.store:
            return False

        # if it redirects to the profile it'll raise an exception as
        # it doesn't sign the redirection request.
        response = self.request("/api/whoami", allow_redirects=False)

        # It should response with a redirect to our profile if it's logged in
        if response.status_code != 302:
            return False

        # the location should be the profile we have
        if response.headers["location"] != self.me.links["self"]:
            return False

        return True

########NEW FILE########
__FILENAME__ = store

# This has been taken from "Waterworks"
# Commit ID: dc05a36ed34ab94b657bcadeb70ccc3187227b2d
# URL: https://github.com/Aeva/waterworks
#
# PyPump is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PyPump is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PyPump.  If not, see <http://www.gnu.org/licenses/>.

import json
import re
import os

from exception import ValidationError, StoreException

# Regex taken from WTForms
EMAIL_REGEX = re.compile(r"^.+@[^.].*\.[a-z]{2,10}$", re.IGNORECASE)

def webfinger_validator(webfinger):
    """ Validates webfinger is correct - should look like user@host.tld """
    error = "Invalid webfinger. Should be informat username@host.tld"
    if not EMAIL_REGEX.match(webfinger):
        raise ValidationError(error)

class AbstractStore(dict):
    """
    This should act like a dictionary. This should be persistant and
    save upon setting a value. The interface to this object is::

    >>> store = AbstractStore.load()
    >>> store["my-key"] = "my-value"
    >>> store["my-key"]
    'my-value'

    This must save when "my-value" was set (in __setitem__). There
    should also be a .save method which should take the entire object
    and write them out.
    """

    prefix = None

    def __init__(self, *args, **kwargs):
        self.__validators = {}
        return super(AbstractStore, self).__init__(*args, **kwargs)

    def __prefix_key(self, key):
        """ This will add the prefix to the key if one exists on the store """
        # If there isn't a prefix don't bother
        if self.prefix is None:
            return key

        # Don't prefix key if it already has it
        if key.startswith(self.prefix + "-"):
            return key

        return "{0}-{1}".format(self.prefix, key)

    def __setitem__(self, key, *args, **kwargs):
        if key in self.__validators.keys():
            self.__validators[key](*args, **kwargs)

        key = self.__prefix_key(key)
        super(AbstractStore, self).__setitem__(key, *args, **kwargs)
        self.save()

    def __getitem__(self, key, *args, **kwargs):
        key = self.__prefix_key(key)
        return super(AbstractStore, self).__getitem__(key, *args, **kwargs)

    def __contains__(self, key, *args, **kwargs):
        key = self.__prefix_key(key)
        return super(AbstractStore, self).__contains__(key, *args, **kwargs)

    def set_validator(self, key, validator):
        self.__validators[key] = validator

    def save(self):
        """ Save all attributes in store """
        raise NotImplementedError("This is a dummy class, abstract")

    def export(self):
        """ Exports as dictionary """
        data = {}
        for key, value in self.items():
            data[key] = value

        return data

    @classmethod
    def load(cls, webfinger, pypump):
        """ This create and populate a store object """
        raise NotImplementedError("This is a dummy class, abstract")

    def __str__(self):
        return str(self.export())

class DummyStore(AbstractStore):
    """
    This doesn't persistantly store any data it just acts like
    a regular dictionary. This shouldn't be used for anything but
    testing as nothing will be stored on disk.
    """

    def save(self):
        pass

    @classmethod
    def load(cls, webfinger, pypump):
        return self()

class JSONStore(AbstractStore):
    """
    Persistant dictionary-like storage

    Will write out all changes to disk as they're made
    NB: Will overwrite any changes made to disk not on class.
    """

    def __init__(self, data=None, filename=None, *args, **kwargs):
        if filename is None:
            filename = self.get_filename()
        self.filename = filename

        if data is None:
            data = {}

        super(JSONStore, self).__init__(data, *args, **kwargs)

    def update(self, *args, **kwargs):
        return_value = super(JSONStore, self).update(*args, **kwargs)
        self.save()
        return return_value

    def save(self):
        """ Saves dictionary to disk in JSON format. """
        if self.filename is None:
            raise StoreException("Filename must be set to write store to disk")

        fout = open(self.filename, "w")
        fout.write(json.dumps(self.export()))
        fout.close()

    @classmethod
    def get_filename(cls):
        """ Gets filename of store on disk """
        config_home = os.environ.get("XDG_CONFIG_HOME", "~/.config")
        config_home = os.path.expanduser(config_home)

        base_path = os.path.join(config_home, "PyPump")
        if not os.path.isdir(base_path):
            os.mkdir(base_path)

        return os.path.join(base_path, "credentials.json")

    @classmethod
    def load(cls, webfinger, pypump):
        """ Load JSON from disk into store object """
        filename = cls.get_filename()

        if os.path.isfile(filename):
            data = open(filename).read()
            data = json.loads(data)
            store = cls(data, filename=filename)
        else:
            store = cls(filename=filename)

        store.prefix = webfinger
        return store

########NEW FILE########
__FILENAME__ = abstract_model_test
from __future__ import absolute_import
from tests import PyPumpTest

from pypump.models import AbstractModel

class AbstractModelTest(PyPumpTest):
    
    def setUp(self):
        super(AbstractModelTest, self).setUp()

        self.model = AbstractModel(pypump=self.pump)

        self.person_json = {
            "preferredUsername": "testuser",
            "url": "https://example.com/testuser",
            "displayName": "TestUser",
            "links": {
                "self": {
                    "href": "https://example.com/api/user/testuser/profile"
                },
                "activity-inbox": {
                    "href": "https://example.com/api/user/testuser/inbox"
                },
                "activity-outbox": {
                    "href": "https://example.com/api/user/testuser/feed"
                }
            },
            "objectType": "person",
            "updated": "2013-08-05T20:24:38Z",
            "published": "2013-03-26T18:00:09Z",
            "followers": {
                "url": "https://example.com/api/user/testuser/followers"
            },
            "following": {
                "url": "https://example.com/api/user/testuser/following"
            },
            "favorites": {
                "url": "https://example.com/api/user/testuser/favorites"
            },
            "lists": {
                "url": "https://example.com/api/user/testuser/lists/person"
            },
            "pump_io": { },
            "location": {
                "displayName": "North Pole",
                "objectType": "place"
            },
            "summary": "test summary",
            "liked": False,
            "image": {
                "url": "https://example.com/uploads/testuser/2013/3/27/n76Spw_thumb.jpg",
                "width": 96,
                "height": 96
            },
            "id": "acct:testuser@example.com"
        }

        self.note_json = {
            "objectType": "note",
            "content": "Test content",
            "published": "2013-12-22T06:27:13Z",
            "updated": "2013-12-22T06:27:13Z",
            "links": {
                "self": {
                    "href": "https://example.com/api/note/CkFucl8qSmald3qAHTllTw"
                }
            },
            "likes": {
                "url": "https://example.com/api/note/CkFucl8qSmald3qAHTllTw/likes",
                "totalItems": 0,
                "pump_io": {
                    "proxyURL": "https://example.com/api/proxy/pjwd3nrLR4O_gBYCvAp4mQ"
                }
            },
            "replies": {
                "url": "https://example.com/api/note/CkFucl8qSmald3qAHTllTw/replies",
                "totalItems": 0,
                "pump_io": {
                    "proxyURL": "https://example.com/api/proxy/99TGqO0ISoazXh-Q_nTinQ"
                }
            },
            "shares": {
                "url": "https://example.com/api/note/CkFucl8qSmald3qAHTllTw/shares",
                "totalItems": 0,
            },
            "url": "https://example.com/testuser/note/CkFucl8qSmald3qAHTllTw",
            "liked": False,
            "pump_io": {
                "shared": False,
                "proxyURL": "https://example.com/api/proxy/wEPeXhnqRw2E8p0j68QO_g"
            },
            "id": "https://example.com/api/note/CkFucl8qSmald3qAHTllTw"
        }

    def test_add_links_person(self):
        "add person object : add_links(person)"
        test_obj = self.person_json
        self.model.add_links(test_obj)

        self.assertTrue(self.model.links.get('self'))
        self.assertEqual(self.model.links['self'], test_obj['links']['self']['href'])
        self.assertTrue(self.model.links.get('activity-inbox'))
        self.assertEqual(self.model.links['activity-inbox'], test_obj['links']['activity-inbox']['href'])

    def test_add_links_note(self):
        "add notes object : add_links(note)"
        test_obj = self.note_json
        self.model.add_links(test_obj)

        self.assertTrue(self.model.links.get('self'))
        self.assertEqual(self.model.links['self'], test_obj['links']['self']['href'])

    def test_add_links_note_links(self):
        "add note's links object : add_links(note['links'])"
        test_obj = self.note_json
        self.model.add_links(test_obj['links'])

        self.assertTrue(self.model.links.get('self'))
        self.assertEqual(self.model.links['self'], test_obj['links']['self']['href'])

    def test_add_links_note_shares_no_proxy(self):
        "note's shares link without a proxyurl"
        test_obj = self.note_json
        self.model.add_links(test_obj)

        self.assertTrue(self.model.links.get('shares'))
        self.assertEqual(self.model.links['shares'], test_obj['shares']['url'])

    def test_add_links_note_likes_proxy(self):
        "note's likes link with a proxyurl"
        test_obj = self.note_json
        self.model.add_links(test_obj)

        self.assertTrue(self.model.links.get('likes'))
        self.assertEqual(self.model.links['likes'], test_obj['likes']['pump_io']['proxyURL'])

########NEW FILE########
__FILENAME__ = activity_test
from __future__ import absolute_import
from tests import PyPumpTest
from dateutil.parser import parse
from pypump.models.activity import ActivityObject, Application


class ActivityTest(PyPumpTest):
    
    def setUp(self):
        super(ActivityTest, self).setUp()
        self.response.data = {
            "objectType":"activity",
            "to": [{
                "objectType" : "person",
                "id" : "acct:testuser@example.com"
            }],
            "cc": [{
                "objectType" : "person",
                "id" : "acct:testuser3@example.com"
            }],
            "verb": "post",
            "generator": {
                "objectType" : "application",
                "id" : "testapp"
            },
            "object": {
                "objectType" : "test",
                "content" : "testing testing",
                "id" : "testid1"
            },
            "actor": {
                "objectType" : "person",
                "id" : "acct:testuser2@example.com"
            },          
            "updated": "2013-12-24T16:58:42Z",
            "links": {
                "self" : {
                    "href" : "https://example.com/api/activity/abc"
                }
            },
            "url": "https://example.com/testuser2/activity/xyz",
            "published": "2013-12-24T16:58:42Z",
            "received": "2013-12-24T16:58:42Z",
            "content": "<a href='https://example.com/testuser2'>testuser2@example.com</a> posted <a href='https://example.com/testuser2/test/xyz'>a test</a>",
            "id": "https://example.com/api/activity/abc"
        }

        self.activity = self.pump.Activity().unserialize(self.response.data)

    def test_create_activity(self):
        self.assertTrue(isinstance(self.activity, type(self.pump.Activity())))

    def test_activity_attr_to(self):
        self.assertTrue(hasattr(self.activity, 'to'))
        self.assertTrue(isinstance(self.activity.to[0], type(self.pump.Person())))
    def test_activity_attr_cc(self):
        self.assertTrue(hasattr(self.activity, 'cc'))
        self.assertTrue(isinstance(self.activity.cc[0], type(self.pump.Person())))
    def test_activity_attr_verb(self):
        self.assertTrue(hasattr(self.activity, 'verb'))
        self.assertEqual(self.activity.verb, self.response["verb"])
    def test_activity_attr_generator(self):
        self.assertTrue(hasattr(self.activity, 'generator'))
        self.assertTrue(isinstance(self.activity.generator, Application))
    def test_activity_attr_obj(self):
        self.assertTrue(hasattr(self.activity, 'obj'))
        self.assertTrue(isinstance(self.activity.obj, ActivityObject))
    def test_activity_attr_actor(self):
        self.assertTrue(hasattr(self.activity, 'actor'))
        self.assertTrue(isinstance(self.activity.actor, type(self.pump.Person())))
    def test_activity_attr_updated(self):
        self.assertTrue(hasattr(self.activity, 'updated'))
        self.assertTrue(self.activity.updated, parse(self.response["updated"]))
    def test_activity_attr_links(self):
        self.assertTrue(hasattr(self.activity, 'links'))
        self.assertTrue(self.activity.links["self"], self.response["links"]["self"]["href"])
    def test_activity_attr_url(self):
        self.assertTrue(hasattr(self.activity, 'url'))
        self.assertEqual(self.activity.url, self.response["url"])
    def test_activity_attr_published(self):
        self.assertTrue(hasattr(self.activity, 'published'))
        self.assertTrue(self.activity.published, parse(self.response["published"]))
    def test_activity_attr_received(self):
        self.assertTrue(hasattr(self.activity, 'received'))
        self.assertTrue(self.activity.received, parse(self.response["received"]))
    def test_activity_attr_content(self):
        self.assertTrue(hasattr(self.activity, 'content'))
        self.assertEqual(self.activity.content, self.response["content"])
    def test_activity_attr_id(self):
        self.assertTrue(hasattr(self.activity, 'id'))
        self.assertEqual(self.activity.id, self.response["id"])

    def test_deleted_image(self):
        """ Activity with deleted image should have image obj with 'deleted' attribute set"""
        # copy default response and replace object with a deleted image for this test
        data = self.response.data.copy()
        data['object'] = {
            "objectType" : "image",
            "deleted" : "2013-12-24T16:58:22",
            "id" : "https://example.com/api/image/uuid",
            "published" : "2013-12-24T16:55:22",
            "updated" : "2013-12-24T16:58:22",
            "author" : {
                "objectType" : "person",
                "id" : "acct:testuser@example.com"
            }
        }

        activity = self.pump.Activity().unserialize(data)

        self.assertTrue(isinstance(activity.obj, type(self.pump.Image())))
        self.assertEqual(activity.obj.deleted, parse(data['object']['deleted']))

    def test_deleted_custom_object(self):
        """ Activity with deleted test object should have test obj with 'deleted' attribute set """
        # copy default response and replace object with a deleted object for this test
        data = self.response.data.copy()
        data['object'] = {
            "objectType" : "test",
            "deleted" : "2013-12-24T16:58:22",
            "id" : "https://example.com/api/test/uuid",
            "published" : "2013-12-24T16:55:22",
            "updated" : "2013-12-24T16:58:22",
            "author" : {
                "objectType" : "person",
                "id" : "acct:testuser@example.com"
            }
        }

        activity = self.pump.Activity().unserialize(data)

        self.assertTrue(isinstance(activity.obj, ActivityObject))
        self.assertEqual(activity.obj.deleted, parse(data['object']['deleted']))


########NEW FILE########
__FILENAME__ = client_test
from __future__ import absolute_import
from tests import PyPumpTest

from pypump import Client

class ClientTest(PyPumpTest):
    """ Test that the clients can register and update via OpenID """

    def setUp(self):
        super(ClientTest, self).setUp()

        self.response.data = {
            "client_id": "MJEgFWzTk7yI3wqbv7Nvuw",
            "client_secret": "SiBOo5NVOSaljxA2auudgu4W4ufCwYVMnbkw5w3KOzY",
            "expires_at": 0,
        }

    def test_minimal_client_registeration(self):
        """ Test client registeration with minimal amount of data """
        client = Client(
            webfinger="TestUser@example.com",
            type="native",
        )

        client.set_pump(self.pump)
        client.register()

        # Check we're registering a new client and sent correct data
        self.assertEqual(self.request["type"], "client_associate")
        self.assertEqual(self.request["application_type"], "native")

        # Check we got back the key, secret and expirey correctly
        self.assertEqual(client.key, self.response.data["client_id"])
        self.assertEqual(client.secret, self.response.data["client_secret"])
        self.assertEqual(client.expirey, self.response.data["expires_at"])

    def test_full_client_registration(self):
        """ Test a full client registration can take place """
        logo = "https://a.website.com/some_picture.png"
        contacts = ["dead@beef.com", "beef@dead.com"]

        client = Client(
            webfinger="TestUser@example.com",
            name="PyPumpTestClient",
            type="web",
            logo=logo,
            contacts=contacts
        )

        client.set_pump(self.pump)
        client.register()

        # Check data was sent correctly
        self.assertEqual(self.request["type"], "client_associate")
        self.assertEqual(self.request["logo_url"], logo)
        self.assertEqual(self.request["contacts"], " ".join(contacts))

        # Check we get back what we should
        self.assertEqual(self.response.data["client_id"], client.key)
        self.assertEqual(self.response.data["client_secret"], client.secret)
        self.assertEqual(self.response.data["expires_at"], client.expirey)

    def test_client_update(self):
        """ Tests that a client can be updated """
        # First make the client which we'll update
        client = Client(
            webfinger="TestUser@example.com",
            type="web"
        )

        client.set_pump(self.pump)
        client.register()

        # Now try and update the client
        client.type = "native"
        client.update()

        self.assertEqual(self.request["type"], "client_update")
        self.assertEqual(self.request["application_type"], "native")

########NEW FILE########
__FILENAME__ = comment_test
from __future__ import absolute_import
from tests import PyPumpTest
from dateutil.parser import parse

class CommentTest(PyPumpTest):
    
    def setUp(self):
        super(CommentTest, self).setUp()
        self.maxidata = {
            "content": "test content",
            "inReplyTo": {
                "objectType": "note",
                "id": "noteid"
            },
            "objectType": "comment",
            "author": {
                "objectType": "person",
                "id":"acct:testuser@example.com"
            },
            "published": "2014-01-04T17:39:21Z",
            "updated": "2014-01-04T17:39:21Z",
            "links": {
                "self": {
                    "href": "https://example.com/api/comment/UOsxSKbITXixW5r_HAyO2A"
                }
            },
            "likes": {
                "url": "https://example.com/api/comment/UOsxSKbITXixW5r_HAyO2A/likes",
                "totalItems": 0
            },
            "replies": {
                "url": "https://example.com/api/comment/UOsxSKbITXixW5r_HAyO2A/replies",
                "totalItems": 0
            },
            "shares": {
                "url": "https://example.com/api/comment/UOsxSKbITXixW5r_HAyO2A/shares",
                "totalItems": 0
            },
            "url": "https://example.com/testuser/comment/UOsxSKbITXixW5r_HAyO2A",
            "id": "https://example.com/api/comment/UOsxSKbITXixW5r_HAyO2A",
            "liked": True,
            "pump_io": {
                "shared": False
            }
        }

        self.minidata = {
            "objectType" : "comment",
            "id": "https://example.com/api/comment/8f40pLbdTQ-uY-ADbQrhwg",
        }

        #used in test_comment_attr_*
        self.maxicomment = self.pump.Comment().unserialize(self.maxidata)

    def test_comment_create(self):
        self.response.data = self.maxidata
        comment = self.pump.Comment('test')
        self.assertTrue(isinstance(comment, type(self.pump.Comment())))
    def test_comment_minimal_unserialize(self):
        comment = self.pump.Comment().unserialize(self.minidata)
        self.assertTrue(isinstance(comment, type(self.pump.Comment())))
    def test_comment_unserialize(self):
        comment = self.pump.Comment().unserialize(self.maxidata)
        self.assertTrue(isinstance(comment, type(self.pump.Comment())))
    def test_comment_attr_content(self):
        self.assertTrue(hasattr(self.maxicomment, 'content'))
        self.assertEqual(self.maxicomment.content, self.maxidata["content"])
    def test_comment_attr_published(self):
        self.assertTrue(hasattr(self.maxicomment, 'published'))
        self.assertEqual(self.maxicomment.published, parse(self.maxidata["published"]))
    def test_comment_attr_updated(self):
        self.assertTrue(hasattr(self.maxicomment, 'updated'))
        self.assertEqual(self.maxicomment.updated, parse(self.maxidata["updated"]))
    def test_comment_attr_links(self):
        self.assertTrue(hasattr(self.maxicomment, 'links'))
        self.assertEqual(self.maxicomment.links['self'], self.maxidata["links"]["self"]["href"])
    def test_comment_attr_url(self):
        self.assertTrue(hasattr(self.maxicomment, 'url'))
        self.assertEqual(self.maxicomment.url, self.maxidata["url"])
    def test_comment_attr_id(self):
        self.assertTrue(hasattr(self.maxicomment, 'id'))
        self.assertEqual(self.maxicomment.id, self.maxidata["id"])
    def test_comment_attr_liked(self):
        self.assertTrue(hasattr(self.maxicomment, 'liked'))
        self.assertEqual(self.maxicomment.liked, self.maxidata["liked"])
    def test_comment_attr_in_reply_to(self):
        self.assertTrue(hasattr(self.maxicomment, 'in_reply_to'))
        self.assertTrue(isinstance(self.maxicomment.in_reply_to, type(self.pump.Note())))
    def test_comment_attr_author(self):
        self.assertTrue(hasattr(self.maxicomment, 'author'))
        self.assertTrue(isinstance(self.maxicomment.author, type(self.pump.Person())))


########NEW FILE########
__FILENAME__ = feed_test
from __future__ import absolute_import
from tests import PyPumpTest
from pypump.models.feed import *
import unittest, json

class FeedTest(PyPumpTest):
    
    def setUp(self):
        super(FeedTest, self).setUp()
        #we dump to string since to make it readonly (we dont want to pop the items list by reference)
        self.response.data = json.dumps({
            "displayName": "Followers for Testuser",
            "url": "https://example.com/api/user/testuser/followers",
            "objectTypes": [
                "person"
            ],
            "items": [{"objectType" : "person", "id" : "acct:testuser%d@example.com" % i} for i in range(20)]
            ,
            "totalItems": 25,
            "author": { "objectType" : "person", "id" : "acct:testuser@example.com"},
            "links": {
                "self": {"href": "https://example.com/api/user/testuser/followers?offset=0&count=20"},
                "current": {"href": "https://example.com/api/user/testuser/followers"},
                "prev": {"href": "https://example.com/api/user/testuser/followers?since=acct%3Atestuser0%40example.com"},
                "next": {"href": "https://example.com/api/user/testuser/followers?before=acct%3Atestuser19%40example.com"}
            }
        })

        self.feed = Feed('https://example.com/api/user/testuser/followers', pypump=self.pump)

    def test_create_feed(self):
        self.assertTrue(isinstance(self.feed, Feed))
    def test_feed_attr_display_name(self):
        self.assertTrue(hasattr(self.feed, 'display_name'))
        self.assertEqual(self.feed.display_name, self.response["displayName"])
    def test_feed_attr_url(self):
        self.assertTrue(hasattr(self.feed, 'url'))
        self.assertEqual(self.feed.url, self.response["url"])
    def test_feed_attr_object_types(self):
        self.assertTrue(hasattr(self.feed, 'object_types'))
        self.assertEqual(self.feed.object_types, self.response["objectTypes"])
    def test_feed_attr_items(self):
        self.assertTrue(hasattr(self.feed, 'items'))
        self.assertTrue(isinstance(self.feed.items, ItemList))
    def test_feed_attr_total_items(self):
        self.assertTrue(hasattr(self.feed, 'total_items'))
        self.assertEqual(self.feed.total_items, self.response["totalItems"])
    def test_feed_attr_author(self):
        self.assertTrue(hasattr(self.feed, 'author'))
        self.assertTrue(isinstance(self.feed.author, type(self.pump.Person())))
    def test_feed_attr_links(self):
        self.assertTrue(hasattr(self.feed, 'links'))
        # we should expand this test when we have settled on way to show links
        self.assertTrue(self.feed.links is not None)
    def test_feed_slice_0_to_5(self):
        sliceditems = list(self.feed[:5])
        self.assertEqual(len(sliceditems), 5)
        self.assertEqual(sliceditems[0].id, self.response['items'][0]['id'])
        self.assertEqual(sliceditems[-1].id, self.response['items'][4]['id'])
    """
    ehh, how do we request offset in test code?
    def test_feed_slice_3_to_6(self):

        sliceditems = list(self.feed[3:6])
        self.assertEqual(len(sliceditems), 3)
        self.assertEqual(sliceditems[0].id, self.response['items'][3]['id'])
        self.assertEqual(sliceditems[-1].id, self.response['items'][5]['id'])
    """

########NEW FILE########
__FILENAME__ = image_test
from __future__ import absolute_import
from tests import PyPumpTest

class ImageTest(PyPumpTest):
    
    def setUp(self):
        super(ImageTest, self).setUp()
        self.imgdata = {
            "url": "https://example.com/testuser/image/Pi9rux49S6C1Yhta0zbxyz",
            "content": "<p>I think i killed santa! :O.</p>\n",
            "displayName": "O M G",
            "id": "https://example.com/api/image/Pi9rux49S6C1Yhta0zbxyz",
            "author": {
                "objectType": "person",
                "id" : "acct:testuser@example.com",
            },
            "image": {
                "url": "https://example.com/uploads/testuser/2013/12/24/XMAS13_thumb.jpg",
                "height": 240,
                "width": 320
            },
            "fullImage": {
                "url": "https://example.com/uploads/testuser/2013/12/24/XMAS13.jpg",
                "width": 1280,
                "height": 960
            },
            "objectType": "image",
            "published": "2013-12-24T23:23:11Z",
            "updated": "2013-12-24T23:23:13Z",
            "links": {
                "self": {
                    "href": "https://example.com/api/image/Pi9rux49S6C1Yhta0zbxyz"
                }
            },
            "likes": {
                "url": "https://example.com/api/image/Pi9rux49S6C1Yhta0zbxyz/likes",
                "totalItems": 0
            },
            "replies": {
                "url": "https://example.com/api/image/Pi9rux49S6C1Yhta0zbxyz/replies",
                "totalItems": 0
            },
            "shares": {
                "url": "https://example.com/api/image/Pi9rux49S6C1Yhta0zbxyz/shares",
                "totalItems": 0
            },
            "liked": "false",
            "pump_io": {
                "shared": "false"
            }
        }

        self.mini_data = {
            "objectType" : "image",
            "id" : "foo",
            "image" : {
                "url": "https://example.com/uploads/testuser/2013/12/24/XMAS13_thumb.jpg",
                "height": 240,
                "width": 320
            }
        }

        self.response.data = {
            "verb": "post",
            "object": self.imgdata,
        }

    def test_mini_unserialize(self):
        image = self.pump.Image().unserialize(self.mini_data)


    def test_unserialize(self):
        """ Tests image unserialization is successful """
        # Make the image object
        image = self.pump.Image().unserialize(self.imgdata)

        # Test unserialization is correct
        self.assertEqual(image.id, self.imgdata["id"])
        self.assertEqual(image.url, self.imgdata["url"])
        self.assertEqual(image.thumbnail.url, self.imgdata["image"]["url"])
        self.assertEqual(image.original.url, self.imgdata["fullImage"]["url"])
        self.assertEqual(image.display_name, self.imgdata["displayName"])
        self.assertEqual(image.content, self.imgdata["content"])
        self.assertEqual(image.thumbnail.height, self.imgdata["image"]["height"])
        self.assertEqual(image.thumbnail.width, self.imgdata["image"]["width"])
        self.assertEqual(image.original.height, self.imgdata["fullImage"]["height"])
        self.assertEqual(image.original.width, self.imgdata["fullImage"]["width"])

    def test_upload_file(self):
        """ Test image can be uploaded succesfully """
        image = self.pump.Image(
            display_name="My lovely image",
            content="This is my sexy description"
        )

        # Check image has my attributs as they were set
        self.assertEqual(image.display_name, "My lovely image")
        self.assertEqual(image.content, "This is my sexy description")

        # Upload an image from the bucket
        image.from_file(self.bucket.path_to_png)

        # Test the data sent is correct.
        upload_request = self.requests[0] # It always happens to be the first request

        # Test that the data is the same
        binary_image = open(self.bucket.path_to_png, "rb").read()
        self.assertEqual(upload_request.data, binary_image)

########NEW FILE########
__FILENAME__ = mapper_test
from __future__ import absolute_import
from tests import PyPumpTest
from pypump.models.activity import Mapper, ActivityObject, Application

class MapperTest(PyPumpTest):
    
    def setUp(self):
        super(MapperTest, self).setUp()
    
    def test_get_object_unknown(self):
        """ Test creation of unknown activity model """
        test_data = {
            "objectType" : "food", # pypump.models.activity.ActivityObject
            "id" : "https://example.com/api/food/pancake-v0.1a",
            "url" : "https://example.com/food/pancake-v0.1a",
            "content" : "flour, sugar, eggs, milk, beans",
            "displayName": "Pancakes (test version)",
            "author" : {
                "objectType" : "person",
                "id" : "acct:badcook@example.com"
            }
        }
        test_obj = Mapper(pypump=self.pump).get_object(test_data)

        # Test unserialization is correct
        self.assertEqual(test_obj.objectType, test_data["objectType"])
        self.assertEqual(test_obj.id, test_data["id"])
        self.assertEqual(test_obj.url, test_data["url"])
        self.assertEqual(test_obj.content, test_data["content"])
        self.assertEqual(test_obj.display_name, test_data["displayName"])

        # test_obj should be ActivityObject
        self.assertTrue(isinstance(test_obj, ActivityObject))

        # test_obj.author should be PyPump.Person
        self.assertTrue(isinstance(test_obj.author, type(self.pump.Person())))

    def test_get_pump_model(self):
        """ Test creation of PyPump model """
        test_data = {
            "objectType" : "person", # pypump.models.person.Person
            "id" : "acct:testuser@example.com"
        }
        test_obj = Mapper(pypump=self.pump).get_object(test_data)

        # Test person model was made
        self.assertTrue(isinstance(test_obj, type(self.pump.Person())))

    def test_get_activity_model(self):
        """ Test creation of known activity model """
        test_data = {
            "objectType" : "application", # pypump.models.activity.Application
            "id" : "coolapp1.2",
            "displayName" : "Cool app"
        }
        test_obj = Mapper(pypump=self.pump).get_object(test_data)

        self.assertTrue(isinstance(test_obj, Application))
        

########NEW FILE########
__FILENAME__ = note_test
from __future__ import absolute_import
from tests import PyPumpTest
from dateutil.parser import parse

class NoteTest(PyPumpTest):
    
    def setUp(self):
        super(NoteTest, self).setUp()
        self.maxidata = {
            "displayName" : "note title",
            "content": "<p>note text</p>\n",
            "objectType": "note",
            "published": "2013-12-23T05:14:54Z",
            "updated": "2013-12-23T05:14:54Z",
            "links": {
                "self": {
                    "href": "https://example.com/api/note/8f40pLbdTQ-uY-ADbQrhwg"
                }
            },
            "likes": {
                "url": "https://example.com/api/note/8f40pLbdTQ-uY-ADbQrhwg/likes",
                "totalItems": 0
            },
            "replies": {
                "url": "https://example.com/api/note/8f40pLbdTQ-uY-ADbQrhwg/replies",
                "totalItems": 0
            },
            "shares": {
                "url": "https://example.com/api/note/8f40pLbdTQ-uY-ADbQrhwg/shares",
                "totalItems": 0
            },
            "url": "https://example.com/testuser/note/8f40pLbdTQ-uY-ADbQrhwg",
            "id": "https://example.com/api/note/8f40pLbdTQ-uY-ADbQrhwg",
            "liked": False,
            "pump_io": {
                "shared": False
            }
        }

        self.minidata = {
            "objectType" : "note",
            "id": "https://example.com/api/note/8f40pLbdTQ-uY-ADbQrhwg",
        }

        #used in test_note_attr_*
        self.maxinote = self.pump.Note().unserialize(self.maxidata)

    def test_note_create(self):
        self.response.data = self.maxidata
        note = self.pump.Note('test')
        self.assertTrue(isinstance(note, type(self.pump.Note())))
    def test_note_minimal_unserialize(self):
        note = self.pump.Note().unserialize(self.minidata)
        self.assertTrue(isinstance(note, type(self.pump.Note())))
    def test_note_unserialize(self):
        note = self.pump.Note().unserialize(self.maxidata)
        self.assertTrue(isinstance(note, type(self.pump.Note())))
    def test_note_attr_display_name(self):
        self.assertTrue(hasattr(self.maxinote, 'display_name'))
        self.assertEqual(self.maxinote.display_name, self.maxidata["displayName"])
    def test_note_attr_content(self):
        self.assertTrue(hasattr(self.maxinote, 'content'))
        self.assertEqual(self.maxinote.content, self.maxidata["content"])
    def test_note_attr_published(self):
        self.assertTrue(hasattr(self.maxinote, 'published'))
        self.assertEqual(self.maxinote.published, parse(self.maxidata["published"]))
    def test_note_attr_updated(self):
        self.assertTrue(hasattr(self.maxinote, 'updated'))
        self.assertEqual(self.maxinote.updated, parse(self.maxidata["updated"]))
    def test_note_attr_links(self):
        self.assertTrue(hasattr(self.maxinote, 'links'))
        self.assertEqual(self.maxinote.links['self'], self.maxidata["links"]["self"]["href"])
    def test_note_attr_url(self):
        self.assertTrue(hasattr(self.maxinote, 'url'))
        self.assertEqual(self.maxinote.url, self.maxidata["url"])
    def test_note_attr_id(self):
        self.assertTrue(hasattr(self.maxinote, 'id'))
        self.assertEqual(self.maxinote.id, self.maxidata["id"])
    def test_note_attr_liked(self):
        self.assertTrue(hasattr(self.maxinote, 'liked'))
        self.assertEqual(self.maxinote.liked, self.maxidata["liked"])


########NEW FILE########
__FILENAME__ = person_test
from __future__ import absolute_import
from tests import PyPumpTest
from pypump.models.place import Place

class PersonTest(PyPumpTest):
    
    def setUp(self):
        super(PersonTest, self).setUp()
        self.response.data = {
            "id": "acct:TestUser@example.com",
            "preferredUsername": "TestUser",
            "url": "http://example.com/TestUser",
            "displayName": "TestUser@example.com",
            "links": {
                "self": {
                    "href": "http://example.com/api/user/TestUser/profile",
                },
                "activity-inbox": {
                    "href": "http://example.com/api/user/TestUser/inbox",
                },
                "activity-outbox": {
                    "href": "http://example.com/api/user/TestUser/feed",
                },
            },
            "objectType": "person",
            "followers": {
                "url": "http://example.com/api/user/TestUser/followers",
                "totalItems": 72,
            },
            "following": {
                "url": "http://example.com/api/user/TestUser/following",
                "totalItems": 27,
            },
            "favorites": {
                "url": "http://example.com/api/user/TestUser/favorites",
                "totalItems": 720,
            },
            "location": {
                "objectType": "place",
                "displayName": "Home Tree, Pandora",
            },
            "summary": "I am a PyPump Test user, I am used for testing!",
            "image": {
                "url": "http://example.com/uploads/TestUser/some_image.jpg",
                "width": 96,
                "height": 96,
            },
            "pump_io": {
                "shared": False,
                "followed": False,
            },
            "updated": "2013-08-13T10:26:54Z",
            "liked": False,
            "shares": {
                "url": "http://example.com/api/person/BlahBlah/shares",
                "items": [],
            }
        }
    
    def test_follow(self):
        """ Tests that pypump sends correct data when attempting to follow a person """
        person = self.pump.Person("TestUser")
        
        # PyPump now expects the object returned back to it
        self.response.data = {"verb": "follow", "object": self.response.data}
        person.follow()

        # Test verb is 'follow'
        self.assertEquals(self.request["verb"], "follow")

        # Test ID is the correct ID
        self.assertEquals(person.id, self.request["object"]["id"])
        
        # Ensure object type is correct
        self.assertEquals(person.objectType, self.request["object"]["objectType"])

    def test_update(self):
        """ Test that a update works """
        person = self.pump.Person("TestUser")
        person.summary = "New summary!"
        person.display_name = "New user"
        
        self.response.data = {
            "verb": "update",
            "object": {
                "id": person.id,
                "summary": person.summary,
                "displayName": person.display_name,
                "objectType": "person",
            },
        }

        person.update()

        self.assertEqual(self.request["verb"], "update")
        self.assertEqual(self.request["object"]["id"], person.id)
        self.assertEqual(self.request["object"]["objectType"], person.objectType)
        self.assertEqual(self.request["object"]["summary"], person.summary)
        self.assertEqual(self.request["object"]["displayName"], person.display_name)

    def test_unfollow(self):
        """ Test that you can unfollow a person """
        person = self.pump.Person("TestUser")

        self.response.data = {"verb": "stop-following", "object": self.response.data}
        person.unfollow()

        self.assertEquals(self.request["verb"], "stop-following")
        self.assertEquals(self.request["object"]["id"], person.id)
        self.assertEquals(self.request["object"]["objectType"], person.objectType) 

    def test_minimal_unserialize(self):
        """ Test the smallest amount of data can be given to unserialize """
        self.response.data = {
            "id": "acct:TestUser@example.com",
            "objectType": "person",
        }

        person = self.pump.Person("TestUser")

        self.assertEquals(self.response["id"], person.id)
        self.assertEquals(self.response["objectType"], person.objectType)

    def test_unserialize(self):
        """ Tests person unserialization is successful """
        # Make the person object
        person = self.pump.Person("TestUser")

        # Test unserialization is correct
        self.assertEqual(person.id, self.response["id"])
        self.assertEqual(person.username, self.response["preferredUsername"])
        self.assertEqual(person.display_name, self.response["displayName"])
        self.assertEqual(person.url, self.response["url"])
        self.assertEqual(person.summary, self.response["summary"])

        # Test image model was made
        #self.assertTrue(isinstance(person.image, self.pump.Image))
        
        # Test place model was made
        self.assertTrue(isinstance(person.location, Place)) 

########NEW FILE########
__FILENAME__ = store_test
from __future__ import absolute_import

from tests import PyPumpTest
from pypump import AbstractStore

class TestStore(AbstractStore):
    """ Provide a more testable store """
    save_called = False

    def save(self):
        """
        Should save data in store
        This will just change a flag to show it's been called
        """
        self.save_called = True

class StoreTest(PyPumpTest):
    """
    Test the store class
    """

    def test_store_and_get(self):
        """ Test that a value can be stored and then retrived """
        store = TestStore()

        # Check that it raises a key error when nothing has been stored.
        with self.assertRaises(KeyError):
            store["coffee"]

        # Store something
        store["coffee"] = "awesome"

        # Check we can get the same value back out
        self.assertEqual(store["coffee"], "awesome")


    def test_save_on_set(self):
        """ Test that save is called when a value is set """
        store = TestStore()

        # Check that save hasn't been called yet.
        self.assertEqual(store.save_called, False)

        # set some information
        store["coffee"] = "awesome"

        # Check save has been called
        self.assertEqual(store.save_called, True)

    def test_prefix(self):
        """ Test that the prefix is applied to the get and set keys """
        store = TestStore()
        store.prefix = "hai"

        # Test that we can store something and get it back
        store["key"] = "value"
        self.assertEqual(store["key"], "value")

        # Remove the prefix and check that we have to manually prefix
        # the key to get back the previously stored value.
        store.prefix = None

        # Unprefixed shouldn't exist.
        with self.assertRaises(KeyError):
            store["key"]

        self.assertEqual(store["hai-key"], "value")

########NEW FILE########
__FILENAME__ = webpump_test
from __future__ import absolute_import

import six
from six.moves.urllib import parse

from tests import PyPumpTest
from pypump import Client

class WebPumpTest(PyPumpTest):
    """ Tests to ensure the WebPump works as it should do """


    def test_url_is_set(self):
        """ Tests that URL is provided with token for OAuth """
        self.assertTrue(isinstance(self.webpump.url, six.string_types))

        url = parse.urlparse(self.webpump.url)
        query = parse.parse_qs(url.query)

        self.assertEqual(url.netloc, self.webpump.client.webfinger.split("@", 1)[1])
        self.assertEqual(url.path, "/oauth/authorize")

########NEW FILE########
