__FILENAME__ = apps
from django.apps import AppConfig

import autocomplete_light


class AutocompleteLightConfig(AppConfig):
    name = 'autocomplete_light'

    def ready(self):
        autocomplete_light.autodiscover()

########NEW FILE########
__FILENAME__ = base
from __future__ import unicode_literals

from django.utils.encoding import force_text
from django.core import urlresolvers
from django.core.exceptions import ImproperlyConfigured
from django.utils.html import escape
from django.utils.translation import ugettext_lazy as _

import six

__all__ = ('AutocompleteInterface', 'AutocompleteBase')


class AutocompleteInterface(object):
    """
    An autocomplete proposes "choices". A choice has a "value". When the user
    selects a "choice", then it is converted to a "value".

    AutocompleteInterface is the minimum to implement in a custom Autocomplete
    class usable by the widget and the view. It has two attributes:

    .. py:attribute:: values

        A list of values which
        :py:meth:`~.base.AutocompleteInterface.validate_values` and
        :py:meth:`~.base.AutocompleteInterface.choices_for_values` should use.

    .. py:attribute:: request

        A request object which
        :py:meth:`~.base.AutocompleteInterface.autocomplete_html()` should use.

    It is recommended that you inherit from :py:class:`~.base.AutocompleteBase`
    instead when making your own classes because it has taken some design
    decisions favorising a DRY implementation of
    :py:class:`~.base.AutocompleteInterface`.

    Instanciate an Autocomplete with a given ``request`` and ``values``
    arguments. ``values`` will be casted to list if necessary and both will
    be assigned to instance attributes
    :py:attr:`~AutocompleteInterface.request` and
    :py:attr:`~AutocompleteInterface.values` respectively.
    """

    def __init__(self, request=None, values=None):
        self.request = request

        if values is None:
            self.values = []
        elif (isinstance(values, six.string_types) or
                not hasattr(values, '__iter__')):
            self.values = [values]
        else:
            self.values = values

    def autocomplete_html(self):
        """
        Return the HTML autocomplete that should be displayed under the text
        input. :py:attr:`request` can be used, if set.
        """
        raise NotImplemented()

    def validate_values(self):
        """
        Return True if :py:attr:`values` are all valid.
        """
        raise NotImplemented()

    def choices_for_values(self):
        """
        Return the list of choices corresponding to :py:attr:`values`.
        """
        raise NotImplemented()

    def get_absolute_url(self):
        """
        Return the absolute url for this autocomplete, using
        autocomplete_light_autocomplete url.
        """
        try:
            return urlresolvers.reverse('autocomplete_light_autocomplete',
                args=(self.__class__.__name__,))
        except urlresolvers.NoReverseMatch as e:
            # Such error will ruin form rendering. It would be automatically
            # silenced because of e.silent_variable_failure=True, which is
            # something we don't want. Let's give the user a hint:
            raise ImproperlyConfigured("URL lookup for autocomplete '%s' "
                    "failed. Have you included autocomplete_light.urls in "
                    "your urls.py?" % (self.__class__.__name__,))


class AutocompleteBase(AutocompleteInterface):
    """
    A basic implementation of AutocompleteInterface that renders HTML and
    should fit most cases. It only needs overload of
    :py:meth:`~.base.AutocompleteBase.choices_for_request` and
    :py:meth:`~.base.AutocompleteInterface.choices_for_values` which is the
    business-logic.

    .. py:attribute:: choice_html_format

        HTML string used to format a python choice in HTML by
        :py:meth:`~.base.AutocompleteBase.choice_html`. It is formated with two
        positionnal parameters: the value and the html representation,
        respectively generated by
        :py:meth:`~.base.AutocompleteBase.choice_value` and
        :py:meth:`~.base.AutocompleteBase.choice_label`. Default is::

            <span data-value="%s">%s</span>

    .. py:attribute:: empty_html_format

        HTML string used to format the message "no matches found" if no choices
        match the current request. It takes a parameter for the translated
        message. Default is::

            <span class="block"><em>%s</em></span>

    .. py:attribute:: autocomplete_html_format

        HTML string used to format the list of HTML choices. It takes a
        positionnal parameter which contains the list of HTML choices which
        come from :py:meth:`~.base.AutocompleteBase.choice_html`. Default is::

            %s

    .. py:attribute:: add_another_url_name

        Name of the url to add another choice via a javascript popup. If empty
        then no "add another" link will appear.

    .. py:attribute:: add_another_url_kwargs

        Keyword arguments to use when reversing the add another url.

    .. py:attribute:: widget_template

        A special attribute used only by the widget. If it is set, the widget
        will use that instead of the default
        ``autocomplete_light/widget.html``.
    """
    choice_html_format = '<span data-value="%s">%s</span>'
    empty_html_format = '<span class="block"><em>%s</em></span>'
    autocomplete_html_format = '%s'
    add_another_url_name = None
    add_another_url_kwargs = None

    def get_add_another_url(self):
        """
        Return the url to use when adding another element
        """
        if self.add_another_url_name:
            url = urlresolvers.reverse(self.add_another_url_name,
                                       kwargs=self.add_another_url_kwargs)
            return url + '?_popup=1'
        else:
            return None

    def choices_for_request(self):
        """
        Return the list of choices that are available. Uses :py:attr:`request`
        if set, this method is used by
        :py:meth:`~.base.AutocompleteBase.autocomplete_html`.
        """
        raise NotImplemented()

    def validate_values(self):
        """
        This basic implementation returns True if all
        :py:attr:`~AutocompleteInterface.values` are in
        :py:meth:`~.base.AutocompleteInterface.choices_for_values`.
        """
        return len(self.choices_for_values()) == len(self.values)

    def autocomplete_html(self):
        """
        Simple rendering of the autocomplete.

        It will append the result of
        :py:meth:`~.base.AutocompleteBase.choice_html` for each choice returned
        by :py:meth:`~.base.AutocompleteBase.choices_for_request`, and
        wrap that in :py:attr:`autocomplete_html_format`.
        """
        html = ''.join(
            [self.choice_html(c) for c in self.choices_for_request()])

        if not html:
            html = self.empty_html_format % _('no matches found').capitalize()

        return self.autocomplete_html_format % html

    def choice_html(self, choice):
        """
        Format a choice using :py:attr:`choice_html_format`.
        """
        return self.choice_html_format % (
            escape(self.choice_value(choice)),
            escape(self.choice_label(choice)))

    def choice_value(self, choice):
        """
        Return the value of a choice. This simple implementation returns the
        textual representation.
        """
        return force_text(choice)

    def choice_label(self, choice):
        """
        Return the human-readable representation of a choice. This simple
        implementation returns the textual representation.
        """
        return force_text(choice)

########NEW FILE########
__FILENAME__ = choice_list
from __future__ import unicode_literals

from django.utils.encoding import force_text

from .list import AutocompleteList

__all__ = ('AutocompleteChoiceList',)


class AutocompleteChoiceList(AutocompleteList):
    """
    Simple :py:class:`~.list.AutocompleteList` implementation which expects
    :py:attr:`choices` to be a list of tuple choices in the fashion of
    :py:attr:`django:django.db.models.Field.choices`.

    .. py:attribute:: choices

        List of choice tuples ``(value, label)`` like
        :py:attr:`django:django.db.models.Field.choices`. Example::

            choices = (
                ('v', 'Video'),
                ('p', 'Paper'),
            )

    .. py:attribute:: limit_choices

        The maximum of items to suggest from :py:attr:`choices`.

    .. py:attribute:: order_by

        :py:meth:`~.choice_list.AutocompleteChoiceList.order_choices` will use
        this against :py:attr:`choices` as an argument :py:func:`sorted`.
    """
    order_by = lambda cls, choice: force_text(choice[1]).lower()

    def choices_for_values(self):
        """
        Return any :py:attr:`choices` that is in :py:attr:`values`.
        """
        values_choices = []

        for choice in self.choices:
            if choice[0] in self.values:
                values_choices.append(choice)

        return self.order_choices(values_choices)

    def choices_for_request(self):
        """
        Return any :py:attr:`choices` tuple that contains the search string. It
        is case insensitive and ignores spaces.
        """
        requests_choices = []
        q = self.request.GET.get('q', '').lower().strip()

        for choice in self.choices:
            m = force_text(choice[0]).lower() + force_text(choice[1]).lower()
            if q in m:
                requests_choices.append(choice)

        return self.order_choices(requests_choices)[0:self.limit_choices]

    def choice_value(self, choice):
        """ Return item 0 of the choice tuple. """
        return choice[0]

    def choice_label(self, choice):
        """ Return item 1 of the choice tuple. """
        return choice[1]

########NEW FILE########
__FILENAME__ = generic
from __future__ import unicode_literals
import six

from django.contrib.contenttypes.models import ContentType
from django.db.models import Q

import autocomplete_light
from ..settings import DEFAULT_SEARCH_FIELDS
from .model import AutocompleteModel

__all__ = ['AutocompleteGeneric']


class AutocompleteGenericMetaClass(type):
    def __new__(cls, name, bases, attrs):
        new_class = super(AutocompleteGenericMetaClass, cls).__new__(cls, name,
                bases, attrs)

        if attrs.get('__module__',
                '').startswith('autocomplete_light.autocomplete'):
            # we are defining own of our own classes
            return new_class

        if not new_class.search_fields:
            default = DEFAULT_SEARCH_FIELDS
            new_class.search_fields = [default] * len(new_class.choices)

        return new_class


class AutocompleteGeneric(six.with_metaclass(AutocompleteGenericMetaClass,
        AutocompleteModel)):
    """
    :py:class:`~.model.AutocompleteModel` extension which considers choices as
    a **list of querysets**, and composes a choice value with both the content
    type pk and the actual model pk.

    .. py:attribute:: choices

        A list of querysets. Example::

            choices = (
                User.objects.all(),
                Group.objects.all(),
            )

    .. py:attribute:: search_fields

        A list of lists of fields to search in, configurable like on
        ModelAdmin.search_fields. The first list of fields will be used for the
        first queryset in choices and so on. Example::

            search_fields = (
                ('email', '^name'),  # Used for User.objects.all()
                ('name',)            # User for Group.objects.all()
            )

    AutocompleteGeneric inherits from :py:class:`.model.AutocompleteModel` and
    supports :py:attr:`~.model.AutocompleteModel.limit_choices` and
    :py:attr:`~.model.AutocompleteModel.split_words` exactly like
    AutocompleteModel.

    However :py:attr:`~.model.AutocompleteModel.order_by` is not supported
    (yet) in AutocompleteGeneric.
    """
    choices = None
    search_fields = None

    def choice_value(self, choice):
        """
        Rely on :py:class:`~autocomplete_light.generic.GenericModelChoiceField`
        to return a string containing the content type id and object id of the
        result.
        """
        field = autocomplete_light.GenericModelChoiceField()
        return field.prepare_value(choice)

    def validate_values(self):
        """
        Ensure that every choice is part of a queryset in :py:attr:`choices`.
        """
        assert self.choices, 'autocomplete.choices should be a queryset list'

        for value in self.values:
            if not isinstance(value, six.string_types):
                return False

            try:
                content_type_id, object_id = value.split('-', 1)
            except ValueError:
                return False

            try:
                content_type = ContentType.objects.get_for_id(content_type_id)
            except ContentType.DoesNotExist:
                return False

            model_class = content_type.model_class()

            found = False
            for queryset in self.choices:
                if queryset.model != model_class:
                    continue

                if queryset.filter(pk=object_id).count() == 1:
                    found = True
                else:
                    return False

            if not found:
                # maybe a user would cheat by using a forbidden ctype id !
                return False

        return True

    def choices_for_request(self):
        """
        Return a list of choices from every queryset in :py:attr:`choices`.
        """
        assert self.choices, 'autocomplete.choices should be a queryset list'

        q = self.request.GET.get('q', '')

        request_choices = []
        querysets_left = len(self.choices)

        i = 0
        for queryset in self.choices:
            conditions = self._choices_for_request_conditions(q,
                    self.search_fields[i])

            limit = ((self.limit_choices - len(request_choices)) /
                querysets_left)
            for choice in queryset.filter(conditions)[:limit]:
                request_choices.append(choice)

            querysets_left -= 1
            i += 1

        return request_choices

    def choices_for_values(self):
        """
        Values which are not found in any querysets of :py:attr:`choices` are
        ignored.
        """
        values_choices = []

        for queryset in self.choices:
            ctype = ContentType.objects.get_for_model(queryset.model).pk

            try:
                ids = [x.split('-')[1] for x in self.values
                    if x is not None and int(x.split('-')[0]) == ctype]
            except ValueError:
                continue

            for choice in queryset.filter(pk__in=ids):
                values_choices.append(choice)

        return values_choices

########NEW FILE########
__FILENAME__ = html

########NEW FILE########
__FILENAME__ = list
from __future__ import unicode_literals

from django.utils.encoding import force_text

__all__ = ('AutocompleteList',)


class AutocompleteList(object):
    """
    Simple Autocomplete implementation which expects :py:attr:`choices` to be a
    list of string choices.

    .. py:attribute:: choices

        List of string choices.

    .. py:attribute:: limit_choices

        The maximum of items to suggest from :py:attr:`choices`.

    .. py:attribute:: order_by

        :py:meth:`~.list.AutocompleteList.order_choices` will use this against
        :py:attr:`choices` as an argument :py:func:`sorted`.

    It was mainly used as a starter for me when doing test-driven development
    and to ensure that the Autocomplete pattern would be concretely simple and
    yet powerful.
    """

    limit_choices = 20
    order_by = lambda cls, choice: force_text(choice).lower()

    def choices_for_values(self):
        """
        Return any :py:attr:`choices` that is in :py:attr:`values`.
        """
        values_choices = []

        for choice in self.choices:
            if choice in self.values:
                values_choices.append(choice)

        return self.order_choices(values_choices)

    def choices_for_request(self):
        """
        Return any :py:attr:`choices` that contains the search string. It is
        case insensitive and ignores spaces.
        """
        assert self.choices, 'autocomplete.choices is not set'

        requests_choices = []
        q = self.request.GET.get('q', '').lower().strip()

        for choice in self.choices:
            if q in force_text(choice).lower():
                requests_choices.append(choice)

        return self.order_choices(requests_choices)[0:self.limit_choices]

    def order_choices(self, choices):
        """
        Run :py:func:`sorted` against ``choices`` and :py:attr:`order_by`.
        """
        return sorted(choices, key=self.order_by)

########NEW FILE########
__FILENAME__ = model
from __future__ import unicode_literals
import six

from django.utils.encoding import force_text
from django.db.models import Q

from ..settings import DEFAULT_SEARCH_FIELDS

__all__ = ('AutocompleteModel', )


class AutocompleteModel(object):
    """
    Autocomplete which considers choices as a queryset.

    .. py:attribute:: choices

        A queryset.

    .. py:attribute:: limit_choices

        Maximum number of choices to display.

    .. py:attribute:: search_fields

        Fields to search in, configurable like on
        :py:attr:`django:django.contrib.admin.ModelAdmin.search_fields`

    .. py:attribute:: split_words

        If True, AutocompleteModel splits the search query into words and
        returns all objects that contain each of the words, case insensitive,
        where each word must be in at least one of search_fields. This mimics
        the mechanism of django's
        :py:attr:`django:django.contrib.admin.ModelAdmin.search_fields`.

        If 'or', AutocompleteModel does the same but returns all objects that
        contain **any** of the words.

    .. py:attribute:: order_by

        If set, it will be used to order choices. It can be a single field name
        or an iterable (ie. list, tuple).
    """
    limit_choices = 20
    choices = None
    search_fields = DEFAULT_SEARCH_FIELDS
    split_words = False
    order_by = None

    def choice_value(self, choice):
        """
        Return the pk of the choice by default.
        """
        return choice.pk

    def choice_label(self, choice):
        """
        Return the textual representation of the choice by default.
        """
        return force_text(choice)

    def order_choices(self, choices):
        """
        Order choices using :py:attr:`order_by` option if it is set.
        """
        if self.order_by is None:
            return choices

        if isinstance(self.order_by, six.string_types):
            return choices.order_by(self.order_by)

        return choices.order_by(*self.order_by)

    def choices_for_values(self):
        """
        Return ordered choices which pk are in
        :py:attr:`~.base.AutocompleteInterface.values`.
        """
        assert self.choices is not None, 'choices should be a queryset'
        return self.order_choices(self.choices.filter(
            pk__in=self.values or []))

    def choices_for_request(self):
        """
        Return a queryset based on :py:attr:`choices` using options
        :py:attr:`split_words`, :py:attr:`search_fields` and
        :py:attr:`limit_choices`.
        """
        assert self.choices is not None, 'choices should be a queryset'
        assert self.search_fields, 'autocomplete.search_fields must be set'
        q = self.request.GET.get('q', '')
        exclude = self.request.GET.getlist('exclude')

        conditions = self._choices_for_request_conditions(q,
                self.search_fields)

        return self.order_choices(self.choices.filter(
            conditions).exclude(pk__in=exclude))[0:self.limit_choices]

    def _construct_search(self, field_name):
        """
        Using a field name optionnaly prefixed by `^`, `=`, `@`, return a
        case-insensitive filter condition name usable as a queryset `filter()`
        keyword argument.
        """
        if field_name.startswith('^'):
            return "%s__istartswith" % field_name[1:]
        elif field_name.startswith('='):
            return "%s__iexact" % field_name[1:]
        elif field_name.startswith('@'):
            return "%s__search" % field_name[1:]
        else:
            return "%s__icontains" % field_name

    def _choices_for_request_conditions(self, q, search_fields):
        """
        Return a `Q` object usable by `filter()` based on a list of fields to
        search in `search_fields` for string `q`.

        It uses options `split_words` and `search_fields` . Refer to the
        class-level documentation for documentation on each of these options.
        """
        conditions = Q()

        if self.split_words:
            for word in q.strip().split():
                word_conditions = Q()
                for search_field in search_fields:
                    word_conditions |= Q(**{
                        self._construct_search(search_field): word})

                if self.split_words == 'or':
                    conditions |= word_conditions
                else:
                    conditions &= word_conditions
        else:
            for search_field in search_fields:
                conditions |= Q(**{self._construct_search(search_field): q})

        return conditions

    def validate_values(self):
        """
        Return True if all values where found in :py:attr:`choices`.
        """
        return len(self.choices_for_values()) == len(self.values)

########NEW FILE########
__FILENAME__ = rest_model
import urllib

from django import http

try:
    import json
except ImportError:
    from django.utils import simplejson as json


from .model import AutocompleteModel


class AutocompleteRestModel(AutocompleteModel):
    widget_js_attributes = {'bootstrap': 'rest_model'}

    @property
    def model(self):
        return self.choices.model

    def post(self, request, *args, **kwargs):
        value = request.POST['value']
        pk = self.download_choice(value)
        return http.HttpResponse(pk, status=201)

    def get_source_url(self, limit):
        """
        Return an API url for the current autocomplete request.

        By default, return self.source_url with the data dict returned by
        get_source_url_data().
        """
        return '%s?%s' % (self.source_url, urllib.urlencode(
            self.get_source_url_data(limit)))

    def get_source_url_data(self, limit):
        """
        Given a limit of items, return a dict of data to send to the API.

        By default, it passes current request GET arguments, along with format:
        'json' and the limit.
        """
        data = {}
        if self.request:
            for key, value in self.request.GET.items():
                data[key] = value

        data.update({
            'format': 'json',
            'limit': limit,
        })

        return data

    def model_for_source_url(self, url):
        """
        Take an URL from the API this remote channel is supposed to work with,
        return the model class to use for that url.

        It is only needed for the default implementation of download(), because
        it has to follow relations recursively.

        By default, it will return the model of self.choices.
        """
        return self.choices.model

    def choices_for_request(self):
        choices = super(AutocompleteRestModel, self).choices_for_request()
        unicodes = [unicode(choice) for choice in choices]

        slots = self.limit_choices - len(choices)

        if slots > 0:
            choices = list(choices)

            for choice in self.get_remote_choices(slots):
                # avoid data that's already in local
                if unicode(choice) in unicodes:
                    continue

                choices.append(choice)

        return choices

    def get_remote_choices(self, max):
        """
        Parses JSON from the API, return model instances.

        The JSON should contain a list of dicts. Each dict should contain the
        attributes of an object. Relation attributes should be represented by
        their url in the API, which is set to model._source_url.
        """
        url = self.get_source_url(max)

        try:
            fh = urllib.urlopen(url)
            body = fh.read()
        except:
            return
        else:
            for data in json.loads(body):
                url = data.pop('url')

                for name in data.keys():
                    field = self.model._meta.get_field_by_name(name)[0]
                    if getattr(field, 'rel', None):
                        data.pop(name)
                model = self.model(**data)
                model.pk = url
                yield model

    def download_choice(self, choice):
        """
        Take a choice's dict representation, return it's local pk which might
        have been just created.

        If your channel works with 0 to 1 API call, consider overriding this
        method.
        If your channel is susceptible of using several different API calls,
        consider overriding download().
        """
        return self.download(choice).pk

    def download(self, url):
        """
        Given an url to a remote object, return the corresponding model from
        the local database.

        The default implementation expects url to respond with a JSON dict of
        the attributes of an object.

        For relation attributes, it expect the value to be another url that
        will respond with a JSON dict of the attributes of the related object.

        It calls model_for_source_url() to find which model class corresponds
        to which url. This allows download() to be recursive.
        """
        model_class = self.model_for_source_url(url)

        fh = urllib.urlopen(url)
        data = json.loads(fh.read())
        data.pop('url')
        fh.close()

        uniques = [f.name for f in model_class._meta.fields if f.unique]
        unique_data = {}

        for key, value in data.items():
            if key not in uniques:
                continue

            field = model_class._meta.get_field_by_name(key)[0]
            if getattr(field, 'rel', False):
                continue

            unique_data[key] = value

        if not unique_data:
            assert self.get_or_create_by, 'get_or_create_by needed'

            for key in self.get_or_create_by:
                if key in data.keys() and data[key]:
                    unique_data[key] = data[key]

            if not len(unique_data.keys()):
                raise Exception('cannot check if this model exists locally')

        try:
            model = model_class.objects.get(**unique_data)
        except model_class.DoesNotExist:
            model = model_class(**unique_data)

        for key, value in data.items():
            is_string = isinstance(value, basestring)
            field = model_class._meta.get_field_by_name(key)[0]

            if getattr(field, 'rel', None) and is_string:
                setattr(model, key, self.download(value))
            else:
                setattr(model, key, value)

        model.save()

        return model

########NEW FILE########
__FILENAME__ = template
import types

from django.template import loader

from .base import AutocompleteBase


class AutocompleteTemplate(AutocompleteBase):
    """
    This extension of :py:class:`~.base.AutocompleteBase` supports two new
    attributes:

    .. py:attribute:: choice_template

        Name of the template to use to render a choice in the autocomplete. If
        none is specified, then :py:class:`~.base.AutocompleteBase` will render
        the choice.

    .. py:attribute:: autocomplete_template

        Name of the template to use to render the autocomplete. Again, fall
        back on :py:class:`~.base.AutocompleteBase` if this is None.
    """
    choice_template = None
    autocomplete_template = None

    def get_base_context(self):
        """
        Return a dict to use as base context for all templates.

        It contains:

        - ``{{ request }}`` if available,
        - ``{{ autocomplete }}`` the "self" instance.
        """
        return {
            'request': self.request,
            'autocomplete': self,
        }

    def render_template_context(self, template, extra_context=None):
        """
        Render ``template`` with base context and ``extra_context``.
        """
        context = self.get_base_context()
        context.update(extra_context or {})
        return loader.render_to_string(template, context)

    def autocomplete_html(self):
        """
        Render :py:attr:`autocomplete_template` with base context and ``{{
        choices }}``. If :py:attr:`autocomplete_template` is None then fall
        back on :py:meth:`.base.AutocompleteBase.autocomplete_html`.
        """
        if self.autocomplete_template:
            choices = self.choices_for_request()

            return self.render_template_context(self.autocomplete_template,
                {'choices': choices})
        else:
            return super(AutocompleteTemplate, self).autocomplete_html()

    def choice_html(self, choice):
        """
        Render :py:attr:`choice_template` with base context and ``{{ choice
        }}``. If :py:attr:`choice_template` is None then fall back on
        :py:meth:`.base.AutocompleteBase.choice_html()`.
        """
        if self.choice_template:
            return self.render_template_context(self.choice_template,
                {'choice': choice})
        else:
            return super(AutocompleteTemplate, self).choice_html(choice)

########NEW FILE########
__FILENAME__ = hvad
"""
This is how to enable `language()` for one Autocomplete::

    import autocomplete_light
    from autocomplete_light.contrib.hvad import AutocompleteModelBase

    autocomplete_light.register(YourModel, AutocompleteModelBase)

Or, enable it globally by updating your `autodiscover()` call like this::

    import autocomplete_light
    from autocomplete_light.contrib.hvad import AutocompleteModelBase
    autocomplete_light.registry.autocomplete_model_base = AutocompleteModelBase
    autocomplete_light.autodiscover()

In that case, you can just register as usual::

    autocomplete_light.register(YourTranslatableModel)
"""

import autocomplete_light


class AutocompleteModel(autocomplete_light.AutocompleteModel):
    """ Ensure that `.language()` is called. """
    def __init__(self, request=None, values=None):
        """
        Overridden init to call .language(). Note: this will replace the
        base `choices`.
        """
        if getattr(self.choices.model.objects, 'language', False):
            self.choices = self.choices.model.objects.language()
        super(AutocompleteModel, self).__init__(request, values)


class AutocompleteModelBase(AutocompleteModel,
                            autocomplete_light.AutocompleteBase):
    """ Drop-in replacement for AutocompleteModelBase """
    pass


class AutocompleteModelTemplate(AutocompleteModel,
                                autocomplete_light.AutocompleteTemplate):
    """ Drop-in replacement for AutocompleteModelTemplate """
    pass

########NEW FILE########
__FILENAME__ = taggit_field
"""
Support for django-taggit tags system. It is used automatically by
autocomplete_light.ModelForm but you can use it independently.

Note that you still need to register an autocomplete for the Tag model.

.. Warning::
    In this case, the tags field is a relation. Thus form.save() **must** be
    called with commit=True.

"""
import six

try:
    from taggit.forms import TagField as TaggitTagField
    from taggit.utils import edit_string_for_tags
except ImportError:
    class TaggitTagField(object):
        pass
    edit_string_for_tags = None

from ..fields import FieldBase
from ..widgets import TextWidget


class TaggitWidget(TextWidget):
    def render(self, name, value, attrs=None):
        if value is not None and not isinstance(value, six.string_types):
            value = edit_string_for_tags(
                [o.tag for o in value.select_related("tag")])
        return super(TaggitWidget, self).render(name, value, attrs)


class TaggitField(FieldBase, TaggitTagField):
    widget = TaggitWidget

    def validate(self, value):
        return TaggitTagField.validate(self, value)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class User(models.Model):
    username = models.CharField(max_length=100)
    email = models.EmailField()
    groups = models.ManyToManyField('Group')


class Group(models.Model):
    name = models.CharField(max_length=100)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

try:
    import genericm2m
except ImportError:
    genericm2m = None

try:
    import taggit
except ImportError:
    taggit = None

from .models import *
from .forms import *


models = [FkModel, OtoModel, MtmModel, GfkModel]

if genericm2m:
    models.append(GmtmModel)

if taggit:
    models.append(TaggitModel)


for model in models:
    ModelForm = autocomplete_light.modelform_factory(model,
        exclude=['for_inline', 'noise'])

    Inline = type(str('%sInline') % model.__name__, (admin.TabularInline,), {
        'form': ModelForm, 'model': model, 'fk_name': 'for_inline'})

    ModelAdmin = type(str('%sAdmin' % model.__name__), (admin.ModelAdmin,), {
        'form': ModelForm, 'inlines': [Inline]})

    admin.site.register(model, ModelAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from .models import *

models = [OtoModel, FkModel, MtmModel, GfkModel]

try:
    import genericm2m
except ImportError:
    pass
else:
    models.append(GmtmModel)

for model in models:
    autocomplete_light.register(model)


class A(autocomplete_light.AutocompleteGenericBase):
    choices=[m.objects.all() for m in models]
    search_fields=[['name']] * len(models)


autocomplete_light.register(A)


# The autocomplete for class B is used to set up the test case for
# autocomplete_light.tests.widgets.TextWidgetTestCase.test_widget_attrs_copy.
# This bug is triggered only when the autocomplete is registered with a
# widget_attrs dictionary.
class B(autocomplete_light.AutocompleteGenericBase):
    choices=[m.objects.all() for m in models]
    search_fields=[['name']] * len(models)


autocomplete_light.register(B, widget_attrs={'data-widget-maximum-values': 4})


try:
    from taggit.models import Tag
except ImportError:
    pass
else:
    autocomplete_light.register(Tag)

########NEW FILE########
__FILENAME__ = forms
from django import VERSION

try:
    import genericm2m
except ImportError:
    genericm2m = None

try:
    import taggit
except ImportError:
    taggit = None

import autocomplete_light

autocomplete_light.autodiscover()

from .models import *


class DjangoCompatMeta:
    if VERSION >= (1, 6):
        fields = '__all__'


class FkModelForm(autocomplete_light.ModelForm):
    class Meta(DjangoCompatMeta):
        model = FkModel


class OtoModelForm(autocomplete_light.ModelForm):
    class Meta(DjangoCompatMeta):
        model = OtoModel


class MtmModelForm(autocomplete_light.ModelForm):
    class Meta(DjangoCompatMeta):
        model = MtmModel


class GfkModelForm(autocomplete_light.ModelForm):
    class Meta(DjangoCompatMeta):
        model = GfkModel


if genericm2m:
    class GmtmModelForm(autocomplete_light.ModelForm):
        class Meta(DjangoCompatMeta):
            model = GmtmModel


if taggit:
    class TaggitModelForm(autocomplete_light.ModelForm):
        class Meta(DjangoCompatMeta):
            model = TaggitModel

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.encoding import python_2_unicode_compatible
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType

try:
    from genericm2m.models import RelatedObjectsDescriptor
except ImportError:
    RelatedObjectsDescriptor = None

try:
    from taggit.managers import TaggableManager
except ImportError:
    TaggableManager = None


@python_2_unicode_compatible
class FkModel(models.Model):
    name = models.CharField(max_length=200)
    relation = models.ForeignKey('self', null=True, blank=True)
    noise = models.ForeignKey('OtoModel', null=True, blank=True)

    for_inline = models.ForeignKey('self', null=True, blank=True,
                                   related_name='reverse_for_inline')
    def __str__(self):
        return self.name


@python_2_unicode_compatible
class OtoModel(models.Model):
    name = models.CharField(max_length=200)
    relation = models.OneToOneField('self', null=True, blank=True)
    noise = models.ForeignKey('FkModel', null=True, blank=True)

    for_inline = models.ForeignKey('self', null=True, blank=True,
                                   related_name='inline')
    def __str__(self):
        return self.name


@python_2_unicode_compatible
class MtmModel(models.Model):
    name = models.CharField(max_length=200)
    relation = models.ManyToManyField('self', blank=True)
    noise = models.ForeignKey('FkModel', null=True, blank=True)

    for_inline = models.ForeignKey('self', null=True, blank=True,
                                   related_name='inline')
    def __str__(self):
        return self.name


@python_2_unicode_compatible
class GfkModel(models.Model):
    name = models.CharField(max_length=200)

    content_type = models.ForeignKey(ContentType, null=True, blank=True)
    object_id = models.PositiveIntegerField(null=True, blank=True)
    relation = generic.GenericForeignKey('content_type', 'object_id')

    noise = models.ForeignKey('FkModel', null=True, blank=True)

    for_inline = models.ForeignKey('self', null=True, blank=True,
                                   related_name='inline')
    def __str__(self):
        return self.name


if RelatedObjectsDescriptor:
    @python_2_unicode_compatible
    class GmtmModel(models.Model):
        name = models.CharField(max_length=200)
        relation = RelatedObjectsDescriptor()

        noise = models.ForeignKey('FkModel', null=True, blank=True)
        for_inline = models.ForeignKey('self', null=True, blank=True,
                                       related_name='inline')

        def __str__(self):
            return self.name


if TaggableManager:
    @python_2_unicode_compatible
    class TaggitModel(models.Model):
        name = models.CharField(max_length=200)
        noise = models.ForeignKey('FkModel', null=True, blank=True)
        relation = TaggableManager()

        for_inline = models.ForeignKey('self', null=True, blank=True,
                                       related_name='inline')
        def __str__(self):
            return self.name


@python_2_unicode_compatible
class FullModel(models.Model):
    name = models.CharField(max_length=200)

    oto = models.OneToOneField('self', related_name='reverse_oto')
    fk = models.ForeignKey('self', related_name='reverse_fk')
    mtm = models.ManyToManyField('self', related_name='reverse_mtm')

    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    gfk = generic.GenericForeignKey("content_type", "object_id")

    if RelatedObjectsDescriptor:
        gmtm = RelatedObjectsDescriptor()

    def __str__(self):
        return self.name

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from forms import TaggableForm
from models import Taggable


class TaggableInline(admin.TabularInline):
    form = TaggableForm
    model = Taggable


class TaggableAdmin(admin.ModelAdmin):
    form = TaggableForm
    list_display = ['name', 'tags']
    inlines = [TaggableInline]

admin.site.register(Taggable, TaggableAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
from tagging.models import Tag

import autocomplete_light


autocomplete_light.register(Tag)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from models import Taggable


class TaggableForm(forms.ModelForm):
    class Meta:
        model = Taggable
        widgets = {
        	'tags': autocomplete_light.TextWidget('TagAutocomplete'),
       	}
########NEW FILE########
__FILENAME__ = models
from django.db import models

from tagging.fields import TagField
import tagging


class Taggable(models.Model):
    name = models.CharField(max_length=50)
    tags = TagField(null=True, blank=True)
    parent = models.ForeignKey('self', null=True, blank=True)

    def __unicode__(self):
        return self.name

tagging.register(Taggable, tag_descriptor_attr='etags')

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from .models import Dummy
from .forms import DummyForm


class DummyInline(admin.TabularInline):
	model = Dummy
	form = DummyForm


class DummyAdmin(admin.ModelAdmin):
    form = DummyForm
    inlines = [DummyInline]
admin.site.register(Dummy, DummyAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from cities_light.models import Country, Region

autocomplete_light.register(Country, search_fields=('name', 'name_ascii',),
    autocomplete_js_attributes={'placeholder': 'country name ..'})


class AutocompleteRegion(autocomplete_light.AutocompleteModelBase):
    autocomplete_js_attributes={'placeholder': 'region name ..'}

    def choices_for_request(self):
        q = self.request.GET.get('q', '')
        country_id = self.request.GET.get('country_id', None)

        choices = self.choices.all()
        if q:
            choices = choices.filter(name_ascii__icontains=q)
        if country_id:
            choices = choices.filter(country_id=country_id)

        return self.order_choices(choices)[0:self.limit_choices]

autocomplete_light.register(Region, AutocompleteRegion)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from .models import Dummy


class DummyForm(autocomplete_light.ModelForm):
    class Media:
        """
        We're currently using Media here, but that forced to move the
        javascript from the footer to the extrahead block ...

        So that example might change when this situation annoys someone a lot.
        """
        js = ('dependant_autocomplete.js',)

    class Meta:
        model = Dummy

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Dummy(models.Model):
    parent = models.ForeignKey('self', null=True, blank=True)
    country = models.ForeignKey('cities_light.country')
    region = models.ForeignKey('cities_light.region')

    def __unicode__(self):
        return '%s %s' % (self.country, self.region)
########NEW FILE########
__FILENAME__ = models
from django.db import models


class Genre(models.Model):
    name = models.CharField(max_length=100)

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ('name',)


class Artist(models.Model):
    name = models.CharField(max_length=100)

    genre = models.ForeignKey(Genre)

    def __unicode__(self):
        return '%s %s' % (self.name, self.genre)

    class Meta:
        ordering = ('name',)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

urlpatterns = patterns('navigation_autocomplete.views',
    url(r'^$', 'navigation_autocomplete', name='navigation_autocomplete'),
)

########NEW FILE########
__FILENAME__ = views
from django import shortcuts
from django.db.models import Q
from django.contrib.auth.models import User, Group

from cities_light.models import Country, Region, City


def navigation_autocomplete(request,
    template_name='navigation_autocomplete/autocomplete.html'):

    q = request.GET.get('q', '')
    context = {'q': q}

    queries = {}
    queries['users'] = User.objects.filter(
        Q(username__icontains=q) |
        Q(first_name__icontains=q) |
        Q(last_name__icontains=q) |
        Q(email__icontains=q)
    ).distinct()[:3]
    queries['groups'] = Group.objects.filter(name__icontains=q)[:3]
    queries['cities'] = City.objects.filter(search_names__icontains=q)[:3]
    queries['regions'] = Region.objects.filter(name_ascii__icontains=q)[:3]
    queries['countries'] = Country.objects.filter(name_ascii__icontains=q)[:3]

    context.update(queries)

    return shortcuts.render(request, template_name, context)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from .models import NonAdminAddAnotherModel


class NonAdminAddAnotherModelAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(NonAdminAddAnotherModel)

admin.site.register(NonAdminAddAnotherModel, NonAdminAddAnotherModelAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from .models import NonAdminAddAnotherModel


autocomplete_light.register(NonAdminAddAnotherModel,
    add_another_url_name='non_admin_add_another_model_create')

########NEW FILE########
__FILENAME__ = forms
import autocomplete_light

from .models import NonAdminAddAnotherModel

NonAdminAddAnotherModelForm = autocomplete_light.modelform_factory(
    NonAdminAddAnotherModel)

########NEW FILE########
__FILENAME__ = models
from __future__ import unicode_literals

from django.db import models
from django.core import urlresolvers
from django.utils.encoding import python_2_unicode_compatible


@python_2_unicode_compatible
class NonAdminAddAnotherModel(models.Model):
    name = models.CharField(max_length=100)
    widgets = models.ManyToManyField('self', blank=True)

    def get_absolute_url(self):
        return urlresolvers.reverse(
            'non_admin_add_another_model_update', args=(self.pk,))

    def __str__(self):
        return self.name

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views import generic

import autocomplete_light

from .forms import NonAdminAddAnotherModelForm
from .models import NonAdminAddAnotherModel


urlpatterns = patterns('',
    url(r'$', autocomplete_light.CreateView.as_view(
        model=NonAdminAddAnotherModel, form_class=NonAdminAddAnotherModelForm),
        name='non_admin_add_another_model_create'),
    url(r'(?P<pk>\d+)/$', generic.UpdateView.as_view(
        model=NonAdminAddAnotherModel, form_class=NonAdminAddAnotherModelForm),
        name='non_admin_add_another_model_update'),
)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from .models import Item


class ItemAdmin(admin.ModelAdmin):
    list_display = ('name', 'private')
    list_editable = ('private',)
admin.site.register(Item, ItemAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from .models import Item

autocomplete_light.register(Item,
    choices=Item.objects.filter(private=False))

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from .models import Item


class DjangoItemForm(forms.ModelForm):
    items = forms.ModelMultipleChoiceField(
        queryset=Item.objects.filter(private=False))

    class Meta:
        model = Item
        exclude = ('private',)


class AutocompleteItemForm(autocomplete_light.ModelForm):
    class Meta:
        model = Item
        exclude = ('private',)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.encoding import python_2_unicode_compatible


@python_2_unicode_compatible
class Item(models.Model):
    name = models.CharField(max_length=100)
    items = models.ManyToManyField('self', blank=True)
    private = models.BooleanField(default=True)

    def __str__(self):
        return self.name

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import url, patterns

from django.views import generic

from .models import Item
from .forms import DjangoItemForm, AutocompleteItemForm


urlpatterns = patterns('',
    url(r'autocomplete/(?P<pk>\d+)/', generic.UpdateView.as_view(
        form_class=AutocompleteItemForm,
        queryset=Item.objects.filter(private=False))),
    url(r'django/(?P<pk>\d+)/', generic.UpdateView.as_view(
        form_class=DjangoItemForm,
        queryset=Item.objects.filter(private=False))),
)

########NEW FILE########
__FILENAME__ = exceptions
class AutocompleteLightException(Exception):
    """ Base Exception for all exceptions of this module. """
    pass


class AutocompleteNotRegistered(AutocompleteLightException):
    """ Attemps to drive the user to debug his registry. """
    def __init__(self, name, registry):
        if registry.keys():
            msg = '%s not registered, you have registered: %s' % (name,
                    list(registry.keys()))
        else:
            msg = '%s not registered (registry is empty)' % name

        super(AutocompleteNotRegistered, self).__init__(msg)


class AutocompleteArgNotUnderstood(AutocompleteLightException):
    """
    Raised by AutocompleteRegistry.get_autocomplete_from_arg when it cannot
    understand the argument.
    """
    def __init__(self, arg, registry):
        msg = '%s not understod by get_autocomplete_from_arg()' % arg
        super(AutocompleteArgNotUnderstood, self).__init__(msg)


class NoGenericAutocompleteRegistered(AutocompleteLightException):
    """
    Raised by AutocompleteRegistry.autocomplete_for_generic when no generic
    autocomplete has been registered.
    """
    def __init__(self, registry):
        msg = 'No generic autocomplete was registered.'
        super(NoGenericAutocompleteRegistered, self).__init__(msg)

########NEW FILE########
__FILENAME__ = fields
from __future__ import unicode_literals
import six

from django import forms
from django.db import models
from django.db.models.query import QuerySet
from django import forms
from django.contrib.contenttypes.generic import GenericForeignKey
from django.contrib.contenttypes.models import ContentType

from .registry import registry as default_registry
from .widgets import ChoiceWidget, MultipleChoiceWidget, TextWidget

__all__ = ['FieldBase', 'ChoiceField', 'MultipleChoiceField',
    'ModelChoiceField', 'ModelMultipleChoiceField', 'GenericModelChoiceField',
    'GenericModelMultipleChoiceField']


class FieldBase(object):
    def __init__(self, autocomplete=None, registry=None, widget=None,
            widget_js_attributes=None, autocomplete_js_attributes=None,
            extra_context=None, *args, **kwargs):

        self.autocomplete = self.get_autocomplete(autocomplete, registry,
                widget)

        widget = widget or self.widget
        if isinstance(widget, type):
            widget = widget(autocomplete, widget_js_attributes,
                    autocomplete_js_attributes, extra_context)
        kwargs['widget'] = widget

        parents = super(FieldBase, self).__self_class__.__bases__
        if ((forms.ModelChoiceField in parents or
                forms.ModelMultipleChoiceField in parents)
                and isinstance(self.autocomplete.choices, QuerySet)):
            kwargs['queryset'] = self.autocomplete.choices

        super(FieldBase, self).__init__(*args, **kwargs)

    def get_autocomplete(self, autocomplete, registry, widget):
        if widget:
            # BC: maybe defining the autocomplete as a widget argument ?
            autocomplete = getattr(widget, 'autocomplete', None)

        registry = registry or default_registry
        return registry.get_autocomplete_from_arg(autocomplete)

    def validate(self, value):
        """
        Wrap around Autocomplete.validate_values().
        """
        super(FieldBase, self).validate(value)

        # FIXME: we might actually want to change the Autocomplete API to
        # support python values instead of raw values, that would probably be
        # more performant.
        values = self.prepare_value(value)

        if value and not self.autocomplete(values=values).validate_values():
            raise forms.ValidationError('%s cannot validate %s' % (
                self.autocomplete.__name__, value))


class ChoiceField(FieldBase, forms.ChoiceField):
    widget = ChoiceWidget

    def __init__(self, autocomplete=None, registry=None, widget=None,
            widget_js_attributes=None, autocomplete_js_attributes=None,
            extra_context=None, *args, **kwargs):

        kwargs.update({'choices':
            self.get_choices(autocomplete, registry, widget)})

        super(ChoiceField, self).__init__(autocomplete, registry, widget,
                widget_js_attributes, autocomplete_js_attributes,
                extra_context, *args, **kwargs)

    def get_choices(self, autocomplete, registry, widget):
        a = self.get_autocomplete(autocomplete, registry, widget)()
        return ((a.choice_value(c), a.choice_label(c)) for c in a.choices)


class MultipleChoiceField(ChoiceField, forms.MultipleChoiceField):
    widget = MultipleChoiceWidget


class ModelChoiceField(FieldBase, forms.ModelChoiceField):
    widget = ChoiceWidget


class ModelMultipleChoiceField(FieldBase,
        forms.ModelMultipleChoiceField):
    widget = MultipleChoiceWidget


class GenericModelChoiceField(FieldBase, forms.Field):
    """
    Simple form field that converts strings to models.
    """
    widget = ChoiceWidget

    def prepare_value(self, value):
        """
        Given a model instance as value, with content type id of 3 and pk of 5,
        return such a string '3-5'.
        """
        if isinstance(value, six.string_types):
            # Apparently there's a bug in django, that causes a python value to
            # be passed here. This ONLY happens when in an inline ....
            return value
        elif isinstance(value, models.Model):
            return '%s-%s' % (ContentType.objects.get_for_model(value).pk,
                              value.pk)

    def to_python(self, value):
        """
        Given a string like '3-5', return the model of content type id 3 and pk
        5.
        """
        if not value:
            return value

        content_type_id, object_id = value.split('-', 1)
        try:
            content_type = ContentType.objects.get_for_id(content_type_id)
        except ContentType.DoesNotExist:
            raise forms.ValidationError('Wrong content type')
        else:
            model = content_type.model_class()

        try:
            return model.objects.get(pk=object_id)
        except model.DoesNotExist:
            raise forms.ValidationError('Wrong object id')


class GenericModelMultipleChoiceField(GenericModelChoiceField):
    """
    Simple form field that converts strings to models.
    """
    widget = MultipleChoiceWidget

    def prepare_value(self, value):
        return [super(GenericModelMultipleChoiceField, self
            ).prepare_value(v) for v in value]

    def to_python(self, value):
        return [super(GenericModelMultipleChoiceField, self).to_python(v)
            for v in value]

########NEW FILE########
__FILENAME__ = forms
"""
High-level API for django-autocomplete-light.

Before, django-autocomplete-light was just a container for a loosely coupled
set of tools. You had to go for a treasure hunt in the docs and source to find
just what you need and add it to your project.

While you can still do that, this module adds a high-level API which couples
all the little pieces together. Basically you could just inherit from ModelForm
or use modelform_factory() and expect everything to work out of the box, from
simple autocompletes to generic many to many autocompletes including a bug fix
for django bug #9321 or even added security.
"""
from __future__ import unicode_literals

import six

from django.utils.encoding import force_text
from django.utils.translation import ugettext_lazy as _
from django.contrib.admin.widgets import RelatedFieldWidgetWrapper
from django import forms
from django.db.models import ForeignKey, OneToOneField, ManyToManyField
from django.contrib.contenttypes.generic import (GenericForeignKey,
                                                 GenericRelation)
from django.contrib.contenttypes.models import ContentType
from django.forms.models import modelform_factory as django_modelform_factory
from django.forms.models import ModelFormMetaclass as DjangoModelFormMetaclass

try:
    from genericm2m.models import RelatedObjectsDescriptor
except ImportError:
    RelatedObjectsDescriptor = None

try:
    from taggit.managers import TaggableManager
except ImportError:
    class TaggableManager(object):
        pass

from .registry import registry as default_registry
from .fields import (ModelChoiceField, ModelMultipleChoiceField,
        GenericModelChoiceField, GenericModelMultipleChoiceField)
from .contrib.taggit_field import TaggitField
from .widgets import ChoiceWidget, MultipleChoiceWidget

__all__ = ['modelform_factory', 'FormfieldCallback', 'ModelForm',
'SelectMultipleHelpTextRemovalMixin', 'VirtualFieldHandlingMixin',
'GenericM2MRelatedObjectDescriptorHandlingMixin']

# OMG #9321 why do we have to hard-code this ?
M = _('Hold down "Control", or "Command" on a Mac, to select more than one.')


class SelectMultipleHelpTextRemovalMixin(forms.BaseModelForm):
    """
    This mixin that removes the 'Hold down "Control" ...' message that is
    enforced in select multiple fields.

    See https://code.djangoproject.com/ticket/9321
    """

    def __init__(self, *args, **kwargs):
        super(SelectMultipleHelpTextRemovalMixin, self).__init__(*args,
                **kwargs)
        msg = force_text(M)

        for name, field in self.fields.items():
            widget = field.widget

            if isinstance(widget, RelatedFieldWidgetWrapper):
                widget = widget.widget

            if not isinstance(widget, MultipleChoiceWidget):
                continue

            field.help_text = field.help_text.replace(msg, '')


class VirtualFieldHandlingMixin(forms.BaseModelForm):
    """
    Enable virtual field (generic foreign key) handling in django's ModelForm.

    - treat virtual fields like GenericForeignKey as normal fields,
    - when setting a GenericForeignKey value, also set the object id and
      content type id fields.

    Probably, django doesn't do that for legacy reasons: virtual fields were
    added after ModelForm and simply nobody asked django to add virtual field
    support in ModelForm.
    """
    def __init__(self, *args, **kwargs):
        """
        The constructor adds virtual field values to
        :py:attr:`django:django.forms.Form.initial`
        """
        super(VirtualFieldHandlingMixin, self).__init__(*args, **kwargs)

        # do what model_to_dict doesn't
        for field in self._meta.model._meta.virtual_fields:
            self.initial[field.name] = getattr(self.instance, field.name, None)

    def _post_clean(self):
        """
        What ModelForm does, but also set virtual field values from
        cleaned_data.
        """
        super(VirtualFieldHandlingMixin, self)._post_clean()

        # take care of virtual fields since django doesn't
        for field in self._meta.model._meta.virtual_fields:
            value = self.cleaned_data.get(field.name, None)

            if value:
                setattr(self.instance, field.name, value)

                self.cleaned_data[field.ct_field] = \
                    ContentType.objects.get_for_model(value)
                self.cleaned_data[field.fk_field] = value.pk


class GenericM2MRelatedObjectDescriptorHandlingMixin(forms.BaseModelForm):
    """
    Extension of autocomplete_light.GenericModelForm, that handles
    genericm2m's RelatedObjectsDescriptor.
    """

    def __init__(self, *args, **kwargs):
        """
        Add related objects to initial for each generic m2m field.
        """
        super(GenericM2MRelatedObjectDescriptorHandlingMixin, self).__init__(
            *args, **kwargs)

        for name, field in self.generic_m2m_fields():
            related_objects = getattr(self.instance, name).all()
            self.initial[name] = [x.object for x in related_objects]

    def generic_m2m_fields(self):
        """
        Yield name, field for each RelatedObjectsDescriptor of the model of
        this ModelForm.
        """
        for name, field in self.fields.items():
            if not isinstance(field, GenericModelMultipleChoiceField):
                continue

            model_class_attr = getattr(self._meta.model, name, None)
            if not isinstance(model_class_attr, RelatedObjectsDescriptor):
                continue

            yield name, field

    def save(self, commit=True):
        """
        Save the form and particularely the generic many to many relations.
        """
        instance = super(GenericM2MRelatedObjectDescriptorHandlingMixin,
                self).save(commit=commit)

        def save_m2m():
            for name, field in self.generic_m2m_fields():
                model_attr = getattr(instance, name)
                selected_relations = self.cleaned_data.get(name, [])

                for related in model_attr.all():
                    if related.object not in selected_relations:
                        model_attr.remove(related)

                for related in selected_relations:
                    model_attr.connect(related)

        if hasattr(self, 'save_m2m'):
            old_m2m = self.save_m2m

            def _():
                save_m2m()
                old_m2m()
            self.save_m2m = _
        else:
            save_m2m()

        return instance


class FormfieldCallback(object):
    """
    Decorate `model_field.formfield()` to use a
    `autocomplete_light.ModelChoiceField` for `OneToOneField` and
    `ForeignKey` or a `autocomplete_light.ModelMultipleChoiceField` for a
    `ManyToManyField`.

    It is the very purpose of our `ModelFormMetaclass` !
    """

    def __init__(self, default=None, meta=None):
        self.autocomplete_exclude = getattr(meta, 'autocomplete_exclude', None)
        self.autocomplete_fields = getattr(meta, 'autocomplete_fields', None)
        self.autocomplete_names = getattr(meta, 'autocomplete_names', {})

        def _default(model_field, **kwargs):
            return model_field.formfield(**kwargs)

        self.default = default or _default

    def __call__(self, model_field, **kwargs):
        if (self.autocomplete_exclude and
                model_field.name in self.autocomplete_exclude):
            pass

        elif (self.autocomplete_fields and
                model_field.name not in self.autocomplete_fields):
            pass

        elif hasattr(model_field, 'rel') and hasattr(model_field.rel, 'to'):
            if model_field.name in self.autocomplete_names:
                autocomplete = default_registry.get(
                    self.autocomplete_names[model_field.name])
            else:
                autocomplete = default_registry.autocomplete_for_model(
                    model_field.rel.to)

            if autocomplete is not None:
                kwargs['autocomplete'] = autocomplete

                if isinstance(model_field, (OneToOneField, ForeignKey)):
                    kwargs['form_class'] = ModelChoiceField
                elif isinstance(model_field, ManyToManyField):
                    kwargs['form_class'] = ModelMultipleChoiceField
                elif isinstance(model_field, TaggableManager):
                    kwargs['form_class'] = TaggitField
                else:
                    # none of our concern
                    kwargs.pop('form_class')

        return self.default(model_field, **kwargs)


class ModelFormMetaclass(DjangoModelFormMetaclass):
    """
    Wrap around django's ModelFormMetaclass to add autocompletes.
    """
    def __new__(cls, name, bases, attrs):
        """
        Add autocompletes in three steps:

        - use our formfield_callback for basic field autocompletes: one to one,
        foreign key, many to many
        - exclude generic foreign key content type foreign key and object id
        field,
        - add autocompletes for generic foreign key and generic many to many.
        """
        meta = attrs.get('Meta', None)

        # use our formfield_callback to add autocompletes if not already used
        formfield_callback = attrs.get('formfield_callback', None)

        if not isinstance(formfield_callback, FormfieldCallback):
            attrs['formfield_callback'] = FormfieldCallback(formfield_callback,
                    meta)

        if meta is not None:
            cls.clean_meta(meta)
            cls.pre_new(meta)

        new_class = super(ModelFormMetaclass, cls).__new__(cls, name, bases,
                attrs)

        if meta is not None:
            cls.post_new(new_class, meta)

        return new_class

    @classmethod
    def skip_field(cls, meta, field):
        if isinstance(field, GenericRelation):
            # skip reverse generic foreign key
            return True

        all_fields = set(getattr(meta, 'fields', [])) | set(getattr(meta,
            'autocomplete_fields', []))
        all_exclude = set(getattr(meta, 'exclude', [])) | set(getattr(meta,
            'autocomplete_exclude', []))

        if getattr(meta, 'fields', None) == '__all__':
            return field.name in all_exclude

        if len(all_fields) and field.name not in all_fields:
            return True

        if len(all_exclude) and field.name in all_exclude:
            return True

    @classmethod
    def clean_meta(cls, meta):
        # All virtual fields/excludes must be move to
        # autocomplete_fields/exclude
        fields = getattr(meta, 'fields', [])

        for field in fields:
            model_field = getattr(meta.model._meta.virtual_fields, field, None)

            if model_field is None:
                model_field = getattr(meta.model, field, None)

            if model_field is None:
                continue

            if ((RelatedObjectsDescriptor and isinstance(model_field,
                (RelatedObjectsDescriptor, GenericForeignKey))) or
                    isinstance(model_field, GenericForeignKey)):

                meta.fields.remove(field)

                if not hasattr(meta, 'autocomplete_fields'):
                    meta.autocomplete_fields = tuple()

                meta.autocomplete_fields += (field,)

    @classmethod
    def pre_new(cls, meta):
        exclude = tuple(getattr(meta, 'exclude', []))
        add_exclude = []

        # exclude gfk content type and object id fields
        for field in meta.model._meta.virtual_fields:
            if cls.skip_field(meta, field):
                continue

            if isinstance(field, GenericForeignKey):
                add_exclude += [field.ct_field, field.fk_field]

        if exclude:
            # safe concatenation of list/tuple
            # thanks lvh from #python@freenode
            meta.exclude = set(add_exclude) | set(exclude)

    @classmethod
    def post_new(cls, new_class, meta):
        cls.add_generic_fk_fields(new_class, meta)

        if RelatedObjectsDescriptor:
            # if genericm2m is installed
            cls.add_generic_m2m_fields(new_class, meta)

    @classmethod
    def add_generic_fk_fields(cls, new_class, meta):
        widgets = getattr(meta, 'widgets', {})

        # Add generic fk and m2m autocompletes
        for field in meta.model._meta.virtual_fields:
            if cls.skip_field(meta, field):
                continue

            new_class.base_fields[field.name] = GenericModelChoiceField(
                widget=widgets.get(field.name, None),
                autocomplete=cls.get_generic_autocomplete(meta, field.name),
                required=not meta.model._meta.get_field_by_name(
                    field.fk_field)
            )

    @classmethod
    def add_generic_m2m_fields(cls, new_class, meta):
        widgets = getattr(meta, 'widgets', {})

        for field in meta.model.__dict__.values():
            if not isinstance(field, RelatedObjectsDescriptor):
                continue

            if cls.skip_field(meta, field):
                continue

            new_class.base_fields[field.name] = \
                GenericModelMultipleChoiceField(
                    widget=widgets.get(field.name, None),
                    autocomplete=cls.get_generic_autocomplete(
                        meta, field.name))

    @classmethod
    def get_generic_autocomplete(self, meta, name):
        autocomplete_name = getattr(meta, 'autocomplete_names', {}).get(
            name, None)

        if autocomplete_name:
            return default_registry[autocomplete_name]
        else:
            return default_registry.default_generic


class ModelForm(six.with_metaclass(ModelFormMetaclass,
        SelectMultipleHelpTextRemovalMixin, VirtualFieldHandlingMixin,
        GenericM2MRelatedObjectDescriptorHandlingMixin, forms.ModelForm)):
    """
    ModelForm override using our metaclass that adds our various mixins.

    .. py:attribute:: autocomplete_fields

        A list field names on which you want automatic autocomplete fields.

    .. py:attribute:: autocomplete_exclude

        A list of field names on which you do not want automatic autocomplete
        fields.

    .. py:attribute:: autocomplete_names

        A dict of ``field_name: AutocompleteName`` to override the default
        autocomplete that would be used for a field.

    Note: all of ``autocomplete_fields``, ``autocomplete_exclude`` and
    ``autocomplete_names`` understand generic foreign key and generic many to
    many descriptor names.
    """
    __metaclass__ = ModelFormMetaclass


def modelform_factory(model, autocomplete_fields=None,
                      autocomplete_exclude=None, autocomplete_names=None,
                      registry=None, **kwargs):
    """
    Wrap around Django's django_modelform_factory, using our ModelForm and
    setting autocomplete_fields and autocomplete_exclude.
    """
    if 'form' not in kwargs.keys():
        kwargs['form'] = ModelForm

    attrs = {'model': model}

    if autocomplete_fields is not None:
        attrs['autocomplete_fields'] = autocomplete_fields
    if autocomplete_exclude is not None:
        attrs['autocomplete_exclude'] = autocomplete_exclude
    if autocomplete_names is not None:
        attrs['autocomplete_names'] = autocomplete_names

    # If parent form class already has an inner Meta, the Meta we're
    # creating needs to inherit from the parent's inner meta.
    parent = (object,)
    if hasattr(kwargs['form'], 'Meta'):
        parent = (kwargs['form'].Meta, object)
    Meta = type(str('Meta'), parent, attrs)

    kwargs['form'] = type(kwargs['form'].__name__, (kwargs['form'],),
            {'Meta': Meta})

    if not issubclass(kwargs['form'], ModelForm):
        raise Exception('form kwarg must be an autocomplete_light ModelForm')

    return django_modelform_factory(model, **kwargs)

########NEW FILE########
__FILENAME__ = generic
from django import forms
from django.db import models
from django.forms import fields
from django.contrib.contenttypes.generic import GenericForeignKey
from django.contrib.contenttypes.models import ContentType

__all__ = ('GenericModelForm', 'GenericModelChoiceField')


class GenericModelForm(forms.ModelForm):
    """
    This simple subclass of ModelForm fixes a couple of issues with django's
    ModelForm.

    - treat virtual fields like GenericForeignKey as normal fields, Django
      should already do that but it doesn't,
    - when setting a GenericForeignKey value, also set the object id and
      content type id fields, again Django could probably afford to do that.
    """
    def __init__(self, *args, **kwargs):
        """
        What ModelForm does, but also add virtual field values to self.initial.
        """
        super(GenericModelForm, self).__init__(*args, **kwargs)

        # do what model_to_dict doesn't
        for field in self._meta.model._meta.virtual_fields:
            self.initial[field.name] = getattr(self.instance, field.name, None)

    def _post_clean(self):
        """
        What ModelForm does, but also set virtual field values from
        cleaned_data.
        """
        super(GenericModelForm, self)._post_clean()

        # take care of virtual fields since django doesn't
        for field in self._meta.model._meta.virtual_fields:
            value = self.cleaned_data.get(field.name, None)

            if value:
                setattr(self.instance, field.name, value)

                self.cleaned_data[field.ct_field] = \
                    ContentType.objects.get_for_model(value)
                self.cleaned_data[field.fk_field] = value.pk


class GenericModelChoiceField(fields.Field):
    """
    Simple form field that converts strings to models.
    """
    def validate(self, value):
        if not value and not self.required:
            return True

        value = self.prepare_value(value)
        valid = self.widget.autocomplete(values=value).validate_values()

        if not valid:
            raise forms.ValidationError('%s cannot validate %s' % (
                self, value))

    def prepare_value(self, value):
        """
        Given a model instance as value, with content type id of 3 and pk of 5,
        return such a string '3-5'.
        """
        if isinstance(value, (str, unicode)):
            # Apparently there's a bug in django, that causes a python value to
            # be passed here. This ONLY happens when in an inline ....
            return value
        elif isinstance(value, models.Model):
            return '%s-%s' % (ContentType.objects.get_for_model(value).pk,
                              value.pk)

    def to_python(self, value):
        """
        Given a string like '3-5', return the model of content type id 3 and pk
        5.
        """
        if not value:
            return value

        content_type_id, object_id = value.split('-', 1)
        try:
            content_type = ContentType.objects.get_for_id(content_type_id)
        except ContentType.DoesNotExist:
            raise forms.ValidationError('Wrong content type')
        else:
            model = content_type.model_class()

        return model.objects.get(pk=object_id)

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = registry
from __future__ import unicode_literals

"""
The registry module provides tools to maintain a registry of autocompletes.

The first thing that should happen when django starts is registration of
autocompletes. It should happen first, because autocompletes are required for
widgets. And autocomplete widgets are required for forms. And forms are
required for ModelAdmin.

It looks like this:

- in ``yourapp/autocomplete_light_registry.py``, register your autocompletes
  with :py:func:`autocomplete_light.register() <register>`,
- in ``urls.py``, call :py:func:`autocomplete_light.autodiscover()
  <autodiscover>` **before** :py:func:`admin.autodiscover()`.

.. py:data:: registry

    Module-level instance of :py:class:`AutocompleteRegistry`.
"""
import six

from django.db import models

from .autocomplete import AutocompleteModelBase, AutocompleteInterface
from .exceptions import (AutocompleteNotRegistered,
                         AutocompleteArgNotUnderstood,
                         NoGenericAutocompleteRegistered)

__all__ = ('AutocompleteRegistry', 'registry', 'register', 'autodiscover')


class AutocompleteRegistry(dict):
    """
    AutocompleteRegistry is a dict of ``AutocompleteName: AutocompleteClass``
    with some shortcuts to handle a registry of autocompletes.

    .. py:attribute:: autocomplete_model_base

        The default model autocomplete class to use when registering a Model
        without Autocomplete class. Default is
        :py:class:`~.autocomplete.AutocompleteModelBase`. You can override
        it just before calling autodiscover() in urls.py as such::

            import autocomplete_light
            autocomplete_light.registry.autocomplete_model_base = \
                autocomplete_light.AutocompleteModelTemplate
            autocomplete_light.autodiscover()
    """

    def __init__(self, autocomplete_model_base=None):
        """
        You can pass a custom base autocomplete which will be set to
        :py:attr:`autocomplete_model_base` when instanciating an
        AutocompleteRegistry.
        """
        self._models = {}
        self.default_generic = None
        self.autocomplete_model_base = autocomplete_model_base

        if self.autocomplete_model_base is None:
            self.autocomplete_model_base = AutocompleteModelBase

    def autocomplete_for_model(self, model):
        """
        Return the default autocomplete class for a given model or None.
        """
        try:
            return self._models[model]
        except KeyError:
            return

    def autocomplete_for_generic(self):
        """ Return the default generic autocomplete. """
        if self.default_generic is None:
            raise NoGenericAutocompleteRegistered(self)

        return self.default_generic

    def unregister(self, name):
        """ Unregister a autocomplete given a name. """
        autocomplete = self[name]
        del self[name]

        try:
            if self._models[autocomplete.choices.model].name == name:
                del self._models[autocomplete.choices.model]
        except AttributeError:
            pass

    @classmethod
    def extract_args(cls, *args):
        """
        Takes any arguments like a model and an autocomplete, or just one of
        those, in any order, and return a model and autocomplete.
        """
        model = None
        autocomplete = None

        for arg in args:
            if issubclass(arg, models.Model):
                model = arg
            else:
                autocomplete = arg

        return [model, autocomplete]

    def register(self, *args, **kwargs):
        """
        Register an autocomplete.

        Two unordered arguments are accepted, at least one should be passed:

        - a model if not a generic autocomplete,
        - an autocomplete class if necessary, else one will be generated.

        'name' is also an acceptable keyword argument, that can be used to
        override the default autocomplete name which is the class name by
        default, which could cause name conflicts in some rare cases.

        In addition, keyword arguments will be set as class attributes.

        For thread safety reasons, a copy of the autocomplete class is stored
        in the registry.
        """
        assert len(args) <= 2, 'register takes at most 2 args'
        assert len(args) > 0, 'register takes at least 1 arg'

        model, autocomplete = self.__class__.extract_args(*args)

        if not model:
            try:
                model = autocomplete.choices.model
            except AttributeError:
                pass

        if model:
            autocomplete = self._register_model_autocomplete(model,
                autocomplete, **kwargs)
        else:
            name = kwargs.get('name', autocomplete.__name__)
            autocomplete = type(str(name), (autocomplete,), kwargs)
            self._register_autocomplete(autocomplete)

        return autocomplete

    def _register_model_autocomplete(self, model, autocomplete=None,
                                    name=None, **kwargs):

        if name is not None:
            pass
        elif autocomplete is not None:
            if autocomplete.__name__.find(model.__name__) == 0:
                name = autocomplete.__name__
            else:
                name = '%s%s' % (model.__name__, autocomplete.__name__)
        else:
            name = '%sAutocomplete' % model.__name__

        if autocomplete is None:
            base = self.autocomplete_model_base
        else:
            base = autocomplete

        if base.choices is None and 'choices' not in kwargs:
            kwargs['choices'] = model._default_manager.all()

        if base.search_fields is None and 'search_fields' not in kwargs:
            try:
                model._meta.get_field('name')
            except:
                raise Exception('Add search_fields kwargs to .register(%s)'
                                % model.__name__)
            else:
                kwargs['search_fields'] = ['name']

        kwargs.update({'model': model})

        autocomplete = type(str(name), (base,), kwargs)

        self._register_autocomplete(autocomplete)

        if model not in self._models.keys():
            self._models[model] = autocomplete

        return autocomplete

    def _register_autocomplete(self, autocomplete):
        """
        Register a autocomplete without model, like a generic autocomplete.
        """
        self[autocomplete.__name__] = autocomplete

        if not getattr(autocomplete, 'model', False):
            if not self.default_generic:
                self.default_generic = autocomplete

    def __getitem__(self, name):
        """
        Return the Autocomplete class registered for this name. If none is
        registered, raise AutocompleteNotRegistered.
        """
        try:
            return super(AutocompleteRegistry, self).__getitem__(name)
        except KeyError:
            raise AutocompleteNotRegistered(name, self)

    def get_autocomplete_from_arg(self, arg=None):
        if isinstance(arg, six.string_types):
            return self[arg]
        elif isinstance(arg, type) and issubclass(arg, models.Model):
            return self.autocomplete_for_model(arg)
        elif isinstance(arg, models.Model):
            return self.autocomplete_for_model(arg.__class__)
        elif isinstance(arg, type) and issubclass(arg, AutocompleteInterface):
            return arg
        elif arg is None:
            return self.default_generic
        else:
            raise AutocompleteArgNotUnderstood(arg, self)


def _autodiscover(registry):
    """See documentation for autodiscover (without the underscore)"""
    import copy
    from django.conf import settings
    from django.utils.importlib import import_module
    from django.utils.module_loading import module_has_submodule

    for app in settings.INSTALLED_APPS:
        try:
            mod = import_module(app)
        except ImportError:
            # not all entries in INSTALLED_APPS are have to be modules
            continue
        # Attempt to import the app's admin module.
        try:
            before_import_registry = copy.copy(registry)
            import_module('%s.autocomplete_light_registry' % app)
        except:
            # Reset the model registry to the state before the last import as
            # this import will have to reoccur on the next request and this
            # could raise NotRegistered and AlreadyRegistered exceptions
            # (see #8245).
            registry = before_import_registry

            # Decide whether to bubble up this error. If the app just
            # doesn't have an admin module, we can ignore the error
            # attempting to import it, otherwise we want it to bubble up.
            if module_has_submodule(mod, 'autocomplete_light_registry'):
                raise

registry = AutocompleteRegistry()


def autodiscover():
    """
    Check all apps in INSTALLED_APPS for stuff related to autocomplete_light.

    For each app, autodiscover imports ``app.autocomplete_light_registry`` if
    possing, resulting in execution of :py:func:`register()` statements in that
    module, filling up :py:data:`registry`.

    Consider a standard app called ``cities_light`` with such a structure::

        cities_light/
            __init__.py
            models.py
            urls.py
            views.py
            autocomplete_light_registry.py

    Where autocomplete_light_registry.py contains something like::

        from models import City, Country
        import autocomplete_light
        autocomplete_light.register(City)
        autocomplete_light.register(Country)

    When ``autodiscover()`` imports
    ``cities_light.autocomplete_light_registry``, both ``CityAutocomplete`` and
    ``CountryAutocomplete`` will be registered. See
    :py:meth:`AutocompleteRegistry.register()` for details on how these
    autocomplete classes are generated.
    """
    _autodiscover(registry)


def register(*args, **kwargs):
    """
    Proxy method :py:meth:`AutocompleteRegistry.register` of the
    :py:data:`registry` module level instance.
    """
    return registry.register(*args, **kwargs)

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings

__all__ = ('DEFAULT_SEARCH_FIELDS',)

DEFAULT_SEARCH_FIELDS = getattr(settings,
    'AUTOCOMPLETE_LIGHT_DEFAULT_SEARCH_FIELDS',
    ('name',)
)

########NEW FILE########
__FILENAME__ = autocomplete_light_tags
from __future__ import unicode_literals

from django import template
from django.utils import safestring

register = template.Library()


@register.filter
def autocomplete_light_data_attributes(attributes, prefix=''):
    html = []

    for key, value in attributes.items():
        html.append('data-%s%s="%s"' % (prefix, key.replace('_', '-'), value))

    return safestring.mark_safe(' '.join(html))


@register.filter
def autocomplete_light_choice_html(choice, autocomplete):
    """Return autocomplete.choice_html(choice)"""
    return safestring.mark_safe(autocomplete.choice_html(choice))

########NEW FILE########
__FILENAME__ = case
from __future__ import unicode_literals

import unittest

from django import http
from django import forms
from django.test import TestCase
from django.contrib.contenttypes.models import ContentType
from six import text_type

from ...example_apps.autocomplete_test_case_app.models import User, Group

import autocomplete_light


def make_get_request(query=''):
    request = http.HttpRequest()
    request.GET = http.QueryDict(query)
    return request


class AutocompleteTestCase(TestCase):
    autocomplete_mock = None
    fixtures = ['autocomplete_model_test_case']

    def setUp(self):
        self.user_ctype = ContentType.objects.get_for_model(User)
        self.group_ctype = ContentType.objects.get_for_model(Group)

        self.rockers = Group.objects.get(name='rockers')
        self.bluesmen = Group.objects.get(name='bluesmen')
        self.jazzmen = Group.objects.get(name='jazzmen')
        self.emos = Group.objects.get(name='emos')

        self.abe = User.objects.get(username='Abe')
        self.jack = User.objects.get(username='Jack')
        self.james = User.objects.get(username='James')
        self.john = User.objects.get(username='John')
        self.elton = User.objects.get(username='Elton')

    def assert_choices_equal(self, result, test):
        self.assertEqual(result, test['expected'],
                'Unexpected result %s\nTest: %s' % (result, test))

    def test_choices_for_request(self):
        if not hasattr(self, 'get_choices_for_request_tests'):
            return

        for test in self.get_choices_for_request_tests():
            mock = self.autocomplete_mock(request=test['fixture'])
            for k, v in test.get('kwargs', {}).items():
                setattr(mock, k, v)
            result = mock.choices_for_request()
            self.assert_choices_equal(list(result), test)

    def test_choices_for_values(self):
        if not hasattr(self, 'get_choices_for_values_tests'):
            return

        for test in self.get_choices_for_values_tests():
            mock = self.autocomplete_mock(values=test['fixture'])
            result = mock.choices_for_values()
            self.assert_choices_equal(result, test)

    def assert_validate_success(self, result, test):
        self.assertEqual(result, test['expected'],
            'Got %s for test %s %s' % (result, self.__class__.__name__,
                test))

    def test_validate(self):
        if not hasattr(self, 'get_validate_tests'):
            return

        for test in self.get_validate_tests():
            mock = self.autocomplete_mock(values=test['fixture'])
            result = mock.validate_values()
            self.assert_validate_success(result, test)

    def test_autocomplete_html(self):
        if not hasattr(self, 'get_autocomplete_html_tests'):
            return

        for test in self.get_autocomplete_html_tests():
            mock = self.autocomplete_mock(request=test['fixture'])
            result = mock.autocomplete_html()
            self.assert_html_equals(result, test)

    def assert_html_equals(self, result, test):
        self.assertEqual(result, test['expected'],
            'Got %s for test %s %s' % (result, self.__class__.__name__,
                test))

    def test_widget(self):
        form_class = None

        if not hasattr(self, 'get_widget_tests'):
            return

        for test in self.get_widget_tests():
            if 'form_class' in test.keys():
                form_class = test['form_class']
            # for display
            test['form_class'] = form_class.__name__

            form = form_class(http.QueryDict(test['fixture']))
            try:
                valid = form.is_valid()
            except TypeError:
                print(self.__class__, test, self.get_widget_tests())
                raise

            self.assertEqual(
                valid, test['expected_valid'],
                'Unexepected valid: %s for test %s %s' % (
                    valid, self.__class__.__name__, test)
            )

            if valid:
                data = form.cleaned_data['x']

                self.assertEqual(text_type(data), text_type(test['expected_data']),
                    'Unexepected data: %s for test %s %s' % (
                        data, self.__class__.__name__, test)
                )

########NEW FILE########
__FILENAME__ = choice_list
from __future__ import unicode_literals

from .case import *


class AutocompleteChoiceListMock(
    autocomplete_light.AutocompleteChoiceListBase):
    limit_choices = 2

    choices = (
        (0, 'Zero'),
        (1, 'One'),
        (2, 'Two'),
        (3, 'Three'),
        (4, 'Four'),
        (10, 'Ten'),
    )


class FormMock(forms.Form):
    x = forms.ChoiceField(choices=AutocompleteChoiceListMock.choices,
        widget=autocomplete_light.ChoiceWidget(
            autocomplete=AutocompleteChoiceListMock))


class MultipleFormMock(forms.Form):
    x = forms.MultipleChoiceField(choices=AutocompleteChoiceListMock.choices,
        widget=autocomplete_light.MultipleChoiceWidget(
            autocomplete=AutocompleteChoiceListMock))


class AutocompleteChoiceListTestCase(AutocompleteTestCase):
    autocomplete_mock = AutocompleteChoiceListMock

    def get_choices_for_values_tests(self):
        return (
            {
                'fixture': [1, 4],
                'expected': [
                    (4, 'Four'),
                    (1, 'One'),
                ]
            },
        )

    def get_choices_for_request_tests(self):
        return (
            {
                'fixture': make_get_request('q=t'),
                'expected': [
                    (10, 'Ten'),
                    (3, 'Three'),
                ]
            },
            {
                'fixture': make_get_request('q=2'),
                'expected': [
                    (2, 'Two'),
                ]
            },
            {
                'fixture': make_get_request(),
                'expected': [
                    (4, 'Four'),
                    (1, 'One'),
                ]
            }
        )

    def get_validate_tests(self):
        return (
            {
                'fixture': [1, 4],
                'expected': True,
            },
            {
                'fixture': [1, 4, 123],
                'expected': False,
            },
        )

    def get_autocomplete_html_tests(self):
        return (
            {
                'fixture': make_get_request('q=t'),
                'expected': ''.join([
                    '<span data-value="10">Ten</span>',
                    '<span data-value="3">Three</span>',
                ])
            },
            {
                'fixture': make_get_request(),
                'expected': ''.join([
                    '<span data-value="4">Four</span>',
                    '<span data-value="1">One</span>',
                ])
            },
        )

    def get_widget_tests(self):
        return (
            {
                'form_class': FormMock,
                'fixture': 'x=4',
                'expected_valid': True,
                'expected_data': 4,
            },
            {
                'fixture': 'x=abc',
                'expected_valid': False,
            },
            {
                'form_class': MultipleFormMock,
                'fixture': 'x=4&x=6',
                'expected_valid': False,
            },
            {
                'fixture': 'x=4&x=10',
                'expected_valid': True,
                'expected_data': ['4', '10'],
            },
            {
                'fixture': 'x=abc&x=2',
                'expected_valid': False,
            },
        )

########NEW FILE########
__FILENAME__ = generic
from __future__ import unicode_literals

from .case import *

from django.contrib.contenttypes.models import ContentType
from django.contrib.auth.models import Permission

from ...example_apps.autocomplete_test_case_app.models import User, Group


class AutocompleteGenericMock(autocomplete_light.AutocompleteGenericBase):
    choices = (
        User.objects.filter(pk__lt=10),
        Group.objects.filter(pk__lt=10),
    )
    search_fields = (
        ('username', 'email'),
        ('name',),
    )
    limit_choices = 3


class FormMock(forms.Form):
    x = autocomplete_light.GenericModelChoiceField(
        widget=autocomplete_light.ChoiceWidget(
            autocomplete=AutocompleteGenericMock))


class AutocompleteGenericTestCase(AutocompleteTestCase):
    autocomplete_mock = AutocompleteGenericMock

    def assert_choices_equal(self, result, test):
        self.assertEqual(list(result), test['expected'])

    def get_choices_for_values_tests(self):
        return (
            {
                'fixture': [
                    '%s-%s' % (self.user_ctype.pk, self.james.pk),
                    '%s-%s' % (self.group_ctype.pk, self.bluesmen.pk),
                ],
                'expected': [
                    self.james,
                    self.bluesmen,
                ]
            },
            {
                'fixture': [
                    '%s-%s' % (self.user_ctype.pk, self.james.pk),
                    '%s-%s' % (self.user_ctype.pk, self.elton.pk),
                    '%s-%s' % (self.group_ctype.pk, self.bluesmen.pk),
                    '%s-%s' % (self.group_ctype.pk, self.emos.pk),
                ],
                'expected': [
                    self.james,
                    self.bluesmen,
                ],
                'name': 'should ignore values that are not in the querysets',
            },
        )

    def get_choices_for_request_tests(self):
        return (
            {
                'fixture': make_get_request('j'),
                'expected': [
                    self.abe,
                    self.rockers,
                    self.bluesmen,
                ],
            },
            {
                'fixture': make_get_request('q=elton'),
                'expected': [],
                'name': 'should not propose models that are not in the qs',
            },
        )

    def get_validate_tests(self):
        return (
            {
                'fixture': [
                    '%s-%s' % (self.user_ctype.pk, self.james.pk),
                    '%s-%s' % (self.group_ctype.pk, self.bluesmen.pk),
                    '%s-%s' % (self.group_ctype.pk, self.emos.pk),
                ],
                'expected': False,
            },
            {
                'fixture': [
                    '%s-%s' % (self.user_ctype.pk, self.james.pk),
                    '%s-%s' % (self.group_ctype.pk, self.bluesmen.pk),
                ],
                'expected': True,
            },
            {
                'fixture': [],
                'expected': True,
            },
            {
                'fixture': ['bla'],
                'expected': False,
            },
            {
                'fixture': ['123123-123123'],
                'expected': False,
            },
        )

    def get_autocomplete_html_tests(self):
        return []

    def get_widget_tests(self):
        return (
            {
                'form_class': FormMock,
                'fixture': 'x=%s-%s' % (
                    self.group_ctype.pk, self.bluesmen.pk),
                'expected_valid': True,
                'expected_data': self.bluesmen,
            },
            {
                'form_class': FormMock,
                'fixture': 'x=%s-%s' % (
                    self.group_ctype.pk, self.emos.pk),
                'expected_valid': False,
            },
            {
                'form_class': FormMock,
                'fixture': 'x=12343-2',
                'expected_valid': False,
            },
            {
                'form_class': FormMock,
                'fixture': 'x=%s-2' % ContentType.objects.get_for_model(
                    Permission).pk,
                'expected_valid': False,
            },
        )

    def test_default_search_fields(self):
        class MyGeneric(autocomplete_light.AutocompleteGenericBase):
            choices = [Group.objects.all()]
        self.assertEqual(MyGeneric.search_fields, [('name',)])


########NEW FILE########
__FILENAME__ = generic_search_fields
from .case import *

from ..models import Artist, Genre


class AutocompleteModelMock(autocomplete_light.AutocompleteModelBase):
    limit_choices = 2
    choices = Artist.objects.all()
    search_fields = ('^name', '^genre__name')


class AutocompleteSearchFieldsTestCase(AutocompleteTestCase):
    autocomplete_mock = AutocompleteModelMock

    def setUp(self):
        def create(cls, name, genre=None):
            m = cls(name=name)

            if genre is not None:
                m.genre = genre

            m.save()
            return m

        Artist.objects.all().delete()
        Genre.objects.all().delete()

        self.blues = create(Genre, 'Blues')
        self.buddy_guy = create(Artist, 'Buddy Guy', self.blues)
        self.muddy_waters = create(Artist, 'Muddy Watters', self.blues)

    def get_choices_for_request_tests(self):
        return (
            {
                'fixture': make_get_request('q=Blu'),
                'expected': [
                    self.buddy_guy,
                    self.muddy_waters,
                ]
            },
            {
                'fixture': make_get_request('q=ues'),
                'expected': []
            },
            {
                'fixture': make_get_request('q=watters'),
                'expected': []
            },
            {
                'fixture': make_get_request('q=buddy gu'),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=bud'),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'kwargs': {'split_words': True},
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=Mud'),
                'expected': [
                    self.muddy_waters,
                ]
            },
        )

########NEW FILE########
__FILENAME__ = get_add_another_url
import mock

from django import test

import autocomplete_light


try:
    from django.conf.urls import patterns, url
except ImportError:
    # Django < 1.5
    from django.conf.urls.defaults import patterns, url

urlpatterns = patterns('',
    url(r'nokwarg/$', mock.Mock, name='test_nokwarg'),
    url(r'onekwarg/(?P<param>\w+)/$', mock.Mock, name='test_onekwarg'),
)


class GetAddAnotherUrlTestCase(test.TestCase):
    urls = 'autocomplete_light.tests.autocomplete.get_add_another_url'

    def generate_url(self, name, kwargs=None):
        class TestAutocomplete(autocomplete_light.AutocompleteBase):
            add_another_url_name = name
            add_another_url_kwargs = kwargs

        return TestAutocomplete().get_add_another_url()

    def test_no_kwargs(self):
        self.assertEquals(self.generate_url('test_nokwarg'),
                          '/nokwarg/?_popup=1')

    def test_with_kwargs(self):
        self.assertEquals(self.generate_url('test_onekwarg', {'param': 'bar'}),
                          '/onekwarg/bar/?_popup=1')

########NEW FILE########
__FILENAME__ = list
from .case import *


class AutocompleteListMock(autocomplete_light.AutocompleteListBase):
    limit_choices = 2

    choices = (
        'Zero',
        'One',
        'Two',
        'Three',
        'Four',
        'Ten',
    )


class AutocompleteListTestCase(AutocompleteTestCase):
    autocomplete_mock = AutocompleteListMock

    def get_choices_for_values_tests(self):
        tests = (
            {
                'fixture': ['Four', 'Zero'],
            },
        )

        for test in tests:
            test['expected'] = test['fixture']

        return tests

    def get_choices_for_request_tests(self):
        return (
            {
                'fixture': make_get_request('q=t'),
                'expected': [
                    'Ten',
                    'Three',
                ]
            },
            {
                'fixture': make_get_request(),
                'expected': [
                    'Four',
                    'One',
                ]
            }
        )

    def get_validate_tests(self):
        return (
            {
                'fixture': ['One', 'Four'],
                'expected': True,
            },
            {
                'fixture': ['One', 'Hellllllo'],
                'expected': False,
            },
        )

    def get_autocomplete_html_tests(self):
        return (
            {
                'fixture': make_get_request('q=t'),
                'expected': ''.join([
                    '<span data-value="Ten">Ten</span>',
                    '<span data-value="Three">Three</span>',
                ])
            },
            {
                'fixture': make_get_request(),
                'expected': ''.join([
                    '<span data-value="Four">Four</span>',
                    '<span data-value="One">One</span>',
                ])
            },
        )

    def get_widget_tests(self):
        return []

########NEW FILE########
__FILENAME__ = model
from __future__ import unicode_literals

from django.contrib.auth.models import User
from django.utils.encoding import force_text

from .case import *


class AutocompleteModelMock(autocomplete_light.AutocompleteModelBase):
    limit_choices = 2
    choices = User.objects.all()
    search_fields = ('username', 'email')


class FormMock(forms.Form):
    x = forms.ModelChoiceField(queryset=AutocompleteModelMock.choices,
        widget=autocomplete_light.ChoiceWidget(
            autocomplete=AutocompleteModelMock))


class MultipleFormMock(forms.Form):
    x = forms.ModelMultipleChoiceField(queryset=AutocompleteModelMock.choices,
        widget=autocomplete_light.MultipleChoiceWidget(
            autocomplete=AutocompleteModelMock))


class AutocompleteModelTestCase(AutocompleteTestCase):
    autocomplete_mock = AutocompleteModelMock

    def assert_choices_equal(self, result, test):
        self.assertEqual([x.pk for x in result],
                         [x.pk for x in test['expected']])

    def get_choices_for_values_tests(self):
        return (
            {
                'fixture': [1, 4],
                'expected': [
                    self.abe,
                    self.john,
                ]
            },
        )

    def get_choices_for_request_tests(self):
        return (
            {
                'fixture': make_get_request('q=j'),
                'kwargs': {
                    'limit_choices': 5,
                },
                'expected': [
                    self.jack,
                    self.james,
                    self.john,
                ]
            },
            {
                'fixture': make_get_request('q=j'),
                'kwargs': {
                    'order_by': '-username',
                    'limit_choices': 5,
                },
                'expected': [
                    self.john,
                    self.james,
                    self.jack,
                ]
            },
            {
                'fixture': make_get_request('q=j'),
                'kwargs': {
                    'order_by': ('-email', 'username'),
                    'limit_choices': 5,
                },
                'expected': [
                    self.james,
                    self.john,
                    self.jack,
                ]
            },
            {
                'fixture': make_get_request('q=sale'),
                'expected': [
                    self.abe,
                    self.james,
                ]
            },
            {
                'fixture': make_get_request(),
                'expected': [
                    self.abe,
                    self.jack,
                ]
            },
        )

    def get_validate_tests(self):
        return (
            {
                'fixture': [1, 4],
                'expected': True,
            },
            {
                'fixture': [1, 4, 123],
                'expected': False,
            },
        )

    def get_autocomplete_html_tests(self):
        return (
            {
                'fixture': make_get_request('q=j'),
                'expected': ''.join([
                    '<span data-value="%s">%s</span>' % (
                        self.jack.pk, force_text(self.jack)),
                    '<span data-value="%s">%s</span>' % (
                        self.james.pk, force_text(self.james)),
                ])
            },
            {
                'fixture': make_get_request(),
                'expected': ''.join([
                    '<span data-value="%s">%s</span>' % (
                        self.abe.pk, force_text(self.abe)),
                    '<span data-value="%s">%s</span>' % (
                        self.jack.pk, force_text(self.jack)),
                ])
            },
        )

    def get_widget_tests(self):
        return (
            {
                'form_class': FormMock,
                'fixture': 'x=4',
                'expected_valid': True,
                'expected_data': self.john,
            },
            {
                'form_class': FormMock,
                'fixture': 'x=3&x=4',
                'expected_valid': True,
                'expected_data': self.john,
            },
            {
                'fixture': 'x=abc',
                'expected_valid': False,
            },
            {
                'form_class': MultipleFormMock,
                'fixture': 'x=4&x=2',
                'expected_valid': True,
                'expected_data': [self.jack, self.john],
            },
            {
                'fixture': 'x=abc&x=2',
                'expected_valid': False,
            },
        )

########NEW FILE########
__FILENAME__ = search_fields
from .case import *

from ...example_apps.music.models import  Artist, Genre


class AutocompleteModelMock(autocomplete_light.AutocompleteModelBase):
    limit_choices = 2
    choices = Artist.objects.all()
    search_fields = ('name', 'genre__name')


class AutocompleteSearchFieldsTestCase(AutocompleteTestCase):
    autocomplete_mock = AutocompleteModelMock

    def setUp(self):
        def create(cls, name, genre=None):
            m = cls(name=name)

            if genre is not None:
                m.genre = genre

            m.save()
            return m

        Artist.objects.all().delete()
        Genre.objects.all().delete()

        self.blues = create(Genre, 'Blues')
        self.buddy_guy = create(Artist, 'Buddy Guy', self.blues)
        self.muddy_waters = create(Artist, 'Muddy Watters', self.blues)

        # Create some noise, those should not appear in results
        self.rock_n_roll = create(Genre, 'Rock\'n\'roll')
        self.chuck_berry = create(Artist, 'Chuck Berry', self.rock_n_roll)

    def get_choices_for_request_tests(self):
        return (
            # First do some tests on search_fields with a one-word query
            {
                'fixture': make_get_request('q=bud'),
                'kwargs': dict(
                    search_fields=('^name', '^genre__name')
                ),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=ues'),
                'kwargs': dict(
                    search_fields=('^name', '^genre__name')
                ),
                'expected': []
            },
            {
                'fixture': make_get_request('q=watters'),
                'expected': [
                    self.muddy_waters,
                ]
            },
            {
                'fixture': make_get_request('q=watters'),
                'kwargs': dict(
                    search_fields=('^name', '^genre__name')
                ),
                'expected': []
            },
            # Same on a related field
            {
                'fixture': make_get_request('q=Blu'),
                'kwargs': dict(
                    search_fields=('^name', '^genre__name')
                ),
                'expected': [
                    self.buddy_guy,
                    self.muddy_waters,
                ]
            },
            {
                'fixture': make_get_request('q=ues'),
                'expected': [
                    self.buddy_guy,
                    self.muddy_waters,
                ]
            },
            # Now test various split_words options
            {
                'fixture': make_get_request('q=buddy gu'),
                'kwargs': dict(
                    search_fields=('^name', '^genre__name')
                ),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=buddy gu'),
                'kwargs': dict(
                    split_words='or',
                    search_fields=('^name', '^genre__name')
                ),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=buddy gu'),
                'kwargs': dict(
                    split_words=True,
                    search_fields=('^name', '^genre__name')
                ),
                'expected': [
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'kwargs': dict(
                    search_fields=('^name', '^genre__name')
                ),
                'expected': [
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'kwargs': dict(
                    split_words=True,
                    search_fields=('^name', '^genre__name')
                ),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'kwargs': dict(
                    split_words='or',
                    search_fields=('^name', '^genre__name')
                ),
                'expected': [
                    self.buddy_guy,
                    self.muddy_waters,
                ]
            },
        )


class AutocompleteGenericMock(autocomplete_light.AutocompleteGenericBase):
    limit_choices = 6
    choices = (
        Artist.objects.all(),
        Genre.objects.all(),
    )
    search_fields = (
        ('name', 'genre__name'),
        ('name',),
    )


class AutocompleteGenericSearchFieldsTestCase(AutocompleteSearchFieldsTestCase):
    autocomplete_mock = AutocompleteGenericMock

    def get_choices_for_request_tests(self):
        return (
            # First do some tests on search_fields with a one-word query
            {
                'fixture': make_get_request('q=bud'),
                'kwargs': dict(
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=ues'),
                'kwargs': dict(
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                ]
            },
            {
                'fixture': make_get_request('q=ues'),
                'expected': [
                    self.buddy_guy,
                    self.muddy_waters,
                    self.blues,
                ]
            },
            {
                'fixture': make_get_request('q=watters'),
                'expected': [
                    self.muddy_waters,
                ]
            },
            {
                'fixture': make_get_request('q=watters'),
                'kwargs': dict(
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': []
            },
            ## Same on a related field
            {
                'fixture': make_get_request('q=Blu'),
                'kwargs': dict(
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                    self.buddy_guy,
                    self.muddy_waters,
                    self.blues,
                ]
            },
            {
                'fixture': make_get_request('q=ues'),
                'expected': [
                    self.buddy_guy,
                    self.muddy_waters,
                    self.blues,
                ]
            },
            ## Now test various split_words options
            {
                'fixture': make_get_request('q=buddy gu'),
                'kwargs': dict(
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=buddy gu'),
                'kwargs': dict(
                    split_words='or',
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=buddy gu'),
                'kwargs': dict(
                    split_words=True,
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'expected': [
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'kwargs': dict(
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'kwargs': dict(
                    split_words=True,
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                    self.buddy_guy,
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'kwargs': dict(
                    split_words='or',
                    search_fields=(('^name',), ('^name',))
                ),
                'expected': [
                    self.buddy_guy,
                    self.blues,
                ]
            },
            {
                'fixture': make_get_request('q=bud bl'),
                'kwargs': dict(
                    split_words='or',
                    search_fields=(('^name', '^genre__name'), ('^name',))
                ),
                'expected': [
                    self.buddy_guy,
                    self.muddy_waters,
                    self.blues,
                ]
            },
        )

########NEW FILE########
__FILENAME__ = template
from __future__ import unicode_literals

from django.utils.encoding import force_text
from django.template import Template, Context

from .case import *
from ...example_apps.autocomplete_test_case_app.models import User, Group


class AutocompleteMock(autocomplete_light.AutocompleteModelTemplate):
    limit_choices = 2
    choices = User.objects.all()
    search_fields = ('username', 'email')

    choice_template = '<li data-value="{{ choice.pk }}">{{ choice }}</li>'
    autocomplete_template = ''.join([
        '{% load autocomplete_light_tags %}',
        '<ul>',
        '{% for choice in choices %}',
        '{{ choice|autocomplete_light_choice_html:autocomplete }}',
        '{% endfor %}',
        '</ul>',
    ])

    def render_template_context(self, template, extra_context=None):
        context = self.get_base_context()
        context.update(extra_context or {})

        template = Template(template)
        return template.render(Context(context))


class AutocompleteModelTemplateTestCase(AutocompleteTestCase):
    autocomplete_mock = AutocompleteMock

    def setUp(self):
        User.objects.all().delete()
        self.abe = User(username='Abe', email='sales@example.com')
        self.jack = User(username='Jack', email='jack@example.com')
        self.james = User(username='James', email='sales@example.com')
        self.john = User(username='John', email='sales@example.com')

        self.abe.save()
        self.jack.save()
        self.james.save()
        self.john.save()

    def get_choices_for_values_tests(self):
        return []

    def get_choices_for_request_tests(self):
        return []

    def get_validate_tests(self):
        return []

    def get_autocomplete_html_tests(self):
        return (
            {
                'fixture': make_get_request('q=j'),
                'expected': ''.join([
                    '<ul>',
                    '<li data-value="%s">%s</li>' % (
                        self.jack.pk, force_text(self.jack)),
                    '<li data-value="%s">%s</li>' % (
                        self.james.pk, force_text(self.james)),
                    '</ul>',
                ])
            },
            {
                'fixture': make_get_request(),
                'expected': ''.join([
                    '<ul>',
                    '<li data-value="%s">%s</li>' % (
                        self.abe.pk, force_text(self.abe)),
                    '<li data-value="%s">%s</li>' % (
                        self.jack.pk, force_text(self.jack)),
                    '</ul>',
                ])
            },
        )

    def get_widget_tests(self):
        return []

########NEW FILE########
__FILENAME__ = dependent
from __future__ import unicode_literals

from .widget import WidgetTestCase


class DependentAutocompleteTestCase(WidgetTestCase):
    fixtures = ['dependent_autocomplete_test_case.json', 'initial_data.json']


class DependentAutocompleteEmptyFormTestCase(DependentAutocompleteTestCase):
    autocomplete_name = 'region'

    def setup_test_case(self):
        pass

    def select_usa(self):
        self.send_keys('united states', 'country')
        self.hilighted_choice('country').click()

    def select_france(self):
        self.send_keys('fra', 'country')
        self.hilighted_choice('country').click()

    def setUp(self):
        super(DependentAutocompleteEmptyFormTestCase, self).setUp()

        self.login()
        self.open_url('/admin/dependant_autocomplete/dummy/add/')
        self.select_france()
        self.input().clear()

    def test_texas_not_in_france(self):
        self.send_keys('tex')
        self.assertAutocompleteEmpty()

    def test_alpes_in_france(self):
        self.send_keys('alp')
        self.assertTrue(len(self.autocomplete_choices()) == 2)

    def test_change_to_different_country_after_region_select(self):
        pass

    def test_change_to_same_country_after_region_select(self):
        pass

########NEW FILE########
__FILENAME__ = exceptions
from django.test import TestCase
from django.conf.urls import patterns

import autocomplete_light

no_urls = patterns('', )


class AutocompleteListMock(autocomplete_light.AutocompleteListBase):
    choices = ('a', 'b', 'c')


class AutocompleteNotRegisteredTestCase(TestCase):
    def test_no_url_empty_registry(self):
        exception = autocomplete_light.AutocompleteNotRegistered(
                'NotRegistered', autocomplete_light.AutocompleteRegistry())
        self.assertEqual(str(exception),
                'NotRegistered not registered (registry is empty)')

    def test_no_url_non_empty_registry(self):
        registry = autocomplete_light.AutocompleteRegistry()
        registry.register(AutocompleteListMock)
        exception = autocomplete_light.AutocompleteNotRegistered(
                'NotRegistered', registry)
        self.assertEqual(str(exception),
                "NotRegistered not registered, you have registered: ['AutocompleteListMock']")

########NEW FILE########
__FILENAME__ = fields
from __future__ import unicode_literals

from django.test import TestCase
from django import forms
from django.contrib.contenttypes.models import ContentType

import autocomplete_light

from ..example_apps.security_test.models import Item
from ..example_apps.basic.models import GfkModel


class BaseTestCase(TestCase):
    GOOD_VALUE = 'b'
    CLEANED_VALUE = 'b'
    BAD_VALUE = 'xx'

    class TestAutocomplete(autocomplete_light.AutocompleteListBase):
        choices = ['a', 'b', 'c']

    def test_automatic_field_choices(self):
        test = self.field_class(self.TestAutocomplete)
        self.assertEqual(test.choices, [('a', 'a'), ('b', 'b'), ('c', 'c')])

    def test_validate(self):
        test = self.field_class(self.TestAutocomplete)
        test.validate(self.GOOD_VALUE)

        with self.assertRaises(forms.ValidationError):
            test.validate(self.BAD_VALUE)

    def test_select_choice(self):
        class TestForm(forms.Form):
            test_field = self.field_class(self.TestAutocomplete)

        form = TestForm({'test_field': self.GOOD_VALUE})
        self.assertTrue(form.is_valid())
        self.assertEqual(form.cleaned_data['test_field'], self.CLEANED_VALUE)


class ChoiceFieldTestCase(BaseTestCase):
    field_class = autocomplete_light.ChoiceField


class MultipleChoiceFieldTestCase(BaseTestCase):
    field_class = autocomplete_light.MultipleChoiceField
    GOOD_VALUE = ['b']
    CLEANED_VALUE = ['b']


class ModelChoiceFieldTestCase(BaseTestCase):
    fixtures = ['security_test.json']
    field_class = autocomplete_light.ModelChoiceField
    GOOD_VALUE = 1
    BAD_VALUE = 2

    def setUp(self):
        self.CLEANED_VALUE = Item.objects.get(pk=self.GOOD_VALUE)

    class TestAutocomplete(autocomplete_light.AutocompleteModelBase):
        choices = Item.objects.filter(private=False)

    def test_automatic_field_choices(self):
        test = self.field_class(self.TestAutocomplete, required=True)
        self.assertEqual(list(test.choices),
                         [('', '---------'), (1, 'public'), (3, 'linked')])


class ModelMultipleChoiceFieldTestCase(ModelChoiceFieldTestCase):
    field_class = autocomplete_light.ModelMultipleChoiceField
    GOOD_VALUE = [1]
    BAD_VALUE = [2]

    def setUp(self):
        self.CLEANED_VALUE = Item.objects.filter(pk=1)

    def test_automatic_field_choices(self):
        test = self.field_class(self.TestAutocomplete, required=True)
        self.assertEqual(list(test.choices),
                         [(1, 'public'), (3, 'linked')])

    def test_select_choice(self):
        class TestForm(forms.Form):
            test_field = self.field_class(self.TestAutocomplete)

        form = TestForm({'test_field': self.GOOD_VALUE})
        self.assertTrue(form.is_valid())
        self.assertEqual(len(form.cleaned_data['test_field']),
                         len(self.CLEANED_VALUE))
        self.assertEqual(form.cleaned_data['test_field'][0],
                         self.CLEANED_VALUE[0])


class GenericModelChoiceFieldTestCase(BaseTestCase):
    field_class = autocomplete_light.GenericModelChoiceField
    fixtures = ['basic_gfk_gmtm.json']

    class TestAutocomplete(autocomplete_light.AutocompleteGenericBase):
        choices = [GfkModel.objects.all()]

    def setUp(self):
        self.gfk_ct = ContentType.objects.get_for_model(GfkModel)
        self.GOOD_VALUE = '%s-%s' % (self.gfk_ct.pk, 1)
        self.BAD_VALUE = '%s-%s' % (self.gfk_ct.pk, 1234)
        self.CLEANED_VALUE = GfkModel.objects.get(pk=1)

    def test_automatic_field_choices(self):
        pass  # generic model choice field has no choices



class GenericModelMultipleChoiceFieldTestCase(GenericModelChoiceFieldTestCase):
    field_class = autocomplete_light.GenericModelMultipleChoiceField

    def setUp(self):
        self.gfk_ct = ContentType.objects.get_for_model(GfkModel)
        self.GOOD_VALUE = ['%s-%s' % (self.gfk_ct.pk, 1)]
        self.BAD_VALUE = ['%s-%s' % (self.gfk_ct.pk, 1234)]
        self.CLEANED_VALUE = [GfkModel.objects.get(pk=1)]

    def test_automatic_field_choices(self):
        pass  # generic model choice field has no choices

########NEW FILE########
__FILENAME__ = forms
import unittest
import autocomplete_light

autocomplete_light.autodiscover()

import lxml.html

from django import VERSION
from django import http
from django import forms
from django.utils import translation
from django.utils.encoding import force_text
from django.contrib.contenttypes.models import ContentType
from django.forms.models import modelform_factory

import autocomplete_light

from ..example_apps.basic.admin import *
from ..example_apps.basic.models import *
from ..example_apps.basic.forms import *


class SelectMultipleHelpTextRemovalMixinTestCase(unittest.TestCase):
    def test_help_text_removed(self):
        class ModelForm(forms.ModelForm):
            class Meta(DjangoCompatMeta):
                model = MtmModel
        form = ModelForm()
        help_text = force_text(form.fields['relation'].help_text).strip()

        class ModelForm(autocomplete_light.ModelForm):
            class Meta(DjangoCompatMeta):
                model = MtmModel
        form = ModelForm()
        my_help_text = force_text(form.fields['relation'].help_text).strip()

        self.assertNotIn(help_text, my_help_text)


class SelectMultipleHelpTextRemovalMixinFrTestCase(
        SelectMultipleHelpTextRemovalMixinTestCase):

    def setUp(self):
        translation.activate('fr_FR')


class BaseModelFormTestCase(unittest.TestCase):
    def setUp(self):
        self.james = self.model_class.objects.create(name='James')
        self.janis = self.model_class.objects.create(name='Janis')
        self.test_instance = self.james

    def tearDown(self):
        self.model_class.objects.all().delete()


class ModelFormBaseTestCase(BaseModelFormTestCase):
    widget_class = autocomplete_light.ChoiceWidget

    def get_new_autocomplete_class(self):
        class SpecialAutocomplete(autocomplete_light.AutocompleteModelBase):
            model = self.model_class
        return SpecialAutocomplete

    def form_value(self, model):
        return 'relation=%s' % model.pk

    def field_value(self, model):
        return getattr(model, 'relation')

    def assertExpectedFormField(self, name='relation'):
        self.assertInForm(name)

        if self.__class__.__name__ != 'TaggitModelFormTestCase':
            # django-taggit enforces verbose_name=_('Tags')
            # bug reported at:
            # https://github.com/alex/django-taggit/issues/177
            self.assertEqual(force_text(self.form[name].label), name.capitalize())

        self.assertTrue(isinstance(self.form.fields[name],
            self.field_class))
        self.assertTrue(isinstance(self.form.fields[name].widget,
            self.widget_class))
        self.assertEqual(self.form.fields[name].autocomplete.__name__,
                self.autocomplete_name)

    def assertInForm(self, name):
        self.assertIn(name, self.form.fields)

    def assertNotInForm(self, name):
        self.assertNotIn(name, self.form.fields)

    def assertIsAutocomplete(self, name):
        self.assertIsInstance(self.form.fields[name],
                autocomplete_light.FieldBase)

    def assertNotIsAutocomplete(self, name):
        self.assertNotIsInstance(self.form.fields[name],
                autocomplete_light.FieldBase)

    def test_appropriate_field_on_modelform(self):
        self.form = self.model_form_class()

        self.assertExpectedFormField()
        self.assertIsAutocomplete('noise')

    def test_appropriate_field_with_modelformfactory(self):
        form_class = modelform_factory(self.model_class,
                form=self.model_form_class)
        self.form = form_class()

        self.assertExpectedFormField()
        self.assertIsAutocomplete('noise')

    @unittest.skipUnless(VERSION >= (1, 6), 'Django >= 1.6')
    def test_appropriate_field_on_modelform_with_all(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta:
                model = self.model_class
                fields = '__all__'
        self.form = ModelForm()

        self.assertExpectedFormField()
        self.assertIsAutocomplete('noise')

    def test_appropriate_field_on_modelform_with_formfield_callback(self):
        # This tests what django admin does
        def cb(f, **kwargs):
            return f.formfield(**kwargs)

        form_class = modelform_factory(self.model_class,
                form=self.model_form_class, formfield_callback=cb)
        self.form = form_class()

        self.assertExpectedFormField()
        self.assertIsAutocomplete('noise')
        self.assertInForm('name')

    def test_widget_override(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta(DjangoCompatMeta):
                model = self.model_class
                widgets = {'relation': self.widget_class(widget_attrs={
                    'class': 'test-class', 'data-foo': 'bar'})}

        self.form = ModelForm()

        et = lxml.html.fromstring(self.form.as_p())
        attrib = et.cssselect('.autocomplete-light-widget.relation')[0].attrib
        self.assertEquals(attrib['data-foo'], 'bar')
        self.assertIn('test-class', attrib['class'])

    def test_meta_exclude_name(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta:
                model = self.model_class
                exclude = ('name',)

        self.form = ModelForm()

        self.assertExpectedFormField()
        self.assertNotInForm('name')
        self.assertIsAutocomplete('noise')

    def test_meta_exclude_relation(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta:
                model = self.model_class
                exclude = ['relation']

        self.form = ModelForm()

        self.assertInForm('name')
        self.assertIsAutocomplete('noise')
        self.assertNotInForm('relation')

    def test_meta_fields_name(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta:
                model = self.model_class
                fields = ['name']

        self.form = ModelForm()

        self.assertInForm('name')
        self.assertNotInForm('noise')
        self.assertNotInForm('relation')

    def test_meta_fields_relation(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta:
                model = self.model_class
                fields = ['relation']

        self.form = ModelForm()

        self.assertExpectedFormField()
        self.assertNotInForm('name')
        self.assertNotInForm('noise')

    def test_meta_autocomplete_fields(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta(DjangoCompatMeta):
                model = self.model_class
                autocomplete_fields = ['relation']

        self.form = ModelForm()

        self.assertExpectedFormField()
        self.assertNotIsAutocomplete('noise')
        self.assertInForm('name')

    def test_meta_autocomplete_exclude(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta(DjangoCompatMeta):
                model = self.model_class
                autocomplete_exclude = ['relation']

        self.form = ModelForm()

        self.assertInForm('name')
        self.assertNotIsAutocomplete('relation')
        self.assertIsAutocomplete('noise')

    def test_meta_autocomplete_names(self):
        SpecialAutocomplete = self.get_new_autocomplete_class()
        autocomplete_light.registry.register(SpecialAutocomplete)

        class ModelForm(autocomplete_light.ModelForm):
            class Meta(DjangoCompatMeta):
                model = self.model_class
                autocomplete_names = {
                    'relation': 'SpecialAutocomplete'
                }

        self.form = ModelForm()

        self.assertInForm('name')
        self.assertIsAutocomplete('relation')
        self.assertIsAutocomplete('noise')

        self.assertTrue(issubclass(self.form.fields['relation'].autocomplete,
                                   SpecialAutocomplete))

    def test_modelform_factory(self):
        self.form = autocomplete_light.modelform_factory(self.model_class)()

        self.assertExpectedFormField()

    def test_modelform_factory_fields_relation(self):
        self.form = autocomplete_light.modelform_factory(self.model_class,
                fields=['relation'])()

        self.assertExpectedFormField()
        self.assertNotInForm('name')
        self.assertNotInForm('noise')

    def test_modelform_factory_exclude_relation(self):
        self.form = autocomplete_light.modelform_factory(self.model_class,
                exclude=['relation'])()

        self.assertNotInForm('relation')
        self.assertInForm('name')
        self.assertIsAutocomplete('noise')

    def test_modelform_factory_autocomplete_fields_relation(self):
        if VERSION < (1, 7):
            fields = None
        else:
            fields = '__all__'

        self.form = autocomplete_light.modelform_factory(self.model_class,
                autocomplete_fields=['relation'], fields=fields)()

        self.assertExpectedFormField()
        self.assertNotIsAutocomplete('noise')
        self.assertInForm('name')

    def test_modelform_factory_autocomplete_exclude_relation(self):
        self.form = autocomplete_light.modelform_factory(self.model_class,
                autocomplete_exclude=['relation'])()

        self.assertNotIsAutocomplete('relation')
        self.assertInForm('name')
        self.assertIsAutocomplete('noise')

    def test_modelform_factory_fields_name(self):
        self.form = autocomplete_light.modelform_factory(self.model_class,
                fields=['name'])()

        self.assertInForm('name')
        self.assertNotInForm('relation')
        self.assertNotInForm('noise')

    def test_modelform_factory_exclude_name(self):
        self.form = autocomplete_light.modelform_factory(self.model_class,
                exclude=['name'])()

        self.assertNotInForm('name')
        self.assertExpectedFormField()
        self.assertIsAutocomplete('noise')

    def test_modelform_factory_autocomplete_names(self):
        SpecialAutocomplete = self.get_new_autocomplete_class()
        autocomplete_light.registry.register(SpecialAutocomplete)

        ModelForm = autocomplete_light.modelform_factory(self.model_class,
            autocomplete_names={'relation': 'SpecialAutocomplete'})

        self.form = ModelForm()

        self.assertInForm('name')
        self.assertIsAutocomplete('relation')
        self.assertIsAutocomplete('noise')

        self.assertTrue(issubclass(self.form.fields['relation'].autocomplete,
                                   SpecialAutocomplete))

    def test_empty_registry(self):
        registry = autocomplete_light.AutocompleteRegistry()

        class ModelForm(autocomplete_light.ModelForm):
            relation = self.field_class(registry=registry,
                autocomplete=registry.register(self.model_class))
            relation2 = self.field_class(registry=registry,
                autocomplete=registry.register(self.model_class))

            class Meta(DjangoCompatMeta):
                model = self.model_class

        self.form = ModelForm()

        self.assertExpectedFormField()
        self.assertExpectedFormField('relation2')

    def test_create_with_relation(self):
        form = self.model_form_class(http.QueryDict(
            'name=test&%s' % self.form_value(self.janis)))

        self.assertTrue(form.is_valid())

        result = form.save()
        self.assertEqual(self.field_value(result), self.janis)

    def test_add_relation(self):
        form = self.model_form_class(http.QueryDict(
            'name=test&%s' % self.form_value(self.janis)),
            instance=self.test_instance)

        self.assertTrue(form.is_valid())

        result = form.save()
        self.assertEqual(self.field_value(result), self.janis)


class GenericModelFormTestCaseMixin(object):
    autocomplete_name = 'A'


    def get_new_autocomplete_class(self):
        class SpecialAutocomplete(autocomplete_light.AutocompleteGenericBase):
            choices = autocomplete_light.registry[self.autocomplete_name].choices
            search_fields = autocomplete_light.registry[self.autocomplete_name].search_fields
        return SpecialAutocomplete

    def test_meta_autocomplete_exclude(self):
        class ModelForm(autocomplete_light.ModelForm):
            class Meta(DjangoCompatMeta):
                model = self.model_class
                autocomplete_exclude = ['relation']

        self.form = ModelForm()

        self.assertNotInForm('relation')
        self.assertInForm('name')
        self.assertIsAutocomplete('noise')

    def test_modelform_factory_autocomplete_exclude_relation(self):
        self.form = autocomplete_light.modelform_factory(self.model_class,
                autocomplete_exclude=['relation'])()

        self.assertNotInForm('relation')
        self.assertInForm('name')
        self.assertIsAutocomplete('noise')

    def test_empty_registry(self):
        registry = autocomplete_light.AutocompleteRegistry()

        class ModelForm(autocomplete_light.ModelForm):
            relation = self.field_class(registry=registry,
                autocomplete=registry.register(autocomplete_light.AutocompleteGenericBase,
                    choices=[self.model_class.objects.all()],
                    search_fields=['name']))

            class Meta(DjangoCompatMeta):
                model = self.model_class

        self.form = ModelForm()

        self.assertExpectedFormField()
        self.assertInForm('name')
        self.assertIsAutocomplete('noise')

    def form_value(self, model):
        return 'relation=%s-%s' % (ContentType.objects.get_for_model(model).pk, model.pk)


class MultipleRelationTestCaseMixin(ModelFormBaseTestCase):
    widget_class = autocomplete_light.MultipleChoiceWidget

    def field_value(self, model):
        return super(MultipleRelationTestCaseMixin, self).field_value(model).all()[0]


class FkModelFormTestCase(ModelFormBaseTestCase):
    model_class = FkModel
    model_form_class = FkModelForm
    field_class = autocomplete_light.ModelChoiceField
    autocomplete_name = 'FkModelAutocomplete'


class OtoModelFormTestCase(ModelFormBaseTestCase):
    model_class = OtoModel
    model_form_class = OtoModelForm
    field_class = autocomplete_light.ModelChoiceField
    autocomplete_name = 'OtoModelAutocomplete'


class GfkModelFormTestCase(GenericModelFormTestCaseMixin,
        ModelFormBaseTestCase):
    model_class = GfkModel
    model_form_class = GfkModelForm
    field_class = autocomplete_light.GenericModelChoiceField


class MtmModelFormTestCase(MultipleRelationTestCaseMixin, ModelFormBaseTestCase):
    model_class = MtmModel
    model_form_class = MtmModelForm
    field_class = autocomplete_light.ModelMultipleChoiceField
    autocomplete_name = 'MtmModelAutocomplete'


try:
    from taggit.models import Tag
except ImportError:
    class TaggitModelFormTestCase(object):
        pass
else:
    class TaggitModelFormTestCase(ModelFormBaseTestCase):
        model_class = TaggitModel
        model_form_class = TaggitModelForm
        field_class = autocomplete_light.TaggitField
        widget_class = autocomplete_light.TaggitWidget
        autocomplete_name = 'TagAutocomplete'

        def setUp(self):
            self.james = 'james'
            self.janis = 'janis'
            self.test_instance = self.model_class.objects.create(name='test')

        def form_value(self, model):
            return 'relation=%s' % model

        def field_value(self, model):
            return model.relation.all().values_list('name', flat=True)[0]

        def test_empty_registry(self):
            pass

        def test_widget_override(self):
            class ModelForm(autocomplete_light.ModelForm):
                class Meta(DjangoCompatMeta):
                    model = self.model_class
                    widgets = {'relation': self.widget_class(attrs={
                        'class': 'test-class', 'data-foo': 'bar'})}

            self.form = ModelForm()

            et = lxml.html.fromstring(self.form.as_p())
            attrib = et.cssselect('input[name=relation].autocomplete')[0].attrib
            self.assertEquals(attrib['data-foo'], 'bar')
            self.assertIn('test-class', attrib['class'])

try:
    import genericm2m
except ImportError:
    class GmtmModelFormTestCase(object):
        pass
else:
    class GmtmModelFormTestCase(MultipleRelationTestCaseMixin,
            GenericModelFormTestCaseMixin,
            ModelFormBaseTestCase):
        model_class = GmtmModel
        model_form_class = GmtmModelForm
        field_class = autocomplete_light.GenericModelMultipleChoiceField

        def field_value(self, model):
            return getattr(model, 'relation').all().generic_objects()[0]

########NEW FILE########
__FILENAME__ = generic
from __future__ import unicode_literals

import unittest

from django.test import TransactionTestCase
from django.contrib.contenttypes.models import ContentType

from cities_light.models import Country, City

from gfk_autocomplete.forms import TaggedItemForm
from optionnal_gfk_autocomplete.forms import OptionnalTaggedItemForm

import autocomplete_light


class GenericModelFormTestCase(unittest.TestCase):
    def setUp(self):
        self.country, c = Country.objects.get_or_create(name='Countryname')
        self.city, c = City.objects.get_or_create(country=self.country,
            name='Paris')

    def tearDown(self):
        self.country.delete()
        self.city.delete()

    def test_model_form(self):
        tests = (
            {
                'content_object': self.city,
                'tag': 'foo',
                'valid': True,
                'form_class': TaggedItemForm,
            },
            {
                'tag': 'bar',
                'valid': False,
                'form_class': TaggedItemForm,
            },
            {
                'content_object': self.city,
                'tag': 'foo',
                'valid': True,
                'form_class': OptionnalTaggedItemForm,
            },
            {
                'tag': 'bar',
                'valid': True,
                'form_class': OptionnalTaggedItemForm,
            },
        )

        for test in tests:
            if 'data' not in test.keys():
                test['data'] = {'tag': test.get('tag', None)}

                if 'content_object' in test.keys():
                    test['data']['content_object'] = '%s-%s' % (
                        ContentType.objects.get_for_model(test['content_object']).pk,
                        test['content_object'].pk)

            form = test['form_class'](test['data'])
            self.assertEqual(form.is_valid(), test['valid'])
            if test['valid']:
                result = form.save()
                self.assertEqual(test['tag'], result.tag)

                if 'content_object' in test.keys():
                    self.assertEqual(test['content_object'],
                        result.content_object)

########NEW FILE########
__FILENAME__ = generic_m2m
from autocomplete.case import *
from autocomplete.generic import AutocompleteGenericMock, AutocompleteGenericTestCase

import django
from django import http
from django.contrib.contenttypes.models import ContentType
from django.contrib.auth.models import User, Group, Permission

from autocomplete_light.contrib.generic_m2m import GenericModelForm, \
    GenericModelMultipleChoiceField

from generic_m2m_autocomplete.models import ModelGroup


class FormMock(GenericModelForm):
    related = GenericModelMultipleChoiceField(
        widget=autocomplete_light.MultipleChoiceWidget(
            AutocompleteGenericMock))

    class Meta:
        model = ModelGroup

        if django.VERSION < (1, 7):
            fields = '__all__'


class AutocompleteGenericM2MTestCase(AutocompleteTestCase):
    autocomplete_mock = AutocompleteGenericMock

    def setUp(self):
        self.setUpAuth()

    def test_form(self):
        tests = (
            {
                'fixture': 'name=foo&related=%s-%s' % (
                    self.group_ctype.pk, self.bluesmen.pk),
                'valid': True,
                'result': [self.bluesmen],
            },
            {
                'fixture': 'name=foo&related=%s-%s&related=%s-%s' % (
                    self.group_ctype.pk, self.rockers.pk,
                    self.user_ctype.pk, self.james.pk),
                'valid': True,
                'result': [self.james, self.rockers],
            },
        )

        instance = None
        for test in tests:
            form = FormMock(http.QueryDict(test['fixture']),
                instance=instance)

            self.assertEqual(form.is_valid(), test['valid'])
            instance = form.save()

            self.assertEqual(instance.related.all().generic_objects(),
                test['result'])

########NEW FILE########
__FILENAME__ = registry
import unittest

from django.contrib.auth.models import User
from django.db import models

import autocomplete_light


class Noname(models.Model):
    number = models.CharField(max_length=100)


class Foo(models.Model):
    name = models.CharField(max_length=100)


class Bar(autocomplete_light.AutocompleteModelBase):
    pass


class Generic(autocomplete_light.AutocompleteGenericBase):
    choices = (
        User.objects.all(),
    )
    search_fields = (
        ('username',),
    )


class RegistryTestCase(unittest.TestCase):
    def setUp(self):
        self.registry = autocomplete_light.AutocompleteRegistry()

    def test_register_model(self):
        self.registry.register(Foo)
        self.assertIn('FooAutocomplete', self.registry.keys())

    def test_register_model_and_autocomplete(self):
        self.registry.register(Foo, Bar)
        self.assertIn('FooBar', self.registry.keys())

    def test_register_autocomplete(self):
        self.registry.register(Bar)
        self.assertIn('Bar', self.registry.keys())

    def test_unregister(self):
        self.registry.register(Bar)
        self.registry.unregister('Bar')
        self.assertEqual(list(self.registry.keys()), [])

    def test_register_with_kwargs(self):
        choices = ['foo']
        self.registry.register(Foo, search_name='search_name', choices=choices)
        self.assertEqual(self.registry['FooAutocomplete'].search_name,
            'search_name')
        self.assertEqual(self.registry['FooAutocomplete'].choices, choices)

    def test_register_with_custom_autocomplete_model_base(self):
        class NewBase(autocomplete_light.AutocompleteModelBase):
            new_base = True

        self.registry.autocomplete_model_base = NewBase
        self.registry.register(Foo)
        self.assertEqual(NewBase, self.registry['FooAutocomplete'].__base__)
        self.assertTrue(self.registry['FooAutocomplete'].new_base)

    def test_register_with_autocomplete_and_kwargs(self):
        self.registry.register(Foo, Bar, search_name='search_name')
        self.assertEqual(self.registry['FooBar'].search_name,
            'search_name')

    def test_register_with_custom_name(self):
        self.registry.register(Foo, Bar, name='BarFoo')
        self.assertIn('BarFoo', self.registry.keys())
        self.assertEqual(self.registry['BarFoo'].__name__, 'BarFoo')

    def test_register_no_name_fail(self):
        try:
            self.registry.register(Noname)
            self.fail('Should raise an exception when registering noname')
        except:
            pass

    def test_register_no_name_pass(self):
        self.registry.register(Noname, search_fields=('number',))

    def test_register_generic_with_custom_name(self):
        self.registry.register(Generic, name='foo')
        self.assertTrue('foo' in self.registry.keys())

    def test_raise_AutocompleteNotRegistered(self):
        try:
            self.registry['NotRegistered']
            self.fail('Should raise AutocompleteNotRegistered')
        except autocomplete_light.AutocompleteNotRegistered:
            pass

    def test_raise_NoGenericAutocompleteRegistered(self):
        self.assertRaises(autocomplete_light.NoGenericAutocompleteRegistered,
                          self.registry.autocomplete_for_generic)

    def test_autocomplete_for_model(self):
        class FirstAutocomplete(autocomplete_light.AutocompleteModelBase):
            pass

        class SecondAutocomplete(autocomplete_light.AutocompleteModelBase):
            pass

        self.registry.register(Foo, FirstAutocomplete)
        self.registry.register(Foo, SecondAutocomplete)

        self.assertTrue(issubclass(
            self.registry.autocomplete_for_model(Foo), FirstAutocomplete))

    def test_autocomplete_for_generic(self):
        class FirstAutocomplete(Generic):
            pass

        class SecondAutocomplete(Generic):
            pass

        self.registry.register(FirstAutocomplete)
        self.registry.register(SecondAutocomplete)

        self.assertTrue(issubclass(
            self.registry.autocomplete_for_generic(), FirstAutocomplete))


class RegistryGetAutocompleteFromArgTestCase(unittest.TestCase):
    def setUp(self):
        self.registry = autocomplete_light.AutocompleteRegistry()
        self.registry.register(Foo)
        self.registry.register(Generic)

    def test_from_string(self):
        a = self.registry.get_autocomplete_from_arg('FooAutocomplete')
        self.assertEqual(a.model, Foo)

    def test_from_model(self):
        a = self.registry.get_autocomplete_from_arg(Foo)
        self.assertEqual(a.model, Foo)

    def test_from_model_instance(self):
        a = self.registry.get_autocomplete_from_arg(Foo())
        self.assertEqual(a.model, Foo)

    def test_from_autocomplete_instance(self):
        a = self.registry.get_autocomplete_from_arg(Generic)
        self.assertEqual(a, Generic)

    def test_default_generic(self):
        a = self.registry.get_autocomplete_from_arg()
        self.assertTrue(issubclass(a, Generic))

########NEW FILE########
__FILENAME__ = templatetags
from __future__ import unicode_literals

import unittest
from collections import OrderedDict

from autocomplete_light.templatetags.autocomplete_light_tags import *


class DataAttributesTestCase(unittest.TestCase):
    def test_without_prefix(self):
        tests = (
            {
                'fixture': {
                    'foo': 'bar',
                },
                'expected': 'data-foo="bar"',
            },
            {
                'fixture': OrderedDict([
                    ('foo', 'bar'),
                    ('test_underscore', 'example'),
                ]),
                'expected': 'data-foo="bar" data-test-underscore="example"',
            },
            {
                'fixture': {
                    'foo': 'bar',
                },
                'prefix': 'autocomplete-',
                'expected': 'data-autocomplete-foo="bar"',
            },
        )

        for test in tests:
            result = autocomplete_light_data_attributes(test['fixture'],
                test.get('prefix', ''))
            self.assertEqual(result, test['expected'],
                'Got %s for %s' % (result, test))

########NEW FILE########
__FILENAME__ = views
from __future__ import unicode_literals

import unittest
import six

try:
    from unittest.mock import Mock, MagicMock, patch
except ImportError:  # python2
    from mock import Mock, MagicMock, patch

from django.utils.encoding import force_text
from django import forms
from django import http
from django.test import RequestFactory
from django.core.urlresolvers import reverse
from django.test import Client
try:
    from django.contrib.auth import get_user_model
except ImportError:
    # Django 1.4
    from django.contrib.auth.models import User
else:
    User = get_user_model()

import autocomplete_light


class RegistryViewTestCase(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        u = User.objects.create(is_staff=True, username='u', is_active=True)
        u.set_password('p')
        u.save()

        u = User.objects.create(is_staff=True, username='su', is_active=True,
                is_superuser=True)
        u.set_password('p')
        u.save()

    @classmethod
    def tearDownClass(cls):
        User.objects.all().delete()

    def setUp(self):
        self.admin = Client()
        self.admin.login(username='u', password='p')

        self.superuser = Client()
        self.superuser.login(username='su', password='p')

        self.anonymous = Client()

        self.old_registry = autocomplete_light.registry
        autocomplete_light.registry = autocomplete_light.AutocompleteRegistry()

    def tearDown(self):
        autocomplete_light.registry = self.old_registry

    def test_requires_superuser(self):
        response = self.anonymous.get(reverse('autocomplete_light_registry'))
        self.assertEqual(response.status_code, 403)

        response = self.admin.get(reverse('autocomplete_light_registry'))
        self.assertEqual(response.status_code, 403)

        response = self.superuser.get(reverse('autocomplete_light_registry'))
        self.assertEqual(response.status_code, 200)

    def test_get_context_data(self):
        response = self.superuser.get(reverse('autocomplete_light_registry'))

        self.assertEqual(response.context['registry'],
                autocomplete_light.registry)
        self.assertEqual(response.context['registry_items'],
                autocomplete_light.registry.items())

    def test_output(self):
        autocomplete_light.registry.register(User)

        response = self.superuser.get(reverse('autocomplete_light_registry'))

        self.assertIn('List of your 1 registered autocompletes', force_text(response.content))
        self.assertIn(reverse('autocomplete_light_autocomplete',
            args=['UserAutocomplete']), force_text(response.content))


class AutocompleteViewTestCase(unittest.TestCase):
    def test_404(self):
        c = Client()
        response = c.get(reverse('autocomplete_light_autocomplete',
            args=['Foo']))
        self.assertEqual(response.status_code, 404)

    def test_get(self):
        self.old_registry = autocomplete_light.registry

        autocomplete_light.registry = MagicMock()
        autocomplete_light.registry.__getitem__.return_value.return_value.autocomplete_html.return_value = 'foo'

        request = RequestFactory().get(
            reverse('autocomplete_light_autocomplete', args=['UserAutocomplete']))

        response = autocomplete_light.AutocompleteView.as_view()(request,
            autocomplete='UserAutocomplete')

        autocomplete_light.registry.__getitem__.assert_called_with('UserAutocomplete')
        autocomplete_light.registry.__getitem__.return_value.assert_called_with(request=request)
        autocomplete_light.registry.__getitem__.return_value.return_value.autocomplete_html.assert_called_with()

        self.assertIn('foo', force_text(response.content))

        autocomplete_light.registry = self.old_registry

    def test_post(self):
        self.old_registry = autocomplete_light.registry
        autocomplete_light.registry = MagicMock()

        request = RequestFactory().post(
            reverse('autocomplete_light_autocomplete', args=['UserAutocomplete']))

        response = autocomplete_light.AutocompleteView.as_view()(request,
            autocomplete='UserAutocomplete')

        autocomplete_light.registry.__getitem__.assert_called_with('UserAutocomplete')
        autocomplete_light.registry.__getitem__.return_value.assert_called_with()

        autocomplete_light.registry.__getitem__.return_value.return_value.post.assert_called_with(request,
                autocomplete='UserAutocomplete')

        autocomplete_light.registry = self.old_registry


class CreateViewTestCase(unittest.TestCase):
    def test_respond_script(self):
        view = autocomplete_light.CreateView()
        class FakeModel(object):
            pk = 5
            def __str__(self):
                return 'abc "yoo"'

        view.object = FakeModel()
        output = view.respond_script()
        expected = '''
        <script type="text/javascript">opener.dismissAddAnotherPopup( window, "5", "abc \\"yoo\\"" );</script>
        '''
        self.assertEqual(force_text(expected.strip()),
                force_text(output.content.strip()))
        self.assertEqual(output.status_code, 201)

    def test_is_popup(self):
        view = autocomplete_light.CreateView()

        request = RequestFactory().get(
            reverse('autocomplete_light_autocomplete', args=['UserAutocomplete']))
        view.request = request
        self.assertFalse(view.is_popup())

        request = RequestFactory().get(
            reverse('autocomplete_light_autocomplete', args=['UserAutocomplete']) + '?_popup=1')
        view.request = request
        self.assertTrue(view.is_popup())

    def test_form_valid(self):
        form = Mock()

        if six.PY3:
            to_patch = 'builtins.super'
        else:
            to_patch = '__builtin__.super'

        with patch(to_patch) as patcher:
            patcher.is_local = True

            view = autocomplete_light.CreateView()
            view.request = Mock()
            view.request.GET.get.return_value = False
            view.object = Mock()
            response = view.form_valid(form)

            # Assert that the parent's response was returned
            self.assertEqual(patcher().form_valid(), response)

            # as popup,
            view.request.GET.get.return_value = '1'
            view.respond_script = lambda: 'foo'
            response = view.form_valid(form)

            # assert that the response contains the script
            self.assertEqual('foo', response)
            self.assertEqual(view.success_url, '/')

########NEW FILE########
__FILENAME__ = widget
from __future__ import unicode_literals

import os

from django import VERSION
from django.test import LiveServerTestCase

from selenium.webdriver.support.ui import Select
from selenium.webdriver.common.keys import Keys
from selenium import webdriver
from selenium.webdriver.support import ui


if VERSION[0] == 1 and VERSION[1] < 7:
    # Patch for travis
    from django.test.testcases import StoppableWSGIServer

    def patient_shutdown(self):
        """
        Stops the serve_forever loop.

        Blocks until the loop has finished. This must be called while
        serve_forever() is running in another thread, or it will
        deadlock.
        """
        self._StoppableWSGIServer__serving = False
        if not self._StoppableWSGIServer__is_shut_down.wait(30):
            raise RuntimeError(
                "Failed to shutdown the live test server in 2 seconds. The "
                "server might be stuck or generating a slow response.")
    StoppableWSGIServer.shutdown = patient_shutdown
else:
    # LiveServerTestCase doesn't serve static files in 1.7 anymore
    from django.contrib.staticfiles.testing import StaticLiveServerCase as LiveServerTestCase


if os.environ.get('TRAVIS', False):
    WAIT_TIME = 300
elif os.environ.get('BUILD_ID', False):  #  Jenkins build server
    WAIT_TIME = 30
else:
    WAIT_TIME = 5


class WidgetTestCase(LiveServerTestCase):
    autocomplete_name = 'relation'
    fixtures = ['basic_fk_model_test_case.json', 'initial_data.json']
    test_case_setup_done = False

    @classmethod
    def setUpClass(cls):
        cls.selenium = webdriver.Firefox()
        cls.selenium.implicitly_wait(WAIT_TIME)
        super(WidgetTestCase, cls).setUpClass()

    @classmethod
    def tearDownClass(cls):
        super(WidgetTestCase, cls).tearDownClass()
        cls.selenium.quit()
        cls.test_case_setup_done = False

    def setUp(self):
        if self.__class__.test_case_setup_done is False:
            self.set_implicit_wait()
            self.setup_test_case()
        self.__class__.test_case_setup_done = True

    def open_url(self, url):
        self.selenium.get('%s%s' % (self.live_server_url, url))

    def send_keys(self, keys, autocomplete_name=None):
        autocomplete_name = autocomplete_name or self.autocomplete_name

        for key in keys:
            self.selenium.find_element_by_css_selector(
                'input[name=%s-autocomplete]' % autocomplete_name
                ).send_keys(key)

    def submit(self, name=None):
        selector = 'input[type=submit]'

        if name:
            selector += '[name=%s]' % name

        self.selenium.find_element_by_css_selector(selector).click()

    def login(self):
        self.open_url('/admin/')
        self.selenium.find_element_by_css_selector('input[name=username]').send_keys('test')
        self.selenium.find_element_by_css_selector('input[name=password]').send_keys('test')
        self.submit()

    def deck_choice_elements(self, autocomplete_name=None):
        autocomplete_name = autocomplete_name or self.autocomplete_name

        return self.selenium.find_elements_by_css_selector(
            '#id_%s-deck [data-value]' % autocomplete_name)

    def autocomplete(self, autocomplete_name=None):
        autocomplete_name = autocomplete_name or self.autocomplete_name

        xpath = ''.join([
            '//*[@id="id_%s-autocomplete"]/' % autocomplete_name,
            'following-sibling::',
            'span[contains(',
                'concat(" ", normalize-space(@class), " "), ',
                '" yourlabs-autocomplete ")',
            ']'])
        return self.selenium.find_element_by_xpath(xpath)

    def deck_choices(self, autocomplete_name=None):
        autocomplete_name = autocomplete_name or self.autocomplete_name

        xpath = ''.join([
            '//*[@id="id_%s-autocomplete"]/' % autocomplete_name,
            'preceding-sibling::',
            'span[contains(',
                'concat(" ", normalize-space(@class), " "), ',
                '" deck ")',
            ']/*[@data-value]'])

        return self.selenium.find_elements_by_xpath(xpath)

    def hilighted_choice(self, autocomplete_name=None):
        autocomplete_name = autocomplete_name or self.autocomplete_name

        xpath = ''.join([
            '//*[@id="id_%s-autocomplete"]/' % autocomplete_name,
            'following-sibling::',
            'span[contains(',
                'concat(" ", normalize-space(@class), " "), ',
                '" yourlabs-autocomplete ")',
            ']',
            '/*[contains(',
                'concat(" ", normalize-space(@class), " "), ',
                '" hilight ")',
            ']'])

        return self.selenium.find_element_by_xpath(xpath)

    def autocomplete_choices(self, autocomplete_name=None):
        autocomplete_name = autocomplete_name or self.autocomplete_name

        xpath = ''.join([
            '//*[@id="id_%s-autocomplete"]/' % autocomplete_name,
            'following-sibling::',
            'span[contains(',
                'concat(" ", normalize-space(@class), " "), ',
                '" yourlabs-autocomplete ")',
            ']/*[@data-value]'])

        return self.selenium.find_elements_by_xpath(xpath)

    def input(self, autocomplete_name=None):
        autocomplete_name = autocomplete_name or self.autocomplete_name

        return self.selenium.find_element_by_css_selector(
                'input[name=%s-autocomplete]' % autocomplete_name)

    def select(self, autocomplete_name=None):
        autocomplete_name = autocomplete_name or self.autocomplete_name

        xpath = ''.join([
            '//*[@id="id_%s-autocomplete"]/' % autocomplete_name,
            'following-sibling::',
            'select'])

        return self.selenium.find_element_by_xpath(xpath)

    def set_implicit_wait(self):
        self.selenium.implicitly_wait(300 if os.environ.get('TRAVIS', False) else 5)

    def unset_implicit_wait(self):
        self.selenium.implicitly_wait(0)

    def select_values(self):
        self.select  # wait for select

        # don't wait for options as there might be none
        self.unset_implicit_wait()

        ret = [o.get_attribute('value') for o in Select(self.select()).options if
                o.is_selected()]

        # restore implicit wait
        self.set_implicit_wait()

        return ret

    def assertSameChoice(self, autocomplete_choice, deck_choice):
        if autocomplete_choice.get_attribute('data-value') != deck_choice.get_attribute('data-value'):
            self.fail('Choices have different data-value')

        if autocomplete_choice.text not in deck_choice.text:
            # deck_choice has an additional span.remove
            self.fail('Choices have different text')

    def assertAutocompleteEmpty(self):
        self.unset_implicit_wait()
        self.assertTrue(len(self.autocomplete_choices()) == 0)
        self.set_implicit_wait()


class ActivateAutocompleteInBlankFormTestCase(WidgetTestCase):
    def setup_test_case(self):
        self.login()
        self.open_url('/admin/basic/fkmodel/add/')
        self.send_keys('ja')

    def test_autocomplete_shows_up(self):
        self.assertTrue(self.autocomplete().is_displayed())

    def test_autocomplete_has_four_choices(self):
        self.assertEqual(4, len(self.autocomplete_choices()))

class XhrPendingTestCase(WidgetTestCase):
    def setup_test_case(self):
        self.login()
        self.open_url('/admin/basic/fkmodel/add/')

    def test_xhr_pending(self):
        self.send_keys('ja')
        self.selenium.find_element_by_css_selector(
            'input[name=%s-autocomplete]' % self.autocomplete_name)
        self.selenium.find_element_by_css_selector(
            'input:not(.xhr-pending)[name=%s-autocomplete]' % self.autocomplete_name)


class SelectChoiceInEmptyFormTestCase(WidgetTestCase):
    def setup_test_case(self):
        self.login()
        self.open_url('/admin/basic/fkmodel/add/')
        self.send_keys('ja')
        self.autocomplete_choices()[1].click()

    def test_autocomplete_disappears(self):
        self.assertFalse(self.autocomplete().is_displayed())

    def test_input_disappears(self):
        self.assertFalse(self.input().is_displayed())

    def test_deck_choice_shows_up(self):
        self.assertEqual(len(self.deck_choices()), 1)

    def test_deck_choice_same_as_selected(self):
        self.assertSameChoice(self.autocomplete_choices()[1], self.deck_choices()[0])

    def test_hidden_select_value(self):
        self.assertEqual(self.select_values(), ['4'])


class WidgetInitialStatusInEditForm(WidgetTestCase):
    def setup_test_case(self):
        self.login()
        self.open_url('/admin/basic/fkmodel/1/')

    def test_hidden_select_values(self):
        self.assertEqual(self.select_values(), ['4'])

    def test_input_is_hidden(self):
        self.assertFalse(self.input().is_displayed())


class RemoveChoiceInEditFormTestCase(WidgetTestCase):
    def setup_test_case(self):
        self.login()
        self.open_url('/admin/basic/fkmodel/1/')
        self.deck_choices()[0].find_element_by_css_selector('.remove').click()

    def test_input_shows_up(self):
        self.assertTrue(self.input().is_displayed())

    def test_hidden_select_option_was_unselected(self):
        self.unset_implicit_wait()
        self.assertEqual(self.select_values(), [])
        self.set_implicit_wait()

    def test_element_was_remove_from_deck(self):
        self.unset_implicit_wait()
        self.assertEqual(0, len(self.deck_choices()))
        self.set_implicit_wait()


class KeyboardTestCase(WidgetTestCase):
    def setup_test_case(self):
        self.login()
        self.open_url('/admin/basic/fkmodel/add/')
        self.send_keys('jac')

    def assertHilightedChoiceNmber(self, n):
        self.assertSameChoice(self.hilighted_choice(), self.autocomplete_choices()[n])

    def send_keys_wait_assert_choice_number(self, key, choice):
        old_hilight = self.hilighted_choice()

        self.send_keys([key])
        ui.WebDriverWait(self.selenium, WAIT_TIME).until(
            lambda x: old_hilight != self.hilighted_choice())

        self.assertSameChoice(self.hilighted_choice(), self.autocomplete_choices()[choice])

    def test_00_first_to_second_with_down(self):
        self.send_keys_wait_assert_choice_number(Keys.ARROW_DOWN, 1)

    def test_01_last_to_first_with_down(self):
        self.send_keys_wait_assert_choice_number(Keys.ARROW_DOWN, 0)

    def test_02_first_to_last_with_up(self):
        self.send_keys_wait_assert_choice_number(Keys.ARROW_UP, -1)

    def test_03_last_to_first_with_up(self):
        self.send_keys_wait_assert_choice_number(Keys.ARROW_UP, 0)

    def test_04_tab_to_select_choice(self):
        self.send_keys([Keys.TAB])
        self.assertSameChoice(self.autocomplete_choices()[0], self.deck_choices()[0])
        self.assertEqual(self.select_values(), ['4'])


class InlineBlankTestCase(ActivateAutocompleteInBlankFormTestCase):
    autocomplete_name = 'reverse_for_inline-3-relation'

    def setup_test_case(self):
        self.login()
        self.open_url('/admin/basic/fkmodel/add/')
        self.selenium.find_element_by_css_selector('.add-row a').click()
        self.send_keys('ja')


class InlineSelectChoiceTestCase(SelectChoiceInEmptyFormTestCase):
    autocomplete_name = 'reverse_for_inline-3-relation'

    def setup_test_case(self):
        self.login()
        self.open_url('/admin/basic/fkmodel/add/')
        self.selenium.find_element_by_css_selector('.add-row a').click()
        self.send_keys('ja')
        self.autocomplete_choices()[1].click()

########NEW FILE########
__FILENAME__ = widgets
from lxml.html import etree
from lxml.cssselect import CSSSelector

try:
    from unittest import mock
except ImportError:  # python2
    import mock

from django.test import TestCase

import autocomplete_light

from ..example_apps.basic.models import FkModel
from ..example_apps.security_test.models import Item


class LazyAutocomplete(autocomplete_light.AutocompleteModelBase):
    pass


class WidgetBaseTestCase(TestCase):
    widget_class = autocomplete_light.WidgetBase
    fixtures = ['security_test.json']

    def autocomplete_input(self, et):
        return CSSSelector('input.autocomplete')(et)[0]

    def test_init_with_registry(self):
        registry = autocomplete_light.AutocompleteRegistry()
        registry.register(FkModel, name='TestAutocomplete')

        widget = self.widget_class('TestAutocomplete', registry=registry)
        self.assertEqual(widget.autocomplete.__name__, 'TestAutocomplete')

    def test_init_without_registry(self):
        widget = self.widget_class('FkModelAutocomplete')
        self.assertEqual(widget.autocomplete.model, FkModel)

    def test_widget_js_attributes_deprecation(self):
        with self.assertRaises(PendingDeprecationWarning) as context:
            widget = self.widget_class(widget_js_attributes={'foo': 'bar'})

    def test_autocomplete_js_attributes_deprecation(self):
        with self.assertRaises(PendingDeprecationWarning) as context:
            widget = self.widget_class(autocomplete_js_attributes={'foo': 'bar'})

    @mock.patch('autocomplete_light.widgets.render_to_string')
    def test_widget_template(self, render_to_string):
        widget = self.widget_class('FkModelAutocomplete',
            widget_template='foo.html')
        widget.render('somewidget', None)
        render_to_string.assert_called_with('foo.html', mock.ANY)

    @mock.patch('autocomplete_light.widgets.render_to_string')
    def test_autocomplete_widget_template(self, render_to_string):
        class Autocomplete(autocomplete_light.AutocompleteListBase):
            widget_template='bar.html'
            choices = ['a', 'b']

        widget = self.widget_class(Autocomplete)
        widget.render('somewidget', [])
        render_to_string.assert_called_with('bar.html', mock.ANY)

    @mock.patch('autocomplete_light.widgets.render_to_string')
    def test_base_context(self, render_to_string):
        widget = self.widget_class('FkModelAutocomplete')
        widget.render('somewidget', None)
        render_to_string.assert_called_with(
            'autocomplete_light/widget.html', {
                'widget': widget,
                'choices': mock.ANY,
                'autocomplete': mock.ANY,
                'attrs': mock.ANY,
                'widget_attrs': mock.ANY,
                'name': 'somewidget',
                'values': [],
            })

    @mock.patch('autocomplete_light.widgets.render_to_string')
    def test_extra_context(self, render_to_string):
        widget = self.widget_class('FkModelAutocomplete',
                                   extra_context={'foo': 'bar'})

        widget.render('somewidget', None)

        render_to_string.assert_called_with(
            'autocomplete_light/widget.html', {
                'widget': widget,
                'choices': mock.ANY,
                'autocomplete': mock.ANY,
                'attrs': mock.ANY,
                'widget_attrs': mock.ANY,
                'name': 'somewidget',
                'values': [],
                'foo': 'bar',
            })

    def test_input_placeholder_attr(self):
        widget = self.widget_class('FkModelAutocomplete',
                                   attrs={'placeholder': 'foo'})
        html = widget.render('somewidget', None)
        et = etree.XML(html)

        self.assertEqual(self.autocomplete_input(et).attrib['placeholder'],
                         'foo')

    def test_widget_attrs(self):
        widget = self.widget_class('FkModelAutocomplete',
                                   widget_attrs={'class': 'foo'})
        html = widget.render('somewidget', None)
        et = etree.XML(html)
        self.assertIn('foo', et.attrib['class'])

        # This was originally masked from the test suite because method
        # definition was repeated
        widget = self.widget_class('FkModelAutocomplete',
            widget_attrs={'data-widget-foo': 'bar', 'class':'foobar'})
        html = widget.render('somewidget', None)
        et = etree.fromstring(html)
        self.assertEquals(et.attrib['data-widget-foo'], 'bar')
        self.assertIn('foobar', et.attrib['class'])
        self.assertIn('autocomplete-light-widget', et.attrib['class'])

    def test_lazy_autocomplete_init(self):
        registry = autocomplete_light.AutocompleteRegistry()

        try:
            self.widget_class('LazyAutocomplete', registry=registry)
        except autocomplete_light.AutocompleteNotRegistered:
            self.fail('WidgetBase initialization should not trigger registry '
                      'access')

    def test_lazy_autcomplete_access(self):
        registry = autocomplete_light.AutocompleteRegistry()

        widget = self.widget_class('LazyAutocomplete', registry=registry)

        try:
            widget.autocomplete
            self.fail('Should raise AutocompleteNotRegistered on unregistered '
                      'LazyAutocomplete')
        except autocomplete_light.AutocompleteNotRegistered:
            pass

        registry.register(LazyAutocomplete)
        self.assertIn('LazyAutocomplete', registry.keys())

        try:
            widget.autocomplete
        except autocomplete_light.AutocompleteNotRegistered:
            self.fail('widget.autocomplete access should not raise '
                      'AutocompleteNotRegistered')

    def test_value_out_of_queryset(self):
        widget = self.widget_class('ItemAutocomplete')
        html = widget.render('somewidget', [1, 2])
        span = etree.fromstring(html)

        choices = CSSSelector('[data-value]')(span)

        self.assertEqual(len(choices), 1)
        self.assertEqual(int(choices[0].attrib['data-value']), 1)


class ChoiceWidgetTestCase(WidgetBaseTestCase):
    widget_class = autocomplete_light.ChoiceWidget


class MultipleChoiceWidgetTestCase(WidgetBaseTestCase):
    widget_class = autocomplete_light.MultipleChoiceWidget


class TextWidgetTestCase(WidgetBaseTestCase):
    widget_class = autocomplete_light.TextWidget

    def autocomplete_input(self, et):
        return et

    def test_extra_context(self):
        pass  # no template for TextWidget

    def test_widget_template(self):
        pass  # no template for TextWidget

    def test_base_context(self):
        pass  # no template for TextWidget

    def test_autocomplete_widget_template(self):
        pass  # no template for TextWidget

    def test_widget_attrs(self):
        pass  # no widget_attrs for TextWidget

    def test_value_out_of_queryset(self):
        pass  # no queryset for text widget

    def test_widget_attrs_copy(self):
        # Test case for GH269
        widget = self.widget_class('B')
        html = widget.render('taggit', value='Cued Speech, languages')
        et = etree.XML(html)
        self.assertTrue('value' in et.attrib)

        html = widget.render('taggit', None)
        et = etree.XML(html)
        self.assertFalse('value' in et.attrib)

########NEW FILE########
__FILENAME__ = urls
"""
An url to AutocompleteView.

autocomplete_light_autocomplete
    Given a 'autocomplete' argument with the name of the autocomplete, this url
    routes to AutocompleteView.

autocomplete_light_registry
    Renders the autocomplete registry, good for debugging, requires being
    authenticated as superuser.
"""

try:
    from django.conf.urls import patterns, url
except ImportError:
    # Django < 1.5
    from django.conf.urls.defaults import patterns, url

from django.views.generic.base import TemplateView

from .views import AutocompleteView, RegistryView


urlpatterns = patterns('',
    url(r'^(?P<autocomplete>[-\w]+)/$',
        AutocompleteView.as_view(),
        name='autocomplete_light_autocomplete'
    ),
    url(r'^$',
        RegistryView.as_view(),
        name='autocomplete_light_registry'
    ),
)

########NEW FILE########
__FILENAME__ = views
from django import http
from django.views import generic
from django.views.generic import base
from django.utils.encoding import force_text

import autocomplete_light

__all__ = ['AutocompleteView', 'RegistryView', 'CreateView']


class RegistryView(base.TemplateView):
    template_name = 'autocomplete_light/registry.html'

    def get(self, request, *args, **kwargs):
        if not request.user.is_superuser:
            return http.HttpResponseForbidden()
        return super(RegistryView, self).get(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        return {
            'registry': autocomplete_light.registry,
            'registry_items': autocomplete_light.registry.items(),
        }


class AutocompleteView(generic.View):
    """Simple view that routes the request to the appropriate autocomplete."""

    def get(self, request, *args, **kwargs):
        """
        Return an HttpResponse with the return value of
        autocomplete.autocomplete_html().

        This view is called by the autocomplete script, it is expected to
        return the rendered autocomplete box contents.

        To do so, it gets the autocomplete class from the registry, given the
        url keyword argument autocomplete, that should be the autocomplete
        name.

        Then, it instanciates the autocomplete with no argument as usual, and
        calls autocomplete.init_for_request, passing all arguments it recieved.

        Finnaly, it makes an HttpResponse with the result of
        autocomplete.autocomplete_html(). The javascript will use that to
        fill the autocomplete suggestion box.
        """
        try:
            autocomplete_class = autocomplete_light.registry[
                kwargs['autocomplete']]
        except autocomplete_light.AutocompleteNotRegistered:
            return http.HttpResponseNotFound()
        autocomplete = autocomplete_class(request=request)
        return http.HttpResponse(autocomplete.autocomplete_html())

    def post(self, request, *args, **kwargs):
        """
        Just proxy autocomplete.post().

        This is the key to communication between the autocomplete and the
        widget in javascript. You can use it to create results and such.
        """
        autocomplete_class = autocomplete_light.registry[
            kwargs['autocomplete']]
        autocomplete = autocomplete_class()
        return autocomplete.post(request, *args, **kwargs)


class CreateView(generic.CreateView):
    """Simple wrapper for generic.CreateView, that responds to _popup."""

    def is_popup(self):
        return self.request.GET.get('_popup', False)

    def respond_script(self, obj=None):
        if obj is None:
            obj = self.object

        html = []
        html.append('<script type="text/javascript">')
        html.append('opener.dismissAddAnotherPopup( window, "%s", "%s" );' % (
            force_text(obj.pk), force_text(obj).replace('"', '\\"')))
        html.append('</script>')

        html = ''.join(html)

        return http.HttpResponse(html, status=201)

    def form_valid(self, form):
        """ If request.GET._popup, return some javascript. """
        if self.is_popup():
            self.success_url = '/'  # avoid ImproperlyConfigured

        response = super(CreateView, self).form_valid(form)

        if not self.is_popup():
            return response

        return self.respond_script()

########NEW FILE########
__FILENAME__ = widgets
from __future__ import unicode_literals

"""
The provided widgets are ment to rely on an Autocomplete class.

- :py:class:`ChoiceWidget` :py:class:`django:django.forms.Select`

ChoiceWidget is intended to work as a replacement for django's Select widget,
and MultipleChoiceWidget for django's SelectMultiple,

Constructing a widget needs an Autocomplete class or registered autocomplete
name.

The choice autocomplete widget renders from autocomplete_light/widget.html
template.
"""

from django import forms
from django.forms.util import flatatt
from django.utils import safestring
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

from .registry import registry as default_registry

__all__ = ['WidgetBase', 'ChoiceWidget', 'MultipleChoiceWidget', 'TextWidget']


class WidgetBase(object):
    """
    Base widget for autocompletes.

    .. py:attribute:: attrs

        HTML ``<input />`` attributes, such as class, placeholder, etc ... Note
        that any ``data-autocomplete-*`` attribute will be parsed as an option
        for ``yourlabs.Autocomplete`` js object. For example::

        attrs={
            'placeholder': 'foo',
            'data-autocomplete-minimum-characters': 0
            'class': 'bar',
        }

        Will render like::
            <input
                placeholder="foo"
                data-autocomplete-minimum-characters="0"
                class="autocomplete bar"
            />

        Which will set by the way ``yourlabs.Autocomplete.minimumCharacters``
        option - the naming conversion is handled by jQuery.

    .. py:attribute:: widget_attrs

        HTML widget container attributes. Note that any ``data-widget-*``
        attribute will be parsed as an option for ``yourlabs.Widget`` js
        object. For example::

            widget_attrs={
                'data-widget-maximum-values': 6,
                'class': 'country-autocomplete',
            }

        Will render like::

            <span
                id="country-wrapper"
                data-widget-maximum-values="6"
                class="country-autocomplete autcomplete-light-widget"
            />

        Which will set by the way ``yourlabs.Widget.maximumValues`` - note that
        the naming conversion is handled by jQuery.

    .. py:attribute:: widget_js_attributes

        **DEPRECATED** in favor of :py:attr::`widget_attrs`.

        A dict of options that will override the default widget options. For
        example::

            widget_js_attributes = {'max_values': 8}

        The above code will set this HTML attribute::

            data-max-values="8"

        Which will override the default javascript widget maxValues option
        (which is 0).

        It is important to understand naming conventions which are sparse
        unfortunately:

        - python: lower case with underscores ie. ``max_values``,
        - HTML attributes: lower case with dashes ie. ``data-max-values``,
        - javascript: camel case, ie. ``maxValues``.

        The python to HTML name conversion is done by the
        autocomplete_light_data_attributes template filter.

        The HTML to javascript name conversion is done by the jquery plugin.

    .. py:attribute:: autocomplete_js_attributes

        **DEPRECATED** in favor of :py:attr::`attrs`.

        A dict of options like for :py:attr:`widget_js_attributes`. However,
        note that HTML attributes will be prefixed by ``data-autocomplete-``
        instead of just ``data-``. This allows the jQuery plugins to make the
        distinction between attributes for the autocomplete instance and
        attributes for the widget instance.

    .. py:attribute:: extra_context

        Extra context dict to pass to the template.

    .. py:attribute:: widget_template

        Template to use to render the widget. Default is
        ``autocomplete_light/widget.html``.
    """

    def __init__(self, autocomplete=None, widget_js_attributes=None,
                 autocomplete_js_attributes=None, extra_context=None,
                 registry=None, widget_template=None, widget_attrs=None):

        self.registry = default_registry if registry is None else registry
        self._autocomplete = None
        self.autocomplete_arg = autocomplete

        self.widget_js_attributes = widget_js_attributes or {}
        self.autocomplete_js_attributes = autocomplete_js_attributes or {}
        self.extra_context = extra_context or {}
        self.widget_template = (widget_template or
                'autocomplete_light/widget.html')
        self.widget_attrs = widget_attrs or {}

        if autocomplete_js_attributes is not None:
            raise PendingDeprecationWarning('autocomplete_js_attributes are'
                    'deprecated in favor of attrs')

        if widget_js_attributes is not None:
            raise PendingDeprecationWarning('widget_js_attributes are'
                    'deprecated in favor of widget_attrs')

    def render(self, name, value, attrs=None):
        widget_attrs = self.build_widget_attrs(name)
        attrs = self.build_attrs(attrs)
        self.html_id = attrs.pop('id', name)

        autocomplete = self.autocomplete(values=value)
        choices = autocomplete.choices_for_values()
        values = [autocomplete.choice_value(c) for c in choices]

        context = {
            'name': name,
            'values': values,
            'choices': choices,
            'widget': self,
            'attrs': safestring.mark_safe(flatatt(attrs)),
            'widget_attrs': safestring.mark_safe(flatatt(widget_attrs)),
            'autocomplete': autocomplete,
        }
        context.update(self.extra_context)

        template = getattr(autocomplete, 'widget_template',
                self.widget_template)
        return safestring.mark_safe(render_to_string(template, context))

    def build_attrs(self, extra_attrs=None, **kwargs):
        self.attrs.update(getattr(self.autocomplete, 'attrs', {}))
        attrs = super(WidgetBase, self).build_attrs(extra_attrs, **kwargs)

        if 'class' not in attrs.keys():
            attrs['class'] = ''

        attrs['class'] += ' autocomplete'

        attrs.setdefault('data-autocomplete-choice-selector', '[data-value]')
        attrs.setdefault('data-autocomplete-url',
                         self.autocomplete().get_absolute_url())
        attrs.setdefault('placeholder', _(
            'type some text to search in this autocomplete').capitalize())

        # for backward compatibility
        for key, value in self.autocomplete_js_attributes.items():
            attrs['data-autocomplete-%s' % key.replace('_', '-')] = value

        return attrs

    def build_widget_attrs(self, name=None):
        attrs = getattr(self.autocomplete, 'widget_attrs', {}).copy()
        attrs.update(self.widget_attrs)

        if 'class' not in attrs:
            attrs['class'] = ''

        attrs.setdefault('data-widget-bootstrap', 'normal')

        # for backward compatibility
        for key, value in self.autocomplete_js_attributes.items():
            attrs['data-widget-%s' % key.replace('_', '-')] = value

        attrs['class'] += ' autocomplete-light-widget '

        if name:
            attrs['class'] += name

        if attrs.get('data-widget-maximum-values', 0) == 1:
            attrs['class'] += ' single'
        else:
            attrs['class'] += ' multiple'

        return attrs

    def autocomplete():
        def fget(self):
            if not self._autocomplete:
                self._autocomplete = self.registry.get_autocomplete_from_arg(
                    self.autocomplete_arg)

            return self._autocomplete

        def fset(self, value):
            self._autocomplete = value
            self.autocomplete_name = value.__class__.__name__

        return {'fget': fget, 'fset': fset}
    autocomplete = property(**autocomplete())


class ChoiceWidget(WidgetBase, forms.Select):
    """
    Widget that provides an autocomplete for zero to one choice.
    """

    def __init__(self, autocomplete=None, widget_js_attributes=None,
            autocomplete_js_attributes=None, extra_context=None, registry=None,
            widget_template=None, widget_attrs=None, *args,
            **kwargs):

        forms.Select.__init__(self, *args, **kwargs)

        WidgetBase.__init__(self, autocomplete, widget_js_attributes,
                autocomplete_js_attributes, extra_context, registry,
                widget_template, widget_attrs)

        self.widget_attrs.setdefault('data-widget-maximum-values', 1)


class MultipleChoiceWidget(WidgetBase, forms.SelectMultiple):
    """
    Widget that provides an autocomplete for zero to n choices.
    """
    def __init__(self, autocomplete=None, widget_js_attributes=None,
            autocomplete_js_attributes=None, extra_context=None, registry=None,
            widget_template=None, widget_attrs=None, *args,
            **kwargs):

        forms.SelectMultiple.__init__(self, *args, **kwargs)

        WidgetBase.__init__(self, autocomplete,
            widget_js_attributes, autocomplete_js_attributes, extra_context,
            registry, widget_template, widget_attrs)


class TextWidget(WidgetBase, forms.TextInput):
    """
    Widget that just adds an autocomplete to fill a text input.

    Note that it only renders an ``<input>``, so attrs and widget_attrs are
    merged together.
    """

    def __init__(self, autocomplete=None, widget_js_attributes=None,
            autocomplete_js_attributes=None, extra_context=None, registry=None,
            widget_template=None, widget_attrs=None, *args,
            **kwargs):

        forms.TextInput.__init__(self, *args, **kwargs)

        WidgetBase.__init__(self, autocomplete, widget_js_attributes,
                autocomplete_js_attributes, extra_context, registry,
                widget_template, widget_attrs)

    def render(self, name, value, attrs=None):
        """ Proxy Django's TextInput.render() """
        return forms.TextInput.render(self, name, value, attrs)

    def build_attrs(self, extra_attrs=None, **kwargs):
        attrs = super(TextWidget, self).build_widget_attrs()
        attrs.update(super(TextWidget, self).build_attrs(
            extra_attrs, **kwargs))

        def update_attrs(source, prefix=''):
            for key, value in source.items():
                key = 'data-%s%s' % (prefix, key.replace('_', '-'))
                attrs[key] = value

        update_attrs(self.widget_js_attributes, 'widget-')
        update_attrs(self.autocomplete_js_attributes, 'autocomplete-')

        attrs['data-widget-bootstrap'] = 'text'
        attrs['class'] += ' autocomplete-light-text-widget'

        return attrs

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-autocomplete-light documentation build configuration file, created by
# sphinx-quickstart2 on Tue May  8 17:10:44 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os, os.path

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../../'))
sys.path.insert(0, os.path.abspath('../../../../lib/python2.7/site-packages/'))
from django.conf import settings
settings.configure()

autoclass_content = "both"

project_root = os.path.abspath('../../')
static_root = os.path.abspath('_static')
import pycco
for script in ('autocomplete', 'addanother', 'widget', 'remote', 'text_widget'):
    html = pycco.generate_documentation(
        os.path.join(project_root, 'autocomplete_light/static/autocomplete_light/%s.js' % script),
        static_root
    )
    html = html.replace('../../../docs/source/_static/pycco.css', 'pycco.css')
    f = open(os.path.join(static_root, '%s.html' % script), 'w+')
    f.write(html)
    f.close()

import os
on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
intersphinx_mapping = {
    'python': ('http://docs.python.org/2/', None),
    'django': ('http://django.readthedocs.org/en/latest/', None),
}

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode', 'sphinx.ext.intersphinx',
        'sphinx.ext.graphviz', 'sphinx.ext.inheritance_diagram']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-autocomplete-light'
copyright = u'2012-2013, James Pic and contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.0'
# The full version, including alpha/beta/rc tags.
release = '2.0.0a17'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-autocomplete-lightdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-autocomplete-light.tex', u'django-autocomplete-light Documentation',
   u'James Pic', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-autocomplete-light', u'django-autocomplete-light Documentation',
     [u'James Pic'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-autocomplete-light', u'django-autocomplete-light Documentation',
   u'James Pic', 'django-autocomplete-light', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import Foo, Bar


class FooInline(admin.TabularInline):
    model = Foo


class FooAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Foo)
admin.site.register(Foo, FooAdmin)


class BarAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Bar)
    inlines = [FooInline]
admin.site.register(Bar, BarAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from models import Foo, Bar

autocomplete_light.register(Foo)
autocomplete_light.register(Bar)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Foo(models.Model):
    name = models.CharField(max_length=100)
    bar = models.ForeignKey('Bar', related_name='bar_fk')

    def __unicode__(self):
        return self.name


class Bar(models.Model):
    name = models.CharField(max_length=100)

    def __unicode__(self):
        return self.name

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import Creatable


class CreatableAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Creatable)
admin.site.register(Creatable, CreatableAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
from django import http

import autocomplete_light

from models import Creatable


class AutocompleteCreatable(autocomplete_light.AutocompleteModelTemplate):
    autocomplete_template = 'ajax_create/autocomplete.html'

    def post(self, request, *args, **kwargs):
        choice = Creatable.objects.create(name=request.POST['createChoice'])
        return http.HttpResponse(self.choice_html(choice))


autocomplete_light.register(Creatable, AutocompleteCreatable)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Creatable(models.Model):
    name = models.CharField(max_length=100)
    related = models.ManyToManyField('self', blank=True)

    def __unicode__(self):
        return self.name

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from forms import TaggableForm
from models import Taggable


class TaggableInline(admin.TabularInline):
    form = TaggableForm
    model = Taggable


class TaggableAdmin(admin.ModelAdmin):
    form = TaggableForm
    list_display = ['name', 'tags']
    inlines = [TaggableInline]

admin.site.register(Taggable, TaggableAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
from tagging.models import Tag

import autocomplete_light


autocomplete_light.register(Tag)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from models import Taggable


class TaggableForm(forms.ModelForm):
    class Meta:
        model = Taggable
        widgets = {
        	'tags': autocomplete_light.TextWidget('TagAutocomplete'),
       	}
########NEW FILE########
__FILENAME__ = models
from django.db import models

from tagging.fields import TagField
import tagging


class Taggable(models.Model):
    name = models.CharField(max_length=50)
    tags = TagField(null=True, blank=True)
    parent = models.ForeignKey('self', null=True, blank=True)

    def __unicode__(self):
        return self.name

tagging.register(Taggable, tag_descriptor_attr='etags')

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import MediaFilter, Media


class MediaFilterAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(MediaFilter)
admin.site.register(MediaFilter, MediaFilterAdmin)

admin.site.register(Media)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from models import Media

autocomplete_light.register(Media, search_fields=('name',))

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _


class Media(models.Model):
    code = models.CharField(_(u'Code'), max_length=128, null=False,
        blank=False, primary_key=True)
    name = models.CharField(_('Name'), max_length=128, null=True,
        blank=True)

    class Meta:
        verbose_name_plural = "media"

    def __unicode__(self):
        return self.name


class MediaFilter(models.Model):
    media = models.ForeignKey(Media, verbose_name=_("Media"))

    def __unicode__(self):
        return u"Filter for %s" % self.media.name

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import TemplatedChoice, TestModel

class TestModelAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(TestModel)

admin.site.register(TestModel, TestModelAdmin)
admin.site.register(TemplatedChoice)
########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from models import TemplatedChoice

autocomplete_light.register(TemplatedChoice,
	autocomplete_light.AutocompleteModelTemplate)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.core.urlresolvers import reverse


class TemplatedChoice(models.Model):
    name = models.CharField(max_length=100)

    class Meta:
        ordering = ('name',)

    def __unicode__(self):
        return self.name

    def get_absolute_update_url(self):
        url = 'admin:default_template_autocomplete_templatedchoice_change'
        return reverse(url, args=(self.pk,))

    def get_absolute_url(self):
        return reverse('templated_choice_detail', args=(self.pk,))


class TestModel(models.Model):
    choices = models.ManyToManyField(TemplatedChoice)

    def __unicode__(self):
        return u', '.join(self.choices.values_list('name', flat=True))

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.views import generic

from models import TemplatedChoice


urlpatterns = patterns('',
    url(r'^(?P<pk>\d+)/$', generic.DetailView.as_view(model=TemplatedChoice),
        name='templated_choice_detail'),
)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import Dummy
from forms import DummyForm


class DummyInline(admin.TabularInline):
	model = Dummy
	form = DummyForm


class DummyAdmin(admin.ModelAdmin):
    form = DummyForm
    inlines = [DummyInline]
admin.site.register(Dummy, DummyAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from cities_light.models import Country, Region

autocomplete_light.register(Country, search_fields=('name', 'name_ascii',),
    autocomplete_js_attributes={'placeholder': 'country name ..'})


class AutocompleteRegion(autocomplete_light.AutocompleteModelBase):
    autocomplete_js_attributes={'placeholder': 'region name ..'}

    def choices_for_request(self):
        q = self.request.GET.get('q', '')
        country_id = self.request.GET.get('country_id', None)

        choices = self.choices.all()
        if q:
            choices = choices.filter(name_ascii__icontains=q)
        if country_id:
            choices = choices.filter(country_id=country_id)

        return self.order_choices(choices)[0:self.limit_choices]

autocomplete_light.register(Region, AutocompleteRegion)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from models import Dummy


class DummyForm(forms.ModelForm):
    class Media:
        """
        We're currently using Media here, but that forced to move the
        javascript from the footer to the extrahead block ...

        So that example might change when this situation annoys someone a lot.
        """
        js = ('dependant_autocomplete.js',)

    class Meta:
        model = Dummy
        widgets = autocomplete_light.get_widgets_dict(Dummy)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Dummy(models.Model):
    parent = models.ForeignKey('self', null=True, blank=True)
    country = models.ForeignKey('cities_light.country')
    region = models.ForeignKey('cities_light.region')

    def __unicode__(self):
        return u'%s %s' % (self.country, self.region)
########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from models import Profile
from forms import ProfileForm


class ProfileAdmin(admin.ModelAdmin):
    form = ProfileForm

admin.site.register(Profile, ProfileAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
from django.contrib.auth.models import User
import autocomplete_light


class UserAutocomplete(autocomplete_light.AutocompleteModelBase):
    search_fields = ('username', 'email', 'first_name', 'last_name')

    # Note that defining *_js_attributes in a Widget also works. Widget has
    # priority since it's the most specific.
    autocomplete_js_attributes = {
        'placeholder': 'type a user name ...',
    }


autocomplete_light.register(User, UserAutocomplete)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.contrib.auth.models import User
from cities_light.models import City
import autocomplete_light

from models import Profile


class ProfileForm(forms.ModelForm):
    user = forms.ModelChoiceField(User.objects.all(),
        widget=autocomplete_light.ChoiceWidget('UserAutocomplete'))

    cities = forms.ModelMultipleChoiceField(City.objects.all(),
        widget=autocomplete_light.MultipleChoiceWidget('CityAutocomplete',
            # optionnal: override an autocomplete.js option
            autocomplete_js_attributes={'minimum_characters': 0,
                                        'placeholder': 'Choose 3 cities ...'},
            # optionnal: override a widget.js option
            widget_js_attributes={'max_values': 3}))

    # Note that defining *_js_attributes on Autocomplete classes or instances
    # also work.

    class Meta:
        model = Profile

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Profile(models.Model):
    user = models.ForeignKey('auth.User')
    cities = models.ManyToManyField('cities_light.city')

    def __unicode__(self):
        return self.user.username

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import Address

class AddressAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Address)

admin.site.register(Address, AddressAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from cities_light.models import City

autocomplete_light.register(City, search_fields=('search_names',),
    autocomplete_js_attributes={'placeholder': 'city name ..'})

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Address(models.Model):
    city = models.ForeignKey('cities_light.city')

########NEW FILE########
__FILENAME__ = admin
from django.contrib.contenttypes import generic
from django.contrib import admin

from forms import RelationshipForm
from models import Relationship, SomeModel


class RelationshipInline(generic.GenericTabularInline):
    model = Relationship
    extra = 0
    ct_field = "content_type"
    ct_fk_field = "object_id"
    form = RelationshipForm

    def get_formset(self, request, obj=None, **kwargs):
        kwargs.update({'form': RelationshipForm})
        return super(RelationshipInline, self).get_formset(request, obj, **kwargs)


class SomeModelAdmin(admin.ModelAdmin):
    inlines = (
        RelationshipInline,
    )

admin.site.register(SomeModel, SomeModelAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
from cities_light.models import City, Country
import autocomplete_light


class AutocompletePeople(autocomplete_light.AutocompleteGenericBase):
    choices = (
        City.objects.all(),
        Country.objects.all(),
    )

    search_fields = (
        ('search_names',),
        ('name',)
    )

    autocomplete_js_attributes = {'placeholder': 'suggestions...', 'minimum_characters': 0}
autocomplete_light.register(AutocompletePeople)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from models import Relationship


class RelationshipForm(autocomplete_light.GenericModelForm):
    person = autocomplete_light.GenericModelChoiceField(
        widget=autocomplete_light.ChoiceWidget(
            autocomplete='AutocompletePeople',
            autocomplete_js_attributes={'minimum_characters': 0}))

    class Meta:
        model = Relationship
        exclude = ('person_content_type', 'person_object_id')

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType


class SomeModel(models.Model):
    name = models.CharField(max_length=200)


class Relationship(models.Model):
    person_content_type = models.ForeignKey(ContentType, related_name="person_type_set")
    person_object_id = models.PositiveIntegerField()
    person = generic.GenericForeignKey("person_content_type", "person_object_id")
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey("content_type", "object_id")

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from models import ModelGroup
from forms import ModelGroupForm


class ModelGroupAdmin(admin.ModelAdmin):
    form = ModelGroupForm
admin.site.register(ModelGroup, ModelGroupAdmin)

########NEW FILE########
__FILENAME__ = forms
import autocomplete_light
from autocomplete_light.contrib.generic_m2m import GenericModelForm, \
    GenericModelMultipleChoiceField

from models import ModelGroup


class ModelGroupForm(GenericModelForm):
    """
    Use AutocompleteTaggableItems defined in
    gfk_autocomplete.autocomplete_light_registry.
    """

    related = GenericModelMultipleChoiceField(
        widget=autocomplete_light.MultipleChoiceWidget(
            'AutocompleteTaggableItems'))

    class Meta:
        model = ModelGroup

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.db.models import signals
from django.contrib.contenttypes import generic

from genericm2m.models import RelatedObjectsDescriptor

class ModelGroup(models.Model):
    name = models.CharField(max_length=100)

    related = RelatedObjectsDescriptor()

    def __unicode__(self):
        return self.name

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from forms import TaggedItemForm
from models import TaggedItem


class TaggedItemAdmin(admin.ModelAdmin):
    form = TaggedItemForm
admin.site.register(TaggedItem, TaggedItemAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light
from cities_light.models import Country, City
from django.contrib.auth.models import User, Group


class AutocompleteTaggableItems(autocomplete_light.AutocompleteGenericBase):
    choices = (
        User.objects.all(),
        Group.objects.all(),
        City.objects.all(),
        Country.objects.all(),
    )

    search_fields = (
        ('username', 'email'),
        ('name',),
        ('search_names',),
        ('name_ascii',),
    )


autocomplete_light.register(AutocompleteTaggableItems)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from models import TaggedItem


class TaggedItemForm(autocomplete_light.GenericModelForm):
    content_object = autocomplete_light.GenericModelChoiceField(
        widget=autocomplete_light.ChoiceWidget(
            autocomplete='AutocompleteTaggableItems',
            autocomplete_js_attributes={'minimum_characters': 0}))

    class Meta:
        model = TaggedItem
        exclude = ('content_type', 'object_id')

########NEW FILE########
__FILENAME__ = models
from django.db import models

from django.contrib.contenttypes import generic


class TaggedItem(models.Model):
    content_type = models.ForeignKey('contenttypes.contenttype', related_name='my_tagged_item')
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey('content_type', 'object_id')

    tag = models.CharField(max_length=100)

    def __unicode__(self):
        return u'%s %s' % (self.tag, self.content_object)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from hvad.admin import TranslatableAdmin
import autocomplete_light

from .models import Category, Item

class CategoryAdmin(TranslatableAdmin):
    model = Category

admin.site.register(Category, CategoryAdmin)


class ItemAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Item)
admin.site.register(Item, ItemAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
from autocomplete_light.contrib.hvad import AutocompleteModelBase
import autocomplete_light
from .models import Category

autocomplete_light.registry.autocomplete_model_base = AutocompleteModelBase

autocomplete_light.register(Category,
                            search_fields=('name',))

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from .models import Category, Item

class ItemForm(forms.ModelForm):
    class Meta:
        widgets = autocomplete_light.get_widgets_dict(Item)
        model = Item
        fields = ('category', )

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.core import urlresolvers
from hvad.models import TranslatableModel, TranslatedFields

class Category(TranslatableModel):
    translations = TranslatedFields(
        name = models.CharField(max_length=255, db_index=True),
        slug = models.SlugField(max_length=255),
    )

    class Meta:
        verbose_name_plural = "categories"

    def __unicode__(self):
        return self.safe_translation_getter('name', 'MyMode: %s' % self.pk)


class Item(models.Model):
    category = models.ForeignKey(Category, null=True, blank=True)

    def __unicode__(self):
        return u"Category: %s" % (self.category)

    def get_absolute_url(self):
        return urlresolvers.reverse('hvad_autocomplete:item_update',
                                    args=(self.pk,))

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views import generic

from forms import ItemForm
from models import Category, Item

urlpatterns = patterns('',
    url(r'item/add/$', generic.CreateView.as_view(
        model=Item, form_class=ItemForm)),
    url(r'item/(?P<pk>\d+)/update/$', generic.UpdateView.as_view(
        model=Item, form_class=ItemForm), name='item_update'),
)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from models import OutsideAdmin

admin.site.register(OutsideAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from models import OutsideAdmin

autocomplete_light.register(OutsideAdmin, search_fields=('name',))

########NEW FILE########
__FILENAME__ = models
from django.db import models

from tagging.fields import TagField
import tagging


class OutsideAdmin(models.Model):
    name = models.CharField(max_length=200)
    parent = models.ForeignKey('self', null=True, blank=True)
    tags = TagField(null=True, blank=True)

    def __unicode__(self):
        return self.name

tagging.register(OutsideAdmin, tag_descriptor_attr='etags')

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from views import FormsetView

urlpatterns = patterns('',
    url(r'$', FormsetView.as_view()),
)

########NEW FILE########
__FILENAME__ = views
from django.views import generic
from django.forms.models import modelformset_factory

import autocomplete_light

from models import OutsideAdmin


OutsideAdminModelForm = autocomplete_light.modelform_factory(OutsideAdmin, widgets={
    'tags': autocomplete_light.TextWidget('TagAutocomplete'),})
OutsideAdminModelFormset = modelformset_factory(OutsideAdmin, form=OutsideAdminModelForm)


class FormsetView(generic.FormView):
    form_class = OutsideAdminModelFormset
    template_name = 'inlines_outside_admin/formset.html'
    success_url = '/inlines_outside_admin/'

    def form_valid(self, form):
        form.save()
        return super(FormsetView, self).form_valid(form)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import VisitedCities


class VisitedCitiesInline(admin.TabularInline):
    form = autocomplete_light.modelform_factory(VisitedCities)
    model = VisitedCities


class VisitedCitiesAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(VisitedCities)
    inlines = [VisitedCitiesInline]


admin.site.register(VisitedCities, VisitedCitiesAdmin)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class VisitedCities(models.Model):
    cities = models.ManyToManyField('cities_light.City')
    parent = models.ForeignKey('self', null=True, blank=True)

    class Meta:
        verbose_name_plural = 'visited cities'

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_project.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from models import Widget

# in the case of this example, we could just have:
# WidgetForm = autocomplete_light.modelform_factory(Widget)
# but we'll not use this shortcut


class WidgetForm(forms.ModelForm):
    class Meta:
        widgets = autocomplete_light.get_widgets_dict(Widget)
        model = Widget

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.core import urlresolvers


class Widget(models.Model):
    city = models.ForeignKey('cities_light.city', null=True, blank=True)
    users = models.ManyToManyField('auth.user', blank=True)

    def get_absolute_url(self):
        return urlresolvers.reverse('non_admin:widget_update', args=(self.pk,))

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views import generic

from forms import WidgetForm
from models import Widget


urlpatterns = patterns('',
    url(r'widget/add/$', generic.CreateView.as_view(
        model=Widget, form_class=WidgetForm)),
    url(r'widget/(?P<pk>\d+)/update/$', generic.UpdateView.as_view(
        model=Widget, form_class=WidgetForm), name='widget_update'),
)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import ItemModel, CodeModel

class ItemModelAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(ItemModel)

admin.site.register(CodeModel)
admin.site.register(ItemModel, ItemModelAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from .models import CodeModel


class AutocompleteCode(autocomplete_light.AutocompleteModelBase):
    '''Autocomplete for non-id foreign key
    '''
    autocomplete_js_attributes = {'placeholder': u'Start type name...'}
    search_fields = ('name',)

    def choice_value(self, choice):
        return choice.code

    def choices_for_values(self):
        return self.order_choices(self.choices.filter(
            code__in=self.values or []))


autocomplete_light.register(CodeModel, AutocompleteCode)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class CodeModel(models.Model):
    code = models.CharField(max_length=4, unique=True)
    name = models.CharField(max_length=200)

    def __unicode__(self):
        return self.name


class ItemModel(models.Model):
    code = models.ForeignKey('CodeModel', to_field='code')
    name = models.CharField(max_length=200)

    def __unicode__(self):
        return self.name

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from forms import OptionnalTaggedItemForm
from models import OptionnalTaggedItem


class OptionnalTaggedItemAdmin(admin.ModelAdmin):
    form = OptionnalTaggedItemForm
admin.site.register(OptionnalTaggedItem, OptionnalTaggedItemAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light

from models import OptionnalTaggedItem


class OptionnalTaggedItemForm(autocomplete_light.GenericModelForm):
    """
    Use AutocompleteTaggableItems defined in
    gfk_autocomplete.autocomplete_light_registry.
    """
    content_object = autocomplete_light.GenericModelChoiceField(
        required=False, widget=autocomplete_light.ChoiceWidget(
            autocomplete='AutocompleteTaggableItems'))

    class Meta:
        model = OptionnalTaggedItem
        exclude = ('content_type', 'object_id')

########NEW FILE########
__FILENAME__ = models
from django.db import models

from django.contrib.contenttypes import generic


class OptionnalTaggedItem(models.Model):
    content_type = models.ForeignKey('contenttypes.contenttype',
        null=True, blank=True)
    object_id = models.PositiveIntegerField(null=True, blank=True)
    content_object = generic.GenericForeignKey('content_type', 'object_id')

    tag = models.CharField(max_length=100)

    def __unicode__(self):
        return u'%s %s' % (self.tag, self.content_object)

########NEW FILE########
__FILENAME__ = models
import cities_light

COUNTRIES = ('FR', 'US', 'BE', 'GB', 'ES', 'PT', 'DE', 'NL')


def filter_city_import(sender, items, **kwargs):
    if items[8] not in COUNTRIES:
        raise cities_light.InvalidItems()
cities_light.signals.city_items_pre_import.connect(filter_city_import)


def filter_region_import(sender, items, **kwargs):
    if items[0].split('.')[0] not in COUNTRIES:
        raise cities_light.InvalidItems()
cities_light.signals.region_items_pre_import.connect(filter_region_import)

########NEW FILE########
__FILENAME__ = forms
from django import forms

import autocomplete_light
from cities_light.models import City

from models import Event


class ScheduleForm(forms.ModelForm):
    street = forms.CharField(label='Street', max_length=30, required=False)
    city = forms.ModelChoiceField(label='City', queryset=City.objects.all(),
                widget=autocomplete_light.ChoiceWidget('CityAutocomplete'))

    class Meta:
        model = Event

########NEW FILE########
__FILENAME__ = models
from django.db import models

class Location(models.Model):
    street = models.CharField(max_length=50, blank=True)
    city = models.ForeignKey('cities_light.City')
    longitude = models.FloatField(blank=True, null=True)
    latitude = models.FloatField(blank=True, null=True)

class Event(models.Model):
    slug = models.CharField(max_length=128, blank=True)
    begin_date = models.DateField(null=True)
    location = models.ForeignKey(Location, blank=True, null=True)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url

from django.views import generic

from forms import ScheduleForm


urlpatterns = patterns('',
    url(r'form/$', generic.FormView.as_view(form_class=ScheduleForm,
        template_name='support_sandino/index.html',
        success_url='success/'), name='support_sandino'),
    url(r'success/', generic.TemplateView.as_view(
        template_name='support_sandino/success.html'),
        name='support_sandino_success'),
)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from models import TableWidget

from autocomplete_light import modelform_factory


class TableWidgetAdmin(admin.ModelAdmin):
    form = modelform_factory(TableWidget)
admin.site.register(TableWidget, TableWidgetAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from models import TableWidget


autocomplete_light.register(TableWidget,
    autocomplete_light.AutocompleteModelTemplate,
    widget_template='tablewidget_widget.html',
    choice_template='tablewidget_choice.html',
    autocomplete_template='tablewidget_autocomplete.html')

########NEW FILE########
__FILENAME__ = models
from django.db import models


class TableWidget(models.Model):
    name = models.CharField(max_length=255)

    widgets = models.ManyToManyField('self', blank=True)

    def __unicode__(self):
        return self.name

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import TemplatedChoice, TestModel

class TestModelAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(TestModel)

admin.site.register(TestModel, TestModelAdmin)
admin.site.register(TemplatedChoice)
########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from models import TemplatedChoice

autocomplete_light.register(TemplatedChoice, 
	autocomplete_light.AutocompleteModelTemplate, 
	choice_template='template_autocomplete/templated_choice.html')
########NEW FILE########
__FILENAME__ = models
from django.db import models


class TemplatedChoice(models.Model):
	name = models.CharField(max_length=100)

	class Meta:
		ordering = ('name',)

	def __unicode__(self):
		return self.name


class TestModel(models.Model):
	choices = models.ManyToManyField(TemplatedChoice)

	def __unicode__(self):
		return u', '.join(self.choices.values_list('name', flat=True))
########NEW FILE########
__FILENAME__ = settings
# Django settings for test_project project.

import os.path
import posixpath

PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

FIXTURE_DIRS = [
    os.path.join(PROJECT_ROOT, 'fixtures'),
]

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'db.sqlite',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

TEMPLATE_CONTEXT_PROCESSORS = ('django.contrib.auth.context_processors.auth',
 "django.core.context_processors.debug",
 'django.core.context_processors.debug',
 'django.core.context_processors.i18n',
 'django.core.context_processors.media',
 'django.core.context_processors.static',
 'django.core.context_processors.request',
 'django.core.context_processors.tz',
 'django.contrib.messages.context_processors.messages')


# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en'

# needed for hvad
LANGUAGES = (
  ('de', 'German'),
  ('en', 'English'),
)

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    os.path.join(PROJECT_ROOT, 'static'),
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'mzdvd*#0=$g(-!v_vj_7^(=zrh3klia(u&amp;cqd3nr7p^khh^ui#'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.locale.LocaleMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'test_project.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'test_project.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(PROJECT_ROOT, 'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    'generic_inline',
    'cities_light',
    'table_autocomplete',
    'djangorestframework',
    'south',
    'project_specific',
    'autocomplete_light',
    'charfield_pk_autocomplete',
    'charfield_autocomplete',
    'fk_autocomplete',
    'gfk_autocomplete',
    'optionnal_gfk_autocomplete',
    'genericm2m',
    'generic_m2m_autocomplete',
    'admin_test_autocomplete',
    'dependant_autocomplete',
    'm2m_autocomplete',
    'navigation_autocomplete',
    'docs_autocomplete',
    'inlines_outside_admin',
    'tagging',
    'template_autocomplete',
    'non_admin',
    'non_id_foreignkey',
    # test models
    'autocomplete_light.tests',
    'non_admin_add_another',
    'support_sandino',
    'default_template_autocomplete',
    'ajax_create',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'console':{
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.request': {
            'handlers':['console'],
            'propagate': True,
            'level':'DEBUG',
        },
        'cities_light': {
            'handlers':['console'],
            'propagate': True,
            'level':'DEBUG',
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.views import generic

import autocomplete_light
autocomplete_light.autodiscover()

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'test_project.views.home', name='home'),
    # url(r'^test_project/', include('test_project.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),

    url(r'support_sandino/', include('support_sandino.urls')),
    url(r'^non_admin/', include('non_admin.urls', namespace='non_admin')),
    url(r'^non_admin_add_another/', include('non_admin_add_another.urls',
        namespace='non_admin_add_another')),
    url(r'^double_loading/', generic.TemplateView.as_view(
        template_name='double_loading.html')),
    url(r'^autocomplete/', include('autocomplete_light.urls')),
    url(r'^navigation/', include('navigation_autocomplete.urls')),
    url(r'^default_template/', include('default_template_autocomplete.urls')),
    url(r'^cities_light/', include('cities_light.contrib.restframework')),
    url(r'^hvad_autocomplete/', include('hvad_autocomplete.urls',
                                        namespace='hvad_autocomplete')),
    url(r'^inlines_outside_admin/', include('inlines_outside_admin.urls',
                                            namespace='inlines_outside_admin')),
    (r'^i18n/', include('django.conf.urls.i18n')),
    (r'^just_javascript/$', generic.TemplateView.as_view(
        template_name='just_javascript.html')),
    (r'^$', generic.TemplateView.as_view(template_name='index.html'))
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for test_project project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_project.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import Foo, Bar


class FooInline(admin.TabularInline):
    model = Foo


class FooAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Foo)
admin.site.register(Foo, FooAdmin)


class BarAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Bar)
    inlines = [FooInline]
admin.site.register(Bar, BarAdmin)

########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from models import Foo, Bar

autocomplete_light.register(Foo)
autocomplete_light.register(Bar)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Foo(models.Model):
    name = models.CharField(max_length=100)
    bar = models.ForeignKey('Bar', related_name='bar_fk')

    def __unicode__(self):
        return self.name


class Bar(models.Model):
    name = models.CharField(max_length=100)

    def __unicode__(self):
        return self.name

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import Trip, City, Trip_City

from django.forms.widgets import HiddenInput

class Trip_CityInline(admin.TabularInline):
    model = Trip_City
    extra = 1
    form = autocomplete_light.modelform_factory(Trip_City)
    sortable_field_name = "order"
    fields = ['city', 'order']


class TripAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Trip)
    inlines = [Trip_CityInline]

admin.site.register(Trip, TripAdmin)
admin.site.register(City)


########NEW FILE########
__FILENAME__ = autocomplete_light_registry
import autocomplete_light

from models import City

autocomplete_light.register(City, search_fields=("city",))


########NEW FILE########
__FILENAME__ = models
from django.db import models


class City(models.Model):
    city = models.CharField(max_length=100)

    def __unicode__(self):
        return self.city


class Trip_City(models.Model):
    trip = models.ForeignKey('Trip')
    city = models.ForeignKey('City')
    order = models.PositiveSmallIntegerField()

    class Meta:
        ordering = ('order',)


class Trip(models.Model):
    name = models.CharField(max_length=200)
    cities = models.ManyToManyField(City, through=Trip_City)
########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_grappelli.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = settings
# Django settings for test_grappelli project.

import os
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'db.sqlite',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(PROJECT_ROOT, 'static'),
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '+*kglu(sy+pz%1ci+l=gl9znllim_9zpfnakt6y06wk5@h74ur'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'test_grappelli.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'test_grappelli.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(PROJECT_ROOT, 'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'grappelli',
    'django.contrib.admin',
    'autocomplete_light',
    'admin_test_autocomplete',
    'inline_autocomplete'
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
import autocomplete_light
autocomplete_light.autodiscover()
# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'test_grappelli.views.home', name='home'),
    # url(r'^test_grappelli/', include('test_grappelli.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
    (r'^grappelli/', include('grappelli.urls')),
    url(r'autocomplete/', include('autocomplete_light.urls')),

)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for test_grappelli project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_grappelli.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_project.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

urlpatterns = patterns('navigation_autocomplete.views',
    url(r'^$', 'navigation_autocomplete', name='navigation_autocomplete'),
)

########NEW FILE########
__FILENAME__ = views
from django import shortcuts
from django.db.models import Q
from django.contrib.auth.models import User, Group


def navigation_autocomplete(request,
    template_name='navigation_autocomplete/autocomplete.html'):

    q = request.GET.get('q', '')
    context = {'q': q}

    queries = {}
    queries['users'] = User.objects.filter(
        Q(username__icontains=q) |
        Q(first_name__icontains=q) |
        Q(last_name__icontains=q) |
        Q(email__icontains=q)
    ).distinct()[:3]
    queries['groups'] = Group.objects.filter(name__icontains=q)[:3]

    context.update(queries)

    return shortcuts.render(request, template_name, context)

########NEW FILE########
__FILENAME__ = settings
# Django settings for test_project project.
import os.path
import django

DEBUG = True
TEMPLATE_DEBUG = DEBUG

PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': os.path.join(PROJECT_ROOT, 'db.sqlite'),                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

FIXTURE_DIRS = [
    os.path.join(PROJECT_ROOT, 'fixtures'),
]

STATICFILES_DIRS = (
    os.path.join(PROJECT_ROOT, 'static'),
)

TEMPLATE_DIRS = (
    os.path.join(PROJECT_ROOT, 'templates'),
)


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'console':{
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.request': {
            'handlers':['console'],
            'propagate': True,
            'level':'DEBUG',
        },
        'cities_light': {
            'handlers':['console'],
            'propagate': True,
            'level':'DEBUG',
        },
    }
}

# Hosts/domain names that are valid for this site; required if DEBUG is False
# See https://docs.djangoproject.com/en/1.5/ref/settings/#allowed-hosts
ALLOWED_HOSTS = []

SITE_ID = 1

STATIC_URL = '/static/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = '^le6=#%$1z63o!#z^qr(r+^ix&iqx)@h*u$@8$bu&n8cv6m)go'

ROOT_URLCONF = 'test_project.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'test_project.wsgi.application'

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.admin',

    'cities_light',

    'autocomplete_light',
    'autocomplete_light.example_apps.basic',
    'autocomplete_light.example_apps.music',
    'autocomplete_light.example_apps.autocomplete_test_case_app',
    'autocomplete_light.example_apps.security_test',
    'autocomplete_light.example_apps.dependant_autocomplete',
    'autocomplete_light.example_apps.non_admin_add_another',

    'navigation_autocomplete',
)


if django.VERSION < (1, 7):
    INSTALLED_APPS += ('south',)


try:
    import genericm2m
except ImportError:
    pass
else:
    INSTALLED_APPS += ('genericm2m',)

try:
    import taggit
except ImportError:
    pass
else:
    INSTALLED_APPS += ('taggit',)

SESSION_SERIALIZER = 'django.contrib.sessions.serializers.JSONSerializer'

TEST_RUNNER = 'django.test.simple.DjangoTestSuiteRunner'

SOUTH_MIGRATION_MODULES = {
    'taggit': 'taggit.south_migrations',
    'cities_light': 'cities_light.south_migrations',
}

########NEW FILE########
__FILENAME__ = settings_postgres
import os

from .settings import *

# NOTE: environment set by pg_virtualenv
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': os.environ.get('PGDATABASE', 'autocomplete_light_test'),
        'USER': os.environ.get('PGUSER', 'postgres'),
        'PASSWORD': os.environ.get('PGPASSWORD', ''),
        'HOST': os.environ.get('PGHOST', ''),
        'PORT': os.environ.get('PGPORT', ''),
    }
}



########NEW FILE########
__FILENAME__ = urls
import django

from django.conf.urls import patterns, include, url
from django.views import generic

if django.VERSION < (1, 7):
    import autocomplete_light
    autocomplete_light.autodiscover()

from django.contrib import admin
admin.autodiscover()

try:
    from hvad_autocomplete import urls as hvad
except ImportError:
    # django 1.6 not support by hvad
    hvad = None

urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^autocomplete/', include('autocomplete_light.urls')),
    url(r'^navigation/', include('navigation_autocomplete.urls')),
    url(r'^security_test/',
        include('autocomplete_light.example_apps.security_test.urls')),
    url(r'^non_admin_add_another/',
        include('autocomplete_light.example_apps.non_admin_add_another.urls')),
    (r'^favicon.ico', generic.RedirectView.as_view(url='http://mozilla.org/favicon.ico')),
    (r'^$', generic.TemplateView.as_view(template_name='index.html'))
)

from django.contrib.staticfiles.urls import staticfiles_urlpatterns
urlpatterns += staticfiles_urlpatterns()

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for test_project project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

# We defer to a DJANGO_SETTINGS_MODULE already in the environment. This breaks
# if running multiple sites in the same mod_wsgi process. To fix this, use
# mod_wsgi daemon mode with each site in its own daemon process, or use
# os.environ["DJANGO_SETTINGS_MODULE"] = "test_project.settings"
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_project.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_remote_project.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

import autocomplete_light

from models import *


class AddressAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Address)
admin.site.register(Address, AddressAdmin)


########NEW FILE########
__FILENAME__ = autocomplete_light_registry
from cities_light.contrib.autocompletes import *

import autocomplete_light


autocomplete_light.register(Country, CountryRestAutocomplete,
    source_url='http://localhost:8000/cities_light/country/')

autocomplete_light.register(Region, RegionRestAutocomplete,
    source_url='http://localhost:8000/cities_light/region/')

autocomplete_light.register(City, CityRestAutocomplete,
    source_url='http://localhost:8000/cities_light/city/')

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Address(models.Model):
    city = models.ForeignKey('cities_light.city')

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = admin

from django.contrib import admin

import autocomplete_light

from models import *


class AddressInline(admin.TabularInline):
    model = Address
    form = autocomplete_light.modelform_factory(Address)


class AddressAdmin(admin.ModelAdmin):
    form = autocomplete_light.modelform_factory(Address)
    inlines = [AddressInline]
admin.site.register(Address, AddressAdmin)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Address(models.Model):
    city = models.ForeignKey('cities_light.city', related_name='address_inline_set')
    parent = models.ForeignKey('self', null=True, blank=True, related_name='children')

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = settings
# Django settings for test_remote_project project.

import os.path
import posixpath

PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

FIXTURE_DIRS = [
    os.path.join(PROJECT_ROOT, 'fixtures'),
]

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'db.sqlite',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    os.path.join(PROJECT_ROOT, 'static'),
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'mzdvd*#0=$g(-!v_vj_7^(=zrh3klia(u&amp;cqd3nr7p^khh^ui#'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'test_remote_project.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'test_remote_project.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(PROJECT_ROOT, 'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    'cities_light',
    'djangorestframework',
    'south',
    'autocomplete_light',
    'remote_autocomplete',
    'remote_autocomplete_inline',
    'navigation_autocomplete',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'console':{
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.request': {
            'handlers':['console'],
            'propagate': True,
            'level':'DEBUG',
        },
        'cities_light': {
            'handlers':['console'],
            'propagate': True,
            'level':'DEBUG',
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url

import autocomplete_light
autocomplete_light.autodiscover()

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'test_project.views.home', name='home'),
    # url(r'^test_project/', include('test_project.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),

    url(r'^autocomplete/', include('autocomplete_light.urls')),
    url(r'^navigation/', include('navigation_autocomplete.urls')),
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for test_remote_project project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_remote_project.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
