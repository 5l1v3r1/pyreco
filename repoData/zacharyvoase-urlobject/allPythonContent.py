__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# URLObject documentation build configuration file, created by
# sphinx-quickstart on Sat Feb 11 19:49:37 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'URLObject'
copyright = '2012, Zachary Voase'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.3.4'
# The full version, including alpha/beta/rc tags.
release = '2.3.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['.build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'URLObjectdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'URLObject.tex', 'URLObject Documentation',
   'Zachary Voase', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'urlobject', 'URLObject Documentation',
     ['Zachary Voase'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'URLObject', 'URLObject Documentation',
   'Zachary Voase', 'URLObject', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = netloc_test
import unittest

from nose.tools import assert_raises

from urlobject.netloc import Netloc


class NetlocTest(unittest.TestCase):

    def test_preserves_equality_of_the_original_string(self):
        netloc = 'zack:1234@github.com:443'
        assert Netloc(netloc) == netloc

    def test_preserves_hash_of_the_original_string(self):
        netloc = 'zack:1234@github.com:443'
        assert hash(Netloc(netloc)) == hash(netloc)

    def test_username(self):
        assert Netloc('github.com').username is None
        assert Netloc('zack@github.com').username == 'zack'
        assert Netloc('zack:1234@github.com').username == 'zack'

    def test_with_username_adds_username(self):
        assert Netloc('github.com').with_username('zack') == 'zack@github.com'

    def test_with_username_replaces_username(self):
        assert (Netloc('zack@github.com').with_username('alice') ==
                'alice@github.com')
        assert (Netloc('zack:1234@github.com').with_username('alice') ==
                'alice:1234@github.com')

    def test_without_username_removes_username(self):
        assert Netloc('github.com').without_username() == 'github.com'
        assert Netloc('zack@github.com').without_username() == 'github.com'
        # Removing the username will also remove the password.
        assert Netloc('zack:1234@github.com:443').without_username() == 'github.com:443'

    def test_password(self):
        assert Netloc('github.com').password is None
        assert Netloc('zack@github.com').password is None
        assert Netloc('zack:1234@github.com').password == '1234'

    def test_with_password_adds_password(self):
        assert (Netloc('zack@github.com').with_password('1234') ==
                'zack:1234@github.com')

    def test_with_password_replaces_password(self):
        assert (Netloc('zack:1234@github.com:443').with_password('5678') ==
                'zack:5678@github.com:443')

    def test_with_password_on_a_netloc_with_no_username_raises_ValueError(self):
        assert_raises(ValueError,
                      lambda: Netloc('github.com').with_password('1234'))

    def test_with_auth_with_one_arg_adds_username(self):
        assert (Netloc('github.com').with_auth('zack') ==
                'zack@github.com')

    def test_auth(self):
        assert Netloc('github.com').auth == (None, None)
        assert Netloc('zack@github.com').auth == ('zack', None)
        assert Netloc('zack:1234@github.com').auth == ('zack', '1234')

    def test_with_auth_with_one_arg_replaces_whole_auth_string_with_username(self):
        assert (Netloc('alice:1234@github.com').with_auth('zack') ==
                'zack@github.com')

    def test_with_auth_with_two_args_adds_username_and_password(self):
        assert (Netloc('github.com').with_auth('zack', '1234') ==
                'zack:1234@github.com')

    def test_with_auth_with_two_args_replaces_whole_auth_string_with_username_and_password(self):
        # Replaces username-only auth string
        assert (Netloc('alice@github.com').with_auth('zack', '1234') ==
                'zack:1234@github.com')

        # Replaces username and password.
        assert (Netloc('alice:4567@github.com').with_auth('zack', '1234') ==
                'zack:1234@github.com')

    def test_without_auth_removes_entire_auth_string(self):
        # No username or password => no-op.
        netloc = Netloc('github.com')
        assert netloc.without_auth() == 'github.com'
        # Username-only.
        netloc = Netloc('alice@github.com')
        assert netloc.without_auth() == 'github.com'
        # Username and password.
        netloc = Netloc('alice:1234@github.com')
        assert netloc.without_auth() == 'github.com'

    def test_hostname(self):
        assert Netloc('zack:1234@github.com:443').hostname == 'github.com'

    def test_with_hostname_replaces_hostname(self):
        assert (Netloc('zack:1234@github.com:443').with_hostname('example.com') ==
                'zack:1234@example.com:443')

    def test_port(self):
        assert Netloc('github.com:443').port == 443
        assert Netloc('github.com').port is None

    def test_with_port_adds_port(self):
        assert Netloc('github.com').with_port(443) == 'github.com:443'

    def test_with_port_replaces_port(self):
        assert Netloc('github.com:443').with_port(80) == 'github.com:80'

    def test_without_port_removes_port(self):
        assert Netloc('github.com:443').without_port() == 'github.com'

########NEW FILE########
__FILENAME__ = path_test
# -*- coding: utf-8 -*-

import unittest

from urlobject.path import URLPath
from urlobject.six import u


class URLPathTest(unittest.TestCase):

    def test_preserves_equality_with_original_string(self):
        assert URLPath('/a/b/c') == '/a/b/c'
        assert URLPath('a/b/c') == 'a/b/c'

    def test_root_always_returns_the_root_path(self):
        assert URLPath.root == '/'
        assert URLPath('/').root == '/'
        assert URLPath('/a/b/c').root == '/'

    def test_preserves_hash_of_the_original_string(self):
        assert hash(URLPath('/a/b/c')) == hash('/a/b/c')

    def test_segments_breaks_the_path_into_segments(self):
        assert URLPath('/a/b/c').segments == ('a', 'b', 'c')
        assert URLPath('/a/b/c/').segments == ('a', 'b', 'c', '')
        assert URLPath('a/b/c').segments == ('a', 'b', 'c')

    def test_segments_decodes_percent_escapes(self):
        assert URLPath('/a%20b/c%2Fd/').segments == ('a b', 'c/d', '')

    def test_join_segments_joins_segments_into_a_single_path(self):
        assert URLPath.join_segments(('a', 'b', 'c')) == '/a/b/c'
        assert URLPath.join_segments(('a', 'b', 'c', '')) == '/a/b/c/'

    def test_join_segments_can_create_relative_paths(self):
        assert URLPath.join_segments(('a', 'b', 'c'), absolute=False) == 'a/b/c'
        assert URLPath.join_segments(('a', 'b', 'c', ''), absolute=False) == 'a/b/c/'

    def test_join_segments_encodes_non_ascii_and_special_characters_including_slash(self):
        assert URLPath.join_segments(('a b', u('d/\N{LATIN SMALL LETTER E WITH ACUTE}'))) == '/a%20b/d%2F%C3%A9'

    def test_is_leaf_node(self):
        assert URLPath('/a/b/c').is_leaf
        assert not URLPath('/a/b/c/').is_leaf

    def test_is_relative_equals_not_is_absolute(self):
        assert URLPath('a/b/c').is_relative
        assert not URLPath('/a/b/c').is_relative
        assert not URLPath('a/b/c').is_absolute
        assert URLPath('/a/b/c').is_absolute

    def test_parent_of_a_leaf_node(self):
        assert URLPath('/a/b/c').parent == '/a/b/'

    def test_parent_of_a_non_leaf_node(self):
        assert URLPath('/a/b/c/').parent == '/a/b/'

    def test_relative_on_a_leaf_node(self):
        path = URLPath('/a/b/c')
        assert path.relative('.') == '/a/b/'
        assert path.relative('d') == '/a/b/d'
        assert path.relative('..') == '/a/'
        assert path.relative('../d') == '/a/d'
        assert path.relative('/') == '/'
        assert path.relative('/d') == '/d'

    def test_relative_on_a_non_leaf_node(self):
        path = URLPath('/a/b/c/')
        assert path.relative('.') == '/a/b/c/'
        assert path.relative('d') == '/a/b/c/d'
        assert path.relative('..') == '/a/b/'
        assert path.relative('../d') == '/a/b/d'
        assert path.relative('/') == '/'
        assert path.relative('/d') == '/d'

    def test_add_segment_adds_path_segments_to_a_path(self):
        assert URLPath('').add_segment('a') == 'a'
        assert URLPath('/').add_segment('a') == '/a'
        assert URLPath('/a/b/c').add_segment('d') == '/a/b/c/d'
        assert URLPath('/a/b/c').add_segment('d/') == '/a/b/c/d%2F'

    def test_add_segment_encodes_non_ascii_and_reserved_characters(self):
        assert URLPath('/a/b/c').add_segment(u('d \N{LATIN SMALL LETTER E WITH ACUTE}')) == '/a/b/c/d%20%C3%A9'

    def test_add_segment_encodes_slash_characters(self):
        assert URLPath('/a/b/c').add_segment('d/e') == '/a/b/c/d%2Fe'

    def test_add_concatenates_whole_paths(self):
        assert URLPath('').add('a') == 'a'
        assert URLPath('/').add('a') == '/a'
        assert URLPath('/a/b/c').add('d') == '/a/b/c/d'
        assert URLPath('/a/b/c').add('d/') == '/a/b/c/d/'
        assert URLPath('/a/b/c').add('d/e/f') == '/a/b/c/d/e/f'

    def test_add_encodes_non_ascii_and_reserved_characters(self):
        assert URLPath('/a/b/c').add(u('d /\N{LATIN SMALL LETTER E WITH ACUTE}')) == '/a/b/c/d%20/%C3%A9'

    def test_add_does_not_encode_slash_characters(self):
        assert URLPath('/a/b/c').add('d/e') == '/a/b/c/d/e'

########NEW FILE########
__FILENAME__ = querystring_test
# -*- coding: utf-8 -*-

import unittest

from urlobject.query_string import QueryString
from urlobject.six import u


class QueryStringTest(unittest.TestCase):

    def test_preserves_equality_with_original_string(self):
        assert QueryString('abc=123') == 'abc=123'

    def test_preserves_hash_value_of_original_string(self):
        assert hash(QueryString('abc=123')) == hash('abc=123')

    def test_list_returns_an_empty_list_for_empty_QueryStrings(self):
        assert QueryString('').list == []

    def test_list_correctly_splits_on_ampersands(self):
        assert QueryString('abc=123&def=456').list == [
            ('abc', '123'), ('def', '456')]

    def test_list_correctly_splits_on_semicolons(self):
        assert QueryString('abc=123;def=456').list == [
            ('abc', '123'), ('def', '456')]

    def test_list_correctly_decodes_special_chars(self):
        assert QueryString('a%20b=c%20d').list == [('a b', 'c d')]
        assert QueryString('a+b=c+d').list == [('a b', 'c d')]
        assert (QueryString('my%20weird%20field=q1!2%22\'w%245%267%2Fz8)%3F').list ==
                [('my weird field', 'q1!2"\'w$5&7/z8)?')])

    def test_list_correctly_decodes_utf_8(self):
        assert QueryString('foo=%EF%BF%BD').list == [('foo', u('\ufffd'))]

    def test_list_doesnt_split_on_percent_encoded_special_chars(self):
        assert QueryString('a%26b%3Dc%3F=a%26b%3Dc%3F').list == [
            ('a&b=c?', 'a&b=c?')]

    def test_list_doesnt_break_if_two_parameters_have_the_same_name(self):
        assert QueryString('abc=123;abc=456').list == [
            ('abc', '123'), ('abc', '456')]

    def test_list_uses_none_as_the_value_for_valueless_parameters(self):
        assert QueryString('abc').list == [('abc', None)]
        assert QueryString('abc=123&def&ghi=456').list == [
            ('abc', '123'), ('def', None), ('ghi', '456')]

    def test_list_uses_empty_string_for_empty_valued_parameters(self):
        assert QueryString('abc=').list == [('abc', '')]
        assert QueryString('abc=123&def=&ghi=456').list == [
            ('abc', '123'), ('def', ''), ('ghi', '456')]

    def test_list_uses_empty_string_for_anonymous_parameters(self):
        assert QueryString('=123').list == [('', '123')]
        assert QueryString('abc=123&=456&ghi=789').list == [
            ('abc', '123'), ('', '456'), ('ghi', '789')]

    def test_list_can_handle_void_parameters(self):
        assert QueryString('abc=123&&def=456').list == [
            ('abc', '123'), ('', None), ('def', '456')]
        assert QueryString('abc=123&=&def=456').list == [
            ('abc', '123'), ('', ''), ('def', '456')]

    def test_dict_returns_a_dictionary_with_one_value_per_key(self):
        assert QueryString('abc=123&abc=456').dict == {'abc': '456'}

    def test_multi_dict_returns_a_dictionary_with_all_values_per_key(self):
        assert QueryString('abc=123&abc=456').multi_dict == {
            'abc': ['123', '456']}

    def test_add_param_encodes_and_adds_the_given_parameter_to_the_QueryString(self):
        s = QueryString('')
        assert s.add_param('abc', '123') == 'abc=123'
        assert (s.add_param('abc', '123')
                 .add_param('def', '456') == 'abc=123&def=456')

    def test_add_param_can_add_valueless_parameters(self):
        s = QueryString('abc=123')
        assert s.add_param('def', None) == 'abc=123&def'

    def test_add_param_can_add_empty_valued_parameters(self):
        s = QueryString('abc=123')
        assert s.add_param('def', '') == 'abc=123&def='

    def test_add_param_can_add_anonymous_parameters(self):
        s = QueryString('abc=123')
        assert s.add_param('', '456') == 'abc=123&=456'

    def test_add_param_encodes_utf8(self):
        s = QueryString('abc=123')
        assert s.add_param('foo', u('\ufffd')) == 'abc=123&foo=%EF%BF%BD'

    def test_add_param_allows_the_same_parameter_name_to_be_added_twice(self):
        s = QueryString('abc=123')
        assert s.add_param('abc', '456') == 'abc=123&abc=456'

    def test_add_param_encodes_special_characters(self):
        s = QueryString('abc=123')
        assert s.add_param('d e f', '4+5#6') == 'abc=123&d+e+f=4%2B5%236'

    def test_set_param_replaces_existing_parameter_names(self):
        s = QueryString('abc=123&abc=456')
        assert s.set_param('abc', '789') == 'abc=789'

    def test_del_param_removes_all_instances_of_the_parameter_from_the_QueryString(self):
        s = QueryString('abc=123&def=456&abc=789')
        assert s.del_param('abc') == 'def=456'
        assert s.del_param('def') == 'abc=123&abc=789'

    def test_del_param_can_remove_valueless_parameters(self):
        valueless = QueryString('abc=123&def&abc=456')
        empty_valued = QueryString('abc=123&def=&abc=456')
        assert valueless.del_param('def') == 'abc=123&abc=456'
        assert empty_valued.del_param('def') == 'abc=123&abc=456'

    def test_del_param_can_remove_anonymous_parameters(self):
        s = QueryString('abc=123&=456&def=789')
        assert s.del_param('') == 'abc=123&def=789'

    def test_add_params_is_equivalent_to_calling_add_param_multiple_times(self):
        s = QueryString('')
        assert (s.add_params([('abc', '123'), ('def', '456')]) ==
                s.add_param('abc', '123').add_param('def', '456'))

    def test_add_params_accepts_the_same_args_as_dict(self):
        s = QueryString('')
        added = s.add_params({'abc': '123'}, foo='bar', xyz='456')
        assert added.dict == {'abc': '123', 'foo': 'bar', 'xyz': '456'}
        added2 = s.add_params([('abc', '123')], foo='bar', xyz='456')
        assert added2.dict == {'abc': '123', 'foo': 'bar', 'xyz': '456'}
        # It also has to fail in the same way as `dict`. If you pass more than
        # one positional argument it should raise a TypeError.
        self.assertRaises(TypeError,
                          s.add_params, {'abc': '123'}, {'foo': 'bar'})

    def test_add_params_accepts_the_same_parameter_name_multiple_times(self):
        s = (QueryString('')
             .add_params([('abc', '123'), ('abc', '456')]))
        assert s.list == [('abc', '123'), ('abc', '456')]

    def test_add_params_with_multiple_values_adds_the_same_parameter_multiple_times(self):
        s = QueryString('')
        assert (s.add_params({'foo': ['bar', 'baz']}) ==
                s.add_param('foo', 'bar').add_param('foo', 'baz'))

    def test_set_params_is_equivalent_to_calling_set_param_multiple_times(self):
        s = QueryString('')
        assert (s.set_params([('abc', '123'), ('def', '456')]) ==
                s.set_param('abc', '123').set_param('def', '456'))

    def test_set_params_accepts_the_same_args_as_dict(self):
        s = QueryString('')
        added = s.set_params({'abc': '123'}, abc='456')
        assert added.dict == {'abc': '456'}
        added2 = s.set_params([('abc', '123')], abc='456')
        assert added2.dict == {'abc': '456'}

    def test_set_params_accepts_the_same_parameter_name_multiple_times(self):
        s = (QueryString('')
             .set_params([('abc', '123'), ('abc', '456')]))
        assert s.list == [('abc', '456')]

    def test_set_params_with_multiple_values_sets_the_same_name_multiple_times(self):
        s = QueryString('foo=spam')
        assert (s.set_params({'foo': ['bar', 'baz']}) ==
                'foo=bar&foo=baz')
        s2 = QueryString('foo=bar&foo=baz')
        assert (s2.set_params({'foo': ['spam', 'ham']}) ==
                'foo=spam&foo=ham')

    def test_del_params_accepts_an_iterable_and_removes_all_listed_parameters(self):
        s = QueryString('abc=123&def=456&xyz=789')
        assert s.del_params(('abc', 'xyz')) == 'def=456'

########NEW FILE########
__FILENAME__ = urlobject_test
import platform
import doctest
import unittest

from nose.tools import assert_raises
from urlobject import urlobject as urlobject_module
from urlobject import URLObject
from urlobject.six import text_type, u, print_


def dictsort(d):
    """``repr()`` a dictionary with sorted key/value pairs, for doctests."""
    items = sorted(d.items())
    print_('{' + ', '.join('%r: %r' % (k, v) for k, v in items) + '}')


class URLObjectTest(unittest.TestCase):

    def setUp(self):
        self.url_string = u("https://github.com/zacharyvoase/urlobject?spam=eggs#foo")

    def test_urlobject_preserves_equality_with_the_original_string(self):
        assert URLObject(self.url_string) == self.url_string

    def test_urlobject_preserves_the_hash_of_the_original_string(self):
        assert hash(URLObject(self.url_string)) == hash(self.url_string)

    def test_calling_unicode_on_a_urlobject_returns_a_normal_string(self):
        url = URLObject(self.url_string)
        # Normally `type(x) is Y` is a bad idea, but it's exactly what we want.
        assert type(text_type(url)) is text_type
        assert text_type(url) == self.url_string


class SphinxDoctestsTest(unittest.TestCase):

    def test__doctest(self):
        result = doctest.testmod(urlobject_module,
                                 extraglobs={'dictsort': dictsort})
        if platform.python_version() < '3.2':
            # Don't run doctests on pre-3.2.
            return
        failed = result.failed
        attempted = result.attempted
        self.assertTrue(attempted > 0, "No doctests were found")
        self.assertEquals(failed, 0, "There are failed doctests")


class URLObjectRelativeTest(unittest.TestCase):

    def setUp(self):
        self.url = URLObject("https://github.com/zacharyvoase/urlobject?spam=eggs#foo")

    def test_relative_with_scheme_returns_the_given_URL(self):
        assert self.url.relative('http://example.com/abc') == 'http://example.com/abc'

    def test_relative_with_netloc_returns_the_given_URL_but_preserves_scheme(self):
        assert self.url.relative('//example.com/abc') == 'https://example.com/abc'

    def test_relative_with_path_replaces_path_and_removes_query_string_and_fragment(self):
        assert self.url.relative('another-project') == 'https://github.com/zacharyvoase/another-project'
        assert self.url.relative('.') == 'https://github.com/zacharyvoase/'
        assert self.url.relative('/dvxhouse/intessa') == 'https://github.com/dvxhouse/intessa'
        assert self.url.relative('/dvxhouse/intessa') == 'https://github.com/dvxhouse/intessa'

    def test_relative_with_empty_string_removes_fragment_but_preserves_query(self):
        # The empty string is treated as a path meaning 'the current location'.
        assert self.url.relative('') == self.url.without_fragment()

    def test_relative_with_query_string_removes_fragment(self):
        assert self.url.relative('?name=value') == self.url.without_fragment().with_query('name=value')

    def test_relative_with_fragment_removes_nothing(self):
        assert self.url.relative('#foobar') == self.url.with_fragment('foobar')

    def test_compound_relative_urls(self):
        assert self.url.relative('//example.com/a/b') == 'https://example.com/a/b'
        assert self.url.relative('//example.com/a/b#bar') == 'https://example.com/a/b#bar'
        assert self.url.relative('//example.com/a/b?c=d#bar') == 'https://example.com/a/b?c=d#bar'
        assert self.url.relative('/a/b?c=d#bar') == 'https://github.com/a/b?c=d#bar'
        assert self.url.relative('?c=d#bar') == 'https://github.com/zacharyvoase/urlobject?c=d#bar'
        assert self.url.relative('#bar') == 'https://github.com/zacharyvoase/urlobject?spam=eggs#bar'



class URLObjectPropertyTest(unittest.TestCase):

    def setUp(self):
        self.url = URLObject("https://github.com/zacharyvoase/urlobject?spam=eggs#foo")

    def test_scheme_returns_scheme(self):
        assert self.url.scheme == 'https'

    def test_netloc_returns_netloc(self):
        assert self.url.netloc == 'github.com'

    def test_hostname_returns_hostname(self):
        assert self.url.hostname == 'github.com'
        url = URLObject("https://user:pass@github.com:443")
        assert url.hostname == 'github.com'

    def test_port_returns_port_or_None(self):
        assert self.url.port is None
        assert URLObject("https://github.com:412").port == 412

    def test_default_port_returns_default_port_when_none_specified(self):
        assert self.url.default_port == 443

    def test_default_port_returns_given_port_when_one_is_specified(self):
        assert URLObject("https://github.com:412").default_port == 412

    def test_path_returns_path(self):
        assert self.url.path == '/zacharyvoase/urlobject'

    def test_query_returns_query(self):
        assert self.url.query == 'spam=eggs'

    def test_query_list_returns_a_list_of_query_params(self):
        assert self.url.query_list == [('spam', 'eggs')]

    def test_query_dict_returns_a_dict_of_query_params(self):
        assert self.url.query_dict == {'spam': 'eggs'}

    def test_query_multi_dict_returns_a_multi_dict_of_query_params(self):
        url = URLObject('https://example.com/?spam=eggs&spam=ham&foo=bar')
        assert url.query_multi_dict == {'spam': ['eggs', 'ham'],
                                        'foo': ['bar']}

    def test_fragment_returns_fragment(self):
        assert self.url.fragment == 'foo'

    def test_fragment_is_decoded_correctly(self):
        url = URLObject('https://example.com/#frag%20ment')
        assert url.fragment == 'frag ment'

    def test_auth_properties_can_parse_username_and_password(self):
        url = URLObject('https://zack:12345@github.com/')
        assert url.username == 'zack'
        assert url.password == '12345'
        assert url.auth == ('zack', '12345')

    def test_auth_properties_can_parse_username(self):
        url = URLObject('https://zack@github.com/')
        assert url.username == 'zack'
        assert url.password is None
        assert url.auth == ('zack', None)

    def test_auth_properties_return_None_with_no_username_or_password(self):
        url = URLObject('https://github.com/')
        assert url.username is None
        assert url.password is None
        assert url.auth == (None, None)


class URLObjectModificationTest(unittest.TestCase):

    def setUp(self):
        self.url = URLObject('https://github.com/zacharyvoase/urlobject?spam=eggs#foo')

    def test_with_scheme_replaces_scheme(self):
        assert (self.url.with_scheme('http') ==
                'http://github.com/zacharyvoase/urlobject?spam=eggs#foo')

    def test_with_netloc_replaces_netloc(self):
        assert (self.url.with_netloc('example.com') ==
                'https://example.com/zacharyvoase/urlobject?spam=eggs#foo')

    def test_with_hostname_replaces_hostname(self):
        url = URLObject('https://user:pass@github.com/')
        assert (url.with_hostname('example.com') ==
                'https://user:pass@example.com/')

    def test_with_username_adds_username(self):
        url = URLObject('https://github.com/')
        assert url.with_username('zack') == 'https://zack@github.com/'

    def test_with_username_replaces_username(self):
        url = URLObject('https://zack@github.com/')
        assert url.with_username('alice') == 'https://alice@github.com/'

    def test_without_username_removes_username(self):
        url = URLObject('https://zack@github.com/')
        assert url.without_username() == 'https://github.com/'

    def test_with_password_adds_password(self):
        url = URLObject('https://zack@github.com/')
        assert url.with_password('1234') == 'https://zack:1234@github.com/'

    def test_with_password_raises_ValueError_when_there_is_no_username(self):
        url = URLObject('https://github.com/')
        assert_raises(ValueError, lambda: url.with_password('1234'))

    def test_with_password_replaces_password(self):
        url = URLObject('https://zack:1234@github.com/')
        assert url.with_password('5678') == 'https://zack:5678@github.com/'

    def test_without_password_removes_password(self):
        url = URLObject('https://zack:1234@github.com/')
        assert url.without_password() == 'https://zack@github.com/'

    def test_with_auth_with_one_arg_adds_username(self):
        url = URLObject('https://github.com/')
        assert url.with_auth('zack') == 'https://zack@github.com/'

    def test_with_auth_with_one_arg_replaces_whole_auth_string_with_username(self):
        url = URLObject('https://alice:1234@github.com/')
        assert url.with_auth('zack') == 'https://zack@github.com/'

    def test_with_auth_with_two_args_adds_username_and_password(self):
        url = URLObject('https://github.com/')
        assert url.with_auth('zack', '1234') == 'https://zack:1234@github.com/'

    def test_with_auth_with_two_args_replaces_whole_auth_string_with_username_and_password(self):
        # Replaces username-only auth string
        url = URLObject('https://alice@github.com/')
        assert url.with_auth('zack', '1234') == 'https://zack:1234@github.com/'

        # Replaces username and password.
        url = URLObject('https://alice:4567@github.com/')
        assert url.with_auth('zack', '1234') == 'https://zack:1234@github.com/'

    def test_without_auth_removes_entire_auth_string(self):
        # No username or password => no-op.
        url = URLObject('https://github.com/')
        assert url.without_auth() == 'https://github.com/'
        # Username-only.
        url = URLObject('https://alice@github.com/')
        assert url.without_auth() == 'https://github.com/'
        # Username and password.
        url = URLObject('https://alice:1234@github.com/')
        assert url.without_auth() == 'https://github.com/'

    def test_with_port_adds_port_number(self):
        assert (self.url.with_port(24) ==
                'https://github.com:24/zacharyvoase/urlobject?spam=eggs#foo')

    def test_with_port_replaces_port_number(self):
        url = URLObject('https://github.com:59/')
        assert url.with_port(67) == 'https://github.com:67/'

    def test_without_port_removes_port_number(self):
        url = URLObject('https://github.com:59/')
        assert url.without_port() == 'https://github.com/'

    def test_with_path_replaces_path(self):
        assert (self.url.with_path('/dvxhouse/intessa') ==
                'https://github.com/dvxhouse/intessa?spam=eggs#foo')

    def test_root_goes_to_root_path(self):
        assert self.url.root == 'https://github.com/?spam=eggs#foo'

    def test_parent_jumps_up_one_level(self):
        url = URLObject('https://github.com/zacharyvoase/urlobject')
        assert url.parent == 'https://github.com/zacharyvoase/'
        assert url.parent.parent == 'https://github.com/'

    def test_add_path_segment_adds_a_path_segment(self):
        url = URLObject('https://github.com/zacharyvoase/urlobject')
        assert (url.add_path_segment('tree') ==
                'https://github.com/zacharyvoase/urlobject/tree')
        assert (url.add_path_segment('tree/master') ==
                'https://github.com/zacharyvoase/urlobject/tree%2Fmaster')

    def test_add_path_adds_a_partial_path(self):
        url = URLObject('https://github.com/zacharyvoase/urlobject')
        assert (url.add_path('tree') ==
                'https://github.com/zacharyvoase/urlobject/tree')
        assert (url.add_path('tree/master') ==
                'https://github.com/zacharyvoase/urlobject/tree/master')

    def test_is_leaf(self):
        assert URLObject('https://github.com/zacharyvoase/urlobject').is_leaf
        assert not URLObject('https://github.com/zacharyvoase/').is_leaf

    def test_with_query_replaces_query(self):
        assert (self.url.with_query('spam-ham-eggs') ==
                'https://github.com/zacharyvoase/urlobject?spam-ham-eggs#foo')

    def test_without_query_removes_query(self):
        assert (self.url.without_query() ==
                'https://github.com/zacharyvoase/urlobject#foo')

    def test_add_query_param_adds_one_query_parameter(self):
        assert (self.url.add_query_param('spam', 'ham') ==
                'https://github.com/zacharyvoase/urlobject?spam=eggs&spam=ham#foo')

    def test_add_query_params_adds_multiple_query_parameters(self):
        assert (self.url.add_query_params([('spam', 'ham'), ('foo', 'bar')]) ==
                'https://github.com/zacharyvoase/urlobject?spam=eggs&spam=ham&foo=bar#foo')

    def test_add_query_params_with_multiple_values_adds_the_same_query_parameter_multiple_times(self):
        assert (self.url.add_query_params({'foo': ['bar', 'baz']}) ==
                'https://github.com/zacharyvoase/urlobject?spam=eggs&foo=bar&foo=baz#foo')

    def test_set_query_param_adds_or_replaces_one_query_parameter(self):
        assert (self.url.set_query_param('spam', 'ham') ==
                'https://github.com/zacharyvoase/urlobject?spam=ham#foo')

    def test_set_query_params_adds_or_replaces_multiple_query_parameters(self):
        assert (self.url.set_query_params({'foo': 'bar'}, spam='ham') ==
                'https://github.com/zacharyvoase/urlobject?foo=bar&spam=ham#foo')

    def test_set_query_params_with_multiple_values_adds_or_replaces_the_same_parameter_multiple_times(self):
        assert (self.url.set_query_params({'spam': ['bar', 'baz']}) ==
                'https://github.com/zacharyvoase/urlobject?spam=bar&spam=baz#foo')
        assert (self.url.set_query_params({'foo': ['bar', 'baz']}) ==
                'https://github.com/zacharyvoase/urlobject?spam=eggs&foo=bar&foo=baz#foo')
        # Ensure it removes all appearances of an existing name before adding
        # the new ones.
        url = URLObject('https://github.com/zacharyvoase/urlobject?foo=bar&foo=baz#foo')
        assert (url.set_query_params({'foo': ['spam', 'ham']}) ==
                'https://github.com/zacharyvoase/urlobject?foo=spam&foo=ham#foo')

    def test_del_query_param_removes_one_query_parameter(self):
        assert (self.url.del_query_param('spam') ==
                'https://github.com/zacharyvoase/urlobject#foo')

    def test_del_query_params_removes_multiple_query_parameters(self):
        url = URLObject('https://github.com/zacharyvoase/urlobject?foo=bar&baz=spam#foo')
        assert (url.del_query_params(['foo', 'baz']) ==
                'https://github.com/zacharyvoase/urlobject#foo')

    def test_with_fragment_replaces_fragment(self):
        assert (self.url.with_fragment('part') ==
                'https://github.com/zacharyvoase/urlobject?spam=eggs#part')

    def test_with_fragment_encodes_fragment_correctly(self):
        assert (self.url.with_fragment('foo bar#baz') ==
                'https://github.com/zacharyvoase/urlobject?spam=eggs#foo%20bar%23baz')

    def test_without_fragment_removes_fragment(self):
        assert (self.url.without_fragment() ==
                'https://github.com/zacharyvoase/urlobject?spam=eggs')

########NEW FILE########
__FILENAME__ = compat
try:
    import urlparse
except ImportError:
    # Python 3
    from urllib import parse as urlparse


# First hasattr checks for Python < 3, second checks for Python < 2.6
if hasattr(urlparse, 'BaseResult') and not hasattr(urlparse, 'ResultMixin'):
    def _replace(split_result, **replace):
        return urlparse.SplitResult(
            **dict((attr, replace.get(attr, getattr(split_result, attr)))
                for attr in ('scheme', 'netloc', 'path', 'query', 'fragment')))
    urlparse.BaseResult._replace = _replace
    del _replace


__all__ = ['urlparse']

########NEW FILE########
__FILENAME__ = netloc
from .compat import urlparse
from .six import text_type, u


class Netloc(text_type):

    """
    A netloc string (``username:password@hostname:port``).

    Contains methods for accessing and (non-destructively) modifying those four
    components of the netloc. All methods return new instances.
    """

    def __repr__(self):
        return u('Netloc(%r)') % (text_type(self),)

    @classmethod
    def __unsplit(cls, username, password, hostname, port):
        """Put together a :class:`Netloc` from its constituent parts."""
        auth_string = ''
        if username:
            auth_string = username
            if password:
                auth_string += ':' + password
            auth_string += '@'
        port_string = ''
        if port is not None:
            port_string = ':%d' % port
        return cls(auth_string + hostname + port_string)

    @property
    def username(self):
        """The username portion of this netloc, or ``None``."""
        return self.__urlsplit.username

    def with_username(self, username):
        """Replace or add a username to this netloc."""
        return self.__replace(username=username)

    def without_username(self):
        """Remove any username (and password) from this netloc."""
        return self.without_password().with_username('')

    @property
    def password(self):
        """The password portion of this netloc, or ``None``."""
        return self.__urlsplit.password

    def with_password(self, password):

        """
        Replace or add a password to this netloc.

        Raises a ``ValueError`` if you attempt to add a password to a netloc
        with no username.
        """

        if password and not self.username:
            raise ValueError("Can't set a password on a netloc with no username")
        return self.__replace(password=password)

    def without_password(self):
        """Remove any password from this netloc."""
        return self.with_password('')

    @property
    def auth(self):
        """The username and password of this netloc as a 2-tuple."""
        return (self.username, self.password)

    def with_auth(self, username, *password):
        """Replace or add a username and password in one method call."""
        netloc = self.without_auth()
        if password:
            return netloc.with_username(username).with_password(*password)
        return netloc.with_username(username)

    def without_auth(self):
        return self.without_password().without_username()

    @property
    def hostname(self):
        """The hostname portion of this netloc."""
        return self.__urlsplit.hostname

    def with_hostname(self, hostname):
        """Replace the hostname on this netloc."""
        return self.__replace(hostname=hostname)

    @property
    def port(self):
        """The port number on this netloc (as an ``int``), or ``None``."""
        return self.__urlsplit.port

    def with_port(self, port):
        """Replace or add a port number to this netloc."""
        return self.__replace(port=port)

    def without_port(self):
        """Remove any port number from this netloc."""
        return self.__replace(port=None)

    @property
    def __urlsplit(self):
        return urlparse.SplitResult('', self, '', '', '')

    def __replace(self, **params):
        """Replace any number of components on this netloc."""
        unsplit_args = {'username': self.username,
                        'password': self.password,
                        'hostname': self.hostname,
                        'port': self.port}
        unsplit_args.update(params)
        return self.__unsplit(**unsplit_args)

########NEW FILE########
__FILENAME__ = path
# -*- coding: utf-8 -*-

import posixpath
import urllib

from .compat import urlparse
from .six import text_type, u


class Root(object):

    """A descriptor which always returns the root path."""

    def __get__(self, instance, cls):
        return cls('/')


class URLPath(text_type):

    root = Root()

    def __repr__(self):
        return u('URLPath(%r)') % (text_type(self),)

    @classmethod
    def join_segments(cls, segments, absolute=True):
        """Create a :class:`URLPath` from an iterable of segments."""
        if absolute:
            path = cls('/')
        else:
            path = cls('')
        for segment in segments:
            path = path.add_segment(segment)
        return path

    @property
    def segments(self):
        """
        Split this path into (decoded) segments.

            >>> URLPath('/a/b/c').segments
            ('a', 'b', 'c')

        Non-leaf nodes will have a trailing empty string, and percent encodes
        will be decoded:

            >>> URLPath('/a%20b/c%20d/').segments
            ('a b', 'c d', '')
        """
        segments = tuple(map(path_decode, self.split('/')))
        if segments[0] == '':
            return segments[1:]
        return segments

    @property
    def parent(self):
        """
        The parent of this node.

            >>> URLPath('/a/b/c').parent
            URLPath('/a/b/')
            >>> URLPath('/foo/bar/').parent
            URLPath('/foo/')
        """
        if self.is_leaf:
            return self.relative('.')
        return self.relative('..')

    @property
    def is_leaf(self):
        """
        Is this path a leaf node?

            >>> URLPath('/a/b/c').is_leaf
            True
            >>> URLPath('/a/b/').is_leaf
            False
        """
        return self and self.segments[-1] != '' or False

    @property
    def is_relative(self):
        """
        Is this path relative?

            >>> URLPath('a/b/c').is_relative
            True
            >>> URLPath('/a/b/c').is_relative
            False
        """
        return self[0] != '/'

    @property
    def is_absolute(self):
        """
        Is this path absolute?

            >>> URLPath('a/b/c').is_absolute
            False
            >>> URLPath('/a/b/c').is_absolute
            True
        """
        return self[0] == '/'

    def relative(self, rel_path):
        """
        Resolve a relative path against this one.

            >>> URLPath('/a/b/c').relative('.')
            URLPath('/a/b/')
            >>> URLPath('/a/b/c').relative('d')
            URLPath('/a/b/d')
            >>> URLPath('/a/b/c').relative('../d')
            URLPath('/a/d')
        """
        return type(self)(urlparse.urljoin(self, rel_path))

    def add_segment(self, segment):
        """
        Add a segment to this path.

            >>> URLPath('/a/b/').add_segment('c')
            URLPath('/a/b/c')

        Non-ASCII and reserved characters (including slashes) will be encoded:

            >>> URLPath('/a/b/').add_segment('dé/f')
            URLPath('/a/b/d%C3%A9%2Ff')
        """
        return type(self)(posixpath.join(self, path_encode(segment)))

    def add(self, path):
        """
        Add a partial path to this one.

        The only difference between this and :meth:`add_segment` is that slash
        characters will not be encoded, making it suitable for adding more than
        one path segment at a time:

            >>> URLPath('/a/b/').add('dé/f/g')
            URLPath('/a/b/d%C3%A9/f/g')
        """
        return type(self)(posixpath.join(self, path_encode(path, safe='/')))


def _path_encode_py2(s, safe=''):
    """Quote unicode or str using path rules."""
    if isinstance(s, unicode):
        s = s.encode('utf-8')
    if isinstance(safe, unicode):
        safe = safe.encode('utf-8')
    return urllib.quote(s, safe=safe).decode('utf-8')


def _path_encode_py3(s, safe=''):
    """Quote str or bytes using path rules."""
    # s can be bytes or unicode, urllib.parse.quote() assumes
    # utf-8 if encoding is necessary.
    return urlparse.quote(s, safe=safe)


def _path_decode_py2(s):
    """Unquote unicode or str using path rules."""
    if isinstance(s, unicode):
        s = s.encode('utf-8')
    return urllib.unquote(s).decode('utf-8')


def _path_decode_py3(s):
    """Unquote str or bytes using path rules."""
    if isinstance(s, bytes):
        s = s.decode('utf-8')
    return urlparse.unquote(s)


if hasattr(urllib, 'quote'):
    path_encode = _path_encode_py2
    path_decode = _path_decode_py2
    del _path_encode_py3
    del _path_decode_py3
else:
    path_encode = _path_encode_py3
    path_decode = _path_decode_py3
    del _path_encode_py2
    del _path_decode_py2

########NEW FILE########
__FILENAME__ = ports
"""Default port numbers for the URI schemes supported by urlparse."""

DEFAULT_PORTS = {
    'ftp': 21,
    'gopher': 70,
    'hdl': 2641,
    'http': 80,
    'https': 443,
    'imap': 143,
    'mms': 651,
    'news': 2009,
    'nntp': 119,
    'prospero': 191,
    'rsync': 873,
    'rtsp': 554,
    'rtspu': 554,
    'sftp': 115,
    'shttp': 80,
    'sip': 5060,
    'sips': 5061,
    'snews': 2009,
    'svn': 3690,
    'svn+ssh': 22,
    'telnet': 23,
}

########NEW FILE########
__FILENAME__ = query_string
import collections
import re
import urllib

from .compat import urlparse
from .six import text_type, string_types, u


class QueryString(text_type):

    def __repr__(self):
        return u('QueryString(%r)') % (text_type(self),)

    @property
    def list(self):
        result = []
        if not self:
            # Empty string => empty list.
            return result

        name_value_pairs = re.split(r'[\&\;]', self)
        for name_value_pair in name_value_pairs:
            # Split the pair string into a naive, encoded (name, value) pair.
            name_value = name_value_pair.split('=', 1)
            # 'param=' => ('param', None)
            if len(name_value) == 1:
                name, value = name_value + [None]
            # 'param=value' => ('param', 'value')
            # 'param=' => ('param', '')
            else:
                name, value = name_value

            name = qs_decode(name)
            if value is not None:
                value = qs_decode(value)

            result.append((name, value))
        return result

    @property
    def dict(self):
        return dict(self.list)

    @property
    def multi_dict(self):
        result = collections.defaultdict(list)
        for name, value in self.list:
            result[name].append(value)
        return dict(result)

    def add_param(self, name, value):
        if value is None:
            parameter = qs_encode(name)
        elif not isinstance(value, string_types) and hasattr(value, '__iter__'):
            # value is a list or tuple
            parameter = '&'.join([qs_encode(name) + '=' + qs_encode(val) for val in value])
        else:
            parameter = qs_encode(name) + '=' + qs_encode(value)
        if self:
            return type(self)(self + '&' + parameter)
        return type(self)(parameter)

    def add_params(self, *args, **kwargs):
        params_list = get_params_list(*args, **kwargs)
        new = self
        for name, value in params_list:
            new = new.add_param(name, value)
        return new

    def del_param(self, name):
        params = [(n, v) for n, v in self.list if n != name]
        qs = type(self)('')
        for param in params:
            qs = qs.add_param(*param)
        return qs

    def set_param(self, name, value):
        return self.del_param(name).add_param(name, value)

    def set_params(self, *args, **kwargs):
        params_list = get_params_list(*args, **kwargs)
        new = self
        for name, value in params_list:
            new = new.set_param(name, value)
        return new

    def del_params(self, params):
        deleted = set(params)
        params = [(name, value) for name, value in self.list
                  if name not in deleted]
        qs = type(self)('')
        for param in params:
            qs = qs.add_param(*param)
        return qs


def get_params_list(*args, **kwargs):
    """Turn dict-like arguments into an ordered list of pairs."""
    params = []
    if args:
        if len(args) > 1:
            raise TypeError("Expected at most 1 arguments, got 2")
        arg = args[0]
        if hasattr(arg, 'items'):
            params.extend(arg.items())
        else:
            params.extend(list(arg))
    if kwargs:
        params.extend(kwargs.items())
    return params


def _qs_encode_py2(s):
    """Quote unicode or str using query string rules."""
    if isinstance(s, unicode):
        s = s.encode('utf-8')
    return urllib.quote_plus(s).decode('utf-8')


def _qs_encode_py3(s):
    """Quote str or bytes using query string rules."""
    # s can be bytes or unicode, urllib.parse.quote() assumes
    # utf-8 if encoding is necessary.
    return urlparse.quote_plus(s)


def _qs_decode_py2(s):
    """Unquote unicode or str using query string rules."""
    if isinstance(s, unicode):
        s = s.encode('utf-8')
    return urllib.unquote_plus(s).decode('utf-8')


def _qs_decode_py3(s):
    """Unquote str or bytes using query string rules."""
    if isinstance(s, bytes):
        s = s.decode('utf-8')
    return urlparse.unquote_plus(s)


if hasattr(urllib, 'quote'):
    qs_encode = _qs_encode_py2
    qs_decode = _qs_decode_py2
    del _qs_encode_py3
    del _qs_decode_py3
else:
    qs_encode = _qs_encode_py3
    qs_decode = _qs_decode_py3
    del _qs_encode_py2
    del _qs_decode_py2

########NEW FILE########
__FILENAME__ = six
"""Utilities for writing code that runs on Python 2 and 3"""

# Copyright (c) 2010-2012 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.2.0"


# True if we are running on Python 3.
PY3 = sys.version_info[0] == 3

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):
            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
            del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result)
        # This is a bit ugly, but it avoids running this again.
        delattr(tp, self.name)
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)



class _MovedItems(types.ModuleType):
    """Lazy loading of moved objects"""


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("reload_module", "__builtin__", "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),

    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("winreg", "_winreg"),
]
for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
del attr

moves = sys.modules[__name__ + ".moves"] = _MovedItems("moves")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_code = "__code__"
    _func_defaults = "__defaults__"

    _iterkeys = "keys"
    _itervalues = "values"
    _iteritems = "items"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_code = "func_code"
    _func_defaults = "func_defaults"

    _iterkeys = "iterkeys"
    _itervalues = "itervalues"
    _iteritems = "iteritems"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)


def iterkeys(d):
    """Return an iterator over the keys of a dictionary."""
    return iter(getattr(d, _iterkeys)())

def itervalues(d):
    """Return an iterator over the values of a dictionary."""
    return iter(getattr(d, _itervalues)())

def iteritems(d):
    """Return an iterator over the (key, value) pairs of a dictionary."""
    return iter(getattr(d, _iteritems)())


if PY3:
    def b(s):
        return s.encode("latin-1")
    def u(s):
        return s
    if sys.version_info[1] <= 1:
        def int2byte(i):
            return bytes((i,))
    else:
        # This is about 2x faster than the implementation above on 3.2+
        int2byte = operator.methodcaller("to_bytes", 1, "big")
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    def b(s):
        return s
    def u(s):
        return unicode(s, "unicode_escape")
    int2byte = chr
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


if PY3:
    import builtins
    exec_ = getattr(builtins, "exec")


    def reraise(tp, value, tb=None):
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value


    print_ = getattr(builtins, "print")
    del builtins

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")


    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")


    def print_(*args, **kwargs):
        """The new-style print function."""
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return
        def write(data):
            if not isinstance(data, basestring):
                data = str(data)
            fp.write(data)
        want_unicode = False
        sep = kwargs.pop("sep", None)
        if sep is not None:
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
        end = kwargs.pop("end", None)
        if end is not None:
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
        if kwargs:
            raise TypeError("invalid keyword arguments to print()")
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n")
            space = unicode(" ")
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args):
            if i:
                write(sep)
            write(arg)
        write(end)

_add_doc(reraise, """Reraise an exception.""")


def with_metaclass(meta, base=object):
    """Create a base class with a metaclass."""
    return meta("NewBase", (base,), {})

########NEW FILE########
__FILENAME__ = urlobject
from .compat import urlparse
from .netloc import Netloc
from .path import URLPath, path_encode, path_decode
from .ports import DEFAULT_PORTS
from .query_string import QueryString
from .six import text_type, u

class URLObject(text_type):

    """
    A URL.

    This class contains properties and methods for accessing and modifying the
    constituent components of a URL. :class:`URLObject` instances are
    immutable, as they derive from the built-in ``unicode``, and therefore all
    methods return *new* objects; you need to consider this when using
    :class:`URLObject` in your own code.

    >>> from urlobject import URLObject
    >>> u = URLObject("http://www.google.com/")
    >>> print(u)
    http://www.google.com/

    URL objects feature properties for directly accessing different parts of
    the URL: :attr:`.scheme`, :attr:`.netloc`, :attr:`.username`,
    :attr:`.password`, :attr:`.hostname`, :attr:`.port`, :attr:`.path`,
    :attr:`.query` and :attr:`.fragment`.

    All of these have a ``with_*`` method for adding/replacing them, and some
    have a ``without_*`` method for removing them altogether. The query string
    and path also have a variety of methods for doing more fine-grained
    inspection and manipulation.
    """

    def __repr__(self):
        return u('URLObject(%r)') % (text_type(self),)

    @property
    def scheme(self):
        """
        This URL's scheme.

        >>> print(URLObject("http://www.google.com").scheme)
        http
        """
        return urlparse.urlsplit(self).scheme

    def with_scheme(self, scheme):
        """
        Add or replace this URL's :attr:`.scheme`.

        >>> print(URLObject("http://www.google.com").with_scheme("ftp"))
        ftp://www.google.com
        >>> print(URLObject("//www.google.com").with_scheme("https"))
        https://www.google.com
        """
        return self.__replace(scheme=scheme)

    @property
    def netloc(self):
        """
        The full network location of this URL.

        This value incorporates :attr:`.username`, :attr:`.password`,
        :attr:`.hostname` and :attr:`.port`.

        >>> print(URLObject("http://user:pass@www.google.com").netloc)
        user:pass@www.google.com
        """
        return Netloc(urlparse.urlsplit(self).netloc)

    def with_netloc(self, netloc):
        """
        Add or replace this URL's :attr:`.netloc`.

        >>> print(URLObject("http://www.google.com/a/b/c").with_netloc("www.amazon.com"))
        http://www.amazon.com/a/b/c
        """
        return self.__replace(netloc=netloc)

    @property
    def username(self):
        """
        This URL's username, if any.

        >>> print(URLObject("http://user@www.google.com").username)
        user
        >>> print(URLObject("http://www.google.com").username)
        None
        """
        return self.netloc.username

    def with_username(self, username):
        """
        Add or replace this URL's :attr:`.username`.

        >>> print(URLObject("http://user@www.google.com").with_username("user2"))
        http://user2@www.google.com
        """
        return self.with_netloc(self.netloc.with_username(username))

    def without_username(self):
        """
        Remove this URL's :attr:`.username`.

        >>> print(URLObject("http://user@www.google.com/").without_username())
        http://www.google.com/
        """
        return self.with_netloc(self.netloc.without_username())

    @property
    def password(self):
        """
        This URL's password, if any.

        >>> print(URLObject("http://user:somepassword@www.google.com").password)
        somepassword
        >>> print(URLObject("http://user@www.google.com").password)
        None
        """
        return self.netloc.password

    def with_password(self, password):
        """
        Add or replace this URL's :attr:`.password`.

        >>> print(URLObject("http://user:somepassword@www.google.com").with_password("passwd"))
        http://user:passwd@www.google.com
        """
        return self.with_netloc(self.netloc.with_password(password))

    def without_password(self):
        """
        Remove this URL's :attr:`.password`.

        >>> print(URLObject("http://user:pwd@www.google.com").without_password())
        http://user@www.google.com
        """
        return self.with_netloc(self.netloc.without_password())

    @property
    def hostname(self):
        """
        This URL's hostname.

        >>> print(URLObject("http://www.google.com").hostname)
        www.google.com
        """
        return self.netloc.hostname

    def with_hostname(self, hostname):
        """
        Add or replace this URL's :attr:`.hostname`.

        >>> print(URLObject("http://www.google.com/a/b/c").with_hostname("cdn.amazon.com"))
        http://cdn.amazon.com/a/b/c
        """
        return self.with_netloc(self.netloc.with_hostname(hostname))

    @property
    def port(self):
        """
        This URL's port number, or ``None``.

        >>> URLObject("http://www.google.com:8080").port
        8080
        >>> print(URLObject("http://www.google.com").port)
        None
        """
        return self.netloc.port

    def with_port(self, port):
        """
        Add or replace this URL's :attr:`.port`.

        >>> print(URLObject("http://www.google.com/a/b/c").with_port(8080))
        http://www.google.com:8080/a/b/c
        """
        return self.with_netloc(self.netloc.with_port(port))

    def without_port(self):
        """
        Remove this URL's :attr:`.port`.

        >>> print(URLObject("http://www.google.com:8080/a/b/c").without_port())
        http://www.google.com/a/b/c
        """
        return self.with_netloc(self.netloc.without_port())

    @property
    def auth(self):
        """
        The username and password of this URL as a 2-tuple.

        >>> URLObject("http://user:password@www.google.com").auth
        ('user', 'password')
        >>> URLObject("http://user@www.google.com").auth
        ('user', None)
        >>> URLObject("http://www.google.com").auth
        (None, None)
        """
        return self.netloc.auth

    def with_auth(self, *auth):
        """
        Add or replace this URL's :attr:`.username` and :attr:`.password`.

        With two arguments, this method adds/replaces both username and
        password. With one argument, it adds/replaces the username and removes
        any password.

        >>> print(URLObject("http://user:password@www.google.com").with_auth("otheruser", "otherpassword"))
        http://otheruser:otherpassword@www.google.com
        >>> print(URLObject("http://www.google.com").with_auth("user"))
        http://user@www.google.com
        """
        return self.with_netloc(self.netloc.with_auth(*auth))

    def without_auth(self):
        """
        Remove any :attr:`.username` and :attr:`.password` on this URL.

        >>> print(URLObject("http://user:password@www.google.com/a/b/c").without_auth())
        http://www.google.com/a/b/c
        """
        return self.with_netloc(self.netloc.without_auth())

    @property
    def default_port(self):
        """
        The destination port number for this URL.

        If no port number is explicitly given in the URL, this will return the
        default port number for the scheme if one is known, or ``None``. The
        mapping of schemes to default ports is defined in
        :const:`urlobject.ports.DEFAULT_PORTS`.

        For URLs *with* explicit port numbers, this just returns the value of
        :attr:`.port`.

        >>> URLObject("https://www.google.com").default_port
        443
        >>> URLObject("http://www.google.com").default_port
        80
        >>> URLObject("http://www.google.com:126").default_port
        126
        """
        port = urlparse.urlsplit(self).port
        if port is not None:
            return port
        return DEFAULT_PORTS.get(self.scheme)

    @property
    def path(self):
        """
        This URL's path.

        >>> print(URLObject("http://www.google.com/a/b/c").path)
        /a/b/c
        >>> print(URLObject("http://www.google.com").path)
        <BLANKLINE>
        """
        return URLPath(urlparse.urlsplit(self).path)

    def with_path(self, path):
        """
        Add or replace this URL's :attr:`.path`.

        >>> print(URLObject("http://www.google.com/a/b/c").with_path("c/b/a"))
        http://www.google.com/c/b/a
        """
        return self.__replace(path=path)

    @property
    def root(self):
        """
        The root node of this URL.

        This is just a synonym for ``url.with_path('/')``.

        >>> print(URLObject("http://www.google.com/a/b/c").root)
        http://www.google.com/
        """
        return self.with_path('/')

    @property
    def parent(self):
        """
        The direct parent node of this URL.

        >>> print(URLObject("http://www.google.com/a/b/c").parent)
        http://www.google.com/a/b/
        >>> print(URLObject("http://www.google.com/a/b/").parent)
        http://www.google.com/a/
        """
        return self.with_path(self.path.parent)

    @property
    def is_leaf(self):
        """
        Whether this URL's :attr:`.path` is a leaf node or not.

        A leaf node is simply one without a trailing slash. Leaf-ness affects
        things like relative URL resolution (c.f. :meth:`.relative`) and
        server-side routing.

        >>> URLObject("http://www.google.com/a/b/c").is_leaf
        True
        >>> URLObject('http://www.google.com/a/').is_leaf
        False
        >>> URLObject('http://www.google.com').is_leaf
        False
        """
        return self.path.is_leaf

    def add_path_segment(self, segment):
        """
        >>> print(URLObject("http://www.google.com").add_path_segment("a"))
        http://www.google.com/a
        """
        return self.with_path(self.path.add_segment(segment))

    def add_path(self, partial_path):
        """
        >>> print(URLObject("http://www.google.com").add_path("a/b/c"))
        http://www.google.com/a/b/c
        """
        return self.with_path(self.path.add(partial_path))

    @property
    def query(self):
        """
        This URL's query string.

        >>> print(URLObject("http://www.google.com").query)
        <BLANKLINE>
        >>> print(URLObject("http://www.google.com?a=b").query)
        a=b
        """
        return QueryString(urlparse.urlsplit(self).query)

    def with_query(self, query):
        """
        Add or replace this URL's :attr:`.query` string.

        >>> print(URLObject("http://www.google.com").with_query("a=b"))
        http://www.google.com?a=b
        """
        return self.__replace(query=query)

    def without_query(self):
        """
        Remove this URL's :attr:`.query` string.

        >>> print(URLObject("http://www.google.com?a=b&c=d").without_query())
        http://www.google.com
        """
        return self.__replace(query='')

    @property
    def query_list(self):
        """
        This URL's :attr:`.query` as a list of name/value pairs.

        This attribute is read-only. Changes you make to the list will not
        propagate back to the URL.

        >>> URLObject("http://www.google.com?a=b&c=d").query_list
        [('a', 'b'), ('c', 'd')]
        """
        return self.query.list

    @property
    def query_dict(self):
        """
        This URL's :attr:`.query` as a dict mapping names to values.

        Each name will have only its last value associated with it. For all the
        values for a given key, see :attr:`.query_multi_dict`.

        >>> dictsort(URLObject("http://www.google.com?a=b&c=d").query_dict)
        {'a': 'b', 'c': 'd'}
        >>> dictsort(URLObject("http://www.google.com?a=b&a=c").query_dict)
        {'a': 'c'}
        """
        return self.query.dict

    @property
    def query_multi_dict(self):
        """
        This URL's :attr:`.query` as a dict mapping names to lists of values.

        All values associated with a given name will be represented, in order,
        in that name's list.

        >>> dictsort(URLObject("http://www.google.com?a=b&c=d").query_multi_dict)
        {'a': ['b'], 'c': ['d']}
        >>> dictsort(URLObject("http://www.google.com?a=b&a=c").query_multi_dict)
        {'a': ['b', 'c']}
        """
        return self.query.multi_dict

    def add_query_param(self, name, value):
        """
        Add a single query parameter.

        You can ``add`` several query parameters with the same name to a URL.

        >>> print(URLObject("http://www.google.com").add_query_param("a", "b"))
        http://www.google.com?a=b
        >>> print(URLObject("http://www.google.com").add_query_param("a", "b").add_query_param("a", "c"))
        http://www.google.com?a=b&a=c
        """
        return self.with_query(self.query.add_param(name, value))

    def add_query_params(self, *args, **kwargs):
        """
        Add multiple query parameters.

        Accepts anything you would normally pass to ``dict()``: iterables of
        name/value pairs, keyword arguments and dictionary objects.

        >>> print(URLObject("http://www.google.com").add_query_params([('a', 'b'), ('c', 'd')]))
        http://www.google.com?a=b&c=d
        >>> print(URLObject("http://www.google.com").add_query_params(a="b"))
        http://www.google.com?a=b
        """
        return self.with_query(self.query.add_params(*args, **kwargs))

    def set_query_param(self, name, value):
        """
        Set a single query parameter, overriding it if it exists already.

        >>> print(URLObject("http://www.google.com?a=b&c=d").set_query_param("a", "z"))
        http://www.google.com?c=d&a=z
        """
        return self.with_query(self.query.set_param(name, value))

    def set_query_params(self, *args, **kwargs):
        """
        Set query parameters, overriding existing ones.

        Accepts anything you would normally pass to ``dict()``: iterables of
        name/value pairs, keyword arguments and dictionary objects.

        >>> print(URLObject("http://www.google.com?a=b&c=d").set_query_params([('a', 'z'), ('d', 'e')]))
        http://www.google.com?c=d&a=z&d=e
        >>> print(URLObject("http://www.google.com?a=b").set_query_params(a="z"))
        http://www.google.com?a=z
        """
        return self.with_query(self.query.set_params(*args, **kwargs))

    def del_query_param(self, name):
        """
        Remove any and all query parameters with the given name from the URL.

        >>> print(URLObject("http://www.google.com?a=b&c=d&c=e").del_query_param("c"))
        http://www.google.com?a=b
        """
        return self.with_query(self.query.del_param(name))

    def del_query_params(self, params):
        """
        Remove multiple query params from the URL.

        >>> print(URLObject("http://www.google.com?a=b&c=d&d=e").del_query_params(["c", "d"]))
        http://www.google.com?a=b
        """
        return self.with_query(self.query.del_params(params))

    @property
    def fragment(self):
        """
        This URL's fragment.

        >>> print(URLObject("http://www.google.com/a/b/c#fragment").fragment)
        fragment
        """
        return path_decode(urlparse.urlsplit(self).fragment)

    def with_fragment(self, fragment):
        """
        Add or replace this URL's :attr:`.fragment`.

        >>> print(URLObject("http://www.google.com/a/b/c#fragment").with_fragment("new_fragment"))
        http://www.google.com/a/b/c#new_fragment
        """
        return self.__replace(fragment=path_encode(fragment))

    def without_fragment(self):
        """
        Remove this URL's :attr:`.fragment`.

        >>> print(URLObject("http://www.google.com/a/b/c#fragment").without_fragment())
        http://www.google.com/a/b/c
        """
        return self.__replace(fragment='')

    def relative(self, other):
        """
        Resolve another URL relative to this one.

        For example, if you have a browser currently pointing to
        ``http://www.google.com/a/b/c/``, then an HTML element like
        ``<a href="../d/e/f">`` would resolve to
        ``http://www.google.com/a/b/d/e/f`` using this function.

        >>> print(URLObject("http://www.google.com/a/b/c/").relative("../d/e/f"))
        http://www.google.com/a/b/d/e/f
        """
        # Relative URL resolution involves cascading through the properties
        # from left to right, replacing
        other = type(self)(other)
        if other.scheme:
            return other
        elif other.netloc:
            return other.with_scheme(self.scheme)
        elif other.path:
            return other.with_scheme(self.scheme).with_netloc(self.netloc) \
                    .with_path(self.path.relative(other.path))
        elif other.query:
            return other.with_scheme(self.scheme).with_netloc(self.netloc) \
                    .with_path(self.path)
        elif other.fragment:
            return other.with_scheme(self.scheme).with_netloc(self.netloc) \
                    .with_path(self.path).with_query(self.query)
        # Empty string just removes fragment; it's treated as a path meaning
        # 'the current location'.
        return self.without_fragment()

    def __replace(self, **replace):
        """Replace a field in the ``urlparse.SplitResult`` for this URL."""
        return type(self)(urlparse.urlunsplit(
            urlparse.urlsplit(self)._replace(**replace)))

########NEW FILE########
