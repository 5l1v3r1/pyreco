__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Django Knowledge documentation build configuration file, created by
# sphinx-quickstart on Thu Feb 16 12:54:45 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
version_tuple = __import__('knowledge').VERSION
version = ".".join([str(v) for v in version_tuple])


# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django Knowledge'
copyright = u'2012, Zapier'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
#version = '0.0.1'
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoKnowledgedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'DjangoKnowledge.tex', u'Django Knowledge Documentation',
   u'Zapier', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'djangoknowledge', u'Django Knowledge Documentation',
     [u'Zapier'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'DjangoKnowledge', u'Django Knowledge Documentation',
   u'Zapier', 'DjangoKnowledge', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from knowledge.models import Question, Response, Category


class CategoryAdmin(admin.ModelAdmin):
    list_display = [f.name for f in Category._meta.fields]
    prepopulated_fields = {'slug': ('title', )}
admin.site.register(Category, CategoryAdmin)


class QuestionAdmin(admin.ModelAdmin):
    list_display = [f.name for f in Question._meta.fields]
    list_select_related = True
    raw_id_fields = ['user']
admin.site.register(Question, QuestionAdmin)


class ResponseAdmin(admin.ModelAdmin):
    list_display = [f.name for f in Response._meta.fields]
    list_select_related = True
    raw_id_fields = ['user', 'question']
admin.site.register(Response, ResponseAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _

from knowledge import settings
from knowledge.models import Question, Response

OPTIONAL_FIELDS = ['alert', 'phone_number']


__todo__ = """
This is serious badness. Really? Functions masquerading as
clases? Lame. This should be fixed. Sorry.
                                                    ~bryan
"""


def QuestionForm(user, *args, **kwargs):
    """
    Build and return the appropriate form depending
    on the status of the passed in user.
    """

    if user.is_anonymous():
        if not settings.ALLOW_ANONYMOUS:
            return None
        else:
            selected_fields = ['name', 'email', 'title', 'body']
    else:
        selected_fields = ['user', 'title', 'body', 'status']

    if settings.ALERTS:
        selected_fields += ['alert']

    class _QuestionForm(forms.ModelForm):
        def __init__(self, *args, **kwargs):
            super(_QuestionForm, self).__init__(*args, **kwargs)

            for key in self.fields:
                if not key in OPTIONAL_FIELDS:
                    self.fields[key].required = True

            # hide the internal status for non-staff
            qf = self.fields.get('status', None)
            if qf and not user.is_staff:
                choices = list(qf.choices)
                choices.remove(('internal', _('Internal')))
                qf.choices = choices

            # a bit of a hack...
            # hide a field, and use clean to force
            # a specific value of ours
            for key in ['user']:
                qf = self.fields.get(key, None)
                if qf:
                    qf.widget = qf.hidden_widget()
                    qf.required = False

        # honey pot!
        phone_number = forms.CharField(required=False)

        def clean_user(self):
            return user

        class Meta:
            model = Question
            fields = selected_fields

    return _QuestionForm(*args, **kwargs)


def ResponseForm(user, question, *args, **kwargs):
    """
    Build and return the appropriate form depending
    on the status of the passed in user and question.
    """

    if question.locked:
        return None

    if not settings.FREE_RESPONSE and not \
            (user.is_staff or question.user == user):
        return None

    if user.is_anonymous():
        if not settings.ALLOW_ANONYMOUS:
            return None
        else:
            selected_fields = ['name', 'email']
    else:
        selected_fields = ['user']

    selected_fields += ['body', 'question']

    if user.is_staff:
        selected_fields += ['status']

    if settings.ALERTS:
        selected_fields += ['alert']

    class _ResponseForm(forms.ModelForm):
        def __init__(self, *args, **kwargs):
            super(_ResponseForm, self).__init__(*args, **kwargs)

            for key in self.fields:
                if not key in OPTIONAL_FIELDS:
                    self.fields[key].required = True

            # a bit of a hack...
            for key in ['user', 'question']:
                qf = self.fields.get(key, None)
                if qf:
                    qf.widget = qf.hidden_widget()
                    qf.required = False

        # honey pot!
        phone_number = forms.CharField(required=False)

        def clean_user(self):
            return user

        def clean_question(self):
            return question

        class Meta:
            model = Response
            fields = selected_fields

    return _ResponseForm(*args, **kwargs)

########NEW FILE########
__FILENAME__ = managers
from django.db import models
from django.db.models import Q


class QuestionManager(models.Manager):
    # def get_query_set(self, *args, **kwargs):
    #     return super(QuestionManager, self).get_query_set(*args, **kwargs)

    def can_view(self, user):
        qs = super(QuestionManager, self).get_query_set()\
                                         .select_related('user')

        if user.is_staff or user.is_superuser:
            return qs.all()

        if user.is_anonymous():
            return qs.filter(status='public')

        return qs.filter(
            Q(status='public') | Q(status='private', user=user)
        )


class ResponseManager(models.Manager):
    # def all(self, *args, **kwargs):
    #     return super(ResponseManager, self).all(*args, **kwargs)\
    #                                        .select_related('question', 'user')

    def can_view(self, user):
        qs = super(ResponseManager, self).get_query_set()\
                                         .select_related('question', 'user')

        if user.is_staff or user.is_superuser:
            return qs.all()

        if user.is_anonymous():
            return qs.filter(
                Q(status='public') |
                Q(status='inherit', question__status='public')
            )

        # ooooh boy this is crazy!
        return qs.filter(
            Q(status='public') |
            Q(  # respect private parent user/status
                Q(status='private') &
                Q(
                    Q(user=user) |
                    Q(question__user=user)
                )
            ) |
            Q(  # follow inherited status/users
                Q(status='inherit') &
                Q(
                    Q(question__status='public') |
                    Q(question__status='private', question__user=user)
                )
            )
        )

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from knowledge.utils import user_model_label

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Category'
        db.create_table('knowledge_category', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('added', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastchanged', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
        ))
        db.send_create_signal('knowledge', ['Category'])

        # Adding model 'Question'
        db.create_table('knowledge_question', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('added', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastchanged', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm[user_model_label], null=True, blank=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=64, null=True, blank=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75, null=True, blank=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('body', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('status', self.gf('django.db.models.fields.CharField')(default='private', max_length=32, db_index=True)),
            ('locked', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('knowledge', ['Question'])

        # Adding M2M table for field categories on 'Question'
        db.create_table('knowledge_question_categories', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('question', models.ForeignKey(orm['knowledge.question'], null=False)),
            ('category', models.ForeignKey(orm['knowledge.category'], null=False))
        ))
        db.create_unique('knowledge_question_categories', ['question_id', 'category_id'])

        # Adding model 'Response'
        db.create_table('knowledge_response', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('added', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastchanged', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm[user_model_label], null=True, blank=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=64, null=True, blank=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75, null=True, blank=True)),
            ('question', self.gf('django.db.models.fields.related.ForeignKey')(related_name='responses', to=orm['knowledge.Question'])),
            ('body', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('status', self.gf('django.db.models.fields.CharField')(default='inherit', max_length=32, db_index=True)),
            ('accepted', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('knowledge', ['Response'])


    def backwards(self, orm):
        
        # Deleting model 'Category'
        db.delete_table('knowledge_category')

        # Deleting model 'Question'
        db.delete_table('knowledge_question')

        # Removing M2M table for field categories on 'Question'
        db.delete_table('knowledge_question_categories')

        # Deleting model 'Response'
        db.delete_table('knowledge_response')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': user_model_label.split('.')[-1]},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'knowledge.category': {
            'Meta': {'object_name': 'Category'},
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'knowledge.question': {
            'Meta': {'ordering': "['-added']", 'object_name': 'Question'},
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'body': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'categories': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['knowledge.Category']", 'symmetrical': 'False'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'locked': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'private'", 'max_length': '32', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm[user_model_label]", 'null': 'True', 'blank': 'True'})
        },
        'knowledge.response': {
            'Meta': {'ordering': "['added']", 'object_name': 'Response'},
            'accepted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'body': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'question': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'responses'", 'to': "orm['knowledge.Question']"}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'inherit'", 'max_length': '32', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm[user_model_label]", 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['knowledge']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_question_alert__add_field_response_alert
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from knowledge.utils import user_model_label

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Question.alert'
        db.add_column('knowledge_question', 'alert', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)

        # Adding field 'Response.alert'
        db.add_column('knowledge_response', 'alert', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Question.alert'
        db.delete_column('knowledge_question', 'alert')

        # Deleting field 'Response.alert'
        db.delete_column('knowledge_response', 'alert')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': user_model_label.split('.')[-1]},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'knowledge.category': {
            'Meta': {'object_name': 'Category'},
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'knowledge.question': {
            'Meta': {'ordering': "['-added']", 'object_name': 'Question'},
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'alert': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'body': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'categories': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['knowledge.Category']", 'symmetrical': 'False'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'locked': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'private'", 'max_length': '32', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm[user_model_label]", 'null': 'True', 'blank': 'True'})
        },
        'knowledge.response': {
            'Meta': {'ordering': "['added']", 'object_name': 'Response'},
            'accepted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'alert': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'body': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'question': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'responses'", 'to': "orm['knowledge.Question']"}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'inherit'", 'max_length': '32', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm[user_model_label]", 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['knowledge']

########NEW FILE########
__FILENAME__ = 0003_auto__add_unique_category_slug
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from knowledge.utils import user_model_label

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding unique constraint on 'Category', fields ['slug']
        db.create_unique('knowledge_category', ['slug'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Category', fields ['slug']
        db.delete_unique('knowledge_category', ['slug'])


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': user_model_label.split('.')[-1]},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'knowledge.category': {
            'Meta': {'object_name': 'Category'},
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'knowledge.question': {
            'Meta': {'ordering': "['-added']", 'object_name': 'Question'},
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'alert': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'body': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'categories': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['knowledge.Category']", 'symmetrical': 'False', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'locked': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'private'", 'max_length': '32', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm[user_model_label]", 'null': 'True', 'blank': 'True'})
        },
        'knowledge.response': {
            'Meta': {'ordering': "['added']", 'object_name': 'Response'},
            'accepted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'added': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'alert': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'body': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastchanged': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'question': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'responses'", 'to': "orm['knowledge.Question']"}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'inherit'", 'max_length': '32', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm[user_model_label]", 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['knowledge']

########NEW FILE########
__FILENAME__ = models
from knowledge import settings

import django
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.conf import settings as django_settings

from knowledge.managers import QuestionManager, ResponseManager
from knowledge.signals import knowledge_post_save

STATUSES = (
    ('public', _('Public')),
    ('private', _('Private')),
    ('internal', _('Internal')),
)


STATUSES_EXTENDED = STATUSES + (
    ('inherit', _('Inherit')),
)


class Category(models.Model):
    added = models.DateTimeField(auto_now_add=True)
    lastchanged = models.DateTimeField(auto_now=True)

    title = models.CharField(max_length=255)
    slug = models.SlugField(unique=True)

    def __unicode__(self):
        return self.title

    class Meta:
        ordering = ['title']
        verbose_name = _('Category')
        verbose_name_plural = _('Categories')


class KnowledgeBase(models.Model):
    """
    The base class for Knowledge models.
    """
    is_question, is_response = False, False

    added = models.DateTimeField(auto_now_add=True)
    lastchanged = models.DateTimeField(auto_now=True)

    user = models.ForeignKey('auth.User' if django.VERSION < (1, 5, 0) else django_settings.AUTH_USER_MODEL, blank=True,
                             null=True, db_index=True)
    alert = models.BooleanField(default=settings.ALERTS,
        verbose_name=_('Alert'),
        help_text=_('Check this if you want to be alerted when a new'
                        ' response is added.'))

    # for anonymous posting, if permitted
    name = models.CharField(max_length=64, blank=True, null=True,
        verbose_name=_('Name'),
        help_text=_('Enter your first and last name.'))
    email = models.EmailField(blank=True, null=True,
        verbose_name=_('Email'),
        help_text=_('Enter a valid email address.'))

    class Meta:
        abstract = True

    def save(self, *args, **kwargs):
        if not self.user and self.name and self.email \
                and not self.id:
            # first time because no id
            self.public(save=False)

        if settings.AUTO_PUBLICIZE and not self.id:
            self.public(save=False)

        super(KnowledgeBase, self).save(*args, **kwargs)

    #########################
    #### GENERIC GETTERS ####
    #########################

    def get_name(self):
        """
        Get local name, then self.user's first/last, and finally
        their username if all else fails.
        """
        name = (self.name or (self.user and (
            u'{0} {1}'.format(self.user.first_name, self.user.last_name).strip()\
            or self.user.username
        )))
        return name.strip() or _("Anonymous")

    get_email = lambda s: s.email or (s.user and s.user.email)
    get_pair = lambda s: (s.get_name(), s.get_email())
    get_user_or_pair = lambda s: s.user or s.get_pair()

    ########################
    #### STATUS METHODS ####
    ########################

    def can_view(self, user):
        """
        Returns a boolean dictating if a User like instance can
        view the current Model instance.
        """

        if self.status == 'inherit' and self.is_response:
            return self.question.can_view(user)

        if self.status == 'internal' and user.is_staff:
            return True

        if self.status == 'private':
            if self.user == user or user.is_staff:
                return True
            if self.is_response and self.question.user == user:
                return True

        if self.status == 'public':
            return True

        return False

    def switch(self, status, save=True):
        self.status = status
        if save:
            self.save()
    switch.alters_data = True

    def public(self, save=True):
        self.switch('public', save)
    public.alters_data = True

    def private(self, save=True):
        self.switch('private', save)
    private.alters_data = True

    def inherit(self, save=True):
        self.switch('inherit', save)
    inherit.alters_data = True

    def internal(self, save=True):
        self.switch('internal', save)
    internal.alters_data = True


class Question(KnowledgeBase):
    is_question = True
    _requesting_user = None

    title = models.CharField(max_length=255,
        verbose_name=_('Question'),
        help_text=_('Enter your question or suggestion.'))
    body = models.TextField(blank=True, null=True,
        verbose_name=_('Description'),
        help_text=_('Please offer details. Markdown enabled.'))

    status = models.CharField(
        verbose_name=_('Status'),
        max_length=32, choices=STATUSES,
        default='private', db_index=True)

    locked = models.BooleanField(default=False)

    categories = models.ManyToManyField('knowledge.Category', blank=True)

    objects = QuestionManager()

    class Meta:
        ordering = ['-added']
        verbose_name = _('Question')
        verbose_name_plural = _('Questions')

    def __unicode__(self):
        return self.title

    @models.permalink
    def get_absolute_url(self):
        from django.template.defaultfilters import slugify

        if settings.SLUG_URLS:
            return ('knowledge_thread', [self.id, slugify(self.title)])
        else:
            return ('knowledge_thread_no_slug', [self.id])

    def inherit(self):
        pass

    def internal(self):
        pass

    def lock(self, save=True):
        self.locked = not self.locked
        if save:
            self.save()
    lock.alters_data = True

    ###################
    #### RESPONSES ####
    ###################

    def get_responses(self, user=None):
        user = user or self._requesting_user
        if user:
            return [r for r in self.responses.all().select_related('user') if r.can_view(user)]
        else:
            return self.responses.all().select_related('user')

    def answered(self):
        """
        Returns a boolean indictating whether there any questions.
        """
        return bool(self.get_responses())

    def accepted(self):
        """
        Returns a boolean indictating whether there is a accepted answer
        or not.
        """
        return any([r.accepted for r in self.get_responses()])

    def clear_accepted(self):
        self.get_responses().update(accepted=False)
    clear_accepted.alters_data = True

    def accept(self, response=None):
        """
        Given a response, make that the one and only accepted answer.
        Similar to StackOverflow.
        """
        self.clear_accepted()

        if response and response.question == self:
            response.accepted = True
            response.save()
            return True
        else:
            return False
    accept.alters_data = True

    def states(self):
        """
        Handy for checking for mod bar button state.
        """
        return [self.status, 'lock' if self.locked else None]

    @property
    def url(self):
        return self.get_absolute_url()


class Response(KnowledgeBase):
    is_response = True

    question = models.ForeignKey('knowledge.Question',
        related_name='responses')

    body = models.TextField(blank=True, null=True,
        verbose_name=_('Response'),
        help_text=_('Please enter your response. Markdown enabled.'))
    status = models.CharField(
        verbose_name=_('Status'),
        max_length=32, choices=STATUSES_EXTENDED,
        default='inherit', db_index=True)
    accepted = models.BooleanField(default=False)

    objects = ResponseManager()

    class Meta:
        ordering = ['added']
        verbose_name = _('Response')
        verbose_name_plural = _('Responses')

    def __unicode__(self):
        return self.body[0:100] + u'...'

    def states(self):
        """
        Handy for checking for mod bar button state.
        """
        return [self.status, 'accept' if self.accepted else None]

    def accept(self):
        self.question.accept(self)
    accept.alters_data = True


# cannot attach on abstract = True... derp
models.signals.post_save.connect(knowledge_post_save, sender=Question)
models.signals.post_save.connect(knowledge_post_save, sender=Response)

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings

# crowd control
LOGIN_REQUIRED = getattr(settings, 'KNOWLEDGE_LOGIN_REQUIRED', False)
LOGIN_URL = getattr(settings, 'LOGIN_URL', '/accounts/login/')
ALLOW_ANONYMOUS = getattr(settings, 'KNOWLEDGE_ALLOW_ANONYMOUS', False)
AUTO_PUBLICIZE = getattr(settings, 'KNOWLEDGE_AUTO_PUBLICIZE', False)
FREE_RESPONSE = getattr(settings, 'KNOWLEDGE_FREE_RESPONSE', True)

# alerts
ALERTS = getattr(settings, 'KNOWLEDGE_ALERTS', False)
ALERTS_FUNCTION_PATH = getattr(settings, 'KNOWLEDGE_ALERTS_FUNCTION_PATH',
    'knowledge.signals.send_alerts')

# misc
SLUG_URLS = getattr(settings, 'KNOWLEDGE_SLUG_URLS', True)

BASE_TEMPLATE = getattr(settings, 'KNOWLEDGE_BASE_TEMPLATE', 'django_knowledge/base.html')

########NEW FILE########
__FILENAME__ = signals
from knowledge.utils import get_module
from knowledge import settings


def send_alerts(target_dict, response=None, question=None, **kwargs):
    """
    This can be overridden via KNOWLEDGE_ALERTS_FUNCTION_PATH.
    """
    from django.contrib.auth.models import User
    from django.template.loader import render_to_string
    from django.contrib.sites.models import Site
    from django.core.mail import EmailMultiAlternatives

    site = Site.objects.get_current()

    for email, name in target_dict.items():
        if isinstance(name, User):
            name = u'{0} {1}'.format(name.first_name, name.last_name)
        else:
            name = name[0]

        context = {
            'name': name,
            'email': email,
            'response': response,
            'question': question,
            'site': site
        }

        subject = render_to_string(
            'django_knowledge/emails/subject.txt', context)

        message = render_to_string(
            'django_knowledge/emails/message.txt', context)

        message_html = render_to_string(
            'django_knowledge/emails/message.html', context)

        subject = u' '.join(line.strip() for line in subject.splitlines()).strip()
        msg = EmailMultiAlternatives(subject, message, to=[email])
        msg.attach_alternative(message_html, 'text/html')
        msg.send()


def knowledge_post_save(sender, instance, created, **kwargs):
    """
    Gathers all the responses for the sender's parent question
    and shuttles them to the predefined module.
    """
    from knowledge.models import Question, Response
    from django.contrib.auth.models import User

    func = get_module(settings.ALERTS_FUNCTION_PATH)

    if settings.ALERTS and created:
        # pull together the out_dict:
        #    {'e@ma.il': ('first last', 'e@ma.il') or <User>}
        if isinstance(instance, Response):
            instances = list(instance.question.get_responses())
            instances += [instance.question]

            # dedupe people who want alerts thanks to dict keys...
            out_dict = dict([[i.get_email(), i.get_user_or_pair()]
                            for i in instances if i.alert])

        elif isinstance(instance, Question):
            staffers = User.objects.filter(is_staff=True)
            out_dict = dict([[user.email, user] for user in staffers
                                if user.has_perm('change_question')])

        # remove the creator...
        if instance.get_email() in out_dict.keys():
            del out_dict[instance.get_email()]

        func(
            target_dict=out_dict,
            response=instance if isinstance(instance, Response) else None,
            question=instance if isinstance(instance, Question) else None
        )

########NEW FILE########
__FILENAME__ = knowledge_tags
from hashlib import md5
from urllib import urlencode

from django import template

register = template.Library()


@register.simple_tag
def get_gravatar(email, size=60, rating='g', default=None):
    """ Return url for a Gravatar. From Zinnia blog. """
    url = 'https://secure.gravatar.com/avatar/{0}.jpg'.format(
        md5(email.strip().lower()).hexdigest()
    )
    options = {'s': size, 'r': rating}
    if default:
        options['d'] = default

    url = '%s?%s' % (url, urlencode(options))
    return url.replace('&', '&amp;')


@register.simple_tag
def page_query(request, page_num):
    qs = request.GET.copy()
    qs['page'] = page_num
    return qs.urlencode().replace('&', '&amp;')

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

urlpatterns = patterns('knowledge.views',
    url(r'^$', 'knowledge_index', name='knowledge_index'),

    url(r'^questions/$', 'knowledge_list', name='knowledge_list'),

    url(r'^questions/(?P<question_id>\d+)/$',
        'knowledge_thread', name='knowledge_thread_no_slug'),

    url(r'^questions/(?P<category_slug>[a-z0-9-_]+)/$', 'knowledge_list',
        name='knowledge_list_category'),

    url(r'^questions/(?P<question_id>\d+)/(?P<slug>[a-z0-9-_]+)/$',
        'knowledge_thread', name='knowledge_thread'),

    url(r'^moderate/(?P<model>[a-z]+)/'
        r'(?P<lookup_id>\d+)/(?P<mod>[a-zA-Z0-9_]+)/$',
        'knowledge_moderate', name='knowledge_moderate'),

    url(r'^ask/$', 'knowledge_ask', name='knowledge_ask'),
)

########NEW FILE########
__FILENAME__ = utils
from django.conf import settings


def paginate(iterable, per_page, page_num):
    """
        recipes = Recipe.objects.all()
        paginator, recipes = paginate(recipes, 12,
            request.GET.get('page', '1'))
    """
    from django.core.paginator import Paginator, InvalidPage, EmptyPage

    paginator = Paginator(iterable, per_page)

    try:
        page = int(page_num)
    except ValueError:
        page = 1

    try:
        iterable = paginator.page(page)
    except (EmptyPage, InvalidPage):
        iterable = paginator.page(paginator.num_pages)

    return paginator, iterable


def get_module(path):
    """
    A modified duplicate from Django's built in backend
    retriever.

        slugify = get_module('django.template.defaultfilters.slugify')
    """
    from django.utils.importlib import import_module

    try:
        mod_name, func_name = path.rsplit('.', 1)
        mod = import_module(mod_name)
    except ImportError, e:
        raise ImportError(
            'Error importing alert function {0}: "{1}"'.format(mod_name, e))

    try:
        func = getattr(mod, func_name)
    except AttributeError:
        raise ImportError(
            ('Module "{0}" does not define a "{1}" function'
                            ).format(mod_name, func_name))

    return func


user_model_label = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

########NEW FILE########
__FILENAME__ = views
import settings

from django.http import Http404, HttpResponseRedirect
from django.shortcuts import render, redirect, get_object_or_404
from django.core.urlresolvers import reverse, NoReverseMatch
from django.db.models import Q

from knowledge.models import Question, Response, Category
from knowledge.forms import QuestionForm, ResponseForm
from knowledge.utils import paginate


ALLOWED_MODS = {
    'question': [
        'private', 'public',
        'delete', 'lock',
        'clear_accepted'
    ],
    'response': [
        'internal', 'inherit',
        'private', 'public',
        'delete', 'accept'
    ]
}


def get_my_questions(request):

    if settings.LOGIN_REQUIRED and not request.user.is_authenticated():
        return HttpResponseRedirect(settings.LOGIN_URL+"?next=%s" % request.path)

    if request.user.is_anonymous():
        return None
    else:
        return Question.objects.can_view(request.user)\
                               .filter(user=request.user)


def knowledge_index(request,
                    template='django_knowledge/index.html'):

    if settings.LOGIN_REQUIRED and not request.user.is_authenticated():
        return HttpResponseRedirect(settings.LOGIN_URL+"?next=%s" % request.path)

    questions = Question.objects.can_view(request.user)\
                                .prefetch_related('responses__question')[0:20]
    # this is for get_responses()
    [setattr(q, '_requesting_user', request.user) for q in questions]

    return render(request, template, {
        'request': request,
        'questions': questions,
        'my_questions': get_my_questions(request),
        'categories': Category.objects.all(),
        'BASE_TEMPLATE' : settings.BASE_TEMPLATE,
    })


def knowledge_list(request,
                   category_slug=None,
                   template='django_knowledge/list.html',
                   Form=QuestionForm):

    if settings.LOGIN_REQUIRED and not request.user.is_authenticated():
        return HttpResponseRedirect(settings.LOGIN_URL+"?next=%s" % request.path)

    search = request.GET.get('title', None)
    questions = Question.objects.can_view(request.user)\
                                .prefetch_related('responses__question')

    if search:
        questions = questions.filter(
            Q(title__icontains=search) | Q(body__icontains=search)
        )

    category = None
    if category_slug:
        category = get_object_or_404(Category, slug=category_slug)
        questions = questions.filter(categories=category)

    paginator, questions = paginate(questions,
                                    50,
                                    request.GET.get('page', '1'))
    # this is for get_responses()
    [setattr(q, '_requesting_user', request.user) for q in questions]

    return render(request, template, {
        'request': request,
        'search': search,
        'questions': questions,
        'my_questions': get_my_questions(request),
        'category': category,
        'categories': Category.objects.all(),
        'form': Form(request.user, initial={'title': search}),  # prefill title
        'BASE_TEMPLATE' : settings.BASE_TEMPLATE,
    })


def knowledge_thread(request,
                     question_id,
                     slug=None,
                     template='django_knowledge/thread.html',
                     Form=ResponseForm):

    if settings.LOGIN_REQUIRED and not request.user.is_authenticated():
        return HttpResponseRedirect(settings.LOGIN_URL+"?next=%s" % request.path)
    
    try:
        question = Question.objects.can_view(request.user)\
                                   .get(id=question_id)
    except Question.DoesNotExist:
        if Question.objects.filter(id=question_id).exists() and \
                                hasattr(settings, 'LOGIN_REDIRECT_URL'):
            return redirect(settings.LOGIN_REDIRECT_URL)
        else:
            raise Http404

    responses = question.get_responses(request.user)

    if request.path != question.get_absolute_url():
        return redirect(question.get_absolute_url(), permanent=True)

    if request.method == 'POST':
        form = Form(request.user, question, request.POST)
        if form and form.is_valid():
            if request.user.is_authenticated() or not form.cleaned_data['phone_number']:
                form.save()
            return redirect(question.get_absolute_url())
    else:
        form = Form(request.user, question)

    return render(request, template, {
        'request': request,
        'question': question,
        'my_questions': get_my_questions(request),
        'responses': responses,
        'allowed_mods': ALLOWED_MODS,
        'form': form,
        'categories': Category.objects.all(),
        'BASE_TEMPLATE' : settings.BASE_TEMPLATE,
    })


def knowledge_moderate(
        request,
        lookup_id,
        model,
        mod,
        allowed_mods=ALLOWED_MODS):

    """
    An easy to extend method to moderate questions
    and responses in a vaguely RESTful way.

    Usage:
        /knowledge/moderate/question/1/inherit/     -> 404
        /knowledge/moderate/question/1/public/      -> 200

        /knowledge/moderate/response/3/notreal/     -> 404
        /knowledge/moderate/response/3/inherit/     -> 200

    """

    if settings.LOGIN_REQUIRED and not request.user.is_authenticated():
        return HttpResponseRedirect(settings.LOGIN_URL+"?next=%s" % request.path)

    if request.method != 'POST':
        raise Http404

    if model == 'question':
        Model, perm = Question, 'change_question'
    elif model == 'response':
        Model, perm = Response, 'change_response'
    else:
        raise Http404

    if not request.user.has_perm(perm):
        raise Http404

    if mod not in allowed_mods[model]:
        raise Http404

    instance = get_object_or_404(
        Model.objects.can_view(request.user),
        id=lookup_id)

    func = getattr(instance, mod)
    if callable(func):
        func()

    try:
        return redirect((
            instance if instance.is_question else instance.question
        ).get_absolute_url())
    except NoReverseMatch:
        # if we delete an instance...
        return redirect(reverse('knowledge_index'))


def knowledge_ask(request,
                  template='django_knowledge/ask.html',
                  Form=QuestionForm):

    if settings.LOGIN_REQUIRED and not request.user.is_authenticated():
        return HttpResponseRedirect(settings.LOGIN_URL+"?next=%s" % request.path)

    if request.method == 'POST':
        form = Form(request.user, request.POST)
        if form and form.is_valid():
            if request.user.is_authenticated() or not form.cleaned_data['phone_number']:
                question = form.save()
                return redirect(question.get_absolute_url())
            else:
                return redirect('knowledge_index')
    else:
        form = Form(request.user)

    return render(request, template, {
        'request': request,
        'my_questions': get_my_questions(request),
        'form': form,
        'categories': Category.objects.all(),
        'BASE_TEMPLATE' : settings.BASE_TEMPLATE,
    })

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = base
from django.test import TestCase as DjangoTestCase
from django.contrib.auth.models import User, AnonymousUser

from knowledge.models import Question, Response


class TestCase(DjangoTestCase):
    def setUp(self):
        self.admin = User.objects.create_superuser('admin', 'admin@example.com', 'secret')
        self.joe = User.objects.create_user('joe', 'joedirt@example.com', 'secret')
        self.bob = User.objects.create_user('bob', 'bob@example.com', 'secret')
        self.anon = AnonymousUser()

        self.joe.first_name = 'Joe'
        self.joe.last_name = 'Dirt'
        self.joe.save()

        ## joe asks a question ##
        self.question = Question.objects.create(
            user = self.joe,
            title = 'What time is it?',
            body = 'Whenever I look at my watch I see the little hand at 3 and the big hand at 7.'
        )

        ## admin responds ##
        self.response = Response.objects.create(
            question = self.question,
            user = self.admin,
            body = 'The little hand at 3 means 3 pm or am, the big hand at 7 means 3:35 am or pm.'
        )
########NEW FILE########
__FILENAME__ = forms
from django.contrib.auth.models import User, AnonymousUser
from django.core.urlresolvers import reverse
from django.template.defaultfilters import slugify

from mock.tests.base import TestCase
from knowledge.models import Question, Response
from knowledge.forms import QuestionForm, ResponseForm


class BasicFormTest(TestCase):
    """
    This tests reflect our defaults... namely KNOWLEDGE_ALLOW_ANONYMOUS,
    KNOWLEDGE_AUTO_PUBLICIZE, and KNOWLEDGE_FREE_RESPONSE.
    """

    def test_question_form_display(self):
        self.assertEqual(
            None,
            QuestionForm(self.anon)
        )

        self.assertNotEqual(
            None,
            QuestionForm(self.joe)
        )

        self.assertNotEqual(
            None,
            ResponseForm(self.admin, self.question)
        )

    def test_response_form_display(self):
        self.assertEqual(
            None,
            ResponseForm(self.anon, self.question)
        )

        self.assertNotEqual(
            None,
            ResponseForm(self.joe, self.question)
        )

        self.assertNotEqual(
            None,
            ResponseForm(self.admin, self.question)
        )

        # the default is to let others comment on
        # questions, even if they aren't staff and
        # didn't ask the question (KNOWLEDGE_FREE_RESPONSE)
        self.assertNotEqual(
            None,
            ResponseForm(self.bob, self.question)
        )

        # lock the question...
        self.question.lock()

        self.assertEqual(
            None,
            ResponseForm(self.admin, self.question)
        )

    def test_form_saving(self):
        QUESTION_POST = {
            'title': 'This is a title friend!',
            'body': 'This is the body friend!',
            'status': 'private'
        }

        form = QuestionForm(self.joe, QUESTION_POST)

        self.assertTrue(form.is_valid())

        question = form.save()

        self.assertEquals(question.status, 'private')
        self.assertEquals(question.name, None)
        self.assertEquals(question.email, None)
        self.assertEquals(question.title, 'This is a title friend!')
        self.assertEquals(question.body, 'This is the body friend!')
        self.assertEquals(question.user, self.joe)


        RESPONSE_POST = {
            'body': 'This is the response body friend!'
        }

        form = ResponseForm(self.joe, question, RESPONSE_POST)

        self.assertTrue(form.is_valid())

        response = form.save()

        self.assertEquals(response.status, 'inherit')
        self.assertEquals(response.name, None)
        self.assertEquals(response.email, None)
        self.assertEquals(response.body, 'This is the response body friend!')
        self.assertEquals(response.user, self.joe)
    
    def test_form_question_status(self):
        # test the default for anonymous in tests/settings.py...
        form = QuestionForm(self.joe)
        self.assertIn('status', form.fields.keys())

        # internal is only selectable for admins
        QUESTION_POST = {
            'title': 'This is a title friend!',
            'body': 'This is the body friend!',
            'status': 'internal'
        }

        self.assertFalse(QuestionForm(self.joe, QUESTION_POST).is_valid())
        self.assertTrue(QuestionForm(self.admin, QUESTION_POST).is_valid())

        QUESTION_POST = {
            'title': 'This is a title friend!',
            'body': 'This is the body friend!',
            'status': 'public'
        }
        question = QuestionForm(self.joe, QUESTION_POST).save()
        self.assertEquals(question.status, 'public')

########NEW FILE########
__FILENAME__ = managers
from django.contrib.auth.models import User, AnonymousUser

from mock.tests.base import TestCase
from knowledge.models import Question, Response

Q = Question.objects
R = Response.objects


class BasicMangerTest(TestCase):
    def test_question_qs(self):
        # the auto generated question tests are private by default
        self.assertEquals(0, Q.can_view(self.anon).count())
        self.assertEquals(0, Q.can_view(self.bob).count())

        self.assertEquals(1, Q.can_view(self.joe).count())
        self.assertEquals(1, Q.can_view(self.admin).count())


        ## someone comes along and publicizes this question ##
        self.question.public()

        # everyone can see
        self.assertEquals(1, Q.can_view(self.anon).count())
        self.assertEquals(1, Q.can_view(self.bob).count())
        self.assertEquals(1, Q.can_view(self.joe).count())
        self.assertEquals(1, Q.can_view(self.admin).count())


        ## someone comes along and privatizes this question ##
        self.question.private()

        self.assertEquals(0, Q.can_view(self.anon).count())
        self.assertEquals(0, Q.can_view(self.bob).count())

        self.assertEquals(1, Q.can_view(self.joe).count())
        self.assertEquals(1, Q.can_view(self.admin).count())

    def test_generic_response_qs(self):
        # the auto generated response tests are inherit 
        # (private by question's status) by default
        self.assertEquals(0, R.can_view(self.anon).count())
        self.assertEquals(0, R.can_view(self.bob).count())

        self.assertEquals(1, R.can_view(self.joe).count())
        self.assertEquals(1, R.can_view(self.admin).count())


        ## someone comes along and publicizes this response ##
        self.response.public()

        # everyone can see
        self.assertEquals(1, R.can_view(self.anon).count())
        self.assertEquals(1, R.can_view(self.bob).count())
        self.assertEquals(1, R.can_view(self.joe).count())
        self.assertEquals(1, R.can_view(self.admin).count())


        ## someone comes along and internalizes this response ##
        self.response.internal()

        # only admin can see
        self.assertEquals(0, R.can_view(self.anon).count())
        self.assertEquals(0, R.can_view(self.bob).count())
        self.assertEquals(0, R.can_view(self.joe).count())

        self.assertEquals(1, R.can_view(self.admin).count())


        ## someone comes along and privatizes this response ##
        self.response.private()
        
        self.assertEquals(0, R.can_view(self.anon).count())
        self.assertEquals(0, R.can_view(self.bob).count())

        self.assertEquals(1, R.can_view(self.joe).count())
        self.assertEquals(1, R.can_view(self.admin).count())
########NEW FILE########
__FILENAME__ = models
from django.contrib.auth.models import User, AnonymousUser
from django.core.urlresolvers import reverse
from django.template.defaultfilters import slugify
from django.core import mail

from mock.tests.base import TestCase
from knowledge.models import Question, Response


class BasicModelTest(TestCase):
    def test_basic_question_answering(self):
        """
        Given a question asked by a real user, track answering and accepted states.
        """

        ## joe asks a question ##
        question = Question.objects.create(
            user = self.joe,
            title = 'What time is it?',
            body = 'Whenever I look at my watch I see the little hand at 3 and the big hand at 7.'
        )

        self.assertFalse(question.answered())
        self.assertFalse(question.accepted())

        ## admin responds ##
        response = Response.objects.create(
            question = question,
            user = self.admin,
            body = 'The little hand at 3 means 3 pm or am, the big hand at 7 means 3:35 am or pm.'
        )

        self.assertTrue(question.answered())
        self.assertFalse(question.accepted())


        ## joe accepts the answer ##
        question.accept(response)

        self.assertTrue(question.answered())
        self.assertTrue(question.accepted())
        self.assertIn('accept', response.states())

        ## someone clears the accepted answer ##
        question.accept()

        self.assertFalse(question.accepted())

        response = Response.objects.get(id=response.id) # reload
        self.assertNotIn('accept', response.states())

        ## someone used the response accept shortcut ##
        response.accept()

        question = Question.objects.get(id=question.id) # reload
        self.assertTrue(question.answered())
        self.assertTrue(question.accepted())
        self.assertIn('accept', response.states())



    def test_switching_question(self):
        ## joe asks a question ##
        question = self.question
        self.assertEquals(question.status, 'private')
        self.assertIn('private', question.states())

        question.public()
        self.assertEquals(question.status, 'public')
        self.assertIn('public', question.states())

        question.private()
        self.assertEquals(question.status, 'private')
        self.assertIn('private', question.states())

        # no change
        question.inherit()
        self.assertEquals(question.status, 'private')
        self.assertIn('private', question.states())
        question.internal()
        self.assertEquals(question.status, 'private')
        self.assertIn('private', question.states())


    def test_switching_response(self):
        ## joe asks a question ##
        response = self.response
        self.assertEquals(response.status, 'inherit')
        self.assertIn('inherit', response.states())

        response.public()
        self.assertEquals(response.status, 'public')
        self.assertIn('public', response.states())

        response.internal()
        self.assertEquals(response.status, 'internal')
        self.assertIn('internal', response.states())

        response.private()
        self.assertEquals(response.status, 'private')
        self.assertIn('private', response.states())

        response.inherit()
        self.assertEquals(response.status, 'inherit')
        self.assertIn('inherit', response.states())


    def test_private_states(self):
        """
        Walk through the public, private and internal states for Question, and public, private,
        inherit and internal states for Response.

        Then checks who can see what with .can_view(<User>).
        """

        ## joe asks a question ##
        question = self.question

        self.assertFalse(question.can_view(self.anon))
        self.assertFalse(question.can_view(self.bob))

        self.assertTrue(question.can_view(self.joe))
        self.assertTrue(question.can_view(self.admin))


        ## someone comes along and publicizes this question ##
        question.public()

        # everyone can see
        self.assertTrue(question.can_view(self.anon))
        self.assertTrue(question.can_view(self.bob))

        self.assertTrue(question.can_view(self.joe))
        self.assertTrue(question.can_view(self.admin))


        ## someone comes along and privatizes this question ##
        question.private()
        
        self.assertFalse(question.can_view(self.anon))
        self.assertFalse(question.can_view(self.bob))

        self.assertTrue(question.can_view(self.joe))
        self.assertTrue(question.can_view(self.admin))


        ## admin responds ##
        response = self.response
        response.inherit()

        self.assertFalse(response.can_view(self.anon))
        self.assertFalse(response.can_view(self.bob))

        self.assertTrue(response.can_view(self.joe))
        self.assertTrue(response.can_view(self.admin))


        ## someone comes along and publicizes the parent question ##
        question.public()

        self.assertTrue(response.can_view(self.anon))
        self.assertTrue(response.can_view(self.bob))
        self.assertTrue(response.can_view(self.joe))
        self.assertTrue(response.can_view(self.admin))


        ## someone privatizes the response ##
        response.private()

        # everyone can see question still
        self.assertTrue(question.can_view(self.anon))
        self.assertTrue(question.can_view(self.bob))
        self.assertTrue(question.can_view(self.joe))
        self.assertTrue(question.can_view(self.admin))

        # only joe and admin can see the response though
        self.assertFalse(response.can_view(self.anon))
        self.assertFalse(response.can_view(self.bob))

        self.assertTrue(response.can_view(self.joe))
        self.assertTrue(response.can_view(self.admin))


        ## someone internalizes the response ##
        response.internal()

        # everyone can see question still
        self.assertTrue(question.can_view(self.anon))
        self.assertTrue(question.can_view(self.bob))
        self.assertTrue(question.can_view(self.joe))
        self.assertTrue(question.can_view(self.admin))

        # only admin can see the response though
        self.assertFalse(response.can_view(self.anon))
        self.assertFalse(response.can_view(self.bob))
        self.assertFalse(response.can_view(self.joe))

        self.assertTrue(response.can_view(self.admin))

    
    def test_get_responses(self):
        """
        Ensures adding another response isn't crossed into other responses.
        """
        self.assertEquals(len(self.question.get_responses(self.anon)), 0)
        self.assertEquals(len(self.question.get_responses(self.joe)), 1)
        self.assertEquals(len(self.question.get_responses(self.admin)), 1)

        question = Question.objects.create(
            title = 'Where is my cat?',
            body = 'His name is whiskers.',
            user = self.joe
        )
        response = Response.objects.create(
            question = question,
            user = self.admin,
            body = 'I saw him in the backyard.'
        )

        self.assertEquals(len(self.question.get_responses(self.anon)), 0)
        self.assertEquals(len(self.question.get_responses(self.joe)), 1)
        self.assertEquals(len(self.question.get_responses(self.admin)), 1)

        self.assertEqual(len(mail.outbox), 0)

    
    def test_get_public_responses(self):
        """
        Bug mentioned in issue #25.
        """
        question = Question.objects.create(
            title = 'Where is my cat?',
            body = 'His name is whiskers.',
            user = self.joe,
            status = 'public'

        )
        response = Response.objects.create(
            question = question,
            user = self.admin,
            body = 'I saw him in the backyard.',
            status = 'inherit'
        )

        self.assertEquals(len(question.get_responses(self.anon)), 1)
        self.assertEquals(len(question.get_responses(self.joe)), 1)
        self.assertEquals(len(question.get_responses(self.admin)), 1)

        self.assertEqual(len(mail.outbox), 0)

    
    def test_urls(self):
        question_url = reverse('knowledge_thread', args=[self.question.id, slugify(self.question.title)])

        self.assertEquals(self.question.url, question_url)


    def test_locking(self):
        self.assertFalse(self.question.locked)
        self.assertNotIn('lock', self.question.states())

        self.question.lock()

        self.assertTrue(self.question.locked)
        self.assertIn('lock', self.question.states())


    def test_url(self):
        self.assertEquals(
            '/knowledge/questions/{0}/{1}/'.format(
                self.question.id,
                slugify(self.question.title)),
            self.question.get_absolute_url()
        )

    def test_normal_question(self):
        self.assertEquals(self.question.get_name(), 'Joe Dirt')
        self.assertEquals(self.question.get_email(), 'joedirt@example.com')

        question = Question.objects.create(
            title = 'Where is my cat?',
            body = 'His name is whiskers.',
            user = self.bob
        )

        self.assertEquals(question.get_name(), 'bob') # no first/last
        self.assertEquals(question.get_email(), 'bob@example.com')


    def test_anon_question(self):
        question = Question.objects.create(
            title = 'Where is my cat?',
            body = 'His name is whiskers.',
            name = 'Joe Dirt',
            email = 'joedirt@example.com'
        )

        self.assertEquals(question.get_name(), 'Joe Dirt')
        self.assertEquals(question.get_email(), 'joedirt@example.com')
























########NEW FILE########
__FILENAME__ = sample
from mock.tests.base import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

    def test_basic_subtraction(self):
        """
        Tests that 5 - 3 always equals 2.
        """
        self.assertEqual(5 - 3, 2)
########NEW FILE########
__FILENAME__ = settings
from mock.tests.base import TestCase

from django.test.client import Client
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from django.template.defaultfilters import slugify

from knowledge import settings
from knowledge.models import Question, Response
from knowledge.forms import QuestionForm, ResponseForm


class BasicSettingsTest(TestCase):
    def test_ALLOW_ANONYMOUS(self):
        self.assertFalse(settings.ALLOW_ANONYMOUS)

        self.assertEqual(
            None,
            QuestionForm(self.anon)
        )

        self.assertEqual(
            None,
            ResponseForm(self.anon, self.question)
        )

        ############# flip setting ##############
        settings.ALLOW_ANONYMOUS = not settings.ALLOW_ANONYMOUS
        ############# flip setting ##############

        self.assertNotEqual(
            None,
            QuestionForm(self.anon)
        )

        self.assertNotEqual(
            None,
            ResponseForm(self.anon, self.question)
        )

        form = QuestionForm(self.anon)
        self.assertNotIn('status', form.fields.keys())

        # missing the name/email...
        QUESTION_POST = {
            'title': 'This is a title friend!',
            'body': 'This is the body friend!'
        }

        form = QuestionForm(self.anon, QUESTION_POST)
        self.assertFalse(form.is_valid())


        QUESTION_POST = {
            'name': 'Test Guy',
            'email': 'anonymous@example.com',
            'title': 'This is a title friend!',
            'body': 'This is the body friend!'
        }

        form = QuestionForm(self.anon, QUESTION_POST)
        self.assertTrue(form.is_valid())

        question = form.save()

        # question has no user and is public by default
        self.assertFalse(question.user)
        self.assertEquals(question.name, 'Test Guy')
        self.assertEquals(question.email, 'anonymous@example.com')
        self.assertEquals(question.status, 'public')

        ############# flip setting ##############
        settings.ALLOW_ANONYMOUS = not settings.ALLOW_ANONYMOUS
        ############# flip setting ##############


    def test_AUTO_PUBLICIZE(self):
        self.assertFalse(settings.AUTO_PUBLICIZE)

        QUESTION_POST = {
            'title': 'This is a title friend!',
            'body': 'This is the body friend!',
            'status': 'private'
        }

        question = QuestionForm(self.joe, QUESTION_POST).save()
        self.assertEquals(question.status, 'private')

        ############# flip setting ##############
        settings.AUTO_PUBLICIZE = not settings.AUTO_PUBLICIZE
        ############# flip setting ##############

        question = QuestionForm(self.joe, QUESTION_POST).save()
        self.assertEquals(question.status, 'public')


        ############# flip setting ##############
        settings.AUTO_PUBLICIZE = not settings.AUTO_PUBLICIZE
        ############# flip setting ##############


    def test_FREE_RESPONSE(self):
        self.assertTrue(settings.FREE_RESPONSE)

        # joe authored the question, it is private so any user can respond...
        self.assertFalse(ResponseForm(self.anon, self.question))
        self.assertTrue(ResponseForm(self.bob, self.question))
        self.assertTrue(ResponseForm(self.joe, self.question))
        self.assertTrue(ResponseForm(self.admin, self.question))

        ############# flip setting ##############
        settings.FREE_RESPONSE = not settings.FREE_RESPONSE
        ############# flip setting ##############

        # ...now bob can't respond!
        self.assertFalse(ResponseForm(self.anon, self.question))
        self.assertFalse(ResponseForm(self.bob, self.question))
        self.assertTrue(ResponseForm(self.joe, self.question))
        self.assertTrue(ResponseForm(self.admin, self.question))

        ############# flip setting ##############
        settings.FREE_RESPONSE = not settings.FREE_RESPONSE
        ############# flip setting ##############


    def test_SLUG_URLS(self):
        self.assertTrue(settings.SLUG_URLS)

        c = Client()

        self.question.public()

        question_url = reverse('knowledge_thread', args=[self.question.id, slugify(self.question.title)])

        r = c.get(reverse('knowledge_thread', args=[self.question.id, 'a-big-long-slug']))
        self.assertEquals(r.status_code, 301)

        r = c.get(question_url)
        self.assertEquals(r.status_code, 200)

        ############# flip setting ##############
        settings.SLUG_URLS = not settings.SLUG_URLS
        ############# flip setting ##############

        r = c.get(reverse('knowledge_thread', args=[self.question.id, 'a-big-long-slug']))
        self.assertEquals(r.status_code, 301)

        r = c.get(question_url)
        self.assertEquals(r.status_code, 301)

        r = c.get(reverse('knowledge_thread_no_slug', args=[self.question.id]))
        self.assertEquals(r.status_code, 200)

        ############# flip setting ##############
        settings.SLUG_URLS = not settings.SLUG_URLS
        ############# flip setting ##############

########NEW FILE########
__FILENAME__ = signals
from django.contrib.auth.models import User, AnonymousUser
from django.core import mail

from mock.tests.base import TestCase
from knowledge.models import Question, Response
from knowledge.forms import QuestionForm, ResponseForm
from knowledge import settings


class BasicSignalTest(TestCase):
    def setUp(self):
        self.assertFalse(settings.ALERTS)
        settings.ALERTS = not settings.ALERTS

        self.admin = User.objects.create_superuser('admin', 'admin@example.com', 'secret')
        self.joe = User.objects.create_user('joe', 'joedirt@example.com', 'secret')
        self.bob = User.objects.create_user('bob', 'bob@example.com', 'secret')
        self.anon = AnonymousUser()

        self.joe.first_name = 'Joe'
        self.joe.last_name = 'Dirt'
        self.joe.save()

        ## joe asks a question ##
        self.question = Question.objects.create(
            user = self.joe,
            title = 'What time is it?',
            body = 'Whenever I look at my watch I see the little hand at 3 and the big hand at 7.',
            alert = settings.ALERTS,
        )

        ## admin responds ##
        self.response = Response.objects.create(
            question = self.question,
            user = self.admin,
            body = 'The little hand at 3 means 3 pm or am, the big hand at 7 means 3:35 am or pm.',
            alert = settings.ALERTS,
        )
        mail.outbox = [] # reset


    def tearDown(self):
        self.assertTrue(settings.ALERTS)
        mail.outbox = []
        settings.ALERTS = not settings.ALERTS
        super(BasicSignalTest, self).tearDown()


    def test_sending_alerts_dedupe(self):
        """
        One question by joe, two responses by admin: bob responds.
        """
        ######## SETUP
        self.assertTrue(settings.ALERTS)

        RESPONSE_POST = {
            'body': 'This is the response body friend!',
            'status': 'inherit',
            'alert': settings.ALERTS,
        }

        # another admin response
        response = ResponseForm(self.admin, self.question, RESPONSE_POST).save()

        mail.outbox = [] # reset
        self.assertEqual(len(mail.outbox), 0)
        ######## TEARDOWN

        RESPONSE_POST = {
            'body': 'This is the response body friend!',
            'alert': settings.ALERTS,
        }

        # question is by joe, first response is by admin
        form = ResponseForm(self.bob, self.question, RESPONSE_POST)
        self.assertTrue(form.is_valid())
        response = form.save()

        self.assertTrue(response.alert)
        self.assertEqual(len(mail.outbox), 2) # one for joe, one for admin


    def test_sending_alerts_normal(self):
        """
        One question by joe, one response by admin: bob responds.
        """
        self.assertTrue(settings.ALERTS)
        
        self.assertEqual(len(mail.outbox), 0)

        RESPONSE_POST = {
            'body': 'This is the response body friend!',
            'alert': settings.ALERTS,
        }

        # question is by joe, first response is by admin
        form = ResponseForm(self.bob, self.question, RESPONSE_POST)
        self.assertTrue(form.is_valid())
        response = form.save()

        self.assertTrue(response.alert)
        self.assertEqual(len(mail.outbox), 2) # one for joe, one for admin


    def test_sending_alerts_remove_self(self):
        """
        One question by joe, one response by admin: joe responds.
        """
        self.assertTrue(settings.ALERTS)

        self.assertEqual(len(mail.outbox), 0)

        RESPONSE_POST = {
            'body': 'This is the response body friend!',
            'alert': settings.ALERTS,
        }

        # question is by joe, first response is by admin
        form = ResponseForm(self.joe, self.question, RESPONSE_POST)
        self.assertTrue(form.is_valid())
        response = form.save()

        self.assertTrue(response.alert)
        self.assertEqual(len(mail.outbox), 1) # one for admin (not joe!)


    def test_sending_staffers(self):
        self.assertTrue(settings.ALERTS)

        self.assertEqual(len(mail.outbox), 0)

        QUESTION_POST = {
            'title': 'This is a title friend!',
            'body': 'This is the body friend!',
            'status': 'private'
        }

        question = QuestionForm(self.joe, QUESTION_POST).save()
        self.assertEqual(len(mail.outbox), 1) # one for admin (not joe!)


    def test_sending_staffers_remove_self(self):
        self.assertTrue(settings.ALERTS)

        self.assertEqual(len(mail.outbox), 0)

        QUESTION_POST = {
            'title': 'This is a title friend!',
            'body': 'This is the body friend!',
            'status': 'private'
        }

        question = QuestionForm(self.admin, QUESTION_POST).save()
        self.assertEqual(len(mail.outbox), 0) # none for admin

########NEW FILE########
__FILENAME__ = templatetags
from django.test.client import RequestFactory

from mock.tests.base import TestCase

from knowledge.templatetags.knowledge_tags import get_gravatar, page_query


class BasicTemplateTagTest(TestCase):
    def test_gravatar(self):
        self.assertEquals(
            'https://secure.gravatar.com/avatar/883955996dbb79f38d8814dbfb336885.jpg?s=60&amp;r=g&amp;d=retro', 
            get_gravatar('bryan@bryanhelmig.com', 60, 'g', 'retro')
        )

    def test_page_query(self):
        request = RequestFactory().get('/faker/?something=extra&page=123')
        self.assertEquals('something=extra&amp;page=666', page_query(request, 666))

        request = RequestFactory().get('/faker/?something=extra')
        self.assertEquals('something=extra&amp;page=666', page_query(request, 666))
########NEW FILE########
__FILENAME__ = utils
from mock.tests.base import TestCase

from knowledge.utils import paginate, get_module


class BasicPaginateTest(TestCase):
    def test_paginate_helper(self):
        paginator, objects = paginate(range(0,1000), 100, 'xcvb')
        self.assertEquals(objects.number, 1) # fall back to first page

        paginator, objects = paginate(range(0,1000), 100, 154543)
        self.assertEquals(objects.number, 10) # fall back to last page

        paginator, objects = paginate(range(0,1000), 100, 1)

        self.assertEquals(len(objects.object_list), 100)
        self.assertEquals(paginator.count, 1000)
        self.assertEquals(paginator.num_pages, 10)

    def test_importer_basic(self):
        from django.template.defaultfilters import slugify
        sluggy = get_module('django.template.defaultfilters.slugify')

        self.assertTrue(slugify is sluggy)

    def test_importer_fail(self):
        self.assertRaises(ImportError, get_module, 'django.notreal.america')
        self.assertRaises(ImportError, get_module, 'django.template.defaultfilters.slugbug')
########NEW FILE########
__FILENAME__ = views
from mock.tests.base import TestCase

from django.test.client import Client
from django.contrib.auth.models import User, AnonymousUser

from django.core.urlresolvers import reverse
from django.template.defaultfilters import slugify

from knowledge.models import Question, Response, Category


class BasicViewTest(TestCase):
    def test_index(self):
        c = Client()

        r = c.get(reverse('knowledge_index'))
        self.assertEquals(r.status_code, 200)


    def test_list(self):
        c = Client()

        r = c.get(reverse('knowledge_list'))
        self.assertEquals(r.status_code, 200)


    def test_list_category(self):
        c = Client()

        r = c.get(reverse('knowledge_list_category', args=['notreal']))
        self.assertEquals(r.status_code, 404)

        category = Category.objects.create(title='Hello!', slug='hello')

        r = c.get(reverse('knowledge_list_category', args=['hello']))
        self.assertEquals(r.status_code, 200)


    def test_list_search(self):
        c = Client()

        r = c.get(reverse('knowledge_list') + '?title=hello!')
        self.assertEquals(r.status_code, 200)


    def test_thread(self):
        c = Client()

        question_url = reverse('knowledge_thread', args=[self.question.id, slugify(self.question.title)])

        r = c.get(reverse('knowledge_thread', args=[123456, 'a-big-long-slug']))
        self.assertEquals(r.status_code, 404)

        # this is private by default
        r = c.get(reverse('knowledge_thread', args=[self.question.id, 'a-big-long-slug']))
        self.assertEquals(r.status_code, 404)
    
        r = c.get(question_url)
        self.assertEquals(r.status_code, 404)

        c.login(username='joe', password='secret')

        r = c.get(reverse('knowledge_thread', args=[self.question.id, 'a-big-long-slug']))
        self.assertEquals(r.status_code, 301)

        r = c.get(question_url)
        self.assertEquals(r.status_code, 200)


        RESPONSE_POST = {
            'body': 'This is the response body friend!'
        }

        r = c.post(question_url, RESPONSE_POST)
        self.assertEquals(r.status_code, 302)

        # back to an anon user
        c.logout()

        # lets make it public...
        self.question.public()
    
        r = c.get(question_url)
        self.assertEquals(r.status_code, 200)

        # invalid responses POSTs are basically ignored...
        r = c.post(question_url, RESPONSE_POST)
        self.assertEquals(r.status_code, 200)


    def test_moderate(self):
        c = Client()

        r = c.get(reverse('knowledge_moderate', args=['question', self.question.id, 'public']))
        self.assertEquals(r.status_code, 404)

        r = c.post(reverse('knowledge_moderate', args=['question', self.question.id, 'public']))
        self.assertEquals(r.status_code, 404)

        r = c.post(reverse('knowledge_moderate', args=['response', self.response.id, 'public']))
        self.assertEquals(r.status_code, 404)


        c.login(username='admin', password='secret')

        r = c.post(reverse('knowledge_moderate', args=['question', self.question.id, 'notreal']))
        self.assertEquals(r.status_code, 404)

        # nice try buddy!
        r = c.post(reverse('knowledge_moderate', args=['user', self.admin.id, 'delete']))
        self.assertEquals(r.status_code, 404)

        # GET does not work
        r = c.get(reverse('knowledge_moderate', args=['question', self.question.id, 'public']))
        self.assertEquals(r.status_code, 404)

        self.assertEquals(Question.objects.get(id=self.question.id).status, 'private')
        r = c.post(reverse('knowledge_moderate', args=['question', self.question.id, 'public']))
        self.assertEquals(r.status_code, 302)
        self.assertEquals(Question.objects.get(id=self.question.id).status, 'public')

        r = c.post(reverse('knowledge_moderate', args=['response', self.response.id, 'public']))
        self.assertEquals(r.status_code, 302)

        r = c.post(reverse('knowledge_moderate', args=['question', self.question.id, 'delete']))
        self.assertEquals(r.status_code, 302)

        r = c.post(reverse('knowledge_moderate', args=['question', self.question.id, 'delete']))
        self.assertEquals(r.status_code, 404)


    def test_ask(self):
        c = Client()

        r = c.get(reverse('knowledge_ask'))
        self.assertEquals(r.status_code, 200)

        QUESTION_POST = {
            'title': 'This is a title friend!',
            'body': 'This is the body friend!',
            'status': 'private'
        }

        # invalid question POSTs are basically ignored...
        r = c.post(reverse('knowledge_ask'), QUESTION_POST)
        self.assertEquals(r.status_code, 200)

        c.login(username='joe', password='secret')

        # ...unless you are a user with permission to ask
        r = c.post(reverse('knowledge_ask'), QUESTION_POST)
        self.assertEquals(r.status_code, 302)
########NEW FILE########
__FILENAME__ = settings
import os

DIRNAME = os.path.dirname(__file__)

DEBUG = True

DATABASE_ENGINE = 'sqlite3'
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': os.path.join(DIRNAME, 'example.sqlite').replace('\\','/'),
        'USER': '',
        'PASSWORD': '',
        'HOST': '',
        'PORT': '',
    }
}

STATIC_URL = '/static/'

INTERNAL_IPS = ('127.0.0.1',)

SITE_ID = 1
SECRET_KEY = 'lolz'

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'debug_toolbar.middleware.DebugToolbarMiddleware',
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.admin',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.markup',

    'debug_toolbar',
    'knowledge',
    'south',
    'django_coverage',
    'mock',
)

ROOT_URLCONF = 'tests.urls'

COVERAGE_REPORT_HTML_OUTPUT_DIR = os.path.join(DIRNAME, 'reports').replace('\\','/')

TEMPLATE_DIRS = (
    os.path.join(DIRNAME, 'templates').replace('\\','/')
)

LOGIN_REDIRECT_URL = '/admin/'

########NEW FILE########
__FILENAME__ = urls
import os

from django.conf.urls import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^knowledge/', include('knowledge.urls')),
    url(r'^static/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': os.path.join(
                os.path.dirname(__file__), '../knowledge/static'
            ).replace('\\','/')}),
)

########NEW FILE########
