__FILENAME__ = build_docs
#!/usr/bin/env python

import logging
import subprocess
import os

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

class LogStream(object):
    def __init__(self, log_func):
        self.log_func = log_func
    
    def log_line(self, line):
        self.log_func(line)
    
    def writelines(self, sequence):
        for line in sequence:
            self.log_line(line)
    
    def write(self, string):
        self.log_line(string)

class TaskLogger(logging.Logger):
    def __init__(self, *args, **kwargs):
        logging.Logger.__init__(self, *args, **kwargs)
        self.log_stream = StringIO()
        handler = logging.StreamHandler(self.log_stream)
        handler.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.addHandler(handler)
    
    def read_log(self):
        return self.log_stream.getvalue()
    
    def get_stdout_object(self):
        return LogStream(self.info)
    
    def get_stderr_object(self):
        return LogStream(self.error)

class CommandResponse(object):
    def __init__(self, session, cmd, popen, block, logger):
        self.session = session
        self.cmd = cmd
        self.popen = popen
        self.joined = False
        self.logger = logger
        if block:
            self.join()
    
    def join(self):
        if self.joined:
            return
        self.joined = True
        self.stdout, self.stderr = self.popen.communicate()
        if self.stdout:
            self.logger.info(self.stdout)
        if self.stderr:
            self.logger.error(self.stderr)
        self.logger.debug('Return Code: %s' % self.returncode)
    
    @property
    def returncode(self):
        return self.popen.returncode

class CommandFailure(Exception):
    pass

class ShellSession(object):
    def __init__(self, logger, cwd=None, **popen_kwargs):
        self.popen_kwargs = {
            'cwd': cwd or os.getcwd(),
            'stdout': subprocess.PIPE,
            'stderr': subprocess.PIPE,
        }
        self.popen_kwargs.update(popen_kwargs)
        self.logger = logger

    def run(self, cmd, block=True):
        kwargs = dict(self.popen_kwargs)
        if isinstance(cmd, basestring):
            kwargs['shell'] = True
        self.logger.info(cmd)
        result = subprocess.Popen(cmd, **kwargs)
        return CommandResponse(self, cmd, result, block, self.logger)
    
    def run_with_retries(self, cmd, retries=3):
        attempts = list()
        while retries:
            response = self.run(cmd)
            if response.returncode:
                retries -= 1
                attempts.append(response)
            else:
                return response
        raise CommandFailure('Failed to run command, # of attempts: %s' % len(attempts), attempts)

    def cd(self, directory):
        if directory.startswith('/'):
            self.popen_kwargs['cwd'] = directory
        else:
            self.popen_kwargs['cwd'] = os.path.join(self.popen_kwargs['cwd'], directory)
        self.logger.info('cd %s' % self.popen_kwargs['cwd'])

if __name__ == '__main__':
    import sys
    logger = TaskLogger('docbuilder')
    shell = ShellSession(logger, stdout=sys.stdout, stderr=sys.stderr)
    shell.run('virtualenv --system-site-packages .')
    shell.run_with_retries('bin/pip install -q -r doc_requirements.txt')
    shell.run_with_retries('bin/pip install -q Sphinx')
    shell.run('bin/python setup.py build_sphinx -E')


########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Daily Deals documentation build configuration file, created by
# sphinx-quickstart on Wed Mar  2 13:19:43 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.insert(0, os.path.abspath('.'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'docproject.settings'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django Hyperadmin'
copyright = u'2013'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.

from hyperadmin import get_version

version = get_version(include_sub=False)
# The full version, including alpha/beta/rc tags.
release = get_version()

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoHyperadmindoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'DjangoHyperadmin.tex', u'Django Hyperadmin Documentation', 'Jason Kraus',
   'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'djangohyperadmin', u'Django Hyperadmin Documentation',
     [u'Jason Kraus'], 1)
]

#additional options added for the project

autodoc_member_order = 'bysource'

########NEW FILE########
__FILENAME__ = settings
# Django settings for {{ project_name }} project.
import os

PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))
DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': ':memory:',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = os.path.join(PROJECT_DIR, 'media')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '/media/'

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = os.path.join(PROJECT_DIR, 'static')

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'notreallyasecret'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'docproject.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    'hyperadmin',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
]

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url
from django.conf import settings

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

import hyperadmin
hyperadmin.autodiscover()
hyperadmin.site.install_models_from_site(admin.site)
hyperadmin.site.install_storage_resources()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', '{{ project_name }}.views.home', name='home'),
    # url(r'^{{ project_name }}/', include('{{ project_name }}.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
    url(r'^hyper-admin/', include(hyperadmin.site.urls)),
)



if settings.DEBUG:
    urlpatterns += patterns('django.views',
        (r'^media/(?P<path>.*)$', 'static.serve', {'document_root': settings.MEDIA_ROOT}),
    )

########NEW FILE########
__FILENAME__ = apirequests
import mimeparse

from django.contrib.auth.models import AnonymousUser

from hyperadmin.states import State


class APIRequest(object):
    """
    An API Request
    """
    def __init__(self, site, path, url_args, url_kwargs, global_state=None):
        self.site = site
        self.path = path
        self.url_args = url_args
        self.url_kwargs = url_kwargs
        #self.payload = payload
        #self.method = method
        #self.user = user
        #self.params = params
        #self.META = meta
        self.session_state = State()
        self.endpoint_state = State()
        self.endpoint_state['endpoints'] = dict()
        self.endpoint_state['link_prototypes'] = dict()
        if global_state is not None:
            self.session_state.update(global_state)
        super(APIRequest, self).__init__()

    def get_django_request(self):
        raise NotImplementedError

    @property
    def META(self):
        return self.session_state['meta']

    @property
    def media_types(self):
        return self.get_site().media_types

    def get_response_type(self):
        """
        Returns the active response type to be used

        :rtype: string
        """
        val = self.META.get('HTTP_ACCEPT', self.META.get('CONTENT_TYPE', ''))
        media_types = self.media_types.keys()
        if not media_types:
            return val
        return mimeparse.best_match(media_types, val) or val

    def get_request_type(self):
        """
        Returns the active request type to be used

        :rtype: string
        """
        val = self.META.get('CONTENT_TYPE', self.META.get('HTTP_ACCEPT', ''))
        media_types = self.media_types.keys()
        if not media_types:
            return val
        return mimeparse.best_match(media_types, val) or val

    def get_request_media_type(self):
        """
        Returns the request media type to be used or raises an error

        :raises ValueError: when the requested content type is unrecognized
        :rtype: string
        """
        content_type = self.get_request_type()
        media_type_cls = self.media_types.get(content_type, None)
        if media_type_cls is None:
            raise ValueError('Unrecognized request content type "%s". Choices are: %s' % (content_type, self.media_types.keys()))
        return media_type_cls(self)

    def get_response_media_type(self):
        """
        Returns the response media type to be used or raises an error

        :raises ValueError: when the requested content type is unrecognized
        :rtype: string
        """
        content_type = self.get_response_type()
        media_type_cls = self.media_types.get(content_type, None)
        if media_type_cls is None:
            raise ValueError('Unrecognized request content type "%s". Choices are: %s' % (content_type, self.media_types.keys()))
        return media_type_cls(self)

    def get_endpoint(self, urlname):
        """
        Returns a bound endpoint matching the urlname

        :param urlname: The urlname to find
        :type urlname: string
        :raises KeyError: when the urlname does not match any endpoints
        :rtype: Endpoint
        """
        if urlname not in self.endpoint_state['endpoints']:
            endpoint = self.site.get_endpoint_from_urlname(urlname)
            bound_endpoint = endpoint.fork(api_request=self)
            if bound_endpoint != self.endpoint_state['endpoints'][urlname]:
                pass
        return self.endpoint_state['endpoints'][urlname]

    def record_endpoint(self, endpoint):
        """
        Record the endpoint in our urlname cache

        :param resource: Endpoint
        """
        assert endpoint.api_request == self
        urlname = endpoint.get_url_name()
        if urlname not in self.endpoint_state['endpoints']:
            self.endpoint_state['endpoints'][urlname] = endpoint
        #else:
        #    original = self.endpoint_state['endpoints'][urlname]
        #    self.site.get_logger().debug('Double registration at api request level on %s by %s, original: %s' % (urlname, endpoint, original))

    def get_link_prototypes(self, endpoint):
        """
        Returns the link prototypes to be used by the endpint

        :param endpoint: endpoint object
        :rtype: list of link prototypes
        """
        urlname = endpoint.get_url_name()
        if urlname not in self.endpoint_state['link_prototypes']:
            link_prototypes = endpoint.create_link_prototypes()
            self.endpoint_state['link_prototypes'][urlname] = link_prototypes
        return self.endpoint_state['link_prototypes'][urlname]

    def get_site(self):
        """
        Returns the bound site

        :rtype: SiteResource
        """
        if 'site' not in self.endpoint_state:
            bound_site = self.site.fork(api_request=self)
            self.endpoint_state['site'] = bound_site
        return self.endpoint_state['site']

    def generate_response(self, link, state):
        """
        Returns a response generated from the response media type

        :param link: The active link representing the endpoint's response
        :param state: The endpoint's state
        :rtype: [Http]Response
        """
        media_type = self.get_response_media_type()
        response_type = self.get_response_type()
        return media_type.serialize(content_type=response_type, link=link, state=state)

    def generate_options_response(self, links, state):
        """
        Returns an OPTIONS response generated from the response media type

        :param links: dictionary mapping available HTTP methods to a link
        :param state: The endpoint's state
        :rtype: [Http]Response
        """
        media_type = self.get_response_media_type()
        response_type = self.get_response_type()
        return media_type.options_serialize(content_type=response_type, links=links, state=state)

    def reverse(self, name, *args, **kwargs):
        return self.get_site().reverse(name, *args, **kwargs)

class InternalAPIRequest(APIRequest):
    """
    An Internal API Request
    """
    def __init__(self, site, path='/', url_args=[], url_kwargs={}, **kwargs):
        super(InternalAPIRequest, self).__init__(site, path, url_args, url_kwargs)
        kwargs.setdefault('method', 'GET')
        kwargs.setdefault('params', {})
        kwargs.setdefault('payload', {})
        kwargs.setdefault('full_path', path)
        for key, val in kwargs.iteritems():
            setattr(self, key, val)
        self.session_state.update(self.get_session_data())

    def get_full_path(self):
        return self.full_path

    def get_django_request(self):
        return self.request

    def get_session_data(self):
        data = {'endpoints': {},
                'resources': {},
                #'request': request,
                'meta': {
                    'CONTENT_TYPE':'application/vnd.Collection.hyperadmin+JSON',
                },
                'extra_get_params':{},}
        if hasattr(self, 'user'):
            data['auth'] = self.user
        return data

class HTTPAPIRequest(APIRequest):
    """
    Represents an API Request spawned from a Django HTTP Request
    """

    get_to_meta_map = {
        '_HTTP_ACCEPT':'HTTP_ACCEPT',
        '_CONTENT_TYPE':'CONTENT_TYPE',
    }

    def __init__(self, request, **kwargs):
        self.request = request
        kwargs.setdefault('path', request.path)
        super(HTTPAPIRequest, self).__init__(**kwargs)
        self.populate_session_data_from_request(request)

    @property
    def payload(self):
        if not hasattr(self, '_payload'):
            media_type = self.get_request_media_type()
            self._payload = media_type.deserialize()
        return self._payload

    @property
    def method(self):
        return self.request.method

    def get_django_request(self):
        return self.request

    def get_full_path(self):
        return self.request.get_full_path()

    @property
    def user(self):
        return self.session_state.get('auth', AnonymousUser())

    @property
    def params(self):
        if not hasattr(self, '_params'):
            self._params = self.request.GET.copy()
        return self._params

    def get_session_data_from_request(self, request):
        #TODO consult site object
        data = {'endpoints': {},
                'resources': {},
                'request': request,
                'meta': self.patched_meta(request),
                'extra_get_params': self.get_passthrough_params(request), }
        if hasattr(request, 'user'):
            data['auth'] = request.user
        return data

    def populate_session_data_from_request(self, request):
        data = self.get_session_data_from_request(request)
        self.session_state.update(data)
        #TODO set response type & request type

    def patched_meta(self, request):
        meta = dict(request.META)
        for src, dst in self.get_to_meta_map.iteritems():
            if src in request.GET:
                val = request.GET[src]
                meta[dst] = val
        return meta

    def get_passthrough_params(self, request):
        pass_through_params = dict()
        for src, dst in self.get_to_meta_map.iteritems():
            if src in request.GET:
                pass_through_params[src] = request.GET[src]
        return pass_through_params


class NamespaceAPIRequest(InternalAPIRequest):
    def __init__(self, api_request, **kwargs):
        self.original_api_request = api_request
        kwargs.setdefault('full_path', self.original_api_request.get_full_path())
        kwargs.setdefault('site', api_request.site)
        super(NamespaceAPIRequest, self).__init__(**kwargs)
        self.site = api_request.site.fork(api_request=self)
        self.session_state = State(substates=[api_request.session_state])

    @property
    def user(self):
        return self.original_api_request.user

    def get_django_request(self):
        return self.original_api_request.get_django_request()


class Namespace(object):
    """
    Represents alternative data associated with the current api request

    Namespaced data is provided by another resource through an internal api request
    """
    def __init__(self, name, endpoint, state_data={}):
        self.name = name
        self.api_request = NamespaceAPIRequest(endpoint.api_request)
        self.state_data = state_data
        self.endpoint = endpoint.fork(api_request=self.api_request)
        self.endpoint.state.update(state_data)
        self.api_request.endpoint_state['endpoints'][self.endpoint.get_url_name()] = self.endpoint

    def get_namespaces(self):
        return dict()

    def get_prompt(self):
        return self.endpoint.get_prompt()

    @property
    def link(self):
        if not hasattr(self, '_link'):
            self._link = self.endpoint.get_link()
        return self._link

    @property
    def state(self):
        return self.endpoint.state

########NEW FILE########
__FILENAME__ = app_settings
from django.conf import settings
from django.utils.importlib import import_module


path = getattr(settings, 'DEFAULT_API_REQUEST_CLASS', 'hyperadmin.apirequests.HTTPAPIRequest')
path, classname = path.rsplit('.', 1)

DEFAULT_API_REQUEST_CLASS = getattr(import_module(path), classname)


########NEW FILE########
__FILENAME__ = common
try:
    from django.conf.urls import patterns, url
except ImportError:
    from django.conf.urls.defaults import patterns, url
from django.views.generic import TemplateView
from django.core.urlresolvers import reverse

from hyperadmin.apirequests import InternalAPIRequest

import logging


class Client(object):
    default_namespace = 'hyper-client'
    default_app_name = 'client'
    
    def __init__(self, api_endpoint, name=None, app_name=None):
        self.api_endpoint = api_endpoint
        self.name = name or self.default_namespace
        self.app_name = app_name or self.default_app_name
    
    def get_logger(self):
        return logging.getLogger(__name__)
    
    def get_urls(self):
        pass
    
    def urls(self):
        return self, self.app_name, self.name
    urls = property(urls)
    
    @property
    def urlpatterns(self):
        return self.get_urls()
    
    def reverse(self, name, *args, **kwargs):
        return reverse('%s:%s' % (self.name, name), args=args, kwargs=kwargs, current_app=self.app_name)

class SimpleTemplateClientView(TemplateView):
    client = None
    
    def get_context_data(self, **kwargs):
        context = super(SimpleTemplateClientView, self).get_context_data(**kwargs)
        context.update(self.client.get_context_data())
        return context

class SimpleTemplateClient(Client):
    template_name = None
    template_view = SimpleTemplateClientView
    
    def get_media(self):
        pass #TODO
    
    def get_context_data(self):
        api_endpoint = self.api_endpoint
        api_request = InternalAPIRequest(site=api_endpoint)
        api_endpoint = api_endpoint.fork(api_request=api_request)
        api_url = api_endpoint.get_url()
        return {'media':self.get_media(),
                'api_endpoint':api_url,
                'client':self,}
    
    def get_urls(self):
        urlpatterns = patterns('',
            url(r'^$',
                self.template_view.as_view(template_name=self.template_name, client=self),
                name='index'),
        )
        return urlpatterns


########NEW FILE########
__FILENAME__ = djangoviews
from django.conf.urls.defaults import patterns, url

from hyperadmin.clients.common import Client
#from hyperadmin.hyperobjects import patch_global_state


class BaseDjangoViewsClient(Client):
    """
    Host a set of django views that proxy to an api endpoint.
    
    Under the hood we create a new api with our own set of endpoints.
    """
    
    #set to False is we should respect the api endpoint's auth requirements
    public = True
    
    def __init__(self, api_endpoint, name='hyper-client', app_name='client'):
        super(BaseDjangoViewsClient, self).__init__(api_endpoint, name=name, app_name=app_name)
    
    def get_view_kwargs(self, **kwargs):
        params = {'client_site':self,}
        params.update(kwargs)
        return params
    
    def get_view_endpoints(self):
        """
        Returns a list of dictionaries containing the following elements:
        
        * url: relative regex url
        * view: the view object
        * name: name for urlresolver
        """
        return []
    
    def get_urls(self):
        urlpatterns = patterns('',)
        for endpoint in self.get_view_endpoints():
            urlpatterns += patterns('',
                url(endpoint['url'],
                    endpoint['view'],
                    name=endpoint['name'],),
            )
        return urlpatterns
    
    def api_permission_check(self, request):
        if not self.public:
            return self.api_endpoint.api_permission_check(request)
    
    def get_related_resource_from_field(self, field):
        return self.api_endpoint.get_related_resource_from_field(field)
    
    def get_html_type_from_field(self, field):
        return self.api_endpoint.get_html_type_from_field(field)
    
    @property
    def state(self):
        return self.api_endpoint.state
    
    @property
    def media_types(self):
        return self.api_endpoint.media_types

class DjangoViewsClient(BaseDjangoViewsClient):
    """
    view_endpoint_defs = [
        {'url':r'/path/',
         'view_class':ListView,
         'resource':site.get_resource(MyModel),
         'endpoint_name':'app_resource_list', #consider, can we detect this?
         'name':'myview_list' or None,}
    ]
    """
    view_endpoint_defs = []
    
    def __init__(self, *args, **kwargs):
        super(DjangoViewsClient, self).__init__(*args, **kwargs)
        self.view_endpoints = list()
    
    def register_view_endpoint(self, url, view_class, resource, endpoint_name, name=None, options={}):
        view_kwargs = self.get_view_kwargs(resource=resource, url_name=endpoint_name, **options)
        
        self.view_endpoints.append({
            'url': url,
            'view': view_class.as_view(**view_kwargs),
            'name': name or endpoint_name,
        })
    
    def get_view_endpoints(self):
        endpoints = super(DjangoViewsClient, self).get_view_endpoints()
        for entry in self.view_endpoint_defs:
            view_class = entry['view_class']
            view_kwargs = self.get_view_kwargs(resource=entry['resource'], url_name=entry['endpoint_name'])
            
            endpoints.append({
                'url': entry['url'],
                'view': view_class.as_view(**view_kwargs),
                'name': entry.get('name', entry['endpoint_name']),
            })
        endpoints.extend(self.view_endpoints)
        return endpoints


########NEW FILE########
__FILENAME__ = mediatype
from copy import copy

try:
    from django.conf.urls import patterns
except ImportError:
    from django.conf.urls.defaults import patterns

from hyperadmin.clients.common import Client
from hyperadmin.endpoints import RootEndpoint


class MediaTypeRootEndpoint(RootEndpoint):
    inner_api_endpoint = None
    client = None
    
    def __init__(self, **kwargs):
        super(MediaTypeRootEndpoint, self).__init__(**kwargs)
        self.media_types = self.client.get_media_types()
    
    def get_api_request_kwargs(self, **kwargs):
        params = {'site':self.get_inner_api_endpoint()}
        params.update(kwargs)
        return params
    
    def get_inner_api_endpoint(self):
        if not hasattr(self, 'bound_inner_api_endpoint'):
            new_attrs = {
                'get_api_request_kwargs':self.get_api_request_kwargs,
                'media_types':self.media_types,
                'reverse':self.reverse,
            }
            self.bound_inner_api_endpoint = self.inner_api_endpoint.fork(**new_attrs)
        return self.bound_inner_api_endpoint
    
    def get_urls(self):
        return self.get_inner_api_endpoint().get_urls()

class MediaTypeClient(Client):
    '''
    Allows you to overide specific media types and host the resulting API at a different location
    '''
    media_types = []
    
    def __init__(self, api_endpoint, name='hyper-client', app_name='client'):
        super(MediaTypeClient, self).__init__(api_endpoint, name=name, app_name=app_name)
        self.site = MediaTypeRootEndpoint(client=self, inner_api_endpoint=api_endpoint, namespace=name, app_name=app_name)
        self.endpoints = dict()
        self.endpoints[self.site.get_url_name()] = self.site
    
    def get_media_types(self):
        media_types = dict(self.api_endpoint.media_types)
        for media_type_handler in self.media_types:
            for media_type in media_type_handler.recognized_media_types:
                media_types[media_type] = media_type_handler
        return media_types
    
    def get_endpoint_kwargs(self, endpoint, **kwargs):
        params = dict(endpoint._init_kwargs)
        params.update({
            'site': self.site,
        })
        if endpoint.parent:
            params['parent'] = self.get_endpoint(endpoint.parent)
        params.update(kwargs)
        return params
    
    def get_endpoint(self, endpoint):
        urlname = endpoint.get_url_name()
        if urlname not in self.endpoints:
            kwargs = self.get_endpoint_kwargs(endpoint)
            endpoint = endpoint.fork(**kwargs)
            self.endpoints[urlname] = endpoint
        return self.endpoints[urlname]
    
    def get_view_kwargs(self, endpoint, **kwargs):
        params = endpoint.get_view_kwargs()
        
        params.update({
            'site': self.site,
            'api_request': None,
        })
        if endpoint.parent:
            params['parent'] = self.get_endpoint(endpoint.parent)
        
        params.update(kwargs)
        return params
    
    def wrap_urls(self, urlpatterns):
        new_patterns = list()
        for entry in urlpatterns:
            entry = copy(entry)
            if hasattr(entry, '_callback') and hasattr(entry._callback, 'endpoint'):
                endpoint = entry._callback.endpoint
                kwargs = self.get_view_kwargs(endpoint)
                new_endpoint = endpoint.fork(**kwargs)
                entry._callback = new_endpoint.get_view()
                
                assert entry._callback.endpoint.site == self.site
            elif hasattr(entry, 'url_patterns'):
                entry._urlconf_module = self.wrap_urls(entry.url_patterns)
            new_patterns.append(entry)
        return patterns('', *new_patterns)
    
    def get_urls(self):
        try:
            return self.wrap_urls(self.site.get_urls())
        except Exception as error:
            self.get_logger().exception('Unabled to load client urls')
            raise


########NEW FILE########
__FILENAME__ = common
from hyperadmin.mediatypes.passthrough import Passthrough


class ClientMixin(object):
    """
    Contains logic for connecting to an endpoint on the API
    """
    resource = None
    url_name = None
    client_site = None
    
    def get_api_endpoint(self):
        for endpoint in self.resource.get_view_endpoints():
            if endpoint.name_suffix == self.url_name:
                return endpoint
    
    def get_api_kwargs(self):
        return dict(self.kwargs)
    
    def get_api_args(self):
        return list(self.args)
    
    def get_global_state(self):
        #with media type = pass through
        kwargs = {'media_types': {'*': Passthrough}}
        #patch permissions by setting your own client_site
        if self.client_site is not None:
            kwargs['site'] = self.client_site
        return kwargs
    
    def get_api_response(self):
        if not hasattr(self, '_api_response'):
            endpoint = self.get_api_endpoint()
            assert endpoint is not None, 'Failed to look up endpint for: %s in %s' % (self.url_name, [e['name'] for e in self.resource.get_view_endpoints()])
            
            api_args = self.get_api_args()
            api_kwargs = self.get_api_kwargs()
            self._api_response = endpoint.get_view()(self.request, *api_args, **api_kwargs)
        return self._api_response
    
    def get_state(self):
        return self.get_api_response().state
    
    def get_link(self):
        return self.get_api_response().link
    
    def get_context_data(self, **kwargs):
        context = super(ClientMixin, self).get_context_data(**kwargs)
        context['state'] = self.get_state()
        context['link'] = self.get_link()
        return context
    
    def dispatch(self, request, *args, **kwargs):
        self.request = request
        self.args = args
        self.kwargs = kwargs
        #TODO use an alternative template response class instead
        patch_params = self.get_global_state()
        with self.client_site.state.patch_state(**patch_params):
            response = super(ClientMixin, self).dispatch(request, *args, **kwargs)
            if hasattr(response, 'render'):
                response.render()
            return response

#CONSIDER: should we expose CRUD functionality as default and have the process entirely controlled by permissions?


########NEW FILE########
__FILENAME__ = detail
from django.views.generic import TemplateView

from hyperadmin.clients.views.common import ClientMixin

class SingleObjectMixin(object):
    context_object_name = None
    
    def get_resource_item(self):
        return self.get_state().item
    
    def get_object(self):
        return self.get_resource_item().instance
    
    def get_context_object_name(self):
        """
        Get the name to use for the object.
        """
        if self.context_object_name:
            return self.context_object_name
        else:
            return 'object'
    
    def get_context_data(self, **kwargs):
        context = super(SingleObjectMixin, self).get_context_data(**kwargs)
        context_object_name = self.get_context_object_name()
        context[context_object_name] = self.get_object()
        context['resource_item'] = self.get_resource_item()
        return context


class DetailView(SingleObjectMixin, ClientMixin, TemplateView):
    view_classes = ['change_form']
    
    def get_context_data(self, **kwargs):
        context = super(DetailView, self).get_context_data(**kwargs)
        return context

########NEW FILE########
__FILENAME__ = edit
from django.views.generic import TemplateView

from hyperadmin.clients.views.common import ClientMixin
from hyperadmin.clients.views.detail import SingleObjectMixin

#TODO features: success_url, initial

class FormMixin(object):
    def get_context_data(self, **kwargs):
        context = super(FormMixin, self).get_context_data(**kwargs)
        context['form'] = self.get_link().form
        return context
    
    def post(self, request, *args, **kwargs):
        response = self.get_api_response()
        if response.status_code != 200:
            return response
        context = self.get_context_data(**kwargs)
        return self.render_to_response(context)

class CreateView(FormMixin, ClientMixin, TemplateView):
    view_classes = ['add_form']

class UpdateView(FormMixin, SingleObjectMixin, ClientMixin, TemplateView):
    view_classes = ['change_form']

class DeleteView(FormMixin, SingleObjectMixin, ClientMixin, TemplateView):
    view_classes = ['delete_confirmation']


########NEW FILE########
__FILENAME__ = list
from django.views.generic import TemplateView

from hyperadmin.clients.views.common import ClientMixin


class MultipleObjectMixin(object):
    context_object_name = None
    
    def get_resource_items(self):
        return self.get_state().get_resource_items()
    
    def get_object_list(self):
        return [ri.instance for ri in self.get_resource_items()]
    
    def get_context_object_name(self):
        """
        Get the name to use for the object.
        """
        if self.context_object_name:
            return self.context_object_name
        else:
            return 'object_list'
    
    def get_context_data(self, **kwargs):
        context = super(MultipleObjectMixin, self).get_context_data(**kwargs)
        context_object_name = self.get_context_object_name()
        context[context_object_name] = self.get_object_list()
        context['resource_items'] = self.get_resource_items()
        return context

class ListView(MultipleObjectMixin, ClientMixin, TemplateView):
    view_classes = ['change_list']
    #TODO option for add params for filters
    
    def get_context_data(self, **kwargs):
        #TODO absorb in index api
        context = super(ListView, self).get_context_data(**kwargs)
        links = self.get_state().get_index_queries()
        context['pagination_links'] = [link for link in links if link.rel == 'pagination']
        filter_links = dict()
        #TODO ignore filter links for params that are set
        for link in links :
            if link.rel == 'filter':
                section = link.cl_headers.get('group', link.prompt)
                filter_links.setdefault(section, [])
                filter_links[section].append(link)
        context['filter_links'] = filter_links
        return context

########NEW FILE########
__FILENAME__ = apirequests
from hyperadmin.apirequests import HTTPAPIRequest

from hyperadmin.contrib.apikey.common import authenticate

HTTP_HEADER = 'API_KEY'
GET_VARIABLE = '_API_KEY'

class APIKeyMixin(object):
    def get_session_data_from_request(self, request):
        data = super(APIKeyMixin, self).get_session_data_from_request(request)
        if HTTP_HEADER in request.META:
            key = request.META[HTTP_HEADER]
            user = authenticate(key)
            if user:
                data['auth'] = user
        if GET_VARIABLE in request.GET:
            key = request.GET[HTTP_HEADER]
            user = authenticate(key)
            if user:
                data['auth'] = user
        return data

class HTTPAPIKeyRequest(APIKeyMixin, HTTPAPIRequest):
    pass


########NEW FILE########
__FILENAME__ = common
from hyperadmin.contrib.apikey.models import ApiKey

def authenticate(key):
    try:
        entry = ApiKey.objects.get(key=key, active=True)
    except ApiKey.DoesNotExist:
        return None
    return entry.user


########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib.auth.models import User


class ApiKey(models.Model):
    key = models.CharField(max_length=100, unique=True)
    user = models.ForeignKey(User)
    active = models.BooleanField(default=True)
    
    def __unicode__(self):
        return self.key


########NEW FILE########
__FILENAME__ = resources
from hyperadmin import site
from hyperadmin.resources.models import ModelResource

from hyperadmin.contrib.apikey.models import ApiKey


class ApiKeyResource(ModelResource):
    model = ApiKey

site.register(ApiKey, ApiKeyResource, app_name='apikey')


########NEW FILE########
__FILENAME__ = test_apikey
from django.utils import unittest
from django.contrib.auth.models import User
from django.http import HttpResponse
from django.test.client import RequestFactory

from hyperadmin.resources.models import ModelResource
from hyperadmin.sites import ResourceSite
from hyperadmin.apirequests import InternalAPIRequest, NamespaceAPIRequest
from hyperadmin.endpoints import RootEndpoint
from hyperadmin.contrib.apikey.apirequests import HTTPAPIKeyRequest
from hyperadmin.contrib.apikey.models import ApiKey

from hyperadmin.tests.common import GenericURLResolver, SuperUserRequestFactory

from mock import MagicMock


class UserResource(ModelResource):
    list_display = ['username', 'email']
    list_filter = ['is_active', 'is_staff', 'is_superuser']
    date_hierarchy = 'date_joined'
    search_fields = ['email', 'username']

class ResourceTestCase(unittest.TestCase):
    def setUp(self):
        self.site = ResourceSite(apirequest_class=HTTPAPIKeyRequest)
        self.site.register_builtin_media_types()
        
        self.user = User.objects.get_or_create(username='superuser', is_staff=True, is_active=True, is_superuser=True)[0]
        self.resource = self.register_resource()
        
        self.api_key_instance = ApiKey.objects.get_or_create(user=self.user, key='foobar')[0]
        self.api_key = self.api_key_instance.key
        self.factory = RequestFactory(HTTP_ACCEPT='text/html', API_KEY=self.api_key)
        
        self.resolver = GenericURLResolver(r'^', self.site.get_urls())
        
        def reverse(name, *args, **kwargs):
            ret = self.resolver.reverse(name, *args, **kwargs)
            return ret
        self.reverse = reverse
        
        def cls_reverse(slf, name, *args, **kwargs):
            return self.resolver.reverse(name, *args, **kwargs)
        
        original_fork = self.site.fork
        
        def fork(**kwargs):
            ret = original_fork(**kwargs)
            ret.reverse = reverse
            return ret
        
        self.site.fork = fork
        NamespaceAPIRequest.reverse = cls_reverse
        RootEndpoint.reverse = cls_reverse
        self.site.reverse = reverse
    
    def get_api_request(self, **kwargs):
        kwargs.setdefault('site', self.site)
        #kwargs.setdefault('user', self.user)
        #kwargs.setdefault('params', {})
        #kwargs.setdefault('method', 'GET')
        #kwargs.setdefault('payload', {})
        kwargs.setdefault('request', self.factory.get('/'))
        kwargs.setdefault('url_args', [])
        kwargs.setdefault('url_kwargs', {})
        #kwargs.setdefault('reverse', self.reverse)
        api_request = HTTPAPIKeyRequest(**kwargs)
        api_request.populate_session_data_from_request(kwargs['request'])
        
        api_request.generate_response = MagicMock(return_value=HttpResponse())
        
        return api_request
    
    def register_resource(self):
        raise NotImplementedError

class APIKeyTestCase(ResourceTestCase):
    def register_resource(self):
        self.site.register(User, UserResource, app_name='auth')
        return self.site.registry[User]
    
    def test_user_lookup(self):
        api_request = self.get_api_request()
        self.assertEqual(self.user, api_request.user)

########NEW FILE########
__FILENAME__ = datataps
#from django.core.files import File

from hyperadmin.links import Link

from datatap.datataps import DataTap


class HypermediaFormDataTap(DataTap):
    '''
    A datatap that serializes forms from hypermedia items to primitives
    '''
    def get_domain(self):
        if self.instream is None: #no instream, I guess we write?
            return 'deserialized_form'
        if isinstance(self.instream, (list, tuple)):
            return 'primitive'
        if self.instream.domain == 'primitive':
            return 'deserialized_form'

    def get_primitive_stream(self, instream):
        '''
        Convert forms to primitive objects
        '''
        return self.serialize_forms(instream)

    def serialize_forms(self, item_list):
        serializable_items = list()
        for item in item_list:
            serializable_items.append(self.serialize_form(item))
        return serializable_items

    #CONSIDER this is redundant in mediatype. Should factor this out
    def serialize_form(self, item):
        return self.get_form_instance_values(item)

    def prepare_field_value(self, val):
        #if isinstance(val, File):
        #    if hasattr(val, 'name'):
        #        val = val.name
        #    else:
        #        val = None
        if isinstance(val, Link):
            val = Link.get_absolute_url()
        return val

    def get_form_instance_values(self, form):
        data = dict()
        for name, field in form.fields.iteritems():
            val = form[name].value()
            val = self.prepare_field_value(val)
            data[name] = val
        return data

    def get_deserialized_form_stream(self, instream):
        '''
        Convert primitive objects to deserialized form instances
        '''
        #TODO
        return instream

########NEW FILE########
__FILENAME__ = endpoints
from django.conf.urls.defaults import url, patterns, include
from django.core.urlresolvers import reverse
from django.views.generic import View
from django.utils.datastructures import MultiValueDict

from hyperadmin.links import Link, LinkCollection, LinkCollectorMixin, LinkNotAvailable
from hyperadmin.app_settings import DEFAULT_API_REQUEST_CLASS
from hyperadmin.apirequests import InternalAPIRequest
from hyperadmin.hyperobjects import Item
from hyperadmin.states import EndpointState
from hyperadmin.views import EndpointViewMixin
from hyperadmin.signals import endpoint_event

import logging
import urlparse


class BaseEndpoint(LinkCollectorMixin, View):
    """
    Represents an API Endpoint
    """

    form_class = None
    '''The default form class for links created by this endpoint'''

    item_form_class = None
    '''The form class representing items from this endpoint.
    The form created is used for serialization of item.'''

    state_class = EndpointState

    resource_item_class = Item

    app_name = None
    '''The slug that identifies the application of this endpoint. Typically set by the site object.'''

    base_url_name_suffix = None
    '''The suffix to apply to the base url name when concating the base
    name from the parent'''

    base_url_name = None
    '''Set the base url name instead of getting it from the parent'''

    name_suffix = None
    '''The suffix to add to the generated url name. This also used by
    the parent endpoint to reference child endpoints'''

    url_name = None
    '''Set the url name of the endpoint instead of generating one'''

    global_state = None
    '''Dictionary for overiding particular values in the state'''

    endpoint_class = None
    '''A slug identifying the primary role of the endpoint'''

    endpoint_classes = []
    '''A list of slugs identifying the various roles or functions of the endpoint'''

    #generated items:
    api_request = None
    '''The api request responsible for the endpoint. Generated automatically.'''

    state = None
    '''The state responsible for the endpoint. Generated automatically.'''

    def __init__(self, **kwargs):
        self._init_kwargs = dict(kwargs)
        self.links = self.get_link_collector()
        super(BaseEndpoint, self).__init__(**kwargs)

        self._registered = False
        self.post_register()
        self._registered = True

    def post_register(self):
        assert not self._registered
        if self.api_request:
            self.api_request.record_endpoint(self)
        else:
            self._site.record_endpoint(self)
        self.register_link_prototypes()

    def get_logger(self):
        return self._site.get_logger()

    def get_site(self):
        if self._registered and self.api_request:
            return self.api_request.get_site()
        return self._site

    def set_site(self, site):
        self._site = site

    site = property(get_site, set_site)

    def get_parent(self):
        if getattr(self, '_parent', None) is None:
            return None
        if self._registered and self.api_request:
            return self.api_request.get_endpoint(self._parent.get_url_name())
        return self._parent

    def set_parent(self, parent):
        assert parent != self
        self._parent = parent

    parent = property(get_parent, set_parent)

    def get_endpoint_kwargs(self, **kwargs):
        '''
        Consult for creating child endpoints
        '''
        kwargs.setdefault('parent', self)
        kwargs.setdefault('site', self.site)
        kwargs.setdefault('api_request', self.api_request)
        #if self.parent:
        #    kwargs = self.parent.get_endpoint_kwargs(**kwargs)
        return kwargs

    def get_common_state(self):
        return None
    common_state = property(get_common_state)

    def get_state(self):
        if not hasattr(self, '_state'):
            assert self.api_request, "Endpoints without an api request are not allowed to have a state"
            self.initialize_state()
        return self._state

    def set_state(self, state):
        self._state = state

    state = property(get_state, set_state)

    def get_meta(self):
        """
        :rtype: dict
        """
        return {}

    def get_endpoint_classes(self):
        """
        Returns a list of functional identifiers

        :rtype: list of strings
        """
        res_classes = list(self.endpoint_classes)
        res_classes.append(self.endpoint_class)
        return res_classes

    def get_state_data(self):
        """
        :rtype: dict
        """
        data = {'endpoint_class':self.endpoint_class,
                'endpoint_classes':self.get_endpoint_classes(),
                'params':self.api_request.params,}
        #TODO send params only if the api request was for this endpoint
        return data

    def get_state_kwargs(self):
        """
        :rtype: dict
        """
        kwargs = {
            'endpoint': self,
            'data':self.get_state_data(),
            'meta':{},
        }
        if self.common_state is not None:
            kwargs['substates'] = [self.common_state]
        return kwargs

    def get_state_class(self):
        return self.state_class

    def initialize_state(self, **data):
        kwargs = self.get_state_kwargs()
        kwargs['data'].update(data)
        self.state = self.get_state_class()(**kwargs)
        self.state.meta = self.get_meta()
        return self.state

    def reverse(self, *args, **kwargs):
        """
        URL Reverse the given arguments

        :rtype: string
        """
        return self.api_request.reverse(*args, **kwargs)

    #urls

    def get_base_url_name_suffix(self):
        assert self.base_url_name_suffix is not None, '%s has not set base_url_name_suffix' % self
        return self.base_url_name_suffix

    def get_base_url_name_prefix(self):
        if self.parent:
            return self.parent.get_base_url_name()
        return ''

    def get_base_url_name(self):
        '''
        Returns the base url name to be used by our name and the name of
        our children endpoints
        Return self.base_url_name if set otherwise return the concat of
        self.get_base_url_name_prefix() and self.get_base_url_name_suffix()
        '''
        if self.base_url_name is not None:
            base = self.base_url_name
        else:
            base = self.get_base_url_name_prefix() + self.get_base_url_name_suffix()
        if base and not base.endswith('_'):
            base += '_'
        return base

    def get_name_suffix(self):
        return self.name_suffix

    def get_url_name(self):
        '''
        Returns the url name that will address this endpoint
        Return self.url_name is set otherwise return the result of
        concatting self.get_base_url_name() and self.get_name_suffx()
        '''
        if self.url_name is not None:
            return self.url_name
        assert self.get_base_url_name() != '_'
        return self.get_base_url_name() + self.get_name_suffix()

    def get_url(self, **kwargs):
        return self.reverse(self.get_url_name(), **kwargs)

    def get_url_suffix(self):
        return ''

    def create_link_collection(self):
        """
        Returns an instantiated LinkCollection object

        :rtype: LinkCollection
        """
        return LinkCollection(endpoint=self)

    #link_prototypes
    def get_link_prototypes(self):
        """
        return a list of tuples containing link prototype class and kwargs
        """
        return []

    def register_link_prototypes(self):
        if self.api_request:
            self.link_prototypes = self.api_request.get_link_prototypes(self)
        else:
            self.link_prototypes = self.create_link_prototypes()

    def create_link_prototypes(self):
        """
        Instantiates the link prototypes from get_link_prototypes

        :rtype: list of link prototypes
        """
        link_prototypes = dict()
        for proto_klass, kwargs in self.get_link_prototypes():
            proto = self.create_link_prototype(proto_klass, **kwargs)
            link_prototypes[proto.name] = proto
        return link_prototypes

    def get_link_prototype_kwargs(self, **kwargs):
        """
        :rtype: dict
        """
        params = {'endpoint':self}
        params.update(kwargs)
        return params

    def create_link_prototype(self, klass, **kwargs):
        kwargs = self.get_link_prototype_kwargs(**kwargs)
        proto = klass(**kwargs)
        return proto

    def fork(self, **kwargs):
        """
        :rtype: endpoint
        """
        params = dict(self._init_kwargs)
        params.update(kwargs)
        return type(self)(**params)

    def fork_state(self, **kwargs):
        """
        :rtype: endpoint
        """
        new_endpoint = self.fork()
        new_endpoint.state.update(kwargs)
        return new_endpoint

    def get_resource_item_class(self):
        return self.resource_item_class

    def get_resource_item(self, instance, **kwargs):
        """
        Wraps an object in a resource item

        :rtype: resource item
        """
        kwargs.setdefault('endpoint', self)
        #if 'datatap' not in kwargs:
        #    kwargs['datatap'] = self.get_datatap()
        return self.get_resource_item_class()(instance=instance, **kwargs)

    def get_instances(self):
        """
        Returns the list of active objects available for this request

        :rtype: list of objects
        """
        return []

    def get_resource_items(self):
        """
        Returns a list of resource items available for this request. Calls get_instances for the objects the items represent.

        :rtype: list of resource items
        """
        instances = self.get_instances()
        return [self.get_resource_item(instance) for instance in instances]

    def get_form_class(self):
        return self.form_class

    def get_form_kwargs(self, **kwargs):
        return kwargs

    def get_item_form_class(self):
        return self.item_form_class or self.get_form_class()

    def get_item_form_kwargs(self, item=None, **kwargs):
        """
        :rtype: dict
        """
        if item is not None:
            kwargs.setdefault('instance', item.instance)
        return kwargs

    def get_namespaces(self):
        """
        :rtype: dictionary of namespaces
        """
        return {}

    def get_item_namespaces(self, item):
        """
        :param item: resource item
        :rtype: dictionary of namespaces
        """
        return {}

    def get_item_url(self, item):
        raise NotImplementedError

    def get_item_link(self, item, **kwargs):
        link_kwargs = {'url':item.get_absolute_url(),
                       'endpoint':self,
                       'rel':'item',
                       'prompt':item.get_prompt(),}
        link_kwargs.update(kwargs)
        item_link = Link(**link_kwargs)
        return item_link

    def get_main_link_name(self):
        raise NotImplementedError

    def get_main_link_prototype(self):
        link_name = self.get_main_link_name()
        if link_name in self.link_prototypes:
            return self.link_prototypes[link_name]
        raise LinkNotAvailable, 'Link unavailable: %s' % link_name

    def get_link(self, **kwargs):
        link_kwargs = {'rel':'self',
                       'endpoint': self,
                       'prompt':self.get_prompt(),}
        link_kwargs.update(kwargs)
        return self.get_main_link_prototype().get_link(**link_kwargs)

    def get_item_prompt(self, item):
        """
        Returns a string representing the resource item
        """
        return unicode(item.instance)

    def get_prompt(self):
        """
        Returns a string representing this endpoint
        """
        return unicode(self)

    def api_permission_check(self, api_request, endpoint):
        return self.site.api_permission_check(api_request, endpoint)

    def generate_response(self, link):
        return self.api_request.generate_response(link=link, state=self.state)

    def generate_options_response(self, links):
        return self.api_request.generate_options_response(links=links, state=self.state)

    def create_internal_apirequest(self, **kwargs):
        return self.site.create_internal_apirequest(**kwargs)

    def create_apirequest(self, **kwargs):
        return self.site.create_apirequest(**kwargs)

    def expand_template_names(self, suffixes):
        return self.site.expand_template_names(suffixes)

    def get_context_data(self, **kwargs):
        return self.site.get_context_data(**kwargs)

    def generate_api_response(self, api_request):
        """
        :rtype: Link or HttpResponse
        """
        raise NotImplementedError

    def emit_event(self, event, item_list=None):
        """
        Fires of the `endpoint_event` signal
        """
        sender = '%s!%s' % (self.get_url_name(), event)
        if item_list is None:
            item_list = self.get_resource_items()
        return endpoint_event.send(sender=sender, endpoint=self, event=event, item_list=item_list)

    def get_datatap(self, instream=None, **kwargs):
        '''
        Returns a datatap that can serialize hypermedia items and deserialize to native instances

        :param instream: A list of resource items or a primitive datatap
        '''
        if instream is None:
            #open for read; give primitives
            return self.get_native_datatap(**kwargs)
        elif isinstance(instream, (list, tuple)):
            #list of resource items; give primitives
            native_instream = self.get_native_datatap_instream_from_items(instream)
            return self.get_native_datatap(instream=native_instream, **kwargs)
        else:
            #read primitives from instream, return deserialized objects
            return self.get_native_datatap(instream=instream, **kwargs)

    def get_native_datatap_instream_from_items(self, items):
        '''
        Makes an instream of item forms
        '''
        return [item.form for item in items]

    def get_native_datatap(self, instream=None, **kwargs):
        '''
        Returns a datatap that can serialize the forms belonging to hypermedia items.
        '''
        from hyperadmin.datataps import HypermediaFormDataTap
        #if there is no instream, read from the global resource items
        if instream is None:
            instream = self.get_resource_items()
        return HypermediaFormDataTap(instream, **kwargs)

class VirtualEndpoint(BaseEndpoint):
    '''
    A type of endpoint that does not define any active endpoints itself
    but references other endpoints.
    '''
    name_suffix = 'virtual'

    def get_children_endpoints(self):
        return []

    def get_urls(self):
        urlpatterns = self.get_extra_urls()
        urls = [endpoint.get_url_object() for endpoint in self.get_children_endpoints()]
        urlpatterns += patterns('', *urls)
        return urlpatterns

    def get_extra_urls(self):
        return patterns('',)

    def urls(self):
        return self.get_urls(), self.app_name, None
    urls = property(urls)

    def dynamic_urls(self):
        return self, self.app_name, None

    @property
    def urlpatterns(self):
        return self.get_urls()

    def get_url_object(self):
        return url(self.get_url_suffix(), include(self.urls))

    def create_link_prototypes(self):
        '''
        Inludes the link prototypes created by the children endpoints
        '''
        link_prototypes = super(VirtualEndpoint, self).create_link_prototypes()

        for endpoint in self.get_children_endpoints():
            link_prototypes.update(endpoint.link_prototypes)

        return link_prototypes

    def get_index_endpoint(self):
        raise NotImplementedError

    def get_main_link_name(self):
        return self.get_index_endpoint().get_main_link_name()

    def get_url(self, **kwargs):
        return self.get_index_endpoint().get_url(**kwargs)

    def generate_api_response(self, api_request):
        """
        Calls the index endpoint and returns it's api response
        :rtype: Link or HttpResponse
        """
        endpoint = self.get_index_endpoint().fork(api_request=api_request)
        return endpoint.generate_api_response(api_request)

class GlobalSiteMixin(object):
    '''
    Endpoints inheriting this class will default to the global site if
    no site is passed in.
    '''
    global_endpoint = False

    def __init__(self, **kwargs):
        if 'site' not in kwargs:
            from hyperadmin.sites import global_site
            kwargs.setdefault('site', global_site)
            self.global_endpoint = True
        super(GlobalSiteMixin, self).__init__(**kwargs)

    def urls(self):
        if self.global_endpoint:
            return self.get_urls(), self.app_name, self.site.namespace
        return self.get_urls(), self.app_name, None
    urls = property(urls)

class APIRequestBuilder(object):
    apirequest_class = DEFAULT_API_REQUEST_CLASS
    '''The api request class to use for incomming django requests'''

    internal_apirequest_class = InternalAPIRequest
    '''The api request class to use for internal api calls'''

    def get_api_request_kwargs(self, **kwargs):
        params = {
            'site': self.site,
            'global_state': self.global_state, }
        params.update(kwargs)
        return params

    def create_apirequest(self, request, url_args, url_kwargs):
        kwargs = self.get_api_request_kwargs(request=request, url_args=url_args, url_kwargs=url_kwargs)
        return self.apirequest_class(**kwargs)

    def get_internal_api_user(self):
        '''
        Returns an authenticated anonymous user with superuser powers
        '''
        from django.contrib.auth.models import AnonymousUser
        class SuperAnonymousUser(AnonymousUser):
            is_staff = True
            is_superuser = True

            def has_perm(self, perm, obj=None):
                return True

            def is_authenticated(self):
                return True

        return SuperAnonymousUser()

    def create_internal_apirequest(self, **kwargs):
        #kwargs.setdefault('request', MockedRequest)
        kwargs.setdefault('user', self.get_internal_api_user())
        kwargs = self.get_api_request_kwargs(**kwargs)
        api_request = self.internal_apirequest_class(**kwargs)
        if self.global_state is not None:
            api_request.session_state.update(self.global_state)
        return api_request

class RootEndpoint(APIRequestBuilder, VirtualEndpoint):
    """
    The top endpoint of a hypermedia aware site

    Child endpoints bind to this and this endpoint is used to mount in urls.py
    """
    namespace = None
    '''The namespace of this endpoint, will be autogenerated if none is supplied'''

    media_types = None
    '''Dictionary of supported media types'''

    template_paths = None
    '''List of template paths to use for template name resolution'''

    base_url_name = ''
    name_suffix = 'virtualroot'

    def __init__(self, **kwargs):
        kwargs.setdefault('media_types', dict())
        kwargs.setdefault('namespace', str(id(self)))
        self.endpoints_by_urlname = dict()
        super(RootEndpoint, self).__init__(**kwargs)

    @property
    def link_prototypes(self):
        return self.get_index_endpoint().link_prototypes

    @property
    def parent(self):
        return None

    def get_logger(self):
        return logging.getLogger(__name__)

    def post_register(self):
        pass #we wrap other endpoints

    def get_site(self):
        if self.api_request:
            return self.api_request.get_site()
        return self

    site = property(get_site)

    def fork(self, **kwargs):
        ret = super(RootEndpoint, self).fork(**kwargs)
        ret.endpoints_by_urlname.update(self.endpoints_by_urlname)
        return ret

    def urls(self):
        return self, None, self.namespace
    urls = property(urls)

    def reverse(self, name, *args, **kwargs):
        return reverse('%s:%s' % (self.namespace, name), args=args, kwargs=kwargs)

    def get_resolver(self):
        from django.core.urlresolvers import RegexURLResolver
        #get our root url
        starter = self.get_link().get_absolute_url()
        return RegexURLResolver(r'^%s' % starter, self.urlpatterns)

    def call_endpoint(self, url, **request_params):
        '''
        Looks up the endpoint as an internal api request
        :rtype: Bound Endpoint
        '''
        url_parts = urlparse.urlparse(url)
        path = url_parts.path
        from django.core.urlresolvers import Resolver404
        from hyperadmin.apirequests import NamespaceAPIRequest
        try:
            match = self.get_resolver().resolve(path)
        except Resolver404 as notfound:
            self.get_logger().exception('Could not resolve %s' % url)
            assert False, str(notfound)
        params = {
            'api_request': self.api_request,
            'path': path,
            'full_path': url,
            'url_kwargs': match.kwargs,
            'url_args': match.args,
            'params': MultiValueDict(urlparse.parse_qs(url_parts.query)),
        }
        params.update(request_params)
        api_request = NamespaceAPIRequest(**params)

        return match.func.endpoint.fork(api_request=api_request)

    def register_media_type(self, media_type, media_type_handler):
        self.media_types[media_type] = media_type_handler

    def record_endpoint(self, endpoint, url_name=None):
        if url_name is None:
            url_name = endpoint.get_url_name()
        if url_name not in self.endpoints_by_urlname:
            self.endpoints_by_urlname[url_name] = endpoint
        else:
            original = self.endpoints_by_urlname[url_name]
            #self.get_logger().debug('Double registration at site level on %s by %s, original: %s' % (url_name, endpoint, original))

    def get_endpoint_from_urlname(self, urlname):
        return self.endpoints_by_urlname[urlname]

    def api_permission_check(self, api_request, endpoint):
        """
        Return a link describing the authentication failure or return None if the request has sufficient permissions
        """
        return None

    def get_template_paths(self):
        if self.template_paths:
            return self.template_paths
        return [self.namespace]

    def expand_template_names(self, suffixes):
        '''
        Maps a list of template names to the template paths belonging to
        the site
        :param suffixes: List of strings
        :rtype: List of strings
        '''
        template_names = list()
        for path in self.get_template_paths():
            for template_name in suffixes:
                template_names.append('/'.join([path, template_name]))
        template_names.extend(suffixes)
        return template_names

    def get_context_data(self, **kwargs):
        return kwargs

class Endpoint(GlobalSiteMixin, EndpointViewMixin, BaseEndpoint):
    """
    Endpoint class that contains link prototypes and maps HTTP requests to those links.
    """
    url_suffix = None
    base_url_name_suffix = ''

    prototype_method_map = {}

    def get_available_methods(self):
        return self.prototype_method_map.keys()

    def get_link_prototype_for_method(self, method):
        """
        Return the link prototype representing the action for the method
        Consults prototype_method_map for the link name and returns the prototype from link_prototypes
        """
        name = self.prototype_method_map.get(method)
        return self.link_prototypes.get(name)

    def get_link_kwargs(self, **kwargs):
        kwargs.setdefault('endpoint', self)
        if 'item' not in kwargs and self.state.item:
            kwargs['item'] = self.state.item
        return kwargs

    def get_available_links(self):
        """
        Returns a dictionary mapping available HTTP methods to a link
        """
        methods = dict()
        for method in self.get_available_methods():
            proto = self.get_link_prototype_for_method(method)
            if proto and proto.show_link():
                kwargs = {'use_request_url':True}
                kwargs = self.get_link_kwargs(**kwargs)
                link = proto.get_link(**kwargs)
                methods[method] = link
        return methods

    def get_url_suffix(self):
        return self.url_suffix

    def get_view_kwargs(self, **kwargs):
        """
        :rtype: dict
        """
        params = dict(self._init_kwargs)
        params.update(kwargs)
        return params

    def get_view(self, **kwargs):
        """
        :rtype: view callable
        """
        #TODO should this be get_endpoint_kwargs?
        params = self.get_view_kwargs(**kwargs)
        view = type(self).as_view(**params)
        #allow for retreiving the endpoint from url patterns
        view.endpoint = self
        #thus allowing us to do: myview.endpoint.get_view(**some_new_kwargs)
        return view

    def get_url_object(self):
        view = self.get_view()
        return url(self.get_url_suffix(), view, name=self.get_url_name(),)

    def get_main_link_name(self):
        return self.get_link_prototype_for_method('GET').name


########NEW FILE########
__FILENAME__ = filters
from django.core.exceptions import ImproperlyConfigured
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import force_unicode

class BaseFilter(object):
    title = None  # Human-readable title to appear in the right sidebar.
    
    def __init__(self, index):
        self.index = index
        self.resource = index.resource
        if self.title is None:
            raise ImproperlyConfigured(
                "The filter '%s' does not specify "
                "a 'title'." % self.__class__.__name__)
    
    @property
    def state(self):
        return self.resource.state
    
    def make_link(self, **kwargs):
        return self.index.get_link(**kwargs)
    
    def populate_state(self):
        pass
    
    def get_links(self, **link_kwargs):
        """
        Returns links representing the filterable actions.
        """
        return []
    
    def filter_index(self, active_index):
        """
        Returns the filtered queryset.
        """
        raise NotImplementedError
    
    def expected_parameters(self):
        """
        Returns the list of parameter names that are expected from the
        request's query string and that will be used by this filter.
        """
        raise NotImplementedError
    
    def is_active(self):
        return False
    
    def values(self):
        vals = list()
        filter_params = self.state.params
        for param in self.expected_parameters():
            vals.append(filter_params.get(param, None))
        return vals

class BaseChoicesFilter(BaseFilter):
    def get_links(self, **link_kwargs):
        links = list()
        for choice in self.choices():
            kwargs = dict(link_kwargs)
            classes = kwargs.get('classes', [])
            kwargs['group'] = self.title
            kwargs['classes'] = classes
            if choice.get('selected', False):
                classes.append('selected')
            #CONSIDER prompt may want to include group if not supported
            kwargs['prompt'] = force_unicode(choice['display'])
            kwargs['url'] = u'./' + choice['query_string']
            links.append(self.make_link(**kwargs))
        return links
    
    def choices(self):
        return []

class SimpleFilter(BaseChoicesFilter):
    # The parameter that should be used in the query string for that filter.
    parameter_name = None

    def __init__(self, index):
        super(SimpleFilter, self).__init__(index)
        if self.parameter_name is None:
            raise ImproperlyConfigured(
                "The list filter '%s' does not specify "
                "a 'parameter_name'." % self.__class__.__name__)
        lookup_choices = self.lookups()
        if lookup_choices is None:
            lookup_choices = ()
        self.lookup_choices = list(lookup_choices)

    def has_output(self):
        return len(self.lookup_choices) > 0

    def value(self):
        """
        Returns the value (in string format) provided in the request's
        query string for this filter, if any. If the value wasn't provided then
        returns None.
        """
        return self.used_parameters.get(self.parameter_name, None)

    def lookups(self):
        """
        Must be overriden to return a list of tuples (value, verbose value)
        """
        raise NotImplementedError

    def expected_parameters(self):
        return [self.parameter_name]
    
    def choices(self):
        yield {
            'selected': self.value() is None,
            'query_string': self.state.get_query_string({}, [self.parameter_name]),
            'display': _('All'),
        }
        for lookup, title in self.lookup_choices:
            yield {
                'selected': self.value() == lookup,
                'query_string': self.state.get_query_string({
                    self.parameter_name: lookup,
                }, []),
                'display': title,
            }


########NEW FILE########
__FILENAME__ = hyperobjects
'''
These are objects generated by the resource and are serialized by a media type.
'''
from hyperadmin.links import LinkCollectorMixin, ItemLinkCollectionProvider, LinkNotAvailable


class Item(LinkCollectorMixin):
    '''
    Represents an instance that is bound to an endpoint
    '''
    form_class = None
    link_collector_class = ItemLinkCollectionProvider
    
    def __init__(self, endpoint, instance, datatap=None):
        self.endpoint = endpoint
        self.instance = instance
        self.links = self.get_link_collector()
        self.datatap = datatap
    
    @property
    def state(self):
        return self.endpoint.state
    
    def get_absolute_url(self):
        try:
            return self.endpoint.get_item_url(self)
        except LinkNotAvailable:
            return '' #or do we return None?
    
    def get_form_class(self):
        if self.form_class is not None:
            return self.form_class
        return self.endpoint.get_item_form_class()
    
    def get_form_kwargs(self, **kwargs):
        kwargs['item'] = self
        return self.endpoint.get_item_form_kwargs(**kwargs)
    
    def get_form(self, **form_kwargs):
        form_cls = self.get_form_class()
        kwargs = self.get_form_kwargs(**form_kwargs)
        form = form_cls(**kwargs)
        return form
    
    @property
    def form(self):
        """
        Mediatype uses this form to serialize the result
        """
        if not hasattr(self, '_form'):
            self._form = self.get_form()
        return self._form
    
    def get_prompt(self):
        """
        Returns a string representing the item
        """
        return self.endpoint.get_item_prompt(self)
    
    def get_resource_items(self):
        return [self]
    
    def get_namespaces(self):
        """
        Returns namespaces associated with this item
        """
        return self.endpoint.get_item_namespaces(item=self)
    
    def get_link(self, **kwargs):
        return self.endpoint.get_item_link(item=self, **kwargs)
    
    def get_outbound_link(self, **kwargs):
        kwargs.setdefault('link_factor', 'LO')
        return self.get_link(**kwargs)


########NEW FILE########
__FILENAME__ = indexes
#TODO pagination should be a mixin
class Index(object):
    """
    Encapsulates logic for doing lookups & filters on a resource
    
    * provide links for filtering
    * method for item lookup
    * url params for item lookup
    
    """
    paginator_class = None
    page_var = 'p'
    
    def __init__(self, name, resource):
        self.name = name
        self.resource = resource
        self.filters = list()
    
    @property
    def state(self):
        return self.resource.state
    
    def register_filter(self, a_filter, **kwargs):
        kwargs['index'] = self
        self.filters.append(a_filter(**kwargs))
    
    def populate_state(self):
        for a_filter in self.filters:
            a_filter.populate_state()
    
    def get_index_query(self):
        return self.resource.get_index_query(self.name)
    
    def get_url_params(self, param_map={}):
        """
        returns url parts for use in the url regexp for conducting item lookups
        """
        param_map.setdefault('pk', 'pk')
        return [r'(?P<{pk}>\d+)'.format(**param_map)]
    
    def get_url_params_from_item(self, item, param_map={}):
        param_map.setdefault('pk', 'pk')
        return {param_map['pk']: item.instance.pk}
    
    def get(self, **kwargs):
        return self.get_index_query().get(**kwargs)
    
    def get_resource_item(self, **kwargs):
        return self.resource.get_resource_item(self.get(**kwargs))
    
    def get_filtered_index(self):
        active_index = self.get_index_query()
        for a_filter in self.filters:
            if a_filter.is_active():
                new_index = a_filter.filter_index(active_index)
                if new_index is not None:
                    active_index = new_index
        return active_index
    
    def get_link(self, **kwargs):
        return self.resource.get_link(**kwargs)
    
    def get_filter_links(self, **link_kwargs):
        links = list()
        for a_filter in self.filters:
            links.extend(a_filter.get_links(**link_kwargs))
        return links
    
    def get_paginator_kwargs(self):
        return self.resource.get_paginator_kwargs()
    
    def get_paginator(self, **kwargs):
        index = self.get_filtered_index()
        kwargs.update(self.get_paginator_kwargs())
        if self.paginator_class:
            return self.paginator_class(index, **kwargs)
        return self.resource.get_paginator(index, **kwargs)
    
    def get_pagination_links(self, **link_kwargs):
        links = list()
        if 'paginator' in self.state:
            paginator = self.state['paginator']
            classes = ["pagination"]
            for page in range(paginator.num_pages):
                if page == '.':
                    continue
                url = self.state.get_query_string({self.page_var: page+1})
                kwargs = {
                    'url':url,
                    'prompt': u"%s" % page,
                    'classes': classes,
                    'rel': "pagination",
                }
                kwargs.update(link_kwargs)
                links.append(self.get_link(**kwargs))
        return links
    
    def get_advaned_link(self):
        """
        Return a link with all the options in one form, ignores pagination
        """
        pass
    
    def get_links(self, **kwargs):
        links = self.get_filter_links(**kwargs)
        #active_section = self.get_active_section()
        #if active_section:
        #    links += active_section.get_pagination_links()
        return links
    
    def get_page(self):
        paginator = self.get_paginator()
        return paginator.page(self.state.params.get(self.page_var, 1))

class PrimaryIndex(Index):
    def get_paginator_kwargs(self):
        return self.resource.get_paginator_kwargs()

########NEW FILE########
__FILENAME__ = links
from copy import copy

from django.http import QueryDict
from django.template.loader import render_to_string


class Link(object):
    """
    A link in the broad hypermedia sense
    """
    def __init__(self, url, endpoint, method='GET', prompt=None, description=None,
                form=None, form_class=None, form_kwargs=None, on_submit=None, errors=None,
                link_factor=None, include_form_params_in_url=False,
                mimetype=None, descriptors=None, template_name='link.html',
                cu_headers=None, cr_headers=None, **cl_headers):
        """
        
        :param url: target url
        :param endpoint: the endpoint that generated this link
        :param method: the HTTP method of the link
        :param prompt: the link display
        :param description: text describing the link, could be help text
        
        :param form: a form instance
        :param form_class: the form class to be used to instantiate the form
        :param form_kwargs: keyword args to be passed into form class for instanting the form
        :param on_submit: a callback that is passed this link and submit_kwargs and returns a link representing the result
        :param mimetype: indicates the mimetype of the link. Useful for creating the proper embedded link tag.
        :param template_name: The name of the template to use for rendering
        """
        self._url = url
        self._method = str(method).upper() #CM
        self.endpoint = endpoint
        self._form = form
        self.form_class = form_class
        self.form_kwargs = form_kwargs
        self.link_factor = link_factor
        self.include_form_params_in_url = include_form_params_in_url
        self.mimetype = mimetype
        self.descriptors = descriptors #is this needed?
        self.cl_headers = cl_headers
        self.prompt = prompt
        self.description = description
        self.template_name = template_name
        self.cu_headers = cu_headers
        self.cr_headers = cr_headers
        self.on_submit = on_submit
        self._errors = errors
    
    @property
    def api_request(self):
        return self.endpoint.api_request
    
    @property
    def resource(self):
        return self.endpoint.resource
    
    @property
    def state(self):
        return self.endpoint.state
    
    @property
    def site(self):
        return self.endpoint.site
    
    @property
    def rel(self):
        return self.cl_headers.get('rel', None)
    
    @property
    def classes(self):
        if not 'classes' in self.cl_headers:
            if 'class' in self.cl_headers:
                self.cl_headers['classes'] = self.cl_headers['class'].split()
            else:
                self.cl_headers['classes'] = []
        return self.cl_headers['classes']
    
    def get_base_url(self):
        #include_form_params_in_url=False
        if self.get_link_factor() == 'LT' and self.include_form_params_in_url: #TODO absorb this in link._url
            if '?' in self._url:
                base_url, url_params = self._url.split('?', 1)
            else:
                base_url, url_params = self._url, ''
            params = QueryDict(url_params, mutable=True)
            form = self.get_form()
            #extract get params
            for field in form:
                val = field.value()
                if val is not None:
                    params[field.html_name] = val
            return '%s?%s' % (base_url, params.urlencode())
        return self._url
    
    def clone_into_links(self):
        assert self.get_link_factor() == 'LT'
        links = list()
        #TODO find a better way
        form = self.get_form()
        options = [(field, key) for key, field in form.fields.iteritems() if hasattr(field, 'choices')]
        for option_field, key in options:
            for val, label in option_field.choices:
                if not val:
                    continue
                form_kwargs = copy(self.form_kwargs)
                form_kwargs['initial'] = {key: val}
                option = self.clone(prompt=label, form_kwargs=form_kwargs, include_form_params_in_url=True)
                links.append(option)
        return links
    
    def get_absolute_url(self):
        """
        The url for this link
        """
        return self.state.get_link_url(self)
    
    def mimetype_is_audio(self):
        return self.mimetype and self.mimetype.startswith('audio')
    
    def mimetype_is_image(self):
        return self.mimetype and self.mimetype.startswith('image')
    
    def mimetype_is_video(self):
        return self.mimetype and self.mimetype.startswith('video')
    
    def get_link_factor(self):
        """
        Returns a two character representation of the link factor.
        
        * LI - Idempotent
        * LN - Non-Idempotent
        * LT - Templated link
        * LO - Outbound link
        * LI - Embedded link
        """
        if self.link_factor:
            return self.link_factor
        if self._method in ('PUT', 'DELETE'):
            return 'LI'
        if self._method == 'POST':
            return 'LN'
        if self._method == 'GET':
            if self.form_class:
                return 'LT'
            #TODO how do we determine which to return?
            return 'LO' #link out to this content
            return 'LE' #embed this content
        return 'L?'
    
    @property
    def is_simple_link(self):
        """
        Returns True if this link is simply to be followed
        """
        if self.get_link_factor() in ('LO', 'LE'):
            return True
        return False
    
    @property
    def method(self):
        """
        The HTTP method of the link
        """
        if self.is_simple_link:
            return 'GET'
        return self._method
    
    def class_attr(self):
        return u' '.join(self.classes)
    
    def get_form_kwargs(self, **form_kwargs):
        if self.form_kwargs:
            kwargs = copy(self.form_kwargs)
        else:
            kwargs = dict()
        kwargs.update(form_kwargs)
        return kwargs
    
    def get_form(self, **form_kwargs):
        kwargs = self.get_form_kwargs(**form_kwargs)
        form = self.form_class(**kwargs)
        return form
    
    @property
    def form(self):
        """
        Returns the active form for the link. Returns None if there is no form.
        """
        if self._form is None and self.form_class and not self.is_simple_link:
            self._form = self.get_form()
        return self._form
    
    @property
    def errors(self):
        """
        Returns the validation errors belonging to the form
        """
        if self.is_simple_link:
            return self._errors
        if self.form_class:
            #TODO merge with self._errors
            return self.form.errors or self._errors
        return self._errors
    
    def submit(self, **kwargs):
        '''
        Returns a link representing the result of the action taken.
        The resource_item of the link may represent the updated/created object
        or in the case of a collection resource item you get access to the filter items
        '''
        on_submit = self.on_submit
        
        if on_submit is None:
            return self.follow()
        else:
            return on_submit(link=self, submit_kwargs=kwargs)
    
    def follow(self):
        '''
        Follows the link to the endpoint in a subrequest
        Returns a link representing the endpoint response
        '''
        params = {
            'url': self.get_absolute_url(),
        }
        endpoint = self.site.call_endpoint(**params)
        return endpoint.generate_api_response(endpoint.api_request)
    
    def clone(self, **kwargs):
        a_clone = copy(self)
        a_clone._form = kwargs.pop('form', self._form)
        for key, value in kwargs.iteritems():
            setattr(a_clone, key, value)
        return a_clone
    
    def __repr__(self):
        return '<%s LF:%s Prompt:"%s" %s>' % (type(self), self.get_link_factor(), self.prompt, self.get_absolute_url())
    
    def get_context_data(self, **kwargs):
        params = {
            'link': self,
        }
        params.update(kwargs)
        return self.endpoint.get_context_data(**params)
    
    def get_template_names(self):
        if isinstance(self.template_name, basestring):
            template_names = [self.template_name]
        else:
            template_names = self.template_name
        return self.expand_template_names(template_names)
    
    def expand_template_names(self, suffixes):
        return self.endpoint.expand_template_names(suffixes)
    
    def get_context_instance(self):
        #TODO request context?
        return None
    
    def render(self, **kwargs):
        context = self.get_context_data(**kwargs)
        template_name = self.get_template_names()
        return render_to_string(template_name,
                                context,
                                context_instance=self.get_context_instance())

#CONSIDER: should we sublcass: django.core.urlresolvers.NoReverseMatch
class LinkNotAvailable(Exception):
    pass

class LinkCollection(list):
    def __init__(self, endpoint):
        self.endpoint = endpoint
    
    @property
    def link_prototypes(self):
        return self.endpoint.link_prototypes
    
    def add_link(self, link_name, **kwargs):
        """
        Adds the specified link from the resource.
        This will only add the link if it exists and the person is allowed to view it.
        """
        from hyperadmin.endpoints import BaseEndpoint
        if isinstance(link_name, BaseEndpoint):
            try:
                link_name = link_name.get_main_link_name()
            except LinkNotAvailable:
                return False
        if link_name not in self.link_prototypes:
            return False
        endpoint_link = self.link_prototypes[link_name]
        if not endpoint_link.show_link(**kwargs):
            return False
        link = endpoint_link.get_link(**kwargs)
        self.append(link)
        return link

class ChainedLinkCollectionProvider(object):
    def __init__(self, call_chain, default_kwargs={}):
        self.call_chain = call_chain
        self.default_kwargs = default_kwargs
        
    def __call__(self, *args, **kwargs):
        links = None
        kwargs.update(self.default_kwargs)
        for subcall in self.call_chain:
            if links is None:
                links = subcall(*args, **kwargs)
            else:
                links.extend(subcall(*args, **kwargs))
        return links

class LinkCollectionProvider(object):
    def __init__(self, container, parent=None):
        self.container = container #resource, endpoint, state
        self.parent = parent #parent container links
    
    def _get_link_functions(self, attr):
        functions = list()
        if self.parent:
            functions.append( getattr(self.parent, attr) )
        else:
            functions.append( lambda *args, **kwargs: self.container.create_link_collection() )
        if hasattr(self.container, attr):
            functions.append( getattr(self.container, attr) )
        return functions
    
    def _get_link_kwargs(self):
        return {}
    
    def __getattribute__(self, attr):
        if not attr.startswith('get_'):
            return object.__getattribute__(self, attr)
        
        functions = self._get_link_functions(attr)
        default_kwargs = self._get_link_kwargs()
        return ChainedLinkCollectionProvider(functions, default_kwargs)

class ItemLinkCollectionProvider(LinkCollectionProvider):
    def __init__(self, container, parent=None):
        self.container = container
    
    @property
    def parent(self):
        return self.container.endpoint.links
    
    def _get_link_kwargs(self):
        return {'item':self.container}

class LinkCollectorMixin(object):
    link_collector_class = LinkCollectionProvider
    
    def get_link_collector_kwargs(self, **kwargs):
        params = {'container':self}
        params.update(kwargs)
        return params
    
    def get_link_collector(self, **kwargs):
        return self.link_collector_class(**self.get_link_collector_kwargs(**kwargs))

class LinkPrototype(object):
    """
    Incapsulates logic related to a link. This class is responsible for:
    
    * creating link
    * handling link submission
    * controlling link visibility
    """
    def __init__(self, endpoint, name, link_kwargs={}):
        self.endpoint = endpoint
        self.name = name
        self.link_kwargs = link_kwargs
    
    @property
    def resource(self):
        return self.endpoint.resource
    
    @property
    def state(self):
        return self.endpoint.state
    
    @property
    def common_state(self):
        return self.endpoint.common_state
    
    @property
    def api_request(self):
        return self.endpoint.api_request
    
    def show_link(self, **kwargs):
        """
        Checks the state and returns False if the link is not active.
        
        :rtype: boolean
        """
        return True
    
    def get_link_description(self):
        return self.__doc__
    
    def get_form_class(self):
        return self.endpoint.get_form_class()
    
    def get_form_kwargs(self, **kwargs):
        """
        :rtype: dict
        """
        return self.endpoint.get_form_kwargs(**kwargs)
    
    def get_link_kwargs(self, **kwargs):
        """
        :rtype: dict
        """
        assert self.endpoint.state, 'link creation must come from a dispatched endpoint'
        params = dict(self.link_kwargs)
        params.setdefault('description', self.get_link_description())
        params.update(kwargs)
        if params.pop('use_request_url', False):
            params['url'] = self.api_request.get_full_path()
        params['form_kwargs'] = self.get_form_kwargs(**params.get('form_kwargs', {}))
        return self.endpoint.get_link_kwargs(**params)
    
    def get_link_class(self):
        return Link
    
    def get_link(self, **link_kwargs):
        """
        Creates and returns the link
        
        :rtype: Link
        """
        link_kwargs = self.get_link_kwargs(**link_kwargs)
        link_class = self.get_link_class()
        link = link_class(**link_kwargs)
        return link
    
    def handle_submission(self, link, submit_kwargs):
        """
        Called when the link is submitted. Returns a link representing the response.
        
        :rtype: Link
        """
        form = link.get_form(**submit_kwargs)
        if form.is_valid():
            instance = form.save()
            resource_item = self.endpoint.get_resource_item(instance)
            return self.on_success(resource_item)
        return link.clone(form=form)
    
    def on_success(self, item=None):
        """
        Returns a link for a successful submission
        
        :rtype: Link
        """
        if item is not None:
            return item.get_link()
        return self.endpoint.get_resource_link()
    
    def get_url(self, **kwargs):
        return self.endpoint.get_url(**kwargs)
    
    def get_url_name(self):
        return self.endpoint.get_url_name()

########NEW FILE########
__FILENAME__ = collectionjson
from __future__ import absolute_import

import json
from django import http

from hyperadmin.mediatypes.encoders import HyperadminJSONEncoder, force_text
from hyperadmin.mediatypes.common import MediaType
from hyperadmin.links import Link


class CollectionJSON(MediaType):
    recognized_media_types = [
        'application/vnd.Collection+JSON',
        'application/vnd.collection+json',
    ]
    
    def prepare_field_value(self, val):
        val = super(CollectionJSON, self).prepare_field_value(val)
        if isinstance(val, Link):
            val = Link.get_absolute_url()
        return val
    
    def convert_field(self, field):
        entry = {"name": force_text(field.name),
                 "prompt": force_text(field.label)}
        return entry
    
    def links_for_item(self, item):
        result = dict()
        links = list()
        links.extend(item.links.get_item_embedded_links())
        links.extend(item.links.get_item_outbound_links())
        result["links"] = [self.convert_link(link) for link in links]
        result["href"] = item.get_absolute_url()
        return result
    
    def convert_item(self, item):
        result = self.links_for_item(item)
        form = item.get_form()
        result['data'] = self.convert_form(form)
        result['prompt'] = item.get_prompt()
        return result
    
    def convert_form(self, form):
        data = list()
        entry_data = self.get_form_instance_values(form)
        for field in form:
            entry = self.convert_field(field)
            #TODO handle link values
            entry['value'] = entry_data.get(field.name, None)
            data.append(entry)
        return data
    
    def convert_link(self, link):
        link_r = {"href":link.get_absolute_url(),
                  "rel":link.rel,
                  "prompt":link.prompt,
                  "classes":link.classes,
                  }
        if link.descriptors and "label" in link.descriptors:
            link_r['prompt'] = link.descriptors['label']
        if link.form:
            link_r['data'] = self.convert_form(link.form)
        return link_r
    
    def convert_errors(self, errors):
        error_r = {'title':'An error occurred',
                   'code':'00',
                   'message':str(errors),}
        return error_r
    
    def prepare_collection(self, form_link, state):
        data = self.prepare_link(form_link)
        
        items = [self.convert_item(item) for item in state.get_resource_items()]
        
        #the following maps hfactor to this media type
        links = list()
        links.extend(state.links.get_embedded_links())
        links.extend(state.links.get_outbound_links())
        queries = state.links.get_filter_links()
        
        data.update({
            "links": [self.convert_link(link) for link in links],
            "items": items,
            "queries": [self.convert_link(query) for query in queries],
        })
        
        data.update(meta=state.meta, prompt=state.resource.get_prompt())
        return data
    
    def prepare_link(self, form_link):
        data = {
            'href':form_link.get_absolute_url(),
            'version': '1.0',
        }
        if form_link and form_link.form and form_link.form.errors:
            data['error'] = self.convert_errors(form_link.form.errors)
        
        if form_link.form:
            data['template'] = self.convert_link(form_link)
        return data
    
    def serialize(self, content_type, link, state):
        if self.detect_redirect(link):
            return self.handle_redirect(link, content_type)
        data = self.prepare_collection(link, state)
        content = json.dumps({"collection":data}, cls=HyperadminJSONEncoder)
        assert content_type in self.recognized_media_types, "%s not in %s" % (content_type, self.recognized_media_types)
        return http.HttpResponse(content, content_type)
    
    def options_serialize(self, content_type, links, state):
        methods = dict()
        for method, link in links.iteritems():
            methods[method] = {'collection':self.prepare_link(link)}
        content = json.dumps(methods, cls=HyperadminJSONEncoder)
        allow = ','.join(links.iterkeys())
        response = http.HttpResponse(content, content_type)
        response['Allow'] = allow
        return response
    
    def deserialize(self):
        request = self.get_django_request()
        if hasattr(request, 'body'):
            payload = request.body
        else:
            payload = request.raw_post_data
        if not payload:
            return {}
        data = json.loads(payload)
        data = data['data']
        form_data = dict()
        files = dict()
        for field in data:
            f_type = field.get('type', 'text')
            form_data[field['name']] = field['value']
            if f_type == 'file' and field['value']:
                #TODO storage lookup could be done better
                storage = self.site.applications['-storages'].resource_adaptor['media'].resource_adaptor
                files[field['name']] = storage.open(field['value'])
        
        return {'data':form_data,
                'files':files,}

CollectionJSON.register_with_builtins()

class CollectionNextJSON(CollectionJSON):
    recognized_media_types = [
        'application/vnd.Collection.next+JSON'
    ]
    
    def convert_field(self, field):
        entry = super(CollectionNextJSON, self).convert_field(field)
        entry['required'] = field.field.required
        entry['type'] = self.get_html_type_from_field(field)
        if hasattr(field.field, 'choices') and field.field.choices is not None:
            options = list()
            for value, prompt in field.field.choices:
                options.append({"value":value,
                                "prompt":prompt})
            entry['list'] = {'options':options}
            from django.forms.widgets import SelectMultiple
            if isinstance(field.field.widget, SelectMultiple):
                entry['multiple'] = True
        return entry
    
    def convert_errors(self, errors):
        messages = list()
        for key, error in errors.iteritems():
            message = {'name':key,
                       'message':unicode(error)}
            messages.append(message)
        error_r = {'code':'00',
                   'messages':messages,}
        return error_r
    
    def convert_link(self, link):
        link_r = super(CollectionNextJSON, self).convert_link(link)
        #TODO link_r["method"]
        link_r["method"] = {"options": [{"value":link.method}]}
        #TODO link_r["enctype"]
        return link_r

CollectionNextJSON.register_with_builtins()

class CollectionHyperAdminJSON(CollectionNextJSON):
    recognized_media_types = [
        'application/vnd.Collection.hyperadmin+JSON'
    ]
    
    def get_accepted_namespaces(self):
        namespaces = list()
        for entry in self.api_request.META.get('HTTP_ACCEPT_NAMESPACES', '').split(','):
            entry = entry.strip()
            if entry:
                namespaces.append(entry)
        return namespaces
    
    def convert_field(self, field):
        entry = super(CollectionHyperAdminJSON, self).convert_field(field)
        resource = self.get_related_resource_from_field(field)
        if resource:
            if isinstance(resource, basestring):
                entry['related_resource_url'] = resource
            else:
                entry['related_resource_url'] = resource.get_absolute_url()
        entry['classes'] = field.css_classes().split()
        #if isinstance(field, forms.FileField):
        #    field.form.instance
        #TODO upload to
        return entry
    
    def prepare_collection(self, form_link, state, include_namespaces=True):
        data = super(CollectionHyperAdminJSON, self).prepare_collection(form_link, state)
        resource_item = state.item
        
        if resource_item:
            update_links = resource_item.links.get_item_ln_links() + resource_item.links.get_item_idempotent_links()
        else:
            update_links = state.links.get_ln_links() + state.links.get_idempotent_links()
        #get_non_idempotent_updates
        #get_idempotent_updates
        if len(update_links):
            data['templates'] = [self.convert_link(link) for link in update_links]
        
        if include_namespaces and resource_item:
            data['namespaces'] = dict()
            accepted_namespaces = self.get_accepted_namespaces()
            #for key, namespace in state.get_namespaces().iteritems():
            for key, namespace in resource_item.get_namespaces().iteritems():
                for a_key in accepted_namespaces:
                    if key.startswith(a_key):
                        data['namespaces'][key] = self.prepare_collection(form_link=namespace.link, state=namespace.state, include_namespaces=False)
                        data['namespaces'][key]['namespace'] = key
                        break
        
        data['resource_class'] = form_link.resource.resource_class
        if 'display_fields' in state.meta:
            data['display_fields'] = state.meta['display_fields']
        return data

CollectionHyperAdminJSON.register_with_builtins()


########NEW FILE########
__FILENAME__ = common
from django.core.files import File
from django import http


BUILTIN_MEDIA_TYPES = dict()

class MediaType(object):
    recognized_media_types = []
    
    @classmethod
    def register_with_builtins(cls):
        for media_type in cls.recognized_media_types:
            BUILTIN_MEDIA_TYPES[media_type] = cls
    
    def __init__(self, api_request):
        self.api_request = api_request
    
    @property
    def site(self):
        return self.api_request.get_site()
    
    def get_django_request(self):
        return self.api_request.get_django_request()
    
    def handle_redirect(self, link, content_type):
        if self.api_request.method != 'GET':
            response = http.HttpResponse(link.get_absolute_url(), status=303, content_type=content_type)
            response['Location'] = link.get_absolute_url()
        else:
            response = http.HttpResponseRedirect(link.get_absolute_url())
            response['Content-Type'] = content_type
        return response
    
    def detect_redirect(self, link):
        if link.get_absolute_url() != self.api_request.get_full_path():
            return True
        return False
    
    def serialize(self, content_type, link, state):
        '''
        Return an HttpResponse
        '''
        raise NotImplementedError
    
    def options_serialize(self, content_type, links, state):
        """
        Return an HttpResponse describing the available OPTIONS at an endpoint
        
        :param links: dictionary mapping available HTTP methods to a link
        """
        context = {
            'links':links,
            'content_type':content_type,
            'allow':','.join(links.iterkeys()),
        }
        response = http.HttpResponse()
        response['Allow'] = context['allow']
        return response
    
    def deserialize(self):
        '''
        returns keyword arguments for instantiating a form
        '''
        raise NotImplementedError
    
    def prepare_field_value(self, val):
        if isinstance(val, File):
            if hasattr(val, 'name'):
                val = val.name
            else:
                val = None
        return val
    
    def get_form_instance_values(self, form, include_initial=True):
        data = dict()
        if getattr(form, 'instance', None) or include_initial:
            for name, field in form.fields.iteritems():
                val = form[name].value()
                val = self.prepare_field_value(val)
                data[name] = val
        return data
    
    def get_related_resource_from_field(self, field):
        return self.site.get_related_resource_from_field(field)
    
    def get_html_type_from_field(self, field):
        return self.site.get_html_type_from_field(field)


########NEW FILE########
__FILENAME__ = datatap
# -*- coding: utf-8 -*-
from __future__ import absolute_import

import io

from django import http

from datatap.datataps import StreamDataTap

from hyperadmin.mediatypes.common import MediaType


class DataTap(MediaType):
    def __init__(self, api_request, datatap_class, **kwargs):
        self.datatap_class = datatap_class
        super(DataTap, self).__init__(api_request, **kwargs)

    def get_content(self, form_link, state):
        instream = state.get_resource_items()
        datatap = state.endpoint.get_datatap(instream=instream)
        serialized_dt = self.datatap_class(instream=datatap)
        payload = io.BytesIO()
        serialized_dt.send(payload)
        return payload.getvalue()

    def serialize(self, content_type, link, state):
        if self.detect_redirect(link):
            return self.handle_redirect(link, content_type)
        content = self.get_content(link, state)
        response = http.HttpResponse(content, content_type)
        #TODO response['X-Next-Page'] = state.links(group='pagination', rel='next')[0]
        #TODO response['X-Previous-Page'] = state.links(group='pagination', rel='previous')[0]
        return response

    def get_datatap(self, request):
        if hasattr(request, 'body'):
            payload = request.body
        else:
            payload = request.raw_post_data
        return self.datatap_class(StreamDataTap(io.BytesIO(payload)))

    def deserialize(self, request):
        #CONSIDER: does using a datatap mean you must post as a list?
        datatap = self.get_datatap(request)
        data = list(datatap)[0]
        return {'data': data,
                'files': request.FILES, }

########NEW FILE########
__FILENAME__ = encoders
from django.utils.functional import Promise
try:
    from django.utils.encoding import force_text
except ImportError:
    from django.utils.encoding import force_unicode as force_text
from django.core.serializers.json import DjangoJSONEncoder


class HyperadminJSONEncoder(DjangoJSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        if isinstance(obj, Promise):
            return force_text(obj)
        return super(HyperadminJSONEncoder, self).default(obj)

########NEW FILE########
__FILENAME__ = html5
from django.template.response import TemplateResponse
from django.middleware.csrf import CsrfViewMiddleware
from django.conf import settings

from hyperadmin.mediatypes.common import MediaType


class Html5MediaType(MediaType):
    template_name = 'hyperadmin/html5/resource.html'
    template_dir_name = 'hyperadmin/html5'
    response_class = TemplateResponse
    recognized_media_types = [
        'text/html',
        'text/plain',
        'application/xhtml+xml',
        'application/text-html',
        'application/x-www-form-urlencoded',
        'multipart/form-data',
    ]
    
    def get_context_data(self, link, state):
        context = {'link':link,
                   'meta':state.meta,
                   'state':state,}
        
        context['namespaces'] = state.get_namespaces()
        
        if 'display_fields' in state.meta:
            context['display_fields'] = state.meta['display_fields']
        
        view_class_context = 'get_%s_context_data' % state['endpoint_class']
        if hasattr(self, view_class_context):
            context = getattr(self, view_class_context)(link, state, context)
        
        #strangely for django 1.3
        if 'STATIC_URL' not in context and getattr(settings, 'STATIC_URL', None):
            context['STATIC_URL'] = getattr(settings, 'STATIC_URL')
        
        if hasattr(state['endpoint'], 'get_context_data'):
            context = state['endpoint'].get_context_data(**context)
        
        return context
    
    def get_template_names(self, state):
        if hasattr(state['endpoint'], 'get_template_names'):
            names = state['endpoint'].get_template_names()
            if names: return names
        
        params = {
            'base': self.template_dir_name,
            'endpoint_class': state['endpoint_class'],
            'resource_name': state.get('resource_name', None),
            'app_name': state.get('app_name', None),
        }
        
        names = [
            '{base}/{app_name}/{resource_name}/{endpoint_class}.html'.format(**params),
            '{base}/{app_name}/{endpoint_class}.html'.format(**params),
            '{base}/{endpoint_class}.html'.format(**params),
            self.template_name,
        ]
        
        return names
    
    def serialize(self, content_type, link, state):
        if self.detect_redirect(link):
            return self.handle_redirect(link, content_type)
        context = self.get_context_data(link=link, state=state)
        
        response = self.response_class(request=self.get_django_request(), template=self.get_template_names(state), context=context)
        response['Content-Type'] = 'text/html'
        
        return response
    
    def get_option_template_names(self):
        return ['{base}/options.html'.format(base=self.template_dir_name)]
    
    def options_serialize(self, content_type, links, state):
        context = {
            'links':links,
            'content_type':content_type,
            'allow':','.join(links.iterkeys()),
        }
        response = self.response_class(request=self.get_django_request(), template=self.get_option_template_names(), context=context)
        response['Allow'] = context['allow']
        return response
    
    def deserialize(self):
        request = self.get_django_request()
        self.check_csrf(request)
        
        return {'data':request.POST,
                'files':request.FILES,}
    
    def check_csrf(self, request):
        csrf_middleware = CsrfViewMiddleware()
        response = csrf_middleware.process_view(request, self.deserialize, [], {})
        if response is not None:
            assert False, 'csrf failed' #TODO APIException(response) or SuspiciousOperation ....
            raise response

Html5MediaType.register_with_builtins()


########NEW FILE########
__FILENAME__ = iframe
import mimeparse

from django.template.response import TemplateResponse
from django.middleware.csrf import CsrfViewMiddleware

from hyperadmin.mediatypes.common import MediaType


class IframeMediaType(MediaType):
    template_name = 'hyperadmin/iframe/resource.html'
    response_class = TemplateResponse
    recognized_media_types = [
        'text/html-iframe-transport;level=1',
    ]
    
    def get_response_type(self):
        response_type = self.api_request.META.get('HTTP_ACCEPT', '')
        effective_type = response_type.split(self.recognized_media_types[0], 1)[-1]
        return mimeparse.best_match(
            self.site.media_types.keys(),
            effective_type
        )
    
    def get_response_media_type(self):
        content_type = self.get_response_type()
        assert content_type not in self.recognized_media_types
        media_type_cls = self.site.media_types.get(content_type, None)
        if media_type_cls is None:
            raise ValueError('Unrecognized response content type: %s' % content_type)
        return media_type_cls(self.api_request)
    
    def get_context_data(self, link, state):
        media_type = self.get_response_media_type()
        content_type = self.get_response_type()
        response = media_type.serialize(content_type=content_type, link=link, state=state)
        context = {
            'payload':response.rendered_content,
            'content_type': content_type,
        }
        return context
    
    def get_template_names(self):
        return [self.template_name]
    
    def serialize(self, content_type, link, state):
        if self.detect_redirect(link):
            return self.handle_redirect(link, content_type)
        
        context = self.get_context_data(link=link, state=state)
        response = self.response_class(request=self.get_django_request(), template=self.get_template_names(), context=context)
        response['Content-Type'] = 'text/html'
        return response
    
    def deserialize(self):
        request = self.get_django_request()
        self.check_csrf(request)
        
        return {'data':request.POST,
                'files':request.FILES,}
    
    def check_csrf(self, request):
        csrf_middleware = CsrfViewMiddleware()
        response = csrf_middleware.process_view(request, self.deserialize, [], {})
        if response is not None:
            assert False, 'csrf failed' #TODO APIException(response) or SuspiciousOperation ....
            raise response

IframeMediaType.register_with_builtins()


########NEW FILE########
__FILENAME__ = json
from __future__ import absolute_import

from django import http

from datatap.datataps import JSONDataTap

from hyperadmin.mediatypes.datatap import DataTap


class JSON(DataTap):
    recognized_media_types = [
        'application/json'
    ]

    def __init__(self, api_request, **kwargs):
        kwargs.setdefault('datatap_class', JSONDataTap)
        super(JSON, self).__init__(api_request, **kwargs)

JSON.register_with_builtins()


class JSONP(JSON):
    recognized_media_types = [
        'text/javascript'
    ]

    def get_jsonp_callback(self):
        #TODO make configurable
        return self.api_request.params['callback']

    def serialize(self, content_type, link, state):
        if self.detect_redirect(link):
            return self.handle_redirect(link, content_type)
        content = self.get_content(link, state)
        callback = self.get_jsonp_callback()
        return http.HttpResponse(u'%s(%s)' % (callback, content), content_type)

JSONP.register_with_builtins()


########NEW FILE########
__FILENAME__ = passthrough
from django.http import HttpResponse

from hyperadmin.mediatypes.common import MediaType


class PassthroughResponse(HttpResponse):
    def __init__(self, *args, **kwargs):
        self.link = kwargs.pop('link')
        self.state = kwargs.pop('state')
        super(PassthroughResponse, self).__init__(*args, **kwargs)

class Passthrough(MediaType):
    def handle_redirect(self, link, content_type):
        if self.api_request.method != 'GET':
            status = 303
        else:
            status = 302
        response = PassthroughResponse(link.get_absolute_url(), status=status, content_type=content_type)
        response['Location'] = link.get_absolute_url()
        return response
    
    def detect_redirect(self, link):
        return False
        #TODO
        if link.get_absolute_url() != self.api_request.get_full_path():
            return True
        return False
    
    def serialize(self, content_type, link, state):
        if self.detect_redirect(link):
            return self.handle_redirect(link, content_type)
        return PassthroughResponse('Unavailable (passthrough media type)', content_type, link=link, state=state)
    
    def deserialize(self):
        #TODO should punt to the real media type
        request = self.get_django_request()
        return {'data':request.POST,
                'files':request.FILES,}

########NEW FILE########
__FILENAME__ = models
"""
Helper function for logging all events that come through the API.
"""
# TODO Write logging model

from contextlib import contextmanager
import logging

from django.utils.encoding import smart_unicode
from django.utils.translation import ugettext_lazy as _

class RelList(list):
    """
    A list subclass that allows us to use dot notation to search for elements
    that match the reltype.
    
    >>> links = RelList([{"rel":"self", "href": "self"}, {"rel":"other", "href":"other"}])
    >>> links.self["href"]
    'self'
    >>> links.other["href"]
    'other'
    >>> links.foo
    
    """
    def __getattr__(self, name):
        for item in self:
            if item['rel'] == name:
                return item

LOGGER = logging.getLogger('hypermedia')

UNSPECIFIED = 0
ADDITION = 1
CHANGE = 2
DELETION = 3

ACTION_NAME = {
    UNSPECIFIED: "???",
    ADDITION: "added",
    CHANGE: "changed",
    DELETION: "deleted"
}

@contextmanager
def log_action(user, obj, action_flag, change_message="", request=None):
    """
    A context manager that logs the action.
    
    If the action fails, it logs that, too.
    """
    if user.is_anonymous:
        user = None
    
    action = ACTION_NAME[action_flag]
    object_repr = smart_unicode(obj)
    
    if not change_message:
        change_message = _(u"Object %s was %s." % (
            object_repr, action
        ))
    
    # Allow the body of the context to run
    try:
        yield
    except:
        LOGGER.error(_(u"Unable to %s object %s." % (action, object_repr)),
            exc_info=True,
            extra={
                'request': request,
                'data': {
                    'user': user
                }
            }
        )
        raise
    
    LOGGER.info(change_message, exc_info=True, extra={
        'stack': True,
        'request': request,
        'data': {
            'user': user
        }
    })
########NEW FILE########
__FILENAME__ = endpoints
from django.contrib.auth import logout
from django import forms

from hyperadmin.links import LinkPrototype
from hyperadmin.resources.endpoints import ResourceEndpoint


class LoginLinkPrototype(LinkPrototype):
    def show_link(self, **kwargs):
        return True
        return not self.common_state.get('authenticated', True) or self.api_request.user.is_anonymous()
    
    def get_link_kwargs(self, **kwargs):
        kwargs = super(LoginLinkPrototype, self).get_link_kwargs(**kwargs)
        
        link_kwargs = {'url':self.get_url(),
                       'on_submit':self.handle_submission,
                       'method':'POST',
                       'form_class': self.get_form_class(),
                       'prompt':'Login',
                       'rel':'login',}
        link_kwargs.update(kwargs)
        return super(LoginLinkPrototype, self).get_link_kwargs(**link_kwargs)
    
    def handle_submission(self, link, submit_kwargs):
        form = link.get_form(**submit_kwargs)
        if form.is_valid():
            form.save()
            self.common_state['authenticated'] = True
            return self.on_success()
        return link.clone(form=form)
    
    def on_success(self):
        return self.resource.site.get_link()

class LogoutLinkPrototype(LinkPrototype):
    def get_form_class(self):
        return forms.Form
    
    def get_form_kwargs(self, **kwargs):
        return {}
    
    def show_link(self, **kwargs):
        return self.common_state.get('authenticated', False) or self.api_request.user.is_authenticated()
    
    def get_link_kwargs(self, **kwargs):
        kwargs = super(LogoutLinkPrototype, self).get_link_kwargs(**kwargs)
        
        link_kwargs = {'url':self.get_url(),
                       'on_submit':self.handle_submission,
                       'method':'POST',
                       'form_class': self.get_form_class(),
                       'prompt':'Logout',
                       'rel':'logout',}
        link_kwargs.update(kwargs)
        return super(LogoutLinkPrototype, self).get_link_kwargs(**link_kwargs)
    
    def handle_submission(self, link, submit_kwargs):
        logout(self.api_request.request)
        self.common_state['authenticated'] = False
        return self.on_success()
    
    def on_success(self):
        return self.endpoint.resource.link_prototypes['login'].get_link()


class AuthMixin(object):
    def get_common_state_data(self):
        state = super(AuthMixin, self).get_common_state_data()
        state['authenticated'] = self.api_request.user.is_authenticated()
        return state
    
    def get_form_kwargs(self, **defaults):
        defaults['request'] = self.api_request.request
        return defaults

class LoginEndpoint(AuthMixin, ResourceEndpoint):
    name_suffix = 'login'
    url_suffix = r'^$'
    
    prototype_method_map = {
        'GET': 'login',
        'POST': 'login',
        'DELETE': 'rest-logout',
    }
    
    login_prototype = LoginLinkPrototype
    logout_prototype = LogoutLinkPrototype
    
    def get_link_prototypes(self):
        return [
            (self.login_prototype, {'name':'login'}),
            (self.logout_prototype, {'name':'rest-logout', 'link_kwargs':{'method':'DELETE'}}),
        ]
    
    def get_outbound_links(self):
        links = self.create_link_collection()
        links.add_link('logout', link_factor='LO')
        return links

class LogoutEndpoint(AuthMixin, ResourceEndpoint):
    name_suffix = 'logout'
    url_suffix = r'^logout/$'
    
    prototype_method_map = {
        'GET': 'logout',
        'POST': 'logout',
    }
    
    logout_prototype = LogoutLinkPrototype
    
    def get_link_prototypes(self):
        return [
            (self.logout_prototype, {'name':'logout'}),
        ]


########NEW FILE########
__FILENAME__ = forms
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth import login

class AuthenticationResourceForm(AuthenticationForm):
    def __init__(self, **kwargs):
        self.instance = kwargs.pop('instance', None)
        super(AuthenticationResourceForm, self).__init__(**kwargs)
    
    def check_for_test_cookie(self):
        return
    
    def save(self, commit=True):
        assert self.request
       
        user = self.get_user()
        login(self.request, user)
        return user


########NEW FILE########
__FILENAME__ = resources
from hyperadmin.resources import BaseResource
from hyperadmin.resources.auth.forms import AuthenticationResourceForm
from hyperadmin.resources.auth.endpoints import LoginEndpoint, LogoutEndpoint


class AuthResource(BaseResource):
    form_class = AuthenticationResourceForm
    login_endpoint_class = LoginEndpoint
    logout_endpoint_class = LogoutEndpoint
    
    def __init__(self, **kwargs):
        kwargs.setdefault('app_name', '-authentication')
        kwargs.setdefault('resource_name', 'authentication')
        kwargs.setdefault('resource_adaptor', None)
        super(AuthResource, self).__init__(**kwargs)
    
    def get_view_endpoints(self):
        endpoints = super(AuthResource, self).get_view_endpoints()
        endpoints.extend([
            (self.login_endpoint_class, {}),
            (self.logout_endpoint_class, {}),
        ])
        return endpoints
    
    def api_permission_check(self, api_request, endpoint):
        return None #resource is accessible to all
    
    def get_main_link_name(self):
        return 'login'
    
    def get_index_endpoint(self):
        return self.endpoints['login']

########NEW FILE########
__FILENAME__ = endpoints
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404

from hyperadmin.links import LinkPrototype
from hyperadmin.resources.endpoints import ResourceEndpoint


class ListLinkPrototype(LinkPrototype):
    """
    Resource Item Listing
    """
    def get_link_kwargs(self, **kwargs):
        link_kwargs = {'url': self.get_url(),
                       'prompt': 'List %s' % self.resource.get_prompt(),
                       'rel': 'list', }
        link_kwargs.update(kwargs)
        return super(ListLinkPrototype, self).get_link_kwargs(**link_kwargs)


class CreateLinkPrototype(LinkPrototype):
    """
    Create Resource Item
    """
    def show_link(self, **kwargs):
        return self.resource.has_create_permission()

    def get_link_kwargs(self, **kwargs):
        kwargs = super(CreateLinkPrototype, self).get_link_kwargs(**kwargs)

        link_kwargs = {'url': self.get_url(),
                       'on_submit': self.handle_submission,
                       'method': 'POST',
                       'form_class': self.get_form_class(),
                       'prompt': 'Create %s' % self.resource.get_prompt(),
                       'rel': 'create', }
        link_kwargs.update(kwargs)
        return super(CreateLinkPrototype, self).get_link_kwargs(**link_kwargs)

    def on_success(self, item):
        return self.resource.on_create_success(item) or super(CreateLinkPrototype, self).on_success(item)


class DetailLinkPrototype(LinkPrototype):
    """
    Display Resource Item
    """
    def show_link(self, **kwargs):
        #TODO view permsions on links
        return True

    def get_link_kwargs(self, **kwargs):
        kwargs = super(DetailLinkPrototype, self).get_link_kwargs(**kwargs)

        item = kwargs['item']
        link_kwargs = {'url': self.get_url(item=item),
                       'prompt': item.get_prompt(),
                       'rel': 'detail', }
        link_kwargs.update(kwargs)
        return super(DetailLinkPrototype, self).get_link_kwargs(**link_kwargs)


class UpdateLinkPrototype(LinkPrototype):
    """
    Update Resource Item
    """
    def show_link(self, **kwargs):
        return self.resource.has_update_permission(item=kwargs.get('item', None))

    def get_link_kwargs(self, **kwargs):
        kwargs = super(UpdateLinkPrototype, self).get_link_kwargs(**kwargs)

        item = kwargs['item']
        link_kwargs = {'url': self.get_url(item=item),
                       'on_submit': self.handle_submission,
                       'method': 'POST',
                       'form_class': item.get_form_class(),
                       'prompt': 'Update %s' % item.get_prompt(),
                       'rel': 'update', }
        link_kwargs.update(kwargs)
        return super(UpdateLinkPrototype, self).get_link_kwargs(**link_kwargs)

    def on_success(self, item):
        return self.resource.on_update_success(item) or super(UpdateLinkPrototype, self).on_success(item)


class DeleteLinkPrototype(LinkPrototype):
    """
    Delete Resource Item
    """
    def show_link(self, **kwargs):
        return self.resource.has_delete_permission(item=kwargs.get('item', None))

    def get_link_kwargs(self, **kwargs):
        kwargs = super(DeleteLinkPrototype, self).get_link_kwargs(**kwargs)

        item = kwargs['item']
        link_kwargs = {'url': self.get_url(item=item),
                       'on_submit': self.handle_submission,
                       'method': 'POST',
                       'prompt': 'Delete %s' % item.get_prompt(),
                       'rel': 'delete', }
        link_kwargs.update(kwargs)
        return super(DeleteLinkPrototype, self).get_link_kwargs(**link_kwargs)

    def handle_submission(self, link, submit_kwargs):
        item = self.resource.state.item
        instance = item.instance
        instance.delete()
        return self.on_success(item)

    def on_success(self, item):
        return self.resource.on_delete_success(item) or super(DeleteLinkPrototype, self).on_success()


class IndexMixin(object):
    index_name = 'primary'

    def get_index(self):
        if self.api_request:
            if 'index' not in self.state:
                self.state['index'] = self.resource.get_index(self.index_name)
                self.state['index'].populate_state()
            return self.state['index']
        else:
            return self.resource.get_index(self.index_name)


class ListEndpoint(IndexMixin, ResourceEndpoint):
    endpoint_class = 'change_list'
    name_suffix = 'list'
    url_suffix = r'^$'

    prototype_method_map = {
        'GET': 'list',
        'POST': 'rest-create',
    }

    list_prototype = ListLinkPrototype
    create_prototype = CreateLinkPrototype

    def post(self, api_request):
        mt = api_request.get_request_media_type()
        has_perm = self.resource.has_create_permission() and self.resource.has_update_permission()
        if (has_perm and
            hasattr(mt, 'get_datatap') and
            hasattr(api_request, 'get_django_request')):

            #use the request payload as an instream for our resource's datatap
            request = api_request.get_django_request()
            instream = mt.get_datatap(request)
            datatap = self.get_datatap(instream=instream)
            datatap.commit()
            return self.get_link()
        return self.handle_link_submission(api_request)

    def get_link_prototypes(self):
        return [
            (self.list_prototype, {'name':'list'}),
            (self.create_prototype, {'name':'rest-create'}),
        ]

    def get_outbound_links(self):
        links = self.create_link_collection()
        links.add_link('create', link_factor='LO')
        return links

    def get_filter_links(self):
        links = self.create_link_collection()
        index = self.get_index()
        links.extend(index.get_filter_links(rel='filter'))
        return links

    def get_pagination_links(self):
        links = self.create_link_collection()
        index = self.get_index()
        links.extend(index.get_pagination_links(rel='paginate'))
        return links

    def get_instances(self):
        #CONSIDER view currently determines this
        index = self.get_index()
        page = index.get_page()
        return page.object_list

    def get_resource_item(self, instance, **kwargs):
        kwargs.setdefault('endpoint', self)
        return self.resource.get_list_resource_item(instance, **kwargs)

    def get_meta(self):
        resource_item = self.resource.get_list_resource_item(instance=None)
        form = resource_item.get_form()
        data = dict()
        data['display_fields'] = list()
        for field in form:
            data['display_fields'].append({'prompt': field.label})
        return data

    def get_common_state_data(self):
        data = super(ListEndpoint, self).get_common_state_data()

        index = self.get_index()
        paginator = index.get_paginator()
        data['paginator'] = paginator
        data['index'] = index
        self.state.meta['object_count'] = paginator.count
        self.state.meta['number_of_pages'] = paginator.num_pages
        return data


class CreateEndpoint(ResourceEndpoint):
    endpoint_class = 'change_form'
    endpoint_classes = ['add_form']
    name_suffix = 'add'
    url_suffix = r'^add/$'

    prototype_method_map = {
        'GET': 'create',
        'POST': 'create',
    }

    create_prototype = CreateLinkPrototype

    def get_link_prototypes(self):
        return [
            (self.create_prototype, {'name':'create'}),
        ]

    def get_breadcrumbs(self):
        breadcrumbs = super(CreateEndpoint, self).get_breadcrumbs()
        breadcrumbs.add_link('create', rel='breadcrumb', link_factor='LO')
        return breadcrumbs

    def get_resource_items(self):
        return []


class DetailMixin(IndexMixin):
    url_param_map = {}

    def get_object(self):
        if not hasattr(self, 'object'):
            try:
                self.object = self.get_index().get(**self.kwargs)
            except ObjectDoesNotExist as error:
                raise Http404(str(error))
        return self.object

    def get_item(self):
        return self.get_resource_item(self.get_object())

    def get_common_state_data(self):
        data = super(DetailMixin, self).get_common_state_data()
        data['item'] = self.get_item()
        return data

    def get_url_param_map(self):
        return dict(self.url_param_map)

    def get_url_params_from_item(self, item):
        param_map = self.get_url_param_map()
        return self.get_index().get_url_params_from_item(item, param_map)

    def get_url_suffix(self):
        param_map = self.get_url_param_map()
        url_suffix = '/'.join(self.get_index().get_url_params(param_map))
        url_suffix = '^%s%s' % (url_suffix, self.url_suffix)
        return url_suffix

    def get_url(self, item):
        params = self.get_url_params_from_item(item)
        return super(DetailMixin, self).get_url(**params)


class DetailEndpoint(DetailMixin, ResourceEndpoint):
    endpoint_class = 'change_form'
    name_suffix = 'detail'
    url_suffix = r'/$'

    prototype_method_map = {
        'GET': 'update',
        #'GET': 'detail',
        'POST': 'update',
        'PUT': 'rest-update',
        'DELETE': 'rest-delete',
    }

    update_prototype = UpdateLinkPrototype
    detail_prototype = DetailLinkPrototype
    delete_prototype = DeleteLinkPrototype

    def get_link_prototype_for_method(self, method):
        """
        Returns a detail link based on whether a client can edit or view the objects
        """
        if method == 'GET' and not self.resource.has_update_permission():
            name = 'detail'
        else:
            name = self.prototype_method_map.get(method)
        return self.link_prototypes.get(name)

    def get_link_prototypes(self):
        return [
            (self.update_prototype, {'name':'update'}),
            (self.detail_prototype, {'name':'detail'}),
            (self.update_prototype, {'name':'rest-update', 'link_kwargs':{'method':'PUT'}}),
            (self.delete_prototype, {'name':'rest-delete', 'link_kwargs':{'method':'DELETE'}}),
        ]

    def get_item_outbound_links(self, item):
        links = self.create_link_collection()
        links.add_link('delete', item=item, link_factor='LO')
        return links

    def get_breadcrumbs(self):
        breadcrumbs = super(DetailEndpoint, self).get_breadcrumbs()
        breadcrumbs.add_link('detail', item=self.common_state.item, rel='breadcrumb', link_factor='LO')
        return breadcrumbs


class DeleteEndpoint(DetailMixin, ResourceEndpoint):
    endpoint_class = 'delete_confirmation'
    name_suffix = 'delete'
    url_suffix = r'/delete/$'

    prototype_method_map = {
        'GET': 'delete',
        'POST': 'delete',
    }

    delete_prototype = DeleteLinkPrototype

    def get_link_prototypes(self):
        return [
            (self.delete_prototype, {'name':'delete'}),
        ]

    def get_breadcrumbs(self):
        breadcrumbs = super(DeleteEndpoint, self).get_breadcrumbs()
        breadcrumbs.add_link('update', item=self.common_state.item, rel='breadcrumb', link_factor='LO')
        breadcrumbs.add_link('delete', item=self.common_state.item, rel='breadcrumb', link_factor='LO')
        return breadcrumbs

########NEW FILE########
__FILENAME__ = hyperobjects
from django.utils.encoding import force_unicode
from django import forms

from hyperadmin.resources.hyperobjects import ResourceItem


class ListForm(forms.Form):
    '''
    hyperadmin knows how to serialize forms, not models.
    So for the list display we need a form
    '''
    
    def __init__(self, **kwargs):
        self.instance = kwargs.pop('instance', None)
        self.endpoint = kwargs.pop('endpoint')
        self.resource = getattr(self.endpoint, 'resource', self.endpoint)
        super(ListForm, self).__init__(**kwargs)
        if self.resource.list_display:
            for display in self.resource.list_display:
                label = display
                if label == '__str__':
                    label = self.resource.resource_name
                self.fields[display] = forms.CharField(label=label)
                if self.instance:
                    if hasattr(self.instance, display):
                        try:
                            val = getattr(self.instance, display)
                        except:
                            val = ''
                    elif hasattr(self.resource, display):
                        try:
                            val = getattr(self.resource, display)(self.instance)
                        except:
                            val = ''
                    else:
                        val = '' #TODO raise ImproperlyConfigured
                    if callable(val):
                        try:
                            val = val()
                        except:
                            val = ''
                    self.initial[display] = force_unicode(val)
        else:
            pass
            #TODO support all field listing as default

class ListResourceItem(ResourceItem):
    form_class = ListForm
    
    def get_form_kwargs(self, **kwargs):
        kwargs = super(ListResourceItem, self).get_form_kwargs(**kwargs)
        form_kwargs = {'instance':kwargs.get('instance', None),
                       'endpoint':self.endpoint}
        return form_kwargs
    
    def get_ln_links(self):
        return []
    
    def get_idempotent_links(self):
        return []

########NEW FILE########
__FILENAME__ = resources
from django.core.paginator import Paginator

from hyperadmin.indexes import PrimaryIndex
from hyperadmin.resources.resources import BaseResource
from hyperadmin.resources.crud.hyperobjects import ListResourceItem
from hyperadmin.resources.crud.endpoints import ListEndpoint, CreateEndpoint, DetailEndpoint, DeleteEndpoint


class CRUDResource(BaseResource):
    resource_class = 'crudresource'
    
    ordering = None
    list_display = ('__str__',) #TODO should list all field by default
    list_resource_item_class = ListResourceItem
    paginator_class = Paginator
    
    #TODO support the following:
    actions = []
    
    form_class = None
    
    list_endpoint = (ListEndpoint, {})
    create_endpoint = (CreateEndpoint, {})
    detail_endpoint = (DetailEndpoint, {})
    delete_endpoint = (DeleteEndpoint, {})
    
    def get_view_endpoints(self):
        endpoints = super(CRUDResource, self).get_view_endpoints()
        endpoints.extend([
            self.list_endpoint,
            self.create_endpoint,
            self.delete_endpoint,
            self.detail_endpoint,
        ])
        return endpoints
    
    def get_absolute_url(self):
        return self.link_prototypes['list'].get_url()
    
    def get_item_url(self, item):
        if self.has_update_permission(item):
            return self.link_prototypes['update'].get_url(item=item)
        return self.link_prototypes['detail'].get_url(item=item)
    
    def get_item_link(self, item, **kwargs):
        if self.has_update_permission(item):
            return self.link_prototypes['update'].get_link(item=item, **kwargs)
        return self.link_prototypes['detail'].get_link(item=item, **kwargs)
    
    def has_permission(self, perm, **kwargs):
        func_name = 'has_%s_permission' % perm
        if hasattr(self, func_name):
            return getattr(self, func_name)(**kwargs)
        return False
    
    def has_create_permission(self):
        return True
    
    def has_update_permission(self, item=None):
        return True
    
    def has_delete_permission(self, item=None):
        return True
    
    def on_create_success(self, item):
        '''
        Called when an item has been successfully created.
        Fires off the create event.
        May return a link.
        '''
        self.emit_event(event='create', item_list=[item])
        return None
    
    def on_update_success(self, item):
        '''
        Called when an item has been successfully updated.
        Fires off the update event.
        May return a link.
        '''
        self.emit_event(event='update', item_list=[item])
        return None
    
    def on_delete_success(self, item):
        '''
        Called when an item has been successfully deleted.
        Fires off the delete event.
        May return a link.
        '''
        self.emit_event(event='delete', item_list=[item])
        return None
    
    def get_indexes(self):
        return {'primary':PrimaryIndex('primary', self)}
    
    def get_index_query(self, name):
        return self.get_primary_query()
    
    def get_item_breadcrumb(self, item):
        return self.get_item_link(item, rel='breadcrumb', link_factor='LO')
    
    def get_list_resource_item_class(self):
        return self.list_resource_item_class
    
    def get_list_resource_item(self, instance, **kwargs):
        kwargs.setdefault('endpoint', self)
        return self.get_list_resource_item_class()(instance=instance, **kwargs)
    
    def get_instances(self):
        '''
        Returns a set of native objects for a given state
        '''
        if 'page' in self.state:
            return self.state['page'].object_list
        if self.state.has_view_class('change_form'):
            return []
        return self.get_primary_query()
    
    def get_resource_items(self):
        instances = self.get_instances()
        if self.state.has_view_class('change_list'):
            return [self.get_list_resource_item(instance) for instance in instances]
        return [self.get_resource_item(instance) for instance in instances]
    
    def get_primary_query(self, **kwargs):
        return self.resource_adaptor.objects.all()
    
    def get_ordering(self):
        """
        Hook for specifying field ordering.
        """
        return self.ordering or ()  # otherwise we might try to *None, which is bad ;)
    
    def get_paginator_class(self):
        return self.paginator_class
    
    def get_paginator_kwargs(self):
        return {'per_page':getattr(self, 'list_per_page', 50),}
    
    def get_paginator(self, index, **kwargs):
        return self.get_paginator_class()(index, **kwargs)
    
    def get_outbound_links(self):
        links = self.create_link_collection()
        links.add_link('list', link_factor='LO')
        links.add_link('create', link_factor='LO')
        return links
    
    def get_actions(self, request):
        actions = self.site.get_actions(request)
        for func in self.actions:
            if isinstance(func, basestring):
                #TODO register as new func in urls, create link for it
                func = getattr(self, func)
            assert callable(func)
            name = func.__name__
            description = getattr(func, 'short_description', name.replace('_', ' '))
            #sorteddictionary
            actions[name] = (func, name, description)
        return actions
    
    def get_action(self, request, action):
        actions = self.get_actions(request)
        return actions[action]
    
    def __unicode__(self):
        return u'CRUD Resource: %s/%s' % (self.app_name, self.resource_name)
    
    def get_form_kwargs(self, **kwargs):
        '''
        CRUD forms are assumed to operate on the active item.
        This inserts the active instance into the form kwargs.
        '''
        if self.state.item:
            kwargs.setdefault('instance', self.state.item.instance)
        return super(CRUDResource, self).get_form_kwargs(**kwargs)

########NEW FILE########
__FILENAME__ = endpoints
from hyperadmin.links import LinkPrototype
from hyperadmin.resources.endpoints import ResourceEndpoint


class ListLinkPrototype(LinkPrototype):
    def get_link_kwargs(self, **kwargs):
        link_kwargs = {'url':self.get_url(),
                       'resource':self,
                       'prompt':'list',
                       'rel':'list',}
        link_kwargs.update(kwargs)
        return super(ListLinkPrototype, self).get_link_kwargs(**link_kwargs)


class ListEndpoint(ResourceEndpoint):
    endpoint_class = 'index'
    view_class = 'app_index'
    
    prototype_method_map = {
        'GET': 'list',
    }
    
    name_suffix = 'list'
    url_suffix = r'^$'
    
    list_prototype = ListLinkPrototype
    
    def get_link_prototypes(self):
        return [
            (self.list_prototype, {'name':'list'}),
        ]


########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.encoding import force_unicode


class ViewResourceForm(forms.Form):
    display = ['resource_class', 'app_name', 'resource_name']
    
    def __init__(self, **kwargs):
        self.instance = kwargs.pop('instance', None)
        super(ViewResourceForm, self).__init__(**kwargs)
        if self.instance:
            for display in self.display:
                label = display
                self.fields[display] = forms.CharField(label=label)
                if hasattr(self.instance, display):
                    try:
                        val = getattr(self.instance, display)
                    except:
                        val = ''
                else:
                    val = '' #TODO raise ImproperlyConfigured
                if callable(val):
                    try:
                        val = val()
                    except:
                        val = ''
                self.initial[display] = force_unicode(val)
        else:
            pass

########NEW FILE########
__FILENAME__ = resources
from django.conf.urls.defaults import patterns, url, include

from hyperadmin.resources import BaseResource
from hyperadmin.resources.directory.forms import ViewResourceForm
from hyperadmin.resources.directory.endpoints import ListEndpoint


#CONSIDER: is this really an EndpointDirectory?
class ResourceDirectory(BaseResource):
    resource_class = 'resourcelisting'
    form_class = ViewResourceForm
    list_endpoint_class = ListEndpoint
    
    def __init__(self, **kwargs):
        kwargs.setdefault('resource_adaptor', dict())
        
        super(ResourceDirectory, self).__init__(**kwargs)
    
    def get_view_endpoints(self):
        endpoints = super(ResourceDirectory, self).get_view_endpoints()
        endpoints.append((self.list_endpoint_class, {}))
        return endpoints
    
    def get_urls(self):
        urlpatterns = super(ResourceDirectory, self).get_urls()
        for key, resource in self.resource_adaptor.iteritems():
            urlpatterns += patterns('',
                url(r'^%s/' % key, include(resource.urls))
            )
        return urlpatterns
    
    def register_resource(self, resource, key=None):
        if key is None:
            key = resource.get_resource_slug()
        self.resource_adaptor[key] = resource
    
    def fork(self, **kwargs):
        ret = super(ResourceDirectory, self).fork(**kwargs)
        ret.resource_adaptor.update(self.resource_adaptor)
        return ret
    
    def get_instances(self):
        applications = self.resource_adaptor.items()
        apps = [entry[1] for entry in sorted(applications, key=lambda x: x[0])]
        all_apps = list()
        for app in apps:
            app = self.api_request.get_endpoint(app.get_url_name())
            all_apps.append(app)
            if isinstance(app, ResourceDirectory):
                all_apps.extend(app.get_instances())
        return all_apps
    
    def get_item_prompt(self, item):
        return item.instance.get_prompt()
    
    def get_item_url(self, item):
        if hasattr(item.instance, 'get_absolute_url'):
            return item.instance.get_absolute_url()
    
    def get_item_outbound_links(self, item):
        return item.instance.links.get_outbound_links()
    
    def __unicode__(self):
        return u'Resource Directory: %s' % self.get_prompt()

########NEW FILE########
__FILENAME__ = site
from django.conf.urls.defaults import patterns, url, include

from hyperadmin.resources.directory.resources import ResourceDirectory

#gets replaced
class SiteResource(ResourceDirectory):
    resource_class = 'resourcelisting'
    auth_resource = None
    
    @property
    def auth_resource(self):
        return self.site.auth_resource
    
    def get_prompt(self):
        return self._site.name
    
    def get_app_name(self):
        return self._site.name
    app_name = property(get_app_name)
    
    def get_urls(self):
        urlpatterns = super(SiteResource, self).get_urls()
        urlpatterns += patterns('',
            url(r'^-authentication/',
                include(self.auth_resource.urls)),
        )
        return urlpatterns


########NEW FILE########
__FILENAME__ = endpoints
from hyperadmin.endpoints import Endpoint
from hyperadmin.links import LinkCollection


class ResourceEndpoint(Endpoint):
    @property
    def resource(self):
        return self.parent

    def create_link_collection(self):
        return LinkCollection(endpoint=self.resource)

    def get_resource_item(self, instance, **kwargs):
        kwargs.setdefault('endpoint', self)
        return self.resource.get_resource_item(instance, **kwargs)

    def get_instances(self):
        return self.resource.get_instances()

    def get_common_state(self):
        return self.resource.state
    common_state = property(get_common_state)

    def get_resource_link(self, **kwargs):
        return self.resource.get_link(**kwargs)

    def get_item_url(self, item):
        return self.resource.get_item_url(item)

    def get_item_prompt(self, item):
        return self.resource.get_item_prompt(item)

    def get_form_class(self):
        return self.form_class or self.resource.get_form_class()

    def get_form_kwargs(self, **kwargs):
        return self.resource.get_form_kwargs(**kwargs)

    def get_item_form_class(self):
        return self.item_form_class or self.resource.get_item_form_class()

    def get_item_form_kwargs(self, **kwargs):
        return self.resource.get_item_form_kwargs(**kwargs)

    def get_namespaces(self):
        return self.resource.get_namespaces()

    def get_item_namespaces(self, item):
        return self.resource.get_item_namespaces(item=item)

    def get_item_link(self, item):
        return self.resource.get_item_link(item=item)

    def get_breadcrumbs(self):
        breadcrumbs = self.resource.get_breadcrumbs()
        breadcrumbs.endpoint = self
        return breadcrumbs

    def api_permission_check(self, api_request, endpoint):
        return self.resource.api_permission_check(api_request, endpoint)

    def create_apirequest(self, **kwargs):
        return self.resource.create_apirequest(**kwargs)

    def expand_template_names(self, suffixes):
        return self.resource.expand_template_names(suffixes)

    def get_context_data(self, **kwargs):
        return self.resource.get_context_data(**kwargs)

    def get_datatap(self, **kwargs):
        return self.resource.get_datatap(**kwargs)

########NEW FILE########
__FILENAME__ = hyperobjects
from hyperadmin.hyperobjects import Item


class ResourceItem(Item):
    @property
    def resource(self):
        return getattr(self.endpoint, 'resource', self.endpoint)


########NEW FILE########
__FILENAME__ = autoload
'''
Maps django model admin entries to model resources.

Usage::

    from hyperadmin.resources.models.autload import DjangoCTModelAdminLoader
    from django.contrib.admin import site as admin_site
    from hyperadmin import site as root_endpoint
    
    loader = DjangoCTModelAdminLoader(root_endpoint, admin_site)
    loader.register_resources()

'''
from django.conf import settings
from django.db import models


class DjangoModelAdminLoader(object):
    '''
    A helper class that maps admin entries from a 
    `django.contrib.admin.site.AdminSite` object to a `RootEndpoint`
    '''
    def __init__(self, root_endpoint, admin_site):
        self.root_endpoint = root_endpoint
        self.admin_site = admin_site
    
    def get_logger(self):
        return self.root_endpoint.get_logger()
    
    def register_resources(self):
        for model, admin_model in self.admin_site._registry.iteritems():
            if not issubclass(model, models.Model):
                continue
            if model in self.root_endpoint.registry:
                continue
            resource_class = self.generate_resource(admin_model)
            try:
                app_name = model._meta.app_label
                resource = self.root_endpoint.register(model, resource_class, app_name=app_name)
                self.register_inlines(admin_model, resource)
            except Exception as error:
                self.get_logger().exception('Could not autoload: %s' % admin_model)
    
    def generate_resource(self, admin_model):
        '''
        When supplied a subclass of `ModelAdmin`
        Returns a ModelResource class with the following options mapped:
        
        * fields
        * fieldsets (flattened to provided fields)
        * exclude
        * paginator
        * list_display
        * list_filter
        * list_select_related (not used)
        * list_per_page
        * list_max_show_all (not used)
        * list_editable (not used)
        * search_fields
        * date_hierarchy (not used)
        * ordering (not used)
        * form_class
        '''
        from django.contrib.admin import ModelAdmin
        if not isinstance(admin_model, ModelAdmin):
            return
        
        from hyperadmin.resources.models import ModelResource
        from django import forms
        if admin_model.fieldsets:
            mfields = list()
            for section, params in admin_model.fieldsets:
                mfields.extend(params['fields'])
        else:
            mfields = admin_model.fields
        class GeneratedModelResource(ModelResource):
            #raw_id_fields = ()
            fields = mfields
            exclude = admin_model.exclude
            #fieldsets = None
            #filter_vertical = ()
            #filter_horizontal = ()
            #radio_fields = {}
            #prepopulated_fields = {}
            #formfield_overrides = {}
            #readonly_fields = ()
            #declared_fieldsets = None
            
            #save_as = False
            #save_on_top = False
            paginator = admin_model.paginator
            inlines = list()
            
            #list display options
            list_display = list(admin_model.list_display)
            #list_display_links = ()
            list_filter = admin_model.list_filter
            list_select_related = admin_model.list_select_related
            list_per_page = admin_model.list_per_page
            list_max_show_all = getattr(admin_model, 'list_max_show_all', 200)
            list_editable = admin_model.list_editable
            search_fields = admin_model.search_fields
            date_hierarchy = admin_model.date_hierarchy
            ordering = admin_model.ordering
            form_class = getattr(admin_model, 'form_class', None)
        
        if 'action_checkbox' in GeneratedModelResource.list_display:
            GeneratedModelResource.list_display.remove('action_checkbox')
        
        if admin_model.form != forms.ModelForm:
            GeneratedModelResource.form_class = admin_model.form
        
        return GeneratedModelResource
    
    def register_inlines(self, admin_model, resource):
        for inline_cls in admin_model.inlines:
            self.register_inline(admin_model, resource, inline_cls)
    
    def register_inline(self, admin_model, resource, inline_cls):
        inline_resource = self.generate_inline(inline_cls)
        if inline_resource:
            try:
                resource.register_inline(inline_resource)
            except:
                self.get_logger().exception('Could not autoload inline: %s' % inline_cls)
            else:
                resource.inlines.append(inline_resource)
                return inline_resource
    
    def generate_inline(self, inline_cls):
        '''
        When supplied a subclass of `InlineModelAdmin`
        Returns an InlineModelResource with the following options mapped:
        
        * model
        * fields
        * exclude
        * fk_name
        '''
        from django.contrib.admin.options import InlineModelAdmin
        
        if not issubclass(inline_cls, InlineModelAdmin):
            return None
        
        from hyperadmin.resources.models import InlineModelResource
        
        class GeneratedInlineModelResource(InlineModelResource):
            model = inline_cls.model
            fields = inline_cls.fields
            exclude = inline_cls.exclude
            fk_name = inline_cls.fk_name
        
        return GeneratedInlineModelResource

class DjangoCTModelAdminLoader(DjangoModelAdminLoader):
    '''
    Extends `DjangoModelAdminLoader` to provide support for autloading 
    generic inlines
    '''
    def generate_inline(self, inline_cls):
        '''
        When supplied a subclass of `GenericInlineModelAdmin`
        Returns a GenericInlineModelResource with the following options mapped:
        
        * model
        * fields
        * exclude
        * ct_field
        * ct_fk_field
        '''
        from django.contrib.contenttypes.generic import GenericInlineModelAdmin
        
        if not issubclass(inline_cls, GenericInlineModelAdmin):
            return super(DjangoCTModelAdminLoader, self).generate_inline(inline_cls)
        
        from hyperadmin.resources.models.generic import GenericInlineModelResource
        
        class GeneratedInlineModelResource(GenericInlineModelResource):
            model = inline_cls.model
            fields = inline_cls.fields
            exclude = inline_cls.exclude
            ct_field = inline_cls.ct_field
            ct_fk_field = inline_cls.ct_fk_field
            formset = inline_cls.formset #TODO is this used?
        
        return GeneratedInlineModelResource

DEFAULT_LOADER = DjangoModelAdminLoader

if 'django.contrib.contenttypes' in settings.INSTALLED_APPS:
    DEFAULT_LOADER = DjangoCTModelAdminLoader

########NEW FILE########
__FILENAME__ = endpoints
from hyperadmin.resources.crud.endpoints import ListEndpoint, CreateEndpoint, DetailMixin, DetailEndpoint, DeleteEndpoint


class InlineModelMixin(object):
    parent_index_name = 'primary'
    parent_url_param_map = {}
    
    def get_parent_index(self):
        if not self.api_request:
            return self.resource.parent.get_index(self.parent_index_name)
        if 'parent_index' not in self.state:
            self.state['parent_index'] = self.resource.parent.get_index(self.parent_index_name)
            self.state['parent_index'].populate_state()
        return self.state['parent_index']
    
    def get_parent_url_param_map(self):
        return dict(self.parent_url_param_map)
    
    def get_url_suffix_parts(self):
        param_map = self.get_parent_url_param_map()
        parts = self.get_parent_index().get_url_params(param_map)
        parts.append(self.resource.rel_name)
        return parts
    
    def get_url_suffix(self):
        #CONSIDER: the parent endpoint is both a resource and a detail endpoint of another resource
        #if we roll the url then we should lookup the details from the parent endpoint/resource
        parts = self.get_url_suffix_parts()
        url_suffix = '/'.join(parts)
        url_suffix = '^%s%s' % (url_suffix, self.url_suffix)
        return url_suffix
    
    def get_common_state_data(self):
        self.common_state['parent'] = self.get_parent_item()
        return super(InlineModelMixin, self).get_common_state_data()
    
    def get_parent_instance(self):
        if 'parent' in self.state:
            return self.state['parent'].instance
        assert 'parent' not in self.common_state, 'state must inherit from common_state: %r\n%r' % (self.state, self.common_state)
        return self.get_parent_index().get(pk=self.kwargs['pk'])
    
    def get_parent_item(self):
        return self.resource.parent.get_resource_item(self.get_parent_instance())
    
    def get_url_params_from_parent(self, item):
        param_map = self.get_parent_url_param_map()
        return self.get_parent_index().get_url_params_from_item(item, param_map)
    
    def get_url(self):
        item = self.get_parent_item()
        params = self.get_url_params_from_parent(item)
        return self.reverse(self.get_url_name(), **params)

class InlineDetailMixin(InlineModelMixin, DetailMixin):
    url_param_map = {'pk':'inline_pk'}
    
    #TODO get_item includes parent in resource item
    #TODO inline index
    
    def get_url_suffix_parts(self):
        parts = InlineModelMixin.get_url_suffix_parts(self)
        param_map = self.get_url_param_map()
        parts.extend(self.get_index().get_url_params(param_map))
        return parts
    
    def get_url(self, item):
        parent_item = self.get_parent_item()
        params = self.get_url_params_from_parent(parent_item)
        params.update(self.get_url_params_from_item(item))
        return self.reverse(self.get_url_name(), **params)

class InlineListEndpoint(InlineModelMixin, ListEndpoint):
    url_suffix = r'/$'

class InlineCreateEndpoint(InlineModelMixin, CreateEndpoint):
    url_suffix = r'/add/$'

class InlineDetailEndpoint(InlineDetailMixin, DetailEndpoint):
    pass

class InlineDeleteEndpoint(InlineDetailMixin, DeleteEndpoint):
    pass


########NEW FILE########
__FILENAME__ = filters
import datetime
import operator

from django.db import models
from django.utils.encoding import smart_unicode
from django.utils.translation import ugettext_lazy as _
try:
    from django.utils import timezone
except ImportError:
    import pytz as timezone
from django.contrib.admin.util import (get_model_from_relation,
    reverse_field_path, get_limit_choices_to_from_path, )
try:
    from django.contrib.admin.util import lookup_needs_distinct, prepare_lookup_value
except ImportError:
    from hyperadmin.resources.models.util import lookup_needs_distinct, prepare_lookup_value

from hyperadmin.filters import BaseChoicesFilter, BaseFilter

SEARCH_VAR = 'q'

class SearchFilter(BaseFilter):
    title = _('Search')
    
    def __init__(self, index, search_fields):
        super(SearchFilter, self).__init__(index)
        self.search_fields = search_fields
    
    def value(self):
        return self.state.params.get(SEARCH_VAR, '')
    
    def is_active(self):
        return bool(self.value())
    
    def filter_index(self, active_index):
        use_distinct = False
        query = self.value()
        
        def construct_search(field_name):
            if field_name.startswith('^'):
                return "%s__istartswith" % field_name[1:]
            elif field_name.startswith('='):
                return "%s__iexact" % field_name[1:]
            elif field_name.startswith('@'):
                return "%s__search" % field_name[1:]
            else:
                return "%s__icontains" % field_name

        if self.search_fields and query:
            orm_lookups = [construct_search(str(search_field))
                           for search_field in self.search_fields]
            for bit in query.split():
                or_queries = [models.Q(**{orm_lookup: bit})
                              for orm_lookup in orm_lookups]
                active_index = active_index.filter(reduce(operator.or_, or_queries))
            if not use_distinct:
                for search_spec in orm_lookups:
                    if lookup_needs_distinct(self.resource.opts, search_spec):
                        use_distinct = True
                        break
        if use_distinct:
            return active_index.distinct()
        return active_index

class FieldFilter(BaseChoicesFilter):
    _field_list_filters = []
    _take_priority_index = 0

    def __init__(self, field, field_path, index):
        self.field = field
        self.field_path = field_path
        self.title = getattr(field, 'verbose_name', field_path)
        self.used_parameters = dict()
        super(FieldFilter, self).__init__(index)

    def is_active(self):
        return bool(self.used_parameters)
    
    def populate_state(self):
        params = self.state.params.copy()
        self.used_parameters = dict()
        for p in self.expected_parameters():
            if p in params:
                value = params[p]
                self.used_parameters[p] = prepare_lookup_value(p, value)

    def filter_index(self, active_index):
        return active_index.filter(**self.used_parameters)
    
    @classmethod
    def register(cls, test, list_filter_class, take_priority=False):
        if take_priority:
            # This is to allow overriding the default filters for certain types
            # of fields with some custom filters. The first found in the list
            # is used in priority.
            cls._field_list_filters.insert(
                cls._take_priority_index, (test, list_filter_class))
            cls._take_priority_index += 1
        else:
            cls._field_list_filters.append((test, list_filter_class))

    @classmethod
    def create(cls, field, field_path, index):
        for test, list_filter_class in cls._field_list_filters:
            if not test(field):
                continue
            return list_filter_class(field, field_path, index)


class RelatedFieldFilter(FieldFilter):
    def __init__(self, field, field_path, index):
        other_model = get_model_from_relation(field)
        rel_name = other_model._meta.pk.name
        self.lookup_kwarg = '%s__%s__exact' % (field_path, rel_name)
        self.lookup_kwarg_isnull = '%s__isnull' % field_path
        self.lookup_choices = field.get_choices(include_blank=False)
        super(RelatedFieldFilter, self).__init__(
            field, field_path, index)
        if hasattr(field, 'verbose_name'):
            self.lookup_title = field.verbose_name
        else:
            self.lookup_title = other_model._meta.verbose_name
        self.title = self.lookup_title

    def has_output(self):
        if (isinstance(self.field, models.related.RelatedObject)
                and self.field.field.null or hasattr(self.field, 'rel')
                    and self.field.null):
            extra = 1
        else:
            extra = 0
        return len(self.lookup_choices) + extra > 1
    
    def is_active(self):
        if not self.has_output():
            return False
        return super(RelatedFieldFilter, self).is_active()

    def expected_parameters(self):
        return [self.lookup_kwarg, self.lookup_kwarg_isnull]
    
    def choices(self):
        from django.contrib.admin.views.main import EMPTY_CHANGELIST_VALUE
        lookup_val, lookup_val_isnull = self.values()
        yield {
            'selected': lookup_val is None and not lookup_val_isnull,
            'query_string': self.state.get_query_string({},
                [self.lookup_kwarg, self.lookup_kwarg_isnull]),
            'display': _('All'),
        }
        for pk_val, val in self.lookup_choices:
            yield {
                'selected': lookup_val == smart_unicode(pk_val),
                'query_string': self.state.get_query_string({
                    self.lookup_kwarg: pk_val,
                }, [self.lookup_kwarg_isnull]),
                'display': val,
            }
        if (isinstance(self.field, models.related.RelatedObject)
                and self.field.field.null or hasattr(self.field, 'rel')
                    and self.field.null):
            yield {
                'selected': bool(lookup_val_isnull),
                'query_string': self.state.get_query_string({
                    self.lookup_kwarg_isnull: 'True',
                }, [self.lookup_kwarg]),
                'display': EMPTY_CHANGELIST_VALUE,
            }

FieldFilter.register(lambda f: (
        hasattr(f, 'rel') and bool(f.rel) or
        isinstance(f, models.related.RelatedObject)), RelatedFieldFilter)


class BooleanFieldFilter(FieldFilter):
    def __init__(self, field, field_path, index):
        self.lookup_kwarg = '%s__exact' % field_path
        self.lookup_kwarg2 = '%s__isnull' % field_path
        super(BooleanFieldFilter, self).__init__(field, field_path, index)

    def expected_parameters(self):
        return [self.lookup_kwarg, self.lookup_kwarg2]

    def choices(self):
        lookup_val, lookup_val2 = self.values()
        for lookup, title in (
                (None, _('All')),
                ('1', _('Yes')),
                ('0', _('No'))):
            yield {
                'selected': lookup_val == lookup and not lookup_val2,
                'query_string': self.state.get_query_string({
                        self.lookup_kwarg: lookup,
                    }, [self.lookup_kwarg2]),
                'display': title,
            }
        if isinstance(self.field, models.NullBooleanField):
            yield {
                'selected': lookup_val2 == 'True',
                'query_string': self.state.get_query_string({
                        self.lookup_kwarg2: 'True',
                    }, [self.lookup_kwarg]),
                'display': _('Unknown'),
            }

FieldFilter.register(lambda f: isinstance(f,
    (models.BooleanField, models.NullBooleanField)), BooleanFieldFilter)


class ChoicesFieldFilter(FieldFilter):
    def __init__(self, field, field_path, index):
        self.lookup_kwarg = '%s__exact' % field_path
        super(ChoicesFieldFilter, self).__init__(
            field, field_path, index)

    def expected_parameters(self):
        return [self.lookup_kwarg]

    def choices(self):
        lookup_val = self.values()[0]
        yield {
            'selected': lookup_val is None,
            'query_string': self.state.get_query_string({}, [self.lookup_kwarg]),
            'display': _('All')
        }
        for lookup, title in self.field.flatchoices:
            yield {
                'selected': smart_unicode(lookup) == lookup_val,
                'query_string': self.state.get_query_string({
                                    self.lookup_kwarg: lookup}),
                'display': title,
            }

FieldFilter.register(lambda f: bool(f.choices), ChoicesFieldFilter)


class DateFieldFilter(FieldFilter):
    def __init__(self, field, field_path, index):
        now = datetime.datetime.now()
        # When time zone support is enabled, convert "now" to the user's time
        # zone so Django's definition of "Today" matches what the user expects.
        #if now.tzinfo is not None:
        #    current_tz = timezone.get_current_timezone()
        #    now = now.astimezone(current_tz)
        #    if hasattr(current_tz, 'normalize'):
        #        # available for pytz time zones
        #        now = current_tz.normalize(now)

        if isinstance(field, models.DateTimeField):
            today = now.replace(hour=0, minute=0, second=0, microsecond=0)
        else:       # field is a models.DateField
            today = now.date()
        tomorrow = today + datetime.timedelta(days=1)
    
        self.lookup_kwarg_since = '%s__gte' % field_path
        self.lookup_kwarg_until = '%s__lt' % field_path
        self.links = (
            (_('Any date'), {}),
            (_('Today'), {
                self.lookup_kwarg_since: str(today),
                self.lookup_kwarg_until: str(tomorrow),
            }),
            (_('Past 7 days'), {
                self.lookup_kwarg_since: str(today - datetime.timedelta(days=7)),
                self.lookup_kwarg_until: str(tomorrow),
            }),
            (_('This month'), {
                self.lookup_kwarg_since: str(today.replace(day=1)),
                self.lookup_kwarg_until: str(tomorrow),
            }),
            (_('This year'), {
                self.lookup_kwarg_since: str(today.replace(month=1, day=1)),
                self.lookup_kwarg_until: str(tomorrow),
            }),
        )
        super(DateFieldFilter, self).__init__(
            field, field_path, index)
    
    def populate_state(self):
        params = self.state.params
        self.field_generic = '%s__' % self.field_path
        self.date_params = dict([(k, v) for k, v in params.items()
                                 if k.startswith(self.field_generic)])
        self.used_parameters = self.date_params

    def expected_parameters(self):
        return [self.lookup_kwarg_since, self.lookup_kwarg_until]

    def choices(self):
        for title, param_dict in self.links:
            yield {
                'selected': self.date_params == param_dict,
                'query_string': self.state.get_query_string(
                                    param_dict, [self.field_generic]),
                'display': title,
            }

FieldFilter.register(
    lambda f: isinstance(f, models.DateField), DateFieldFilter)


# This should be registered last, because it's a last resort. For example,
# if a field is eligible to use the BooleanFieldFilter, that'd be much
# more appropriate, and the AllValuesFieldFilter won't get used for it.
class AllValuesFieldFilter(FieldFilter):
    def __init__(self, field, field_path, index):
        super(AllValuesFieldFilter, self).__init__(
            field, field_path, index)
        
        model = self.resource.model
        
        self.lookup_kwarg = field_path
        self.lookup_kwarg_isnull = '%s__isnull' % field_path
        parent_model, reverse_path = reverse_field_path(model, field_path)
        queryset = parent_model._default_manager.all()
        # optional feature: limit choices base on existing relationships
        # queryset = queryset.complex_filter(
        #    {'%s__isnull' % reverse_path: False})
        limit_choices_to = get_limit_choices_to_from_path(model, field_path)
        queryset = queryset.filter(limit_choices_to)

        self.lookup_choices = (queryset
                               .distinct()
                               .order_by(field.name)
                               .values_list(field.name, flat=True))
        

    def expected_parameters(self):
        return [self.lookup_kwarg, self.lookup_kwarg_isnull]

    def choices(self):
        lookup_val, lookup_val_isnull = self.values()
        from django.contrib.admin.views.main import EMPTY_CHANGELIST_VALUE
        yield {
            'selected': (lookup_val is None
                and lookup_val_isnull is None),
            'query_string': self.state.get_query_string({},
                [self.lookup_kwarg, self.lookup_kwarg_isnull]),
            'display': _('All'),
        }
        include_none = False
        for val in self.lookup_choices:
            if val is None:
                include_none = True
                continue
            val = smart_unicode(val)
            yield {
                'selected': lookup_val == val,
                'query_string': self.state.get_query_string({
                    self.lookup_kwarg: val,
                }, [self.lookup_kwarg_isnull]),
                'display': val,
            }
        if include_none:
            yield {
                'selected': bool(lookup_val_isnull),
                'query_string': self.state.get_query_string({
                    self.lookup_kwarg_isnull: 'True',
                }, [self.lookup_kwarg]),
                'display': EMPTY_CHANGELIST_VALUE,
            }

FieldFilter.register(lambda f: True, AllValuesFieldFilter)

########NEW FILE########
__FILENAME__ = generic
from django.contrib.contenttypes.models import ContentType
from django import forms

from hyperadmin.resources.models.resources import InlineModelResource


class GenericInlineModelResource(InlineModelResource):
    model = None
    ct_field = "content_type"
    ct_fk_field = "object_id"
    
    def post_register(self):
        self._ct_field = self.opts.get_field(self.ct_field)
        self._ct_fk_field = self.opts.get_field(self.ct_fk_field)
        if self.rel_name is None:
            self.rel_name = '-'.join((
                self.opts.app_label, self.opts.object_name.lower(),
                self.ct_field, self.ct_fk_field,
            ))
        super(InlineModelResource, self).post_register()
    
    @property
    def content_type(self):
        return ContentType.objects.get_for_model(self.model)
    
    def get_queryset(self, parent):
        queryset = self.resource_adaptor.objects.all()
        
        queryset = queryset.filter(**{
            self.ct_field: self.content_type,
            self.ct_fk_field: parent.pk,
        })
        
        if not self.has_create_permission():
            queryset = queryset.none()
        return queryset
    
    def get_primary_query(self, **kwargs):
        return self.get_queryset(parent=self.state['parent'].instance)
    
    def get_form_class(self):
        if self.form_class:
            return self.form_class
        
        resource = self
        
        class AdminForm(forms.ModelForm):
            state = self.state
            
            def save(self, commit=True):
                instance = super(AdminForm, self).save(commit=False)
                
                setattr(instance, resource._ct_field.get_attname(), resource.content_type.pk)
                setattr(instance, resource._ct_fk_field.get_attname(), self.state['parent'].instance.pk)
                if commit:
                    instance.save()
                return instance
            
            class Meta:
                model = self.model
                exclude = self.get_exclude() + [self.ct_field, self.ct_fk_field]
                #TODO formfield overides
                #TODO fields
        return AdminForm

########NEW FILE########
__FILENAME__ = indexes
from hyperadmin.indexes import Index


class ModelIndex(Index):
    @property
    def model(self):
        return self.resource.model
    
    def get_primary_field(self):
        return self.model._meta.pk
    
    def get_url_params(self, param_map={}):
        """
        returns url parts for use in the url regexp for conducting item lookups
        """
        #TODO support non integer lookups
        param_map.setdefault('pk', 'pk')
        field = self.get_primary_field()
        from django.db import models
        if isinstance(field, (models.IntegerField, models.AutoField)):
            #TODO detect if positive integers only
            return [r'(?P<{pk}>(-){{0,1}}\d+)'.format(**param_map)]
        return [r'(?P<{pk}>[\w\d\-]+)'.format(**param_map)]
    
    def get_paginator_kwargs(self):
        return {'per_page':self.resource.list_per_page,}
    
    def get_links(self):
        links = super(ModelIndex, self).get_links()
        #links += self.getchangelist_sort_links()
        return links
    
    def get_changelist_sort_links(self):
        links = list()
        changelist = self.state['changelist']
        from django.contrib.admin.templatetags.admin_list import result_headers
        for header in result_headers(changelist):
            if header.get("sortable", False):
                prompt = unicode(header["text"])
                classes = ["sortby"]
                if "url" in header:
                    links.append(self.get_link(url=header["url"], prompt=prompt, classes=classes+["primary"], rel="sortby"))
                else:
                    if header["ascending"]:
                        classes.append("ascending")
                    if header["sorted"]:
                        classes.append("sorted")
                    links.append(self.get_link(url=header["url_primary"], prompt=prompt, classes=classes+["primary"], rel="sortby"))
                    links.append(self.get_link(url=header["url_remove"], prompt=prompt, classes=classes+["remove"], rel="sortby"))
                    links.append(self.get_link(url=header["url_toggle"], prompt=prompt, classes=classes+["toggle"], rel="sortby"))
        return links

class InlineIndex(Index):
    def get(self, **kwargs):
        return self.get_index_query().get(pk=kwargs['inline_pk'])

########NEW FILE########
__FILENAME__ = resources
from django.conf.urls.defaults import patterns, url, include
from django import forms

from hyperadmin.apirequests import Namespace
from hyperadmin.resources.crud import CRUDResource
from hyperadmin.resources.models.indexes import ModelIndex, InlineIndex
from hyperadmin.resources.models.endpoints import ListEndpoint, CreateEndpoint, DetailEndpoint, DeleteEndpoint
from hyperadmin.resources.models.endpoints import InlineListEndpoint, InlineCreateEndpoint, InlineDetailEndpoint, InlineDeleteEndpoint


class BaseModelResource(CRUDResource):
    #TODO support the following:
    #raw_id_fields = ()
    fields = None
    exclude = []
    #fieldsets = None
    #filter_vertical = ()
    #filter_horizontal = ()
    #radio_fields = {}
    #prepopulated_fields = {}
    formfield_overrides = {}
    #readonly_fields = ()
    #declared_fieldsets = None
    
    #save_as = False
    #save_on_top = False
    #changelist_class = ModelChangeList
    inlines = []
    
    #list display options
    list_display_links = ()
    list_filter = ()
    list_select_related = False
    list_per_page = 100
    list_max_show_all = 200
    list_editable = ()
    search_fields = ()
    date_hierarchy = None
    
    @property
    def opts(self):
        return self.resource_adaptor._meta
    
    def get_app_name(self):
        return self.opts.app_label
    
    def get_resource_name(self):
        return self.opts.module_name
    
    def get_primary_query(self, **kwargs):
        return self.get_queryset()
    
    def get_indexes(self):
        #from hyperadmin.resources.indexes import Index
        from hyperadmin.resources.models.filters import FieldFilter, SearchFilter

        from django.db import models
        from django.contrib.admin.util import get_fields_from_path
        try:
            from django.contrib.admin.util import lookup_needs_distinct
        except ImportError:
            from hyperadmin.resources.models.util import lookup_needs_distinct
        
        indexes = {'primary': ModelIndex('primary', self)}
        
        index = ModelIndex('filter', self)
        indexes['filter'] = index
        
        if self.list_filter:
            for list_filter in self.list_filter:
                use_distinct = False
                if callable(list_filter):
                    # This is simply a custom list filter class.
                    spec = list_filter(index=index)
                else:
                    field_path = None
                    if isinstance(list_filter, (tuple, list)):
                        # This is a custom FieldListFilter class for a given field.
                        field, field_list_filter_class = list_filter
                    else:
                        # This is simply a field name, so use the default
                        # FieldListFilter class that has been registered for
                        # the type of the given field.
                        field, field_list_filter_class = list_filter, FieldFilter.create
                    if not isinstance(field, models.Field):
                        field_path = field
                        field = get_fields_from_path(self.model, field_path)[-1]
                    spec = field_list_filter_class(field, field_path=field_path, index=index)
                    # Check if we need to use distinct()
                    use_distinct = (use_distinct or
                                    lookup_needs_distinct(self.opts,
                                                          field_path))
                if spec:
                    index.filters.append(spec)
        
        if self.search_fields:
            index.register_filter(SearchFilter, search_fields=self.search_fields)
        '''
        date_section = self.register_section('date', FilterSection)
        if self.date_hierarchy:
            pass
        '''
        return indexes
    
    def lookup_allowed(self, lookup, value):
        '''Currently unused'''
        return True #TODO
    
    def get_queryset(self):
        queryset = self.resource_adaptor.objects.all()
        if not self.has_update_permission(): #TODO has_list_permission?
            queryset = queryset.none()
        return queryset
    
    def has_create_permission(self):
        user = self.api_request.user
        if self.opts.auto_created:
            # We're checking the rights to an auto-created intermediate model,
            # which doesn't have its own individual permissions. The user needs
            # to have the change permission for the related model in order to
            # be able to do anything with the intermediate model.
            return self.has_update_permission()
        return user.has_perm(
            self.opts.app_label + '.' + self.opts.get_add_permission())

    def has_update_permission(self, item=None):
        user = self.api_request.user
        
        if item:
            obj = item.instance
        else:
            obj = None
        opts = self.opts
        if opts.auto_created and hasattr(self, 'parent_model'):
            # The model was auto-created as intermediary for a
            # ManyToMany-relationship, find the target model
            for field in opts.fields:
                if field.rel and field.rel.to != self.parent_model:
                    opts = field.rel.to._meta
                    break
        return user.has_perm(
            opts.app_label + '.' + opts.get_change_permission(), obj)

    def has_delete_permission(self, item=None):
        user = self.api_request.user
        #obj = item.instance
        if self.opts.auto_created:
            # We're checking the rights to an auto-created intermediate model,
            # which doesn't have its own individual permissions. The user needs
            # to have the change permission for the related model in order to
            # be able to do anything with the intermediate model.
            return self.has_update_permission(item)
        return user.has_perm(
            self.opts.app_label + '.' + self.opts.get_delete_permission())
        
    def get_exclude(self):
        return self.exclude or []
    
    def get_form_class(self):
        if self.form_class:
            return self.form_class
        class AdminForm(forms.ModelForm):
            class Meta:
                model = self.model
                exclude = self.get_exclude()
                #TODO formfield overides
                #TODO fields
        return AdminForm
    
    def get_native_datatap_instream_from_items(self, items):
        '''
        Makes an instream of model instances
        '''
        return [item.instance for item in items]
    
    def get_native_datatap(self, instream=None, **kwargs):
        '''
        Returns a ModelDataTap suited for this resource
        '''
        from datatap.datataps import ModelDataTap
        if instream is None:
            instream = [self.resource_adaptor]
        return ModelDataTap(instream, **kwargs)

class ModelResource(BaseModelResource):
    list_endpoint = (ListEndpoint, {'index_name':'filter'})
    create_endpoint = (CreateEndpoint, {})
    detail_endpoint = (DetailEndpoint, {})
    delete_endpoint = (DeleteEndpoint, {})
    
    def post_register(self):
        super(ModelResource, self).post_register()
        self.initialize_inlines()
    
    @property
    def model(self):
        return self.resource_adaptor
    
    def initialize_inlines(self):
        self.inline_instances = list()
        for inline_cls in self.inlines:
            self.register_inline(inline_cls)
    
    def register_inline(self, inline_cls):
        self.inline_instances.append(inline_cls(parent=self, api_request=self.api_request))
    
    def get_urls(self):
        urlpatterns = super(ModelResource, self).get_urls()
        for inline in self.inline_instances:
            urlpatterns += patterns('',
                url('', include(inline.urls))
            )
        return urlpatterns
    
    def get_item_namespaces(self, item):
        assert self.api_request
        namespaces = super(ModelResource, self).get_item_namespaces(item)
        for inline in self.inline_instances:
            #new api request, perhaps wrap in namespace?
            name = 'inline-%s' % inline.rel_name
            
            assert inline.api_request
            
            namespace = Namespace(name=name, endpoint=inline, state_data={'parent':item})
            assert 'parent' in namespace.endpoint.state
            namespace.link
            namespaces[name] = namespace
        return namespaces

class InlineModelResource(BaseModelResource):
    model = None
    fk_name = None
    rel_name = None
    
    list_endpoint = (InlineListEndpoint, {})
    create_endpoint = (InlineCreateEndpoint, {})
    detail_endpoint = (InlineDetailEndpoint, {})
    delete_endpoint = (InlineDeleteEndpoint, {})
    
    def __init__(self, parent, **kwargs):
        kwargs['site'] = parent.site
        kwargs['resource_adaptor'] = self.model
        kwargs['parent'] = parent
        super(InlineModelResource, self).__init__(**kwargs)
    
    def post_register(self):
        from django.db.models.fields.related import RelatedObject
        from django.forms.models import _get_foreign_key
        self.fk = _get_foreign_key(self._parent.resource_adaptor, self.model, self.fk_name)
        if self.rel_name is None:
            #TODO invert this
            self.rel_name = RelatedObject(self.fk.rel.to, self.model, self.fk).get_accessor_name()
        super(InlineModelResource, self).post_register()
    
    def get_queryset(self, parent):
        queryset = self.resource_adaptor.objects.all()
        queryset = queryset.filter(**{self.fk.name:parent})
        if not self.has_update_permission():
            queryset = queryset.none()
        return queryset
    
    def get_primary_query(self, **kwargs):
        return self.get_queryset(parent=self.state['parent'].instance)
    
    def get_indexes(self):
        return {'primary':InlineIndex('primary', self)}
    
    def get_base_url_name_suffix(self):
        assert self.rel_name is not None
        return self.rel_name
    
    def get_item_url(self, item):
        return self.link_prototypes['update'].get_url(item=item)
    
    def get_absolute_url(self):
        return self.link_prototypes['list'].get_url()
    
    def get_breadcrumbs(self):
        breadcrumbs = self.parent.get_breadcrumbs()
        parent_item = self.state['parent']
        breadcrumbs.append(self.parent.get_item_breadcrumb(parent_item))
        breadcrumbs.append(self.get_breadcrumb())
        if self.state.item:
            breadcrumbs.append(self.get_item_breadcrumb(self.state.item))
        return breadcrumbs
    
    def get_form_class(self):
        if self.form_class:
            return self.form_class
        
        resource = self
        
        class AdminForm(forms.ModelForm):
            state = self.state
            
            def save(self, commit=True):
                instance = super(AdminForm, self).save(commit=False)
                setattr(instance, resource.fk.name, self.state['parent'].instance)
                if commit:
                    instance.save()
                return instance
            
            class Meta:
                model = self.model
                exclude = self.get_exclude() + [self.fk.name]
                #TODO formfield overides
                #TODO fields
        return AdminForm
    
    def get_ln_links(self):
        links = self.create_link_collection()
        if self.state.namespace:
            for item in self.get_resource_items():
                links.append(self.link_prototypes['update'].get_link(item=item))
        return links
    
    def get_idempotent_links(self):
        links = self.create_link_collection()
        if self.state.namespace:
            for item in self.get_resource_items():
                links.append(self.link_prototypes['delete'].get_link(item=item))
        return links


########NEW FILE########
__FILENAME__ = util
from django.db import models

#helper functions backported from django 1.4

def lookup_needs_distinct(opts, lookup_path):
    """
    Returns True if 'distinct()' should be used to query the given lookup path.
    """
    field_name = lookup_path.split('__', 1)[0]
    field = opts.get_field_by_name(field_name)[0]
    if ((hasattr(field, 'rel') and
         isinstance(field.rel, models.ManyToManyRel)) or
        (isinstance(field, models.related.RelatedObject) and
         not field.field.unique)):
         return True
    return False

def prepare_lookup_value(key, value):
    """
    Returns a lookup value prepared to be used in queryset filtering.
    """
    # if key ends with __in, split parameter into separate values
    if key.endswith('__in'):
        value = value.split(',')
    # if key ends with __isnull, special case '' and false
    if key.endswith('__isnull'):
        if value.lower() in ('', 'false'):
            value = False
        else:
            value = True
    return value


########NEW FILE########
__FILENAME__ = resources
from django import forms
from django.utils.datastructures import SortedDict
from django.template.defaultfilters import slugify

from hyperadmin.endpoints import VirtualEndpoint, GlobalSiteMixin
from hyperadmin.resources.hyperobjects import ResourceItem
from hyperadmin.signals import resource_event


class EmptyForm(forms.Form):
    def __init__(self, **kwargs):
        self.instance = kwargs.pop('instance', None)
        super(EmptyForm, self).__init__(**kwargs)

class BaseResource(GlobalSiteMixin, VirtualEndpoint):
    '''
    A collection of endpoints representing a particular service
    '''
    resource_class = '' #hint to the client how this resource is used
    form_class = EmptyForm
    resource_item_class = ResourceItem
    name_suffix = 'resource'
    
    resource_adaptor = None
    '''The object representing the resource connection. Typically passed in during construction'''
    
    def __init__(self, **kwargs):
        assert 'resource_adaptor' in kwargs
        self._installed_endpoints = SortedDict()
        super(BaseResource, self).__init__(**kwargs)
    
    def fork(self, **kwargs):
        kwargs.setdefault('_installed_endpoints', self._installed_endpoints)
        return super(BaseResource, self).fork(**kwargs)
    
    @property
    def resource(self):
        #endpoints have a resource attribute
        return self
    
    def post_register(self):
        self.register_endpoints()
        super(BaseResource, self).post_register()
    
    def get_app_name(self):
        """
        Return the application name of this resource.
        Provides the return value of the `app_name` property.
        """
        return getattr(self, '_app_name', None)
    
    def _get_app_name(self):
        return self.get_app_name()
    
    def _set_app_name(self, name):
        self._app_name = name
    
    app_name = property(_get_app_name, _set_app_name, None, 'Set or get the application name')
    
    def get_resource_name(self):
        """
        Return the name of this resource.
        Provides the return value of the `resource_name` property.
        """
        return self._resource_name
    
    def _get_resource_name(self):
        return self.get_resource_name()
    
    def _set_resource_name(self, name):
        self._resource_name = name
    
    resource_name = property(_get_resource_name, _set_resource_name, None, 'Set or get the name of the resource')
    
    
    def get_resource_slug(self):
        """
        Return the slug of this resource.
        Provides the return value of the `resource_slug` property.
        """
        if hasattr(self, '_resource_slug'):
            return self._resource_slug
        return slugify(self.get_resource_name())
    
    def _get_resource_slug(self):
        return self.get_resource_slug()
    
    def _set_resource_slug(self, slug):
        self._resource_slug = slug
    
    resource_slug = property(_get_resource_slug, _set_resource_slug, None, 'Set or get the slug of the resource')
    
    def get_prompt(self):
        return self.resource_name
    
    def get_base_url_name_suffix(self):
        if self.base_url_name_suffix is None:
            return self.resource_slug
        return self.base_url_name_suffix
    
    def register_endpoints(self):
        self.endpoints = SortedDict()
        for endpoint_cls, kwargs in self.get_view_endpoints():
            self._register_endpoint(endpoint_cls, **kwargs)
        for key, endpoint in self._installed_endpoints.iteritems():
            self.endpoints[key] = self.fork(**self.get_endpoint_kwargs())
    
    def register_endpoint(self, endpoint_cls, **kwargs):
        endpoint = self._register_endpoint(endpoint_cls, **kwargs)
        self._installed_endpoints[endpoint.get_name_suffix()] = endpoint
        return endpoint
    
    def _register_endpoint(self, endpoint_cls, **kwargs):
        kwargs = self.get_endpoint_kwargs(**kwargs)
        endpoint = endpoint_cls(**kwargs)
        self.endpoints[endpoint.get_name_suffix()] = endpoint
        return endpoint
    
    def get_view_endpoints(self):
        """
        Returns a list of tuples containing
        (endpoint class, endpoint kwargs)
        """
        return []
    
    def get_children_endpoints(self):
        return self.endpoints.values()
    
    def reverse(self, name, *args, **kwargs):
        return self.site.reverse(name, *args, **kwargs)
    
    def get_state_data(self):
        data = super(BaseResource, self).get_state_data()
        data.update({'resource_name': self.resource_name,
                     'app_name': self.app_name,})
        return data
    
    def get_indexes(self):
        return {}
    
    def get_index(self, name):
        return self.get_indexes()[name]
    
    def get_index_query(self, name):
        raise NotImplementedError
    
    def get_item_url(self, item):
        return None
    
    def get_related_resource_from_field(self, field):
        return self.site.get_related_resource_from_field(field)
    
    def get_html_type_from_field(self, field):
        return self.site.get_html_type_from_field(field)
    
    def get_absolute_url(self):
        return self.get_url()
    
    def get_url(self, **kwargs):
        return self.get_main_link_prototype().get_url(**kwargs)
    
    def get_resource_link_item(self):
        return None
    
    def get_index_endpoint(self):
        return self.endpoints['list']
    
    def get_breadcrumb(self):
        bread = self.create_link_collection()
        bread.add_link(self.get_index_endpoint(), rel='breadcrumb', link_factor='LO', prompt=self.get_prompt())
        return bread
    
    def get_breadcrumbs(self):
        if self.parent:
            breadcrumbs = self.parent.get_breadcrumbs()
        else:
            breadcrumbs = self.create_link_collection()
        breadcrumbs.extend(self.get_breadcrumb())
        return breadcrumbs
    
    def get_paginator_kwargs(self):
        return {}
    
    def emit_event(self, event, item_list=None):
        """
        Fires of the `resource_event` signal
        """
        sender = '%s!%s' % (self.get_url_name(), event)
        if item_list is None:
            item_list = self.get_resource_items()
        resource_event.send(sender=sender, resource=self, event=event, item_list=item_list)

########NEW FILE########
__FILENAME__ = endpoints
from hyperadmin.links import LinkPrototype, Link
from hyperadmin.resources.endpoints import ResourceEndpoint
from hyperadmin.resources.crud.endpoints import ListEndpoint as BaseListEndpoint, CreateEndpoint, DetailEndpoint, DeleteEndpoint


class BoundFile(object):
    def __init__(self, storage, name):
        self.storage = storage
        self.name = name

    @property
    def pk(self):
        return self.name

    @property
    def url(self):
        return self.storage.url(self.name)

    def delete(self):
        return self.storage.delete(self.name)

    def exists(self):
        return self.storage.exists(self.name)

    def __unicode__(self):
        return self.name


class CreateUploadLinkPrototype(LinkPrototype):
    def show_link(self, **kwargs):
        return self.resource.has_create_permission()

    def get_link_kwargs(self, **kwargs):
        form_kwargs = kwargs.pop('form_kwargs', None)
        if form_kwargs is None:
            form_kwargs = {}
        form_kwargs = self.resource.get_upload_link_form_kwargs(**form_kwargs)

        link_kwargs = {'url': self.get_url(),
                       'on_submit': self.handle_submission,
                       'method': 'POST',
                       'form_kwargs': form_kwargs,
                       'form_class': self.resource.get_upload_link_form_class(),
                       'prompt': 'create upload link',
                       'rel': 'upload-link', }
        link_kwargs.update(kwargs)
        return super(CreateUploadLinkPrototype, self).get_link_kwargs(**link_kwargs)

    def handle_submission(self, link, submit_kwargs):
        form = link.get_form(**submit_kwargs)
        if form.is_valid():
            upload_link = form.save()
            return self.on_success(upload_link)
        return link.clone(form=form)

    def on_success(self, link):
        assert isinstance(link, Link)
        return link


class ListEndpoint(BaseListEndpoint):
    def get_outbound_links(self):
        #links = self.create_link_collection()
        links = super(ListEndpoint, self).get_outbound_links()
        links.add_link('upload', link_factor='LO')
        return links


class CreateUploadEndpoint(ResourceEndpoint):
    name_suffix = 'upload'
    url_suffix = r'^upload/$'

    prototype_method_map = {
        'GET': 'upload',
        'POST': 'upload',
    }

    create_upload_prototype = CreateUploadLinkPrototype

    def get_link_prototypes(self):
        return [
            (self.create_upload_prototype, {'name':'upload'}),
        ]


class Base64UploadEndpoint(CreateEndpoint):
    name_suffix = 'base64-upload'
    url_suffix = r'^base64-upload/$'

    prototype_method_map = {
        'GET': 'base64-upload',
        'POST': 'base64-upload',
    }

    def get_form_class(self):
        return self.resource.get_base64_upload_form_class()

    def get_link_prototypes(self):
        return [
            (self.create_prototype, {'name':'base64-upload'}),
        ]

########NEW FILE########
__FILENAME__ = forms
import base64

from django import forms
from django.core.files.base import ContentFile
from django.middleware.csrf import get_token

from hyperadmin.resources.storages.endpoints import BoundFile


class UploadForm(forms.Form):
    name = forms.CharField()
    upload = forms.FileField()
    overwrite = forms.BooleanField(required=False)

    def __init__(self, **kwargs):
        self.instance = kwargs.pop('instance', None)
        self.storage = kwargs.pop('storage')
        super(UploadForm, self).__init__(**kwargs)
        if self.instance:
            self.initial['name'] = self.instance.name
            self.initial['overwrite'] = True

    def add_csrf_field(self, request):
        value = get_token(request)
        self.fields['csrfmiddlewaretoken'] = forms.CharField(initial=value, widget=forms.HiddenInput)

    def save(self, commit=True):
        if self.cleaned_data.get('overwrite', False): #TODO would be better if storage accepted an argument to overwrite
            if self.storage.exists(self.cleaned_data['name']):
                self.storage.delete(self.cleaned_data['name'])
        name = self.storage.save(self.cleaned_data['name'], self.cleaned_data['upload'])
        return BoundFile(self.storage, name)


class Base64UploadForm(UploadForm):
    upload = forms.CharField(widget=forms.Textarea)

    def clean_upload(self):
        django_file = None
        payload = self.cleaned_data.get('upload')
        if payload:
            try:
                django_file = ContentFile(base64.b64decode(payload))
            except TypeError as error:
                raise forms.ValidationError('Inproperly encoded file: %s' % error)
        return django_file


class UploadLinkForm(forms.Form):
    name = forms.CharField() #desired file name
    upload_to = forms.CharField(required=False) #directory path
    overwrite = forms.BooleanField(required=False)

    def __init__(self, **kwargs):
        self.storage = kwargs.pop('storage')
        self.resource = kwargs.pop('resource')
        self.request = kwargs.pop('request') #this is useful because we may return a full url
        super(UploadLinkForm, self).__init__(**kwargs)

    def save(self, commit=True):
        import os
        file_name = self.storage.get_valid_name(self.cleaned_data['name'])
        upload_to = self.cleaned_data.get('upload_to', '')
        if upload_to:
            path = os.path.join(upload_to, file_name)
        else:
            path = file_name
        overwrite = self.cleaned_data.get('overwrite', False)
        if overwrite:
            name = path
        else:
            name = self.storage.get_available_name(path)
        form_kwargs = {'initial':{'name':name, 'overwrite':overwrite}}
        link = self.resource.link_prototypes['create'].get_link(form_kwargs=form_kwargs, rel='direct-upload')
        link.form.add_csrf_field(self.request)
        response_type = self.request.META.get('HTTP_ACCEPT', None)
        if response_type:
            link.state['extra_get_params']['_HTTP_ACCEPT'] = 'text/html-iframe-transport;level=1,'+response_type
        return link

########NEW FILE########
__FILENAME__ = indexes
from hyperadmin.indexes import Index
from hyperadmin.resources.storages.endpoints import BoundFile

from django.core.paginator import Page
from django.core.exceptions import ObjectDoesNotExist


class StoragePaginator(object):
    #count, num_pages, object_list
    def __init__(self, index):
        self.instances = index
        self.count = len(self.instances)
        self.num_pages = 1
        self.object_list = self.instances
    
    @property
    def endpoint(self):
        return self.state.endpoint
    
    def page(self, page_num):
        return Page(self.object_list, page_num, self)

class StorageIndex(Index):
    paginator_class = StoragePaginator
    
    @property
    def storage(self):
        return self.resource.storage
    
    def get_url_params(self, param_map={}):
        """
        returns url parts for use in the url regexp for conducting item lookups
        """
        param_map.setdefault('path', 'path')
        return [r'(?P<{path}>.+)'.format(**param_map)]
    
    def get_url_params_from_item(self, item, param_map={}):
        param_map.setdefault('path', 'path')
        return {param_map['path']: item.instance.name}
    
    def populate_state(self):
        self.path = self.state.params.get('path', '')
        query = self.get_index_query().filter(self.path)
        self.dirs, self.instances = query.get_dirs_and_files()
    
    def get_filtered_index(self):
        return self.instances
    
    def get_filter_links(self, **link_kwargs):
        links = list()
        if self.path:
            kwargs = {
                'url':'./%s' % self.state.get_query_string({}, ['path']),
                'prompt':u"/", 
                'classes':['filter', 'directory'], 
                'rel':"filter", 
                'group':"directory",
            }
            kwargs.update(link_kwargs)
            link = self.get_link(**kwargs)
            links.append(link)
        for directory in self.dirs:
            if self.path:
                path = self.path + '/' + directory
            else:
                path = directory
            kwargs = {
                'url':'./%s' % self.state.get_query_string({'path':path}),
                'prompt':path,
                'classes':['filter', 'directory'],
                'rel':"filter",
                'group':"directory",
            }
            kwargs.update(link_kwargs)
            link = self.get_link(**kwargs)
            links.append(link)
        if '/' in self.path:
            kwargs = {
                'url':'./%s' % self.state.get_query_string({'path':self.path[:self.path.rfind('/')]}),
                'prompt':u"../",
                'classes':['filter', 'directory'],
                'rel':"filter",
                'group':"directory"
            }
            kwargs.update(link_kwargs)
            link = self.get_link(**kwargs)
            links.append(link)
        return links


########NEW FILE########
__FILENAME__ = resources
import os

from django.core.exceptions import ObjectDoesNotExist

from hyperadmin.links import Link
from hyperadmin.resources.crud import CRUDResource
from hyperadmin.resources.storages.forms import UploadForm, Base64UploadForm, UploadLinkForm
from hyperadmin.resources.storages.indexes import StorageIndex
from hyperadmin.resources.storages.endpoints import ListEndpoint, CreateUploadEndpoint, Base64UploadEndpoint, BoundFile


class StorageQuery(object):
    def __init__(self, storage, path=''):
        self.storage = storage
        self.path = path

    def filter(self, path):
        if self.path:
            path = os.path.join(self.path, path)
        return StorageQuery(self.storage, path)

    def get_dirs_and_files(self):
        try:
            dirs, files = self.storage.listdir(self.path)
        except NotImplementedError:
            return [], []
        if self.path:
            files = [os.path.join(self.path, filename) for filename in files]
        return dirs, [BoundFile(self.storage, filename) for filename in files]

    def get(self, path):
        if self.path:
            path = os.path.join(self.path, path)
        if not self.storage.exists(path):
            raise ObjectDoesNotExist
        return BoundFile(self.storage, path)


class StorageResource(CRUDResource):
    #resource_adaptor = storage object
    form_class = UploadForm
    upload_link_form_class = UploadLinkForm
    base64_upload_form_class = Base64UploadForm
    list_endpoint = (ListEndpoint, {})
    create_upload_endpoint = (CreateUploadEndpoint, {})
    base64_upload_endpoint = (Base64UploadEndpoint, {})

    def __init__(self, **kwargs):
        kwargs.setdefault('app_name', '-storages')
        super(StorageResource, self).__init__(**kwargs)

    def get_storage(self):
        return self.resource_adaptor
    storage = property(get_storage)

    def get_base64_upload_form_class(self):
        return self.base64_upload_form_class

    def get_upload_link_form_class(self):
        return self.upload_link_form_class

    def get_view_endpoints(self):
        endpoints = super(StorageResource, self).get_view_endpoints()
        endpoints.insert(0, self.create_upload_endpoint)
        return endpoints

    def get_indexes(self):
        return {'primary': StorageIndex('primary', self)}

    def get_primary_query(self):
        return StorageQuery(self.storage)

    def get_instances(self):
        '''
        Returns a set of native objects for a given state
        '''
        if 'page' in self.state:
            return self.state['page'].object_list
        if self.state.has_view_class('change_form'):
            return []
        dirs, files = self.get_primary_query()
        instances = [BoundFile(self.storage, file_name) for file_name in files]
        return instances

    def get_item_form_kwargs(self, item=None, **kwargs):
        kwargs = super(StorageResource, self).get_item_form_kwargs(item, **kwargs)
        kwargs['storage'] = self.storage
        return kwargs

    def get_form_kwargs(self, **kwargs):
        kwargs = super(StorageResource, self).get_form_kwargs(**kwargs)
        kwargs['storage'] = self.storage
        return kwargs

    def get_upload_link_form_kwargs(self, **kwargs):
        kwargs = self.get_form_kwargs(**kwargs)
        kwargs['resource'] = self
        kwargs['request'] = self.api_request.request
        return kwargs

    def get_item_url(self, item):
        return self.link_prototypes['update'].get_url(item=item)

    def get_item_storage_link(self, item, **kwargs):
        link_kwargs = {'url': item.instance.url,
                       'resource': self,
                       'prompt': 'Absolute Url',
                       'rel': 'storage-url', }
        link_kwargs.update(kwargs)
        storage_link = Link(**link_kwargs)
        return storage_link

    def get_item_outbound_links(self, item):
        links = self.create_link_collection()
        links.append(self.get_item_storage_link(item, link_factor='LO'))
        return links

    def get_item_prompt(self, item):
        return item.instance.name

    def get_paginator_kwargs(self):
        return {}

########NEW FILE########
__FILENAME__ = endpoints
from hyperadmin.resources import ResourceEndpoint

from hyperadmin.resources.wizard.links import FormStepLinkPrototype, ControlStepLinkPrototype
from hyperadmin.resources.wizard.forms import StepControlForm


class StepList(ResourceEndpoint):
    url_suffix = r'^$'
    name_suffix = 'start'
    link_prototype = ControlStepLinkPrototype
    form_class = StepControlForm
    
    @property
    def wizard(self):
        return self.parent
    
    @property
    def prototype_method_map(self):
        return {
            'GET':'steps',
            'POST':'steps',
        }
    
    def get_link_prototypes(self):
        return [
            (self.link_prototype, {'name':'steps'}),
        ]
    
    def get_form_kwargs(self, **kwargs):
        available_steps = list()
        for step in self.wizard.available_steps:
            available_steps.append((step.slug, step.get_prompt()))
        params = {
            'available_steps': available_steps
        }
        params.update(kwargs)
        return super(StepList, self).get_form_kwargs(**params)
    #post here for step control
    #get for loader, api for steps as items with status

class StepProvider(object):
    slug = None
    base_url_name_suffix = 'step'
    status_choices = [
        ('incomplete', 'Incomplete'),
        ('inactive', 'Inactive'),
        ('skipped', 'Skipped'),
        ('complete', 'Complete'),
    ]
    
    @property
    def wizard(self):
        return self.parent
    
    def can_skip(self):
        return False
    
    def is_active(self):
        return True
    
    @property
    def status(self):
        return self.wizard.step_statuses[self.slug]
    
    def is_available(self):
        return self.is_active() and self.status in ('incomplete', 'skipped', 'complete')
    
    def get_extra_status_info(self):
        submitted_data = self.wizard.get_step_data(self.slug)
        return {'submitted_data':submitted_data}
    
    def get_url_suffix(self):
        return r'^%s/$' % self.slug
    
    def get_name_suffix(self):
        return self.slug
    
    def get_prompt(self):
        return self.slug
    
    def get_outbound_links(self):
        links = self.create_link_collection()
        if self.can_skip():
            form_kwargs = {
                'initial': {
                    'skip_steps': [self.slug],
                },
            }
            link = links.add_link(self.wizard, link_factor='LN', form_kwargs=form_kwargs, prompt='Skip')
        return links
    
    def get_item(self):
        return self.get_resource_item(self)
    
    def get_common_state_data(self):
        data = super(StepProvider, self).get_common_state_data()
        data['item'] = self.get_item()
        return data
    
class Step(StepProvider, ResourceEndpoint):
    def get_skip_steps(self):
        return []
    
    def get_desired_step(self):
        return None

class FormStep(Step):
    link_prototype = FormStepLinkPrototype
    form_class = None
    
    @property
    def prototype_method_map(self):
        return {
            'GET':'step_%s' % self.slug,
            'POST':'step_%s' % self.slug,
        }
    
    def get_link_prototypes(self):
        return [
            (self.link_prototype, {'name':'step_%s' % self.slug}),
        ]
    
    def get_context_data(self, **kwargs):
        kwargs['form'] = kwargs['link'].form
        return kwargs
        return super(FormStep, self).get_context_data(**kwargs)
    
    def form_valid(self, form):
        self.wizard.set_step_data(self.slug, form.cleaned_data)
        self.wizard.set_step_status(self.slug, 'complete')
    
    def form_invalid(self, form):
        pass


########NEW FILE########
__FILENAME__ = forms
from django import forms

class StepControlForm(forms.Form):
    skip_steps = forms.MultipleChoiceField(choices=[], required=False)
    desired_step = forms.ChoiceField(choices=[], required=False)
    
    def __init__(self, **kwargs):
        available_steps = kwargs.pop('available_steps', [])
        super(StepControlForm, self).__init__(**kwargs)
        self.fields['skip_steps'].choices = available_steps
        self.fields['desired_step'].choices = available_steps

class StepStatusForm(forms.Form):
    slug = forms.CharField()
    status = forms.CharField()
    can_skip = forms.BooleanField(required=False)
    is_active = forms.BooleanField(required=False)
    
    def __init__(self, **kwargs):
        self.instance = kwargs.pop('instance', None)
        super(StepStatusForm, self).__init__(**kwargs)
        if self.instance:
            self.initial['slug'] = self.instance.slug
            self.initial['status'] = self.instance.status
            self.initial['can_skip'] = self.instance.can_skip()
            self.initial['is_active'] = self.instance.is_active()
            
            for key, datum in self.instance.get_extra_status_info().iteritems():
                self.fields[key] = forms.CharField(required=False)
                self.initial[key] = datum

########NEW FILE########
__FILENAME__ = links
from hyperadmin.links import LinkPrototype


class FormStepLinkPrototype(LinkPrototype):
    def get_link_kwargs(self, **kwargs):
        link_kwargs = {'on_submit':self.handle_submission,
                       'method':'POST',
                       'url':self.get_url(),
                       'form_class': self.get_form_class(),
                       'prompt':'step',
                       'rel':'step',}
        link_kwargs.update(kwargs)
        return super(FormStepLinkPrototype, self).get_link_kwargs(**link_kwargs)
    
    def handle_submission(self, link, submit_kwargs):
        """
        Called when the link is submitted. Returns a link representing the response.
        
        :rtype: Link
        """
        form = link.get_form(**submit_kwargs)
        if form.is_valid():
            self.endpoint.form_valid(form)
            
            return self.on_success()
        self.endpoint.form_invalid(form)
        return link.clone(form=form)
    
    def get_next_step_kwargs(self):
        return {
            'skip_steps': self.endpoint.get_skip_steps(),
            'desired_step': self.endpoint.get_desired_step(),
        }
    
    def on_success(self, item=None):
        params = self.get_next_step_kwargs()
        return self.endpoint.wizard.next_step(**params)

class ControlStepLinkPrototype(LinkPrototype):
    def get_link_kwargs(self, **kwargs):
        link_kwargs = {'on_submit':self.handle_submission,
                       'method':'POST',
                       'url':self.get_url(),
                       'form_class': self.get_form_class(),
                       'prompt':'step',
                       'rel':'step',}
        link_kwargs.update(kwargs)
        return super(ControlStepLinkPrototype, self).get_link_kwargs(**link_kwargs)
    
    def handle_submission(self, link, submit_kwargs):
        """
        Called when the link is submitted. Returns a link representing the response.
        
        :rtype: Link
        """
        form = link.get_form(**submit_kwargs)
        if form.is_valid():
            return self.on_success(form)
        return link.clone(form=form)
    
    def get_next_step_kwargs(self, form):
        return {
            'skip_steps': form.cleaned_data.get('skip_steps', []),
            'desired_step': form.cleaned_data.get('desired_step', None),
        }
    
    def on_success(self, form):
        params = self.get_next_step_kwargs(form)
        return self.endpoint.wizard.next_step(**params)


########NEW FILE########
__FILENAME__ = resources
from django.utils.datastructures import MultiValueDict

from hyperadmin.resources import BaseResource

from hyperadmin.resources.wizard.endpoints import StepList, StepProvider
from hyperadmin.resources.wizard.forms import StepStatusForm

from django.contrib.formtools.wizard.storage.session import SessionStorage


def multi_value_merge(dest, source):
    for key, value in source.iteritems():
        dest[key] = value

#CONSIDER: are we a resource or a complex endpoint?
class Wizard(BaseResource):
    step_definitions = [] #tuples of Step and dictionary kwargs, kwarg must contain slug
    list_endpoint = StepList
    instance_form_class = StepStatusForm
    storage_class = SessionStorage
    
    def __init__(self, **kwargs):
        kwargs.setdefault('resource_adaptor', None)
        super(Wizard, self).__init__(**kwargs)
    
    def get_index_endpoint(self):
        return self.endpoints['start']
    
    @property
    def storage(self):
        if not hasattr(self, '_storage'):
            self._storage = self.create_storage()
        return self._storage
    
    def create_storage(self):
        kwargs = self.get_storage_kwargs()
        storage = self.get_storage_class()(**kwargs)
        if not hasattr(storage, 'data'):
            storage.init_data()
        return storage
    
    def get_storage_class(self):
        return self.storage_class
    
    def get_storage_kwargs(self):
        return {
            'prefix': self.get_url_name(),
            'request': self.api_request.get_django_request(),
            'file_storage': None
        }
    
    @property
    def steps(self):
        ret = list()
        for endpoint in self.endpoints.itervalues():
            if isinstance(endpoint, StepProvider):
                ret.append(endpoint)
        return ret
    
    @property
    def available_steps(self):
        ret = list()
        for endpoint in self.steps:
            if endpoint.is_available():
                ret.append(endpoint)
        return ret
    
    def step_index(self, slug):
        return self.endpoints.keyOrder.index(slug)
    
    def get_instances(self):
        return self.available_steps
    
    def get_item_url(self, item):
        return item.instance.get_url()
    
    def get_view_endpoints(self):
        endpoints = super(Wizard, self).get_view_endpoints()
        endpoints.append((self.list_endpoint, {}))
        endpoints.extend(self.step_definitions)
        return endpoints
    
    def set_step_status(self, slug, status):
        statuses = MultiValueDict([(slug, [status]),])
        return self.update_statuses(statuses)
    
    def update_statuses(self, statuses):
        return self.set_step_statuses(statuses)
    
    @property
    def step_statuses(self):
        if 'step_statuses' not in self.state:
            self.state['step_statuses'] = self.get_step_statuses()
        return self.state['step_statuses']
    
    def get_step_statuses(self):
        data = self.storage.get_step_data('_step_statuses')
        if data is None:
            data = MultiValueDict()
        for step in self.steps:
            if step.slug not in data:
                data[step.slug] = 'incomplete'
        return data
    
    def set_step_statuses(self, statuses):
        effective_statuses = self.step_statuses.copy()
        multi_value_merge(effective_statuses, statuses)
        self.storage.set_step_data('_step_statuses', effective_statuses)
        self.state.pop('step_statuses', None)
    
    def get_step_data(self, key):
        return self.storage.get_step_data(key)
    
    def set_step_data(self, key, value):
        self.storage.set_step_data(key, value)
    
    def get_next_step(self, skip_steps=[], desired_step=None):
        statuses = {}
            
        for step in self.steps:
            if step.slug in skip_steps and step.can_skip():
                statuses[step.slug] = 'skipped'
            elif step.status == 'incomplete' and step.is_active():
                if desired_step and step.slug != desired_step and step.status.can_skip():
                    #CONSIDER: this assumes we can get to our desired step
                    statuses[step.slug] = 'skipped'
                    continue
                self.update_statuses(statuses)
                return step
        self.update_statuses(statuses)
        return None
    
    def next_step(self, skip_steps=[], desired_step=None):
        step = self.get_next_step(skip_steps, desired_step)
        if step is None:
            submissions = dict()
            for step in self.steps:
                key = step.slug
                submissions[key] = self.get_step_data(key)
            return self.done(submissions)
        return step.get_link()
    
    def done(self, submissions):
        raise NotImplementedError
    
    def get_current_step_links(self):
        links = self.create_link_collection()
        step = self.get_next_step()
        links.add_link(step, link_factor='LN')
        return links
    
    def get_context_data(self, **kwargs):
        kwargs.setdefault('wizard', self)
        return super(Wizard, self).get_context_data(**kwargs)

class MultiPartStep(StepProvider, Wizard):
    #main form is step control from wizard
    def __init__(self, **kwargs):
        kwargs.setdefault('resource_adaptor', kwargs['parent'].resource_adaptor)
        super(MultiPartStep, self).__init__(**kwargs)
    
    def get_resource_name(self):
        return self.slug
    
    def get_url_suffix(self):
        return r'^%s/' % self.slug
    
    def get_base_url_name_suffix(self):
        return 'step_%s' % self.slug
    
    def can_skip(self):
        for endpoint in self.steps:
            if (endpoint.is_active() and
                not endpoint.can_skip() and
                endpoint.status != 'complete'):
                return False
        return True
    
    def get_outbound_links(self):
        links = self.create_link_collection()
        if self.can_skip():
            form_kwargs = {
                'initial': {
                    'skip_steps': [self.slug],
                },
            }
            #but this link should complete this step not skip it
            link = links.add_link(self, link_factor='LN', form_kwargs=form_kwargs, prompt='Continue')
        return links
    
    def done(self, submissions):
        self.wizard.set_step_data(self.slug, submissions)
        self.wizard.set_step_status(self.slug, 'complete')
        return self.wizard.next_step()
    
    def get_current_step_links(self):
        if self.can_skip():
            links = self.create_link_collection()
            for step in self.available_steps:
                links.add_link(step, link_factor='LN')
            return links
        return super(MultiPartStep, self).get_current_step_links()
    
    #CONSIDER: default should crawl up parents then site
    def expand_template_names(self, suffixes):
        return self.parent.expand_template_names(suffixes)
    
    def create_apirequest(self, **kwargs):
        return self.parent.create_apirequest(**kwargs)

########NEW FILE########
__FILENAME__ = signals
'''
NOTE: the construction of the sender is based on the urlname and the event.
This allows for listeners to be registered independently of resource construction.
'''

from django.dispatch import Signal


endpoint_event = Signal(providing_args=["endpoint", "event", "item_list"])
endpoint_event.__doc__ = '''
Sent by the endpoint when an event occurs

:param sender: The full url name of the endpoint + ! + the event
:param endpoint: The endpoint emitting the event
:param event: A string representing the event
:param item_list: An item list for which the event applies, may be empty
'''

resource_event = Signal(providing_args=["resource", "event", "item_list"])
resource_event.__doc__ = '''
Sent by the resource when an event occurs

:param sender: The full url name of the resource + ! + the event
:param resource: The resource emitting the event
:param event: A string representing the event
:param item_list: An item list for which the event applies, may be empty
'''

########NEW FILE########
__FILENAME__ = sites
from django.utils.datastructures import SortedDict

from hyperadmin.endpoints import RootEndpoint
from hyperadmin.resources.directory import ResourceDirectory
from hyperadmin.resources.auth import AuthResource
from hyperadmin.throttle import Throttle

import collections


class Registry(dict):
    def __init__(self, resource_site):
        self.resource_site = resource_site
    
    def __getitem__(self, key):
        item = super(Registry, self).__getitem__(key)
        if self.resource_site.api_request:
            return self.resource_site.api_request.get_endpoint(item.get_url_name())
        return item
    
    def items(self):
        items = super(Registry, self).items()
        if self.resource_site.api_request:
            items = [(key, self[key]) for key, val in items]
        return items

class BaseResourceSite(RootEndpoint):
    directory_resource_class = ResourceDirectory
    throttle = Throttle(throttle_at=1200)
    name = 'hyperadmin'
    
    def __init__(self, **kwargs):
        self.registry = dict()
        kwargs.setdefault('namespace', kwargs.get('name', self.name))
        super(BaseResourceSite, self).__init__(**kwargs)
    
    def post_register(self):
        super(BaseResourceSite, self).post_register()
        self.directory_resource = self.create_directory_resource(base_url_name_suffix=self.base_url_name_suffix)
    
    def get_directory_resource_kwargs(self, **kwargs):
        kwargs.setdefault('resource_name', self.name)
        #kwargs.setdefault('parent', self)
        return self.get_resource_kwargs(**kwargs)
    
    def create_directory_resource(self, **kwargs):
        params = self.get_directory_resource_kwargs(**kwargs)
        return self.directory_resource_class(**params)
    
    def get_children_endpoints(self):
        return [self.directory_resource]
    
    def get_index_endpoint(self):
        return self.directory_resource
    
    def get_resource_kwargs(self, **kwargs):
        params = {'site': self,
                  'api_request': self.api_request,}
        params.update(kwargs)
        return params
    
    def get_endpoint_kwargs(self, **kwargs):
        kwargs.setdefault('parent', self.directory_resource)
        params = self.get_resource_kwargs(**kwargs)
        return params
    
    def fork(self, **kwargs):
        ret = super(BaseResourceSite, self).fork(**kwargs)
        ret.registry.update(self.registry)
        ret.directory_resource.resource_adaptor.update(self.directory_resource.resource_adaptor)
        return ret
    
    def register_endpoint(self, klass, **options):
        kwargs = self.get_endpoint_kwargs(**options)
        endpoint = klass(**kwargs)
        if 'resource_adaptor' in kwargs:
            self.registry[kwargs['resource_adaptor']] = endpoint
        self.directory_resource.register_resource(endpoint)
        return endpoint
    
    #TODO review the following for inclusion into RootEndpoint
    def register_builtin_media_types(self):
        from mediatypes import BUILTIN_MEDIA_TYPES
        for key, value in BUILTIN_MEDIA_TYPES.iteritems():
            self.register_media_type(key, value)
    
    def get_html_type_from_field(self, field):
        #TODO fill this out, datetime, etc
        from django.forms import widgets
        from django.forms import FileField
        if hasattr(field, 'field'): #CONSIDER internally we use boundfield
            field = field.field
        widget = field.widget
        if isinstance(widget, widgets.Input):
            return widget.input_type
        if isinstance(widget, widgets.CheckboxInput):
            return 'checkbox'
        if isinstance(widget, widgets.Select):
            #if widget.allow_multiple_selected
            return 'select'
        if isinstance(field, FileField):
            return 'file'
        self.get_logger().warning('Unhandled widget type: %s' % type(widget))
        return 'text'
    
    def get_media_resource_urlname(self):
        return '%s_-storages_media_resource' % self.base_url_name_suffix
    
    def get_media_resource(self):
        urlname = self.get_media_resource_urlname()
        return self.api_request.get_endpoint(urlname)
    
    def get_related_resource_from_field(self, field):
        #TODO make more dynamic
        from django.forms import FileField
        from django.forms.models import ModelChoiceField
        if hasattr(field, 'field'): #CONSIDER internally we use boundfield
            field = field.field
        if isinstance(field, ModelChoiceField):
            model = field.queryset.model
            if model in self.registry:
                resource = self.registry[model]
                return self.api_request.get_endpoint(resource.get_url_name())
        if isinstance(field, FileField):
            return self.get_media_resource().link_prototypes['upload'].get_url()
        return None
    
    def api_permission_check(self, api_request, endpoint):
        response = self.throttle.throttle_check(api_request, endpoint)
        if response:
            return response
        return super(BaseResourceSite, self).api_permission_check(api_request, endpoint)

class ResourceSite(BaseResourceSite):
    '''
    A Resource Site that is suited for administrative purposes. By 
    default the user must be a staff user.
    '''
    auth_resource_class = AuthResource
    name = 'hyperadmin'
    base_url_name_suffix = 'admin'
    
    def post_register(self):
        super(ResourceSite, self).post_register()
        self.auth_resource = self.register_endpoint(self.auth_resource_class)
    
    @property
    def applications(self):
        return self.directory_resource.resource_adaptor
    
    def register(self, model_or_iterable, admin_class, **options):
        if isinstance(model_or_iterable, collections.Iterable) and not isinstance(model_or_iterable, basestring):
            resources = list()
            for model in model_or_iterable:
                resources.append(self.register(model, admin_class, **options))
            return resources
        model = model_or_iterable
        app_name = options.pop('app_name')
        app_resource = self.register_application(app_name)
        options.setdefault('parent', app_resource)
        kwargs = self.get_resource_kwargs(resource_adaptor=model, **options)
        resource = admin_class(**kwargs)
        self.applications[app_name].register_resource(resource)
        self.registry[model] = resource
        return resource
    
    def register_application(self, app_name, app_class=None, **options):
        if app_name not in self.applications:
            if app_class is None:
                app_class = self.directory_resource_class
            app_resource = self.register_endpoint(app_class, app_name=self.name, resource_name=app_name)
            assert app_name in self.applications
        return self.applications[app_name]
    
    def get_login_link(self, api_request, **kwargs):
        auth_resource = api_request.get_endpoint(self.auth_resource.get_url_name())
        return auth_resource.get_link(**kwargs)
    
    def api_permission_check(self, api_request, endpoint):
        user = api_request.user
        if not user.is_authenticated():
            return self.get_login_link(api_request, prompt='Login Required')
        if not user.is_staff:
            return self.get_login_link(api_request, prompt='Unauthorized', http_status=401)
        return super(ResourceSite, self).api_permission_check(api_request, endpoint)
    
    def get_actions(self, request):
        return SortedDict()
    
    def install_models_from_site(self, site):
        from hyperadmin.resources.models.autoload import DEFAULT_LOADER
        
        loader = DEFAULT_LOADER(root_endpoint=self, admin_site=site)
        loader.register_resources()
    
    def install_storage_resources(self, media_resource_class=None, static_resource_class=None):
        from hyperadmin.resources.storages import StorageResource
        from django.core.files.storage import default_storage as media_storage
        try:
            from django.contrib.staticfiles.storage import staticfiles_storage as static_storage
        except ImportError:
            from django.conf import settings
            from django.core.files.storage import get_storage_class
            static_storage = get_storage_class(settings.STATICFILES_STORAGE)()
        if media_resource_class is None:
            media_resource_class = StorageResource
        if static_resource_class is None:
            static_resource_class = StorageResource
        app_name = '-storages'
        self.register(media_storage, media_resource_class, resource_name='media', app_name=app_name)
        self.register(static_storage, static_resource_class, resource_name='static', app_name=app_name)

class GlobalSite(BaseResourceSite):
    '''
    A Resource Site that is meant for globally registering endpoints 
    without needing to explicitly create a Resource Site.
    '''
    name = 'apisite'
    
    def get_resolver(self):
        from django.core.urlresolvers import get_resolver
        return get_resolver(None)

site = ResourceSite()
site.register_builtin_media_types()

global_site = GlobalSite()
global_site.register_builtin_media_types()

########NEW FILE########
__FILENAME__ = states
from copy import copy

from django.utils.http import urlencode
from django.utils.datastructures import MergeDict
from django.http import QueryDict

from hyperadmin.links import LinkCollectionProvider, LinkCollectorMixin


class State(MergeDict):
    def __init__(self, substates=[], data={}):
        self.active_dictionary = dict()
        self.substates = substates
        dictionaries = self.get_dictionaries()
        super(State, self).__init__(*dictionaries)
        self.update(data)
    
    def get_dictionaries(self):
        return [self.active_dictionary] + self.substates
    
    def __copy__(self):
        substates = self.get_dictionaries()
        ret = self.__class__(substates=substates)
        return ret
    
    def __setitem__(self, key, value):
        self.active_dictionary[key] = value
    
    def __delitem__(self, key):
        del self.active_dictionary[key]
    
    def pop(self, key, default=None):
        return self.active_dictionary.pop(key, default)
    
    def update(self, other_dict):
        self.active_dictionary.update(other_dict)

class EndpointStateLinkCollectionProvider(LinkCollectionProvider):
    def _get_link_functions(self, attr):
        functions = super(EndpointStateLinkCollectionProvider, self)._get_link_functions(attr)
        key_name = attr[len('get_'):]
        functions.append(lambda *args, **kwargs: self.container['state_links'].get(key_name, []))
        return functions
    
    def add_link(self, key, link):
        self.container['state_links'].setdefault(key, list())
        self.container['state_links'][key].append(link)

class EndpointState(LinkCollectorMixin, State):
    """
    Used by resources to determine what links and items are available in the response.
    """
    link_collector_class = EndpointStateLinkCollectionProvider
    
    def __init__(self, endpoint, meta, substates=[], data={}):
        self.endpoint = endpoint
        super(EndpointState, self).__init__(substates=substates, data=data)
        self.meta = meta
        self.links = self.get_link_collector()
        
        #nuke previous state links
        self.update({'state_links': {},
                     'extra_get_params':{},
                     'endpoint': self.endpoint,})
    
    @property
    def api_request(self):
        return self.endpoint.api_request
    
    def get_link_collector_kwargs(self, **kwargs):
        params = super(EndpointState, self).get_link_collector_kwargs(**kwargs)
        params['parent'] = self.endpoint.links
        return params
    
    def get_dictionaries(self):
        return [self.active_dictionary] + self.substates + [self.endpoint.api_request.session_state]
    
    @property
    def resource(self):
        return getattr(self.endpoint, 'resource', self.endpoint)
    
    @property
    def site(self):
        return self.get('site', self.endpoint.site)
    
    def reverse(self, name, *args, **kwargs):
        return self.api_request.reverse(name, *args, **kwargs)
    
    def _set_item(self, val):
        self['item'] = val
    
    def _get_item(self):
        return self.get('item', None)
    
    item = property(_get_item, _set_item)
    
    def _set_meta(self, val):
        self['meta'] = val
    
    def _get_meta(self):
        return self.get('meta', {})
    
    meta = property(_get_meta, _set_meta)
    
    def get_link_url(self, link):
        url = link.get_base_url()
        params = self.get('extra_get_params', None) or QueryDict('', mutable=True)
        if params:
            params = copy(params)
            if '?' in url:
                url, get_string = url.split('?', 1)
                url_args = QueryDict(get_string)
                if hasattr(params, 'setlist'):
                    for key, value in url_args.iterlists():
                        params.setlist(key, value)
                else:
                    params.update(url_args)
            if hasattr(params, 'urlencode'):
                params = params.urlencode()
            else:
                params = urlencode(params)
            url += '?' + params
        return url
    
    def has_view_class(self, cls):
        view_classes = self.get('view_classes', [])
        return cls in view_classes
    
    @property
    def params(self):
        """
        The filter and pagination parameters
        """
        if 'params' in self:
            return self['params']
        if 'request' in self:
            return self['request'].GET
        return {}
    
    @property
    def namespace(self):
        return self.get('namespace', None)
    
    def get_resource_items(self):
        """
        Returns resource items that are associated with this state.
        """
        if self.item is not None:
            return self.item.get_resource_items()
        return self.endpoint.get_resource_items()
    
    def get_query_string(self, new_params=None, remove=None):
        if new_params is None: new_params = {}
        if remove is None: remove = []
        p = copy(self.params)
        for r in remove:
            for k in p.keys():
                if k.startswith(r):
                    del p[k]
        for k, v in new_params.items():
            if v is None:
                if k in p:
                    del p[k]
            else:
                p[k] = v
        if hasattr(p, 'urlencode'):
            return '?%s' % p.urlencode()
        return '?%s' % urlencode(p)
    
    def get_namespaces(self):
        return self.endpoint.get_namespaces()
    
    def __copy__(self):
        substates = self.get_dictionaries()
        ret = self.__class__(self.endpoint, copy(self.meta), substates=substates)
        return ret


########NEW FILE########
__FILENAME__ = hyperadmin_utils
# Copyright 2009, EveryBlock
# This code is released under the GPL.

from django import template
register = template.Library()

def raw(parser, token):
    # Whatever is between {% raw %} and {% endraw %} will be preserved as
    # raw, unrendered template code.
    text = []
    parse_until = 'endraw'
    tag_mapping = {
        template.TOKEN_TEXT: ('', ''),
        template.TOKEN_VAR: ('{{', '}}'),
        template.TOKEN_BLOCK: ('{%', '%}'),
        template.TOKEN_COMMENT: ('{#', '#}'),
    }
    # By the time this template tag is called, the template system has already
    # lexed the template into tokens. Here, we loop over the tokens until
    # {% endraw %} and parse them to TextNodes. We have to add the start and
    # end bits (e.g. "{{" for variables) because those have already been
    # stripped off in a previous part of the template-parsing process.
    while parser.tokens:
        token = parser.next_token()
        if token.token_type == template.TOKEN_BLOCK and token.contents == parse_until:
            return template.TextNode(u''.join(text))
        start, end = tag_mapping[token.token_type]
        text.append(u'%s%s%s' % (start, token.contents, end))
    parser.unclosed_block_tag(parse_until)
raw = register.tag(raw)

@register.inclusion_tag('hyperadmin/html5/resource.html')
def include_namespace(namespace):
    return {'state':namespace.state,
            'link':namespace.link,
            'namespaces':namespace.get_namespaces(),}

########NEW FILE########
__FILENAME__ = common
from django.test.client import RequestFactory
from django.core.urlresolvers import RegexURLResolver

from hyperadmin.apirequests import NamespaceAPIRequest
from hyperadmin.endpoints import RootEndpoint


class MockSession(dict):
    def flush(self):
        pass

class SuperUserRequestFactory(RequestFactory):
    def __init__(self, **kwargs):
        self.user = kwargs.pop('user', None)
        super(SuperUserRequestFactory, self).__init__(**kwargs)
    
    def request(self, **request):
        ret = super(SuperUserRequestFactory, self).request(**request)
        ret.user = self.user
        ret.session = MockSession()
        ret.csrf_processing_done = True #lets not worry about csrf
        return ret

class GenericURLResolver(RegexURLResolver):
    def __init__(self, regex, url_patterns, default_kwargs=None, app_name=None, namespace=None):
        # regex is a string representing a regular expression.
        # urlconf_name is a string representing the module containing URLconfs.
        super(GenericURLResolver, self).__init__(regex, urlconf_name=None, default_kwargs=default_kwargs, app_name=app_name, namespace=namespace)
        self._url_patterns = url_patterns
    
    def _get_url_patterns(self):
        return self._url_patterns
    url_patterns = property(_get_url_patterns)
    
    def __repr__(self):
        return '<%s (%s:%s) %s>' % (self.__class__.__name__, self.app_name, self.namespace, self.regex.pattern)

class URLReverseMixin(object):
    def patch_reverse(self, resolver):
        def cls_reverse(slf, name, *args, **kwargs):
            return resolver.reverse(name, *args, **kwargs)
        
        self._orignal_request_reverse = NamespaceAPIRequest.reverse
        self._orignal_root_reverse = RootEndpoint.reverse
        NamespaceAPIRequest.reverse = cls_reverse
        RootEndpoint.reverse = cls_reverse
    
    def unpatch_reverse(self):
        NamespaceAPIRequest.reverse = self._orignal_request_reverse
        RootEndpoint.reverse = self._orignal_root_reverse

########NEW FILE########
__FILENAME__ = common
from django.contrib.contenttypes.models import ContentType

from hyperadmin.resources.models import ModelResource
from hyperadmin.tests.test_resources import ResourceTestCase

from mock import MagicMock

class MediaTypeTestCase(ResourceTestCase):
    def setUp(self):
        super(MediaTypeTestCase, self).setUp()
        self.adaptor = self.get_adaptor()
        self.adaptor.detect_redirect = MagicMock()
        self.adaptor.detect_redirect.return_value = False
    
    def get_adaptor(self):
        pass
    
    def register_resource(self):
        self.site.register(ContentType, ModelResource, app_name='auth')
        return self.site.registry[ContentType]

########NEW FILE########
__FILENAME__ = test_collectionjson
from django.contrib.contenttypes.models import ContentType
from django.utils import simplejson as json
from django.utils.translation import ugettext_lazy as _

from hyperadmin.mediatypes.collectionjson import CollectionJSON, CollectionNextJSON
from hyperadmin.resources.directory import ResourceDirectory
from hyperadmin.sites import site

from common import MediaTypeTestCase

class CollectionJsonTestCase(MediaTypeTestCase):
    content_type = 'application/vnd.Collection+JSON'
    
    def get_adaptor(self):
        self.api_request = self.get_api_request()
        return CollectionJSON(self.api_request)
    
    def test_queryset_serialize(self):
        endpoint = self.resource.endpoints['list'].fork(api_request=self.api_request)
        
        link = endpoint.link_prototypes['list'].get_link()
        state = endpoint.state
        
        response = self.adaptor.serialize(content_type=self.content_type, link=link, state=state)
        data = json.loads(response.content)
        json_items = data['collection']['items']
        self.assertEqual(len(json_items), len(ContentType.objects.all()))
    
    def test_model_instance_serialize(self):
        instance = ContentType.objects.all()[0]
        endpoint = self.resource.endpoints['detail'].fork(api_request=self.api_request)
        
        endpoint.state.item = item = endpoint.get_resource_item(instance)
        link = item.get_link()
        state = endpoint.state
        
        response = self.adaptor.serialize(content_type=self.content_type, link=link, state=state)
        data = json.loads(response.content)
        json_items = data['collection']['items']
        self.assertEqual(len(json_items), 1)
    
    def test_directory_resource_serialize(self):
        site_resource = site.directory_resource
        
        def get_prompt(*args):
            return _('lazy string')
        
        endpoint = site_resource.endpoints['list'].fork(api_request=self.api_request)
        
        link = endpoint.link_prototypes['list'].get_link()
        state = endpoint.state
        state.resource.get_prompt = get_prompt
        
        response = self.adaptor.serialize(content_type=self.content_type, link=link, state=state)
        data = json.loads(response.content)
        json_items = data['collection']['items']
        self.assertEqual(data['collection']['prompt'], 'lazy string')
    
    def test_model_instance_deserialize(self):
        pass
        #items = [ContentType.objects.all()[0]]
        #payload = '''{"data":{}}'''
        #return
        #view.request = view.factory.post('/', **{'wsgi.input':FakePayload(payload), 'CONTENT_LENGTH':len(payload)})
        #adaptor = CollectionJSON(view)
        #data = adaptor.deserialize()
        #json_items = data['collection']['items']

class CollectionNextJsonTestCase(MediaTypeTestCase):
    def get_adaptor(self):
        self.api_request = self.get_api_request()
        return CollectionNextJSON(self.api_request)
    
    def test_convert_field(self):
        form_class = self.resource.get_form_class()
        form = form_class()
        fields = list(form)
        field = fields[0]
        field_r = self.adaptor.convert_field(field)
        self.assertEqual(field_r['required'], field.field.required)
    
    def test_convert_errors(self):
        form_class = self.resource.get_form_class()
        form = form_class(data={})
        assert form.errors
        error_r = self.adaptor.convert_errors(form.errors)
        self.assertEqual(len(error_r['messages']), len(form.errors))
        


########NEW FILE########
__FILENAME__ = test_json
from django.contrib.contenttypes.models import ContentType
from django.utils import simplejson as json

from hyperadmin.mediatypes.json import JSON, JSONP

from common import MediaTypeTestCase


class JsonTestCase(MediaTypeTestCase):
    def get_adaptor(self):
        self.api_request = self.get_api_request()
        return JSON(self.api_request)
    
    def test_queryset_serialize(self):
        endpoint = self.resource.endpoints['list']
        endpoint = endpoint.fork(api_request=self.api_request)
        
        link = endpoint.link_prototypes['list'].get_link()
        state = endpoint.state
        
        response = self.adaptor.serialize(content_type='application/json', link=link, state=state)
        data = json.loads(response.content)
        self.assertEqual(len(data), ContentType.objects.count())
    
    def test_model_instance_serialize(self):
        instance = ContentType.objects.all()[0]
        
        endpoint = self.resource.endpoints['detail']
        endpoint = endpoint.fork(api_request=self.api_request)
        endpoint.state.item = item = endpoint.get_resource_item(instance)
        link = item.get_link()
        state = endpoint.state
        
        response = self.adaptor.serialize(content_type='application/json', link=link, state=state)
        data = json.loads(response.content)
        assert data, str(data)
        #self.assertEqual(len(json_items), 1)

class JsonpTestCase(MediaTypeTestCase):
    def get_adaptor(self):
        self.api_request = self.get_api_request(params={'callback':'jscallback'})
        return JSONP(self.api_request)
    
    def test_queryset_serialize(self):
        
        endpoint = self.resource.endpoints['list']
        endpoint = endpoint.fork(api_request=self.api_request)
        
        link = endpoint.link_prototypes['list'].get_link()
        state = endpoint.state
        
        response = self.adaptor.serialize(content_type='text/javascript', link=link, state=state)
        self.assertTrue(response.content.startswith('jscallback('))
        #data = json.loads(response.content)
        #self.assertEqual(len(data), len(items))
    
    def test_model_instance_serialize(self):
        instance = ContentType.objects.all()[0]
        
        endpoint = self.resource.endpoints['detail']
        endpoint = endpoint.fork(api_request=self.api_request)

        endpoint.state.item = item = endpoint.get_resource_item(instance)
        link = item.get_link()
        state = endpoint.state
        
        response = self.adaptor.serialize(content_type='text/javascript', link=link, state=state)
        self.assertTrue(response.content.startswith('jscallback('))
        #data = json.loads(response.content)
        #assert data, str(data)
        #self.assertEqual(len(json_items), 1)
        


########NEW FILE########
__FILENAME__ = test_resources
from StringIO import StringIO

from django.utils import unittest
from django.utils.datastructures import MergeDict
from django.contrib.auth.models import User, Group
from django.http import HttpResponse
from django.core.files.base import ContentFile

from hyperadmin.resources.models import ModelResource, InlineModelResource
from hyperadmin.sites import ResourceSite
from hyperadmin.apirequests import InternalAPIRequest, NamespaceAPIRequest
from hyperadmin.endpoints import RootEndpoint

from common import GenericURLResolver, SuperUserRequestFactory, URLReverseMixin

from mock import MagicMock


class GroupsInline(InlineModelResource):
    model = User.groups.through
    rel_name = 'user' #TODO this should not be needed

class UserResource(ModelResource):
    inlines = [GroupsInline]
    list_display = ['username', 'email']
    list_filter = ['is_active', 'is_staff', 'is_superuser']
    date_hierarchy = 'date_joined'
    search_fields = ['email', 'username']

class ResourceTestCase(URLReverseMixin, unittest.TestCase):
    def setUp(self):
        self.site = ResourceSite()
        self.site.register_builtin_media_types()
        
        self.user = User.objects.get_or_create(username='superuser', is_staff=True, is_active=True, is_superuser=True)[0]
        self.resource = self.register_resource()
        
        self.factory = SuperUserRequestFactory(user=self.user, HTTP_ACCEPT='text/html')
        
        self.resolver = GenericURLResolver(r'^', self.site.get_urls())
        
        self.patch_reverse(self.resolver)
    
    def tearDown(self):
        self.unpatch_reverse()
    
    def get_api_request(self, **kwargs):
        kwargs.setdefault('site', self.site)
        kwargs.setdefault('user', self.user)
        kwargs.setdefault('params', {})
        kwargs.setdefault('method', 'GET')
        kwargs.setdefault('payload', {})
        kwargs.setdefault('request', self.factory.get('/'))
        api_request = InternalAPIRequest(**kwargs)
        
        api_request.generate_response = MagicMock(return_value=HttpResponse())
        
        return api_request
    
    def register_resource(self):
        raise NotImplementedError

class ModelResourceTestCase(ResourceTestCase):
    def register_resource(self):
        self.site.register(User, UserResource, app_name='auth')
        return self.site.registry[User]
    
    def test_get_url_name(self):
        urlname = self.resource.get_url_name()
        self.assertEqual(urlname, 'admin_auth_user_resource')
    
    def test_get_list(self):
        api_request = self.get_api_request()
        endpoint = self.resource.endpoints['list'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertEqual(len(state.get_resource_items()), User.objects.count())
        
        links = state.links.get_filter_links()
        self.assertTrue(links, 'filter links are empty')
        
        links = state.links.get_breadcrumbs()
        self.assertTrue(links, 'breadcrumbs are empty')
        
        links = state.links.get_outbound_links()
        self.assertTrue(links, 'outbound links are empty')
    
    def test_get_detail(self):
        instance = self.user
        api_request = self.get_api_request(url_kwargs={'pk':instance.pk})
        endpoint = self.resource.endpoints['detail'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertEqual(len(state.get_resource_items()), 1)
        self.assertTrue(state.item)
        self.assertEqual(state.item.instance, instance)
        
        links = state.links.get_breadcrumbs()
        #TODO check for item breadcrumb
        self.assertTrue(links, 'breadcrumbs are empty')
        
        links = state.item.links.get_item_outbound_links()
        self.assertTrue(links, 'outbound links are empty')
    
    def test_negative_primary_key(self):
        instance = User.objects.create(pk=-1, username='anonymous', email='nowhere@nowhere.com')
        api_request = self.get_api_request(url_kwargs={'pk':instance.pk})
        endpoint = self.resource.endpoints['detail'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertEqual(len(state.get_resource_items()), 1)
    
    def test_internal_dispatch(self):
        instance = self.user
        response = self.resource.endpoints['detail'].internal_dispatch(url_kwargs={'pk':instance.pk})
        print response
    
    def test_post_list(self):
        update_data = {
            'username': 'normaluser',
            'email': 'z@z.com',
        }
        api_request = self.get_api_request(payload={'data': update_data}, method='POST')
        endpoint = self.resource.endpoints['list'].fork(api_request=api_request)
        
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertTrue(link.form)
        self.assertTrue(link.form.errors)
    
    def test_post_detail(self):
        instance = self.user
        update_data = {
            'email': 'z@z.com',
        }
        api_request = self.get_api_request(url_kwargs={'pk':instance.pk}, payload={'data': update_data}, method='POST')
        endpoint = self.resource.endpoints['detail'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertTrue(link.form)
        self.assertTrue(link.form.errors)
        
        self.assertTrue(state.item)
        self.assertEqual(state.item.instance, instance)

class InlineModelResourceTestCase(ResourceTestCase):
    def setUp(self):
        super(InlineModelResourceTestCase, self).setUp()
        self.test_group = Group.objects.get_or_create(name='testgroup')[0]
        self.user.groups.add(self.test_group)
    
    def register_resource(self):
        self.site.register(User, UserResource, app_name='auth')
        self.user_resource = self.site.registry[User]
        return self.user_resource.inline_instances[0]
    
    def test_get_list(self):
        api_request = self.get_api_request(url_kwargs={'pk':self.user.pk})
        endpoint = self.resource.endpoints['list'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertEqual(len(state.get_resource_items()), self.user.groups.all().count())
    
    def test_namespaced_form(self):
        instance = self.user
        api_request = self.get_api_request(url_kwargs={'pk':self.user.pk})
        endpoint = self.user_resource.endpoints['detail'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertEqual(len(state.get_resource_items()), 1)
        self.assertTrue(state.item)
        self.assertEqual(state.item.instance, instance)
        
        #self.skipTest("Need to patch namespace's api_request's reverse")
        item_namespaces = state.item.get_namespaces()
        self.assertTrue(item_namespaces)
        namespace = item_namespaces.values()[0]
        self.assertTrue(namespace.link.get_absolute_url())
            
        inline_items = namespace.state.get_resource_items()
        self.assertTrue(inline_items)
        item = inline_items[0]
        inline_link = item.get_outbound_link()
        self.assertEqual(inline_link.get_link_factor(), 'LO')
        self.assertTrue(inline_link.get_absolute_url())
        
        edit_link = inline_link.follow()
        self.assertEqual(edit_link.method, 'POST', str(edit_link.endpoint))
    
    #TODO
    def test_get_detail(self):
        return
        instance = self.user
        view_kwargs = self.resource.get_view_kwargs()
        view = self.resource.detail_view.as_view(**view_kwargs)
        request = self.factory.get('/')
        view(request, pk=instance.pk)
        
        media_type, response_type, link = self.site.generate_response.call_args[0]
            
    #TODO
    def test_post_list(self):
        return
        instance = self.user
        view_kwargs = self.resource.get_view_kwargs()
        view = self.resource.list_view.as_view(**view_kwargs)
        update_data = {
            'username': 'normaluser',
            'email': 'z@z.com',
        }
        request = self.factory.post('/', update_data)
        view(request, pk=instance.pk)
        
        media_type, response_type, link = self.site.generate_response.call_args[0]
    
    #TODO
    def test_post_detail(self):
        return
        instance = self.user
        view_kwargs = self.resource.get_view_kwargs()
        view = self.resource.detail_view.as_view(**view_kwargs)
        update_data = {
            'email': 'z@z.com',
        }
        request = self.factory.post('/', update_data)
        view(request, pk=instance.pk)
        
        media_type, response_type, link = self.site.generate_response.call_args[0]

class SiteResourceTestCase(ResourceTestCase):
    def register_resource(self):
        self.site.register(User, ModelResource, app_name='auth')
        return self.site.directory_resource
    
    '''
    def test_index(self):
        factory = SuperUserRequestFactory(user=self.user)
        view_kwargs = self.resource.get_view_kwargs()
        view = self.resource.list_view.as_view(**view_kwargs)
        request = factory.get('/')
        response = view(request)
    '''
    
    def test_get_list(self):
        api_request = self.get_api_request()
        endpoint = self.resource.endpoints['list'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertTrue(state.get_resource_items())
    
    def test_url_stability_after_fork(self):
        api_request = self.get_api_request()
        bound_site = self.site.fork(api_request=api_request)
        print self.site.get_urls()
        print api_request.get_site().get_urls()
        self.assertEqual(str(self.site.get_urls()), str(bound_site.get_urls()))
        self.assertEqual(str(self.site.get_urls()), str(api_request.get_site().get_urls()))

class ApplicationResourceTestCase(ResourceTestCase):
    def register_resource(self):
        self.site.register(User, ModelResource, app_name='auth')
        return self.site.applications['auth']
    
    def test_get_list(self):
        api_request = self.get_api_request()
        endpoint = self.resource.endpoints['list'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertTrue(state.get_resource_items())

class StorageResourceTestCase(ResourceTestCase):
    def register_resource(self):
        from django.conf import settings
        import os, shutil
        for directory in (settings.MEDIA_ROOT, settings.STATIC_ROOT):
            try:
                shutil.rmtree(directory, ignore_errors=True)
                os.makedirs(directory)
            except:
                pass
        self.site.install_storage_resources()
        return self.site.applications['-storages'].resource_adaptor['media']
    
    def test_get_list(self):
        self.resource.resource_adaptor.save('test.txt', ContentFile('foobar'))
        
        api_request = self.get_api_request()
        endpoint = self.resource.endpoints['list'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        #list view sets the state here
        #self.assertEqual(len(state.get_resource_items()), 1)
    
    def test_get_detail(self):
        self.resource.resource_adaptor.save('test.txt', ContentFile('foobar'))
        
        api_request = self.get_api_request(url_kwargs={'path':'test.txt'})
        endpoint = self.resource.endpoints['detail'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        #with state.push_session(self.popped_states):
        self.assertEqual(len(state.get_resource_items()), 1)
        
        item = state.get_resource_items()[0]
        
        self.assertEqual(item.instance.url, '/media/test.txt')
    
    def test_post_list(self):
        update_data = {
            'name': 'test.txt',
            'upload': StringIO('test2'),
        }
        update_data['upload'].name = 'test.txt'
        
        api_request = self.get_api_request(payload={'data':update_data}, method='POST')
        endpoint = self.resource.endpoints['list'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        #self.assertEqual(link.rel, 'item')
        #if there was an error:
        #self.assertTrue(link.form)
        #self.assertTrue(link.form.errors)
    
    def test_post_detail(self):
        self.resource.resource_adaptor.save('test.txt', ContentFile('foobar'))
        update_data = {
            'name': 'test.txt',
            'upload': StringIO('test2'),
        }
        update_data['upload'].name = 'test.txt'
        api_request = self.get_api_request(url_kwargs={'path':'test.txt'}, payload={'data':update_data}, method='POST')
        endpoint = self.resource.endpoints['detail'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        self.assertEqual(link.rel, 'update')
        #if not rel
        #self.assertTrue(link.form.errors)

class AuthenticationResourceTestCase(ResourceTestCase):
    def register_resource(self):
        return self.site.auth_resource
    
    def test_get_detail(self):
        api_request = self.get_api_request(request=self.factory.get('/'))
        endpoint = self.resource.endpoints['login'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        #with state.push_session(self.popped_states):
        self.assertTrue(state['authenticated'])
        self.assertTrue(state.links.get_outbound_links()) #TODO logout link?
    
    def test_restful_logout(self):
        api_request = self.get_api_request(method='DELETE', request=self.factory.get('/'))
        endpoint = self.resource.endpoints['login'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        #TODO it seems we aren't tracking test states properly
        #with state.push_session(self.popped_states):
        #    self.assertFalse(state['authenticated'])
    
    def test_logout(self):
        api_request = self.get_api_request(method='POST', request=self.factory.get('/'))
        endpoint = self.resource.endpoints['logout'].fork(api_request=api_request)
        response = endpoint.dispatch_api(api_request)
        
        call_kwargs = api_request.generate_response.call_args[1]
        link = call_kwargs['link']
        state = call_kwargs['state']
        
        #TODO it seems we aren't tracking test states properly
        #with state.push_session(self.popped_states):
        #    self.assertFalse(state['authenticated'])


########NEW FILE########
__FILENAME__ = test_sites
from django.utils import unittest
from django.contrib import admin

from hyperadmin import get_api
from hyperadmin.sites import ResourceSite, site

class SiteTestCase(unittest.TestCase):
    def test_install_from_admin_site(self):
        
        site = ResourceSite()
        admin.autodiscover()
        site.install_models_from_site(admin.site)
        
        self.assertTrue(site.registry)
    
    def test_get_api(self):
        found_site = get_api('hyperadmin')
        self.assertEqual(found_site, site)


########NEW FILE########
__FILENAME__ = test_wizard
import django

from hyperadmin.tests.test_resources import ResourceTestCase


class SimpleWizardTestCase(ResourceTestCase):
    def setUp(self):
        if django.VERSION[0] <= 1 and django.VERSION[1] < 4:
            self.skipTest('Wizard requires django 1.4 or later')
        return super(SimpleWizardTestCase, self).setUp()
    
    def register_resource(self):
        from hyperadmin.tests.wizard_fixtures import TestStorage, SimpleWizard
        TestStorage._session = dict()
        self.site.register('mywizard', SimpleWizard, app_name='wizard', resource_name='adduser', storage_class=TestStorage)
        return self.site.registry['mywizard']
    
    def test_get_wizard(self):
        api_request = self.get_api_request()
        resource = self.resource.fork(api_request=api_request)
        resource.get_link()
    
    def test_email_step(self):
        #start = self.resource.get_link()
        data = {
            'email': 'z@z.com',
        }
        api_request = self.get_api_request(payload={'data':data}, method='POST')
        endpoint = self.resource.endpoints['email'].fork(api_request=api_request)
        assert endpoint.link_prototypes
        response = endpoint.generate_api_response(api_request)
        self.assertEqual(endpoint.status, 'complete')
        self.assertEqual(response.endpoint.get_url_name(), 'admin_wizard_adduser_step_username')
        
    def test_username_step(self):
        #start = self.resource.get_link()
        data = {
            'username': 'foobar',
        }
        api_request = self.get_api_request(payload={'data':data}, method='POST')
        endpoint = self.resource.endpoints['username'].fork(api_request=api_request)
        endpoint.wizard.set_step_status('email', 'complete')
        assert endpoint.link_prototypes
        response = endpoint.generate_api_response(api_request)
        self.assertEqual(endpoint.status, 'complete')
        self.assertEqual(response.endpoint.get_url_name(), 'admin_wizard_adduser_step_password')
        
    def test_password_step(self):
        #start = self.resource.get_link()
        data = {
            'password': 'secret',
        }
        api_request = self.get_api_request(payload={'data':data}, method='POST')
        endpoint = self.resource.endpoints['password'].fork(api_request=api_request)
        endpoint.wizard.set_step_status('email', 'complete')
        endpoint.wizard.set_step_status('username', 'complete')
        assert endpoint.link_prototypes
        response = endpoint.generate_api_response(api_request)
        self.assertEqual(endpoint.status, 'complete')
        self.assertEqual(response, 'success')

class ExpandedWizardTestCase(ResourceTestCase):
    def setUp(self):
        if django.VERSION[0] <= 1 and django.VERSION[1] < 4:
            self.skipTest('Wizard requires django 1.4 or later')
        return super(ExpandedWizardTestCase, self).setUp()
    
    def register_resource(self):
        from hyperadmin.tests.wizard_fixtures import TestStorage, ExpandedWizard
        TestStorage._session = dict()
        self.site.register(TestStorage, ExpandedWizard, app_name='wizard', resource_name='adduser')
        return self.site.registry[TestStorage]
        
    def test_get_attributes_step(self):
        #start = self.resource.get_link()
        api_request = self.get_api_request()
        endpoint = self.resource.endpoints['attributes'].fork(api_request=api_request)
        endpoint.wizard.set_step_status('email', 'complete')
        endpoint.wizard.set_step_status('username', 'complete')
        endpoint.wizard.set_step_status('password', 'complete')
        
        link = endpoint.get_link()
        response = link.follow()
    
    def test_attributes_1step(self):
        #start = self.resource.get_link()
        data = {
            'key': 'firstname',
            'value': 'johnson',
        }
        api_request = self.get_api_request(payload={'data':data}, method='POST')
        metastep = self.resource.endpoints['attributes'].fork(api_request=api_request)
        metastep.wizard.set_step_status('email', 'complete')
        metastep.wizard.set_step_status('username', 'complete')
        metastep.wizard.set_step_status('password', 'complete')
        
        endpoint = metastep.endpoints['attr1']
        response = endpoint.generate_api_response(api_request)
        self.assertEqual(endpoint.status, 'complete')
        self.assertEqual(response.endpoint.get_url_name(), 'admin_wizard_adduser_step_attributes_step_attr2')
    
    def test_attributes_completion(self):
        #start = self.resource.get_link()
        data = {
            'key': 'firstname',
            'value': 'johnson',
        }
        api_request = self.get_api_request(payload={'data':data}, method='POST')
        metastep = self.resource.endpoints['attributes'].fork(api_request=api_request)
        metastep.wizard.set_step_status('email', 'complete')
        metastep.wizard.set_step_status('username', 'complete')
        metastep.wizard.set_step_status('password', 'complete')
        metastep.set_step_status('attr1', 'complete')
        
        endpoint = metastep.endpoints['attr2']
        response = endpoint.generate_api_response(api_request)
        self.assertEqual(endpoint.status, 'complete')
        self.assertEqual(response, 'success')
    
    def test_attributes_skip_1step(self):
        #start = self.resource.get_link()
        data = {
            'skip_steps': ['attr1'],
        }
        api_request = self.get_api_request(payload={'data':data}, method='POST')
        metastep = self.resource.endpoints['attributes'].fork(api_request=api_request)
        metastep.wizard.set_step_status('email', 'complete')
        metastep.wizard.set_step_status('username', 'complete')
        metastep.wizard.set_step_status('password', 'complete')
        
        control = metastep.endpoints['start']
        response = control.generate_api_response(api_request)
        endpoint = metastep.endpoints['attr1']
        self.assertEqual(endpoint.status, 'skipped')
        self.assertEqual(response.endpoint.get_url_name(), 'admin_wizard_adduser_step_attributes_step_attr2')

#TODO test step listing


########NEW FILE########
__FILENAME__ = wizard_fixtures
from django import forms
from django.contrib.formtools.wizard.storage import BaseStorage

from hyperadmin.resources.wizard import Wizard, FormStep, MultiPartStep


class EmailForm(forms.Form):
    email = forms.EmailField()

class UsernameForm(forms.Form):
    username = forms.CharField()

class PasswordForm(forms.Form):
    password = forms.CharField()

class AttributeForm(forms.Form):
    key = forms.CharField()
    value = forms.CharField()

class GetEmail(FormStep):
    form_class = EmailForm

class GetUsername(FormStep):
    form_class = UsernameForm

class GetPassword(FormStep):
    form_class = PasswordForm

class GetAttribute(FormStep):
    form_class = AttributeForm
    
    def can_skip(self):
        return True

class GetAttributes(MultiPartStep):
    step_definitions = [
        (GetAttribute, {'slug':'attr1'}),
        (GetAttribute, {'slug':'attr2'}),
    ]

class SimpleWizard(Wizard):
    step_definitions = [
        (GetEmail, {'slug':'email'}),
        (GetUsername, {'slug':'username'}),
        (GetPassword, {'slug':'password'}),
    ]
    
    def done(self, submissions):
        return 'success'

class ExpandedWizard(Wizard):
    step_definitions = [
        (GetEmail, {'slug':'email'}),
        (GetUsername, {'slug':'username'}),
        (GetPassword, {'slug':'password'}),
        (GetAttributes, {'slug':'attributes'}),
    ]
    
    def done(self, submissions):
        return 'success'

class TestStorage(BaseStorage):
    _session = dict()
    
    def _get_data(self):
        return self._session[self.prefix]

    def _set_data(self, value):
        print 'set data:', value
        self._session[self.prefix] = value

    data = property(_get_data, _set_data)

########NEW FILE########
__FILENAME__ = throttle
import time
from django.core.cache import cache
from django.http import HttpResponse


class BaseThrottle(object):
    def throttle_check(self, api_request, endpoint):
        return None

class Throttle(BaseThrottle):
    def __init__(self, throttle_at=150, timeframe=3600, expiration=None):
        self.throttle_at = throttle_at
        # In seconds, please.
        self.timeframe = timeframe
        
        if expiration is None:
            # Expire in a week.
            expiration = 604800
        
        self.expiration = int(expiration)
    
    def throttle_check(self, api_request, endpoint):
        """
        Returns a link if the request should be throttled
        """
        key = self.get_identifier(api_request, endpoint)
        
        # Make sure something is there.
        cache.add(key, [])
        
        # Weed out anything older than the timeframe.
        minimum_time = int(time.time()) - int(self.timeframe)
        times_accessed = [access for access in cache.get(key) if access >= minimum_time]
        
        if len(times_accessed) >= int(self.throttle_at):
            # Throttle them.
            if hasattr(api_request.site, 'get_throttle_link'):
                return api_request.site.get_throttle_link()
            return HttpResponse(status=429)
        
        times_accessed.append(int(time.time()))
        cache.set(key, times_accessed, self.expiration)
        return None
    
    def get_identifier(self, api_request, endpoint):
        return '%s_%s' % (endpoint.get_url_name(), self.user_id(api_request))
    
    def user_id(self, api_request):
        if api_request.user:
            if hasattr(api_request.user, 'pk'):
                return  api_request.user.pk
            return api_request.user
        return ''


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url
from django.conf import settings

import hyperadmin
hyperadmin.autodiscover()

if 'django.contrib.admin' in settings.INSTALLED_APPS:
    from django.contrib import admin
    hyperadmin.site.install_models_from_site(admin.site) #ports admin models to hyperadmin

hyperadmin.site.install_storage_resources() #enables the storage resource for media and static

urlpatterns = patterns('',
    url(r'', include(hyperadmin.site.urls)),
)


########NEW FILE########
__FILENAME__ = views
from django import http
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.utils.cache import add_never_cache_headers
from django.utils.translation import ugettext_lazy as _

from hyperadmin.links import Link


class ConditionalAccessMixin(object):
    etag_function = None
    
    def check_etag(self, data):
        new_etag = self.etag_function and self.etag_function(data)
        if not new_etag:
            return
        if self.request.META.get('HTTP_IF_NONE_MATCH', None) == new_etag:
            raise http.HttpResponseNotModified()
        if self.request.META.get('HTTP_IF_MATCH', new_etag) != new_etag:
            raise http.HttpResponse(status=412) # Precondition Failed
        
class EndpointViewMixin(ConditionalAccessMixin):
    #state = None
    global_state = None
    cacheable = False
    submit_methods = ['POST', 'PUT', 'DELETE']
    template_name = None
    
    def get_template_names(self):
        if self.template_name:
            if isinstance(self.template_name, basestring):
                template_names = [self.template_name]
            else:
                template_names = self.template_name
            return self.expand_template_names(template_names)
        return None
    
    def get_request_form_kwargs(self):
        return self.api_request.payload
    
    def get_item(self):
        return None
    
    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        """
        Takes a django request object and builds an APIRequest object
        Calls dispatch_api with the api request
        :rtype: HttpResponse
        """
        assert not self.api_request
        api_request = self.create_apirequest(request=request, url_args=args, url_kwargs=kwargs)
        endpoint = api_request.get_endpoint(self.get_url_name())
        return endpoint.dispatch_api(api_request)
    
    def internal_dispatch(self, **kwargs):
        '''
        Can be called directly to execute an API call. kwargs are passed to the intenral api request.
        '''
        assert not self.api_request
        api_request = self.create_internal_apirequest(**kwargs)
        endpoint = api_request.get_endpoint(self.get_url_name())
        return endpoint.dispatch_api(api_request)
    
    def dispatch_api(self, api_request):
        '''
        Execute the api request
        :rtype: HttpResponse
        '''
        response = self.generate_api_response(api_request)
        return self.normalize_response(response)
    
    def generate_api_response(self, api_request):
        '''
        Returns the result of executing a link
        :rtype: Link or HttpResponse
        '''
        if api_request.method.lower() in self.http_method_names:
            handler = getattr(self, api_request.method.lower(), self.handle_link_submission)
        else:
            handler = self.http_method_not_allowed
        self.api_request = api_request
        self.args = api_request.url_args
        self.kwargs = api_request.url_kwargs
        
        self.initialize_state()
        
        assert self.state is not None
        
        self.common_state.update(self.get_common_state_data())
        
        permission_response = self.api_permission_check(api_request, self)
        if permission_response is not None:
            return permission_response
        else:
            return handler(api_request)
    
    def normalize_response(self, response_or_link):
        '''
        Converts a link response to an HttpResponse
        :rtype: HttpResponse
        '''
        if isinstance(response_or_link, Link):
            #TODO TemplateResponse with a link
            response = self.generate_response(response_or_link)
        else:
            response = response_or_link
        if not self.cacheable and isinstance(response, http.HttpResponse):
            add_never_cache_headers(response)
        return response
    
    def get_common_state_data(self):
        """
        Return state data that should be available at the resource level for processing the api request
        """
        return {}
    
    def handle_link_submission(self, api_request):
        """
        Looks up the appropriate link for the HTTP Method and returns 
        the link.
        If Method is in `self.submit_methods` then return the result of
        submitting the link.
        """
        method = api_request.method.upper()
        proto = self.get_link_prototype_for_method(method)
        
        if proto:
            if proto.show_link():
                kwargs = {'use_request_url':True}
                if method in self.submit_methods:
                    #TODO other kwargs may be added
                    kwargs['form_kwargs'] = api_request.payload
                kwargs = self.get_link_kwargs(**kwargs)
                link = proto.get_link(**kwargs)
                if method in self.submit_methods:
                    response_link = link.submit()
                    return response_link
                return link
            else:
                return http.HttpResponseForbidden(_(u"You may not access this endpoint"))
        return http.HttpResponseBadRequest(_(u"Method %s is not allowed") % method)
    
    def options(self, api_request):
        links = self.get_available_links()
        return self.generate_options_response(links=links)

########NEW FILE########
__FILENAME__ = noseplugins
from nose.selector import Selector
from nose.plugins import Plugin

import os
import logging
import sys
import unittest

import django
import django.test
from django.conf import settings

log = logging.getLogger(__name__)
log.setLevel(logging.INFO)
log.addHandler(logging.StreamHandler(sys.stdout))

class TestDiscoverySelector(Selector):
    
    def wantDirectory(self, dirname):
        log.debug('Do we want dir: %s' % dirname)
        if 'wizard' in dirname and django.VERSION[0] <= 1 and django.VERSION[1] < 4:
            return False
        
        return super(TestDiscoverySelector, self).wantDirectory(dirname)

    def wantClass(self, cls):
        log.debug('Do we want class: %s (%s)' % (cls, issubclass(cls, django.test.TestCase)))
        return issubclass(cls, unittest.TestCase)

    def wantFile(self, filename):
        log.debug('Do we want file: %s' % filename)
        if 'wizard' in filename and django.VERSION[0] <= 1 and django.VERSION[1] < 4:
            return False
        return filename.endswith('.py')
    
    def wantModule(self, module):
        log.debug('Do we want module: %s' % module)
        parts = module.__name__.split('.')
        if 'wizard' in parts and django.VERSION[0] <= 1 and django.VERSION[1] < 4:
            return False
        
        return super(TestDiscoverySelector, self).wantModule(module)
    
    def wantFunction(self, function):
        log.debug('Do we want function: %s' % function)
        return False

class TestDiscoveryPlugin(Plugin):
    enabled = True

    def configure(self, options, conf):
        pass

    def prepareTestLoader(self, loader):
        loader.selector = TestDiscoverySelector(loader.config)


########NEW FILE########
__FILENAME__ = runtests
"""
Test support harness for doing setup.py test.
See http://ericholscher.com/blog/2009/jun/29/enable-setuppy-test-your-django-apps/.
"""
import sys

import os

os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_settings'

# Bootstrap Django's settings.
from django.conf import settings
settings.DATABASES = {
    'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}
}
settings.TEST_RUNNER = "django_nose.NoseTestSuiteRunner"
settings.NOSE_PLUGINS = ['tests.noseplugins.TestDiscoveryPlugin']

def runtests():
    """Test runner for setup.py test."""
    # Run you some tests.
    import django.test.utils
    runner_class = django.test.utils.get_runner(settings)
    test_runner = runner_class(verbosity=1, interactive=True)
    failures = test_runner.run_tests(['hyperadmin'])

    # Okay, so this is a nasty hack. If this isn't here, `setup.py test` craps out
    # when generating a coverage report via Nose. I have no idea why, or what's
    # supposed to be going on here, but this seems to fix the problem, and I
    # *really* want coverage, so, unless someone can tell me *why* I shouldn't
    # do this, I'm going to just whistle innocently and keep on doing this.
    sys.exitfunc = lambda: 0

    sys.exit(failures)

########NEW FILE########
__FILENAME__ = test_settings
# Django settings for {{ project_name }} project.
import os

PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))
DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': ':memory:',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = os.path.join(PROJECT_DIR, 'media')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '/media/'

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = os.path.join(PROJECT_DIR, 'static')

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'NOTASECRET'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'tests.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    'hyperadmin',
    'hyperadmin.contrib.apikey',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
]

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url
from django.conf import settings

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

import hyperadmin
#hyperadmin.autodiscover()
#hyperadmin.site.install_models_from_site(admin.site)
#hyperadmin.site.install_storage_resources()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', '{{ project_name }}.views.home', name='home'),
    # url(r'^{{ project_name }}/', include('{{ project_name }}.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
    url(r'^hyper-admin/', include(hyperadmin.site.urls)),
)



if settings.DEBUG:
    urlpatterns += patterns('django.views',
        (r'^media/(?P<path>.*)$', 'static.serve', {'document_root': settings.MEDIA_ROOT}),
    )

########NEW FILE########
